/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sshpk";
exports.ids = ["vendor-chunks/sshpk"];
exports.modules = {

/***/ "(action-browser)/./node_modules/sshpk/lib/algs.js":
/*!****************************************!*\
  !*** ./node_modules/sshpk/lib/algs.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\n\nvar algInfo = {\n\t'dsa': {\n\t\tparts: ['p', 'q', 'g', 'y'],\n\t\tsizePart: 'p'\n\t},\n\t'rsa': {\n\t\tparts: ['e', 'n'],\n\t\tsizePart: 'n'\n\t},\n\t'ecdsa': {\n\t\tparts: ['curve', 'Q'],\n\t\tsizePart: 'Q'\n\t},\n\t'ed25519': {\n\t\tparts: ['A'],\n\t\tsizePart: 'A'\n\t}\n};\nalgInfo['curve25519'] = algInfo['ed25519'];\n\nvar algPrivInfo = {\n\t'dsa': {\n\t\tparts: ['p', 'q', 'g', 'y', 'x']\n\t},\n\t'rsa': {\n\t\tparts: ['n', 'e', 'd', 'iqmp', 'p', 'q']\n\t},\n\t'ecdsa': {\n\t\tparts: ['curve', 'Q', 'd']\n\t},\n\t'ed25519': {\n\t\tparts: ['A', 'k']\n\t}\n};\nalgPrivInfo['curve25519'] = algPrivInfo['ed25519'];\n\nvar hashAlgs = {\n\t'md5': true,\n\t'sha1': true,\n\t'sha256': true,\n\t'sha384': true,\n\t'sha512': true\n};\n\n/*\n * Taken from\n * http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf\n */\nvar curves = {\n\t'nistp256': {\n\t\tsize: 256,\n\t\tpkcs8oid: '1.2.840.10045.3.1.7',\n\t\tp: Buffer.from(('00' +\n\t\t    'ffffffff 00000001 00000000 00000000' +\n\t\t    '00000000 ffffffff ffffffff ffffffff').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\ta: Buffer.from(('00' +\n\t\t    'FFFFFFFF 00000001 00000000 00000000' +\n\t\t    '00000000 FFFFFFFF FFFFFFFF FFFFFFFC').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tb: Buffer.from((\n\t\t    '5ac635d8 aa3a93e7 b3ebbd55 769886bc' +\n\t\t    '651d06b0 cc53b0f6 3bce3c3e 27d2604b').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\ts: Buffer.from(('00' +\n\t\t    'c49d3608 86e70493 6a6678e1 139d26b7' +\n\t\t    '819f7e90').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tn: Buffer.from(('00' +\n\t\t    'ffffffff 00000000 ffffffff ffffffff' +\n\t\t    'bce6faad a7179e84 f3b9cac2 fc632551').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tG: Buffer.from(('04' +\n\t\t    '6b17d1f2 e12c4247 f8bce6e5 63a440f2' +\n\t\t    '77037d81 2deb33a0 f4a13945 d898c296' +\n\t\t    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16' +\n\t\t    '2bce3357 6b315ece cbb64068 37bf51f5').\n\t\t    replace(/ /g, ''), 'hex')\n\t},\n\t'nistp384': {\n\t\tsize: 384,\n\t\tpkcs8oid: '1.3.132.0.34',\n\t\tp: Buffer.from(('00' +\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\n\t\t    'ffffffff ffffffff ffffffff fffffffe' +\n\t\t    'ffffffff 00000000 00000000 ffffffff').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\ta: Buffer.from(('00' +\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE' +\n\t\t    'FFFFFFFF 00000000 00000000 FFFFFFFC').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tb: Buffer.from((\n\t\t    'b3312fa7 e23ee7e4 988e056b e3f82d19' +\n\t\t    '181d9c6e fe814112 0314088f 5013875a' +\n\t\t    'c656398d 8a2ed19d 2a85c8ed d3ec2aef').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\ts: Buffer.from(('00' +\n\t\t    'a335926a a319a27a 1d00896a 6773a482' +\n\t\t    '7acdac73').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tn: Buffer.from(('00' +\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\n\t\t    'ffffffff ffffffff c7634d81 f4372ddf' +\n\t\t    '581a0db2 48b0a77a ecec196a ccc52973').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tG: Buffer.from(('04' +\n\t\t    'aa87ca22 be8b0537 8eb1c71e f320ad74' +\n\t\t    '6e1d3b62 8ba79b98 59f741e0 82542a38' +\n\t\t    '5502f25d bf55296c 3a545e38 72760ab7' +\n\t\t    '3617de4a 96262c6f 5d9e98bf 9292dc29' +\n\t\t    'f8f41dbd 289a147c e9da3113 b5f0b8c0' +\n\t\t    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f').\n\t\t    replace(/ /g, ''), 'hex')\n\t},\n\t'nistp521': {\n\t\tsize: 521,\n\t\tpkcs8oid: '1.3.132.0.35',\n\t\tp: Buffer.from((\n\t\t    '01ffffff ffffffff ffffffff ffffffff' +\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\n\t\t    'ffff').replace(/ /g, ''), 'hex'),\n\t\ta: Buffer.from(('01FF' +\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tb: Buffer.from(('51' +\n\t\t    '953eb961 8e1c9a1f 929a21a0 b68540ee' +\n\t\t    'a2da725b 99b315f3 b8b48991 8ef109e1' +\n\t\t    '56193951 ec7e937b 1652c0bd 3bb1bf07' +\n\t\t    '3573df88 3d2c34f1 ef451fd4 6b503f00').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\ts: Buffer.from(('00' +\n\t\t    'd09e8800 291cb853 96cc6717 393284aa' +\n\t\t    'a0da64ba').replace(/ /g, ''), 'hex'),\n\t\tn: Buffer.from(('01ff' +\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\n\t\t    'ffffffff ffffffff ffffffff fffffffa' +\n\t\t    '51868783 bf2f966b 7fcc0148 f709a5d0' +\n\t\t    '3bb5c9b8 899c47ae bb6fb71e 91386409').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tG: Buffer.from(('04' +\n\t\t    '00c6 858e06b7 0404e9cd 9e3ecb66 2395b442' +\n\t\t         '9c648139 053fb521 f828af60 6b4d3dba' +\n\t\t         'a14b5e77 efe75928 fe1dc127 a2ffa8de' +\n\t\t         '3348b3c1 856a429b f97e7e31 c2e5bd66' +\n\t\t    '0118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9' +\n\t\t         '98f54449 579b4468 17afbd17 273e662c' +\n\t\t         '97ee7299 5ef42640 c550b901 3fad0761' +\n\t\t         '353c7086 a272c240 88be9476 9fd16650').\n\t\t    replace(/ /g, ''), 'hex')\n\t}\n};\n\nmodule.exports = {\n\tinfo: algInfo,\n\tprivInfo: algPrivInfo,\n\thashAlgs: hashAlgs,\n\tcurves: curves\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvYWxncy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxhQUFhLHlHQUE4Qjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2FsZ3MuanM/NGJhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNSBKb3llbnQsIEluYy5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGFsZ0luZm8gPSB7XG5cdCdkc2EnOiB7XG5cdFx0cGFydHM6IFsncCcsICdxJywgJ2cnLCAneSddLFxuXHRcdHNpemVQYXJ0OiAncCdcblx0fSxcblx0J3JzYSc6IHtcblx0XHRwYXJ0czogWydlJywgJ24nXSxcblx0XHRzaXplUGFydDogJ24nXG5cdH0sXG5cdCdlY2RzYSc6IHtcblx0XHRwYXJ0czogWydjdXJ2ZScsICdRJ10sXG5cdFx0c2l6ZVBhcnQ6ICdRJ1xuXHR9LFxuXHQnZWQyNTUxOSc6IHtcblx0XHRwYXJ0czogWydBJ10sXG5cdFx0c2l6ZVBhcnQ6ICdBJ1xuXHR9XG59O1xuYWxnSW5mb1snY3VydmUyNTUxOSddID0gYWxnSW5mb1snZWQyNTUxOSddO1xuXG52YXIgYWxnUHJpdkluZm8gPSB7XG5cdCdkc2EnOiB7XG5cdFx0cGFydHM6IFsncCcsICdxJywgJ2cnLCAneScsICd4J11cblx0fSxcblx0J3JzYSc6IHtcblx0XHRwYXJ0czogWyduJywgJ2UnLCAnZCcsICdpcW1wJywgJ3AnLCAncSddXG5cdH0sXG5cdCdlY2RzYSc6IHtcblx0XHRwYXJ0czogWydjdXJ2ZScsICdRJywgJ2QnXVxuXHR9LFxuXHQnZWQyNTUxOSc6IHtcblx0XHRwYXJ0czogWydBJywgJ2snXVxuXHR9XG59O1xuYWxnUHJpdkluZm9bJ2N1cnZlMjU1MTknXSA9IGFsZ1ByaXZJbmZvWydlZDI1NTE5J107XG5cbnZhciBoYXNoQWxncyA9IHtcblx0J21kNSc6IHRydWUsXG5cdCdzaGExJzogdHJ1ZSxcblx0J3NoYTI1Nic6IHRydWUsXG5cdCdzaGEzODQnOiB0cnVlLFxuXHQnc2hhNTEyJzogdHJ1ZVxufTtcblxuLypcbiAqIFRha2VuIGZyb21cbiAqIGh0dHA6Ly9jc3JjLm5pc3QuZ292L2dyb3Vwcy9TVC90b29sa2l0L2RvY3VtZW50cy9kc3MvTklTVFJlQ3VyLnBkZlxuICovXG52YXIgY3VydmVzID0ge1xuXHQnbmlzdHAyNTYnOiB7XG5cdFx0c2l6ZTogMjU2LFxuXHRcdHBrY3M4b2lkOiAnMS4yLjg0MC4xMDA0NS4zLjEuNycsXG5cdFx0cDogQnVmZmVyLmZyb20oKCcwMCcgK1xuXHRcdCAgICAnZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAnICtcblx0XHQgICAgJzAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0YTogQnVmZmVyLmZyb20oKCcwMCcgK1xuXHRcdCAgICAnRkZGRkZGRkYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAnICtcblx0XHQgICAgJzAwMDAwMDAwIEZGRkZGRkZGIEZGRkZGRkZGIEZGRkZGRkZDJykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0YjogQnVmZmVyLmZyb20oKFxuXHRcdCAgICAnNWFjNjM1ZDggYWEzYTkzZTcgYjNlYmJkNTUgNzY5ODg2YmMnICtcblx0XHQgICAgJzY1MWQwNmIwIGNjNTNiMGY2IDNiY2UzYzNlIDI3ZDI2MDRiJykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0czogQnVmZmVyLmZyb20oKCcwMCcgK1xuXHRcdCAgICAnYzQ5ZDM2MDggODZlNzA0OTMgNmE2Njc4ZTEgMTM5ZDI2YjcnICtcblx0XHQgICAgJzgxOWY3ZTkwJykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0bjogQnVmZmVyLmZyb20oKCcwMCcgK1xuXHRcdCAgICAnZmZmZmZmZmYgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYnICtcblx0XHQgICAgJ2JjZTZmYWFkIGE3MTc5ZTg0IGYzYjljYWMyIGZjNjMyNTUxJykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0RzogQnVmZmVyLmZyb20oKCcwNCcgK1xuXHRcdCAgICAnNmIxN2QxZjIgZTEyYzQyNDcgZjhiY2U2ZTUgNjNhNDQwZjInICtcblx0XHQgICAgJzc3MDM3ZDgxIDJkZWIzM2EwIGY0YTEzOTQ1IGQ4OThjMjk2JyArXG5cdFx0ICAgICc0ZmUzNDJlMiBmZTFhN2Y5YiA4ZWU3ZWI0YSA3YzBmOWUxNicgK1xuXHRcdCAgICAnMmJjZTMzNTcgNmIzMTVlY2UgY2JiNjQwNjggMzdiZjUxZjUnKS5cblx0XHQgICAgcmVwbGFjZSgvIC9nLCAnJyksICdoZXgnKVxuXHR9LFxuXHQnbmlzdHAzODQnOiB7XG5cdFx0c2l6ZTogMzg0LFxuXHRcdHBrY3M4b2lkOiAnMS4zLjEzMi4wLjM0Jyxcblx0XHRwOiBCdWZmZXIuZnJvbSgoJzAwJyArXG5cdFx0ICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicgK1xuXHRcdCAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUnICtcblx0XHQgICAgJ2ZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmJykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0YTogQnVmZmVyLmZyb20oKCcwMCcgK1xuXHRcdCAgICAnRkZGRkZGRkYgRkZGRkZGRkYgRkZGRkZGRkYgRkZGRkZGRkYnICtcblx0XHQgICAgJ0ZGRkZGRkZGIEZGRkZGRkZGIEZGRkZGRkZGIEZGRkZGRkZFJyArXG5cdFx0ICAgICdGRkZGRkZGRiAwMDAwMDAwMCAwMDAwMDAwMCBGRkZGRkZGQycpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdGI6IEJ1ZmZlci5mcm9tKChcblx0XHQgICAgJ2IzMzEyZmE3IGUyM2VlN2U0IDk4OGUwNTZiIGUzZjgyZDE5JyArXG5cdFx0ICAgICcxODFkOWM2ZSBmZTgxNDExMiAwMzE0MDg4ZiA1MDEzODc1YScgK1xuXHRcdCAgICAnYzY1NjM5OGQgOGEyZWQxOWQgMmE4NWM4ZWQgZDNlYzJhZWYnKS5cblx0XHQgICAgcmVwbGFjZSgvIC9nLCAnJyksICdoZXgnKSxcblx0XHRzOiBCdWZmZXIuZnJvbSgoJzAwJyArXG5cdFx0ICAgICdhMzM1OTI2YSBhMzE5YTI3YSAxZDAwODk2YSA2NzczYTQ4MicgK1xuXHRcdCAgICAnN2FjZGFjNzMnKS5cblx0XHQgICAgcmVwbGFjZSgvIC9nLCAnJyksICdoZXgnKSxcblx0XHRuOiBCdWZmZXIuZnJvbSgoJzAwJyArXG5cdFx0ICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicgK1xuXHRcdCAgICAnZmZmZmZmZmYgZmZmZmZmZmYgYzc2MzRkODEgZjQzNzJkZGYnICtcblx0XHQgICAgJzU4MWEwZGIyIDQ4YjBhNzdhIGVjZWMxOTZhIGNjYzUyOTczJykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0RzogQnVmZmVyLmZyb20oKCcwNCcgK1xuXHRcdCAgICAnYWE4N2NhMjIgYmU4YjA1MzcgOGViMWM3MWUgZjMyMGFkNzQnICtcblx0XHQgICAgJzZlMWQzYjYyIDhiYTc5Yjk4IDU5Zjc0MWUwIDgyNTQyYTM4JyArXG5cdFx0ICAgICc1NTAyZjI1ZCBiZjU1Mjk2YyAzYTU0NWUzOCA3Mjc2MGFiNycgK1xuXHRcdCAgICAnMzYxN2RlNGEgOTYyNjJjNmYgNWQ5ZTk4YmYgOTI5MmRjMjknICtcblx0XHQgICAgJ2Y4ZjQxZGJkIDI4OWExNDdjIGU5ZGEzMTEzIGI1ZjBiOGMwJyArXG5cdFx0ICAgICcwYTYwYjFjZSAxZDdlODE5ZCA3YTQzMWQ3YyA5MGVhMGU1ZicpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpXG5cdH0sXG5cdCduaXN0cDUyMSc6IHtcblx0XHRzaXplOiA1MjEsXG5cdFx0cGtjczhvaWQ6ICcxLjMuMTMyLjAuMzUnLFxuXHRcdHA6IEJ1ZmZlci5mcm9tKChcblx0XHQgICAgJzAxZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyArXG5cdFx0ICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicgK1xuXHRcdCAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnICtcblx0XHQgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyArXG5cdFx0ICAgICdmZmZmJykucmVwbGFjZSgvIC9nLCAnJyksICdoZXgnKSxcblx0XHRhOiBCdWZmZXIuZnJvbSgoJzAxRkYnICtcblx0XHQgICAgJ0ZGRkZGRkZGIEZGRkZGRkZGIEZGRkZGRkZGIEZGRkZGRkZGJyArXG5cdFx0ICAgICdGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGRicgK1xuXHRcdCAgICAnRkZGRkZGRkYgRkZGRkZGRkYgRkZGRkZGRkYgRkZGRkZGRkYnICtcblx0XHQgICAgJ0ZGRkZGRkZGIEZGRkZGRkZGIEZGRkZGRkZGIEZGRkZGRkZDJykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0YjogQnVmZmVyLmZyb20oKCc1MScgK1xuXHRcdCAgICAnOTUzZWI5NjEgOGUxYzlhMWYgOTI5YTIxYTAgYjY4NTQwZWUnICtcblx0XHQgICAgJ2EyZGE3MjViIDk5YjMxNWYzIGI4YjQ4OTkxIDhlZjEwOWUxJyArXG5cdFx0ICAgICc1NjE5Mzk1MSBlYzdlOTM3YiAxNjUyYzBiZCAzYmIxYmYwNycgK1xuXHRcdCAgICAnMzU3M2RmODggM2QyYzM0ZjEgZWY0NTFmZDQgNmI1MDNmMDAnKS5cblx0XHQgICAgcmVwbGFjZSgvIC9nLCAnJyksICdoZXgnKSxcblx0XHRzOiBCdWZmZXIuZnJvbSgoJzAwJyArXG5cdFx0ICAgICdkMDllODgwMCAyOTFjYjg1MyA5NmNjNjcxNyAzOTMyODRhYScgK1xuXHRcdCAgICAnYTBkYTY0YmEnKS5yZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdG46IEJ1ZmZlci5mcm9tKCgnMDFmZicgK1xuXHRcdCAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnICtcblx0XHQgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZhJyArXG5cdFx0ICAgICc1MTg2ODc4MyBiZjJmOTY2YiA3ZmNjMDE0OCBmNzA5YTVkMCcgK1xuXHRcdCAgICAnM2JiNWM5YjggODk5YzQ3YWUgYmI2ZmI3MWUgOTEzODY0MDknKS5cblx0XHQgICAgcmVwbGFjZSgvIC9nLCAnJyksICdoZXgnKSxcblx0XHRHOiBCdWZmZXIuZnJvbSgoJzA0JyArXG5cdFx0ICAgICcwMGM2IDg1OGUwNmI3IDA0MDRlOWNkIDllM2VjYjY2IDIzOTViNDQyJyArXG5cdFx0ICAgICAgICAgJzljNjQ4MTM5IDA1M2ZiNTIxIGY4MjhhZjYwIDZiNGQzZGJhJyArXG5cdFx0ICAgICAgICAgJ2ExNGI1ZTc3IGVmZTc1OTI4IGZlMWRjMTI3IGEyZmZhOGRlJyArXG5cdFx0ICAgICAgICAgJzMzNDhiM2MxIDg1NmE0MjliIGY5N2U3ZTMxIGMyZTViZDY2JyArXG5cdFx0ICAgICcwMTE4IDM5Mjk2YTc4IDlhM2JjMDA0IDVjOGE1ZmI0IDJjN2QxYmQ5JyArXG5cdFx0ICAgICAgICAgJzk4ZjU0NDQ5IDU3OWI0NDY4IDE3YWZiZDE3IDI3M2U2NjJjJyArXG5cdFx0ICAgICAgICAgJzk3ZWU3Mjk5IDVlZjQyNjQwIGM1NTBiOTAxIDNmYWQwNzYxJyArXG5cdFx0ICAgICAgICAgJzM1M2M3MDg2IGEyNzJjMjQwIDg4YmU5NDc2IDlmZDE2NjUwJykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4Jylcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGluZm86IGFsZ0luZm8sXG5cdHByaXZJbmZvOiBhbGdQcml2SW5mbyxcblx0aGFzaEFsZ3M6IGhhc2hBbGdzLFxuXHRjdXJ2ZXM6IGN1cnZlc1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/algs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/algs.js":
/*!****************************************!*\
  !*** ./node_modules/sshpk/lib/algs.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\n\nvar algInfo = {\n\t'dsa': {\n\t\tparts: ['p', 'q', 'g', 'y'],\n\t\tsizePart: 'p'\n\t},\n\t'rsa': {\n\t\tparts: ['e', 'n'],\n\t\tsizePart: 'n'\n\t},\n\t'ecdsa': {\n\t\tparts: ['curve', 'Q'],\n\t\tsizePart: 'Q'\n\t},\n\t'ed25519': {\n\t\tparts: ['A'],\n\t\tsizePart: 'A'\n\t}\n};\nalgInfo['curve25519'] = algInfo['ed25519'];\n\nvar algPrivInfo = {\n\t'dsa': {\n\t\tparts: ['p', 'q', 'g', 'y', 'x']\n\t},\n\t'rsa': {\n\t\tparts: ['n', 'e', 'd', 'iqmp', 'p', 'q']\n\t},\n\t'ecdsa': {\n\t\tparts: ['curve', 'Q', 'd']\n\t},\n\t'ed25519': {\n\t\tparts: ['A', 'k']\n\t}\n};\nalgPrivInfo['curve25519'] = algPrivInfo['ed25519'];\n\nvar hashAlgs = {\n\t'md5': true,\n\t'sha1': true,\n\t'sha256': true,\n\t'sha384': true,\n\t'sha512': true\n};\n\n/*\n * Taken from\n * http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf\n */\nvar curves = {\n\t'nistp256': {\n\t\tsize: 256,\n\t\tpkcs8oid: '1.2.840.10045.3.1.7',\n\t\tp: Buffer.from(('00' +\n\t\t    'ffffffff 00000001 00000000 00000000' +\n\t\t    '00000000 ffffffff ffffffff ffffffff').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\ta: Buffer.from(('00' +\n\t\t    'FFFFFFFF 00000001 00000000 00000000' +\n\t\t    '00000000 FFFFFFFF FFFFFFFF FFFFFFFC').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tb: Buffer.from((\n\t\t    '5ac635d8 aa3a93e7 b3ebbd55 769886bc' +\n\t\t    '651d06b0 cc53b0f6 3bce3c3e 27d2604b').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\ts: Buffer.from(('00' +\n\t\t    'c49d3608 86e70493 6a6678e1 139d26b7' +\n\t\t    '819f7e90').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tn: Buffer.from(('00' +\n\t\t    'ffffffff 00000000 ffffffff ffffffff' +\n\t\t    'bce6faad a7179e84 f3b9cac2 fc632551').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tG: Buffer.from(('04' +\n\t\t    '6b17d1f2 e12c4247 f8bce6e5 63a440f2' +\n\t\t    '77037d81 2deb33a0 f4a13945 d898c296' +\n\t\t    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16' +\n\t\t    '2bce3357 6b315ece cbb64068 37bf51f5').\n\t\t    replace(/ /g, ''), 'hex')\n\t},\n\t'nistp384': {\n\t\tsize: 384,\n\t\tpkcs8oid: '1.3.132.0.34',\n\t\tp: Buffer.from(('00' +\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\n\t\t    'ffffffff ffffffff ffffffff fffffffe' +\n\t\t    'ffffffff 00000000 00000000 ffffffff').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\ta: Buffer.from(('00' +\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE' +\n\t\t    'FFFFFFFF 00000000 00000000 FFFFFFFC').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tb: Buffer.from((\n\t\t    'b3312fa7 e23ee7e4 988e056b e3f82d19' +\n\t\t    '181d9c6e fe814112 0314088f 5013875a' +\n\t\t    'c656398d 8a2ed19d 2a85c8ed d3ec2aef').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\ts: Buffer.from(('00' +\n\t\t    'a335926a a319a27a 1d00896a 6773a482' +\n\t\t    '7acdac73').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tn: Buffer.from(('00' +\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\n\t\t    'ffffffff ffffffff c7634d81 f4372ddf' +\n\t\t    '581a0db2 48b0a77a ecec196a ccc52973').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tG: Buffer.from(('04' +\n\t\t    'aa87ca22 be8b0537 8eb1c71e f320ad74' +\n\t\t    '6e1d3b62 8ba79b98 59f741e0 82542a38' +\n\t\t    '5502f25d bf55296c 3a545e38 72760ab7' +\n\t\t    '3617de4a 96262c6f 5d9e98bf 9292dc29' +\n\t\t    'f8f41dbd 289a147c e9da3113 b5f0b8c0' +\n\t\t    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f').\n\t\t    replace(/ /g, ''), 'hex')\n\t},\n\t'nistp521': {\n\t\tsize: 521,\n\t\tpkcs8oid: '1.3.132.0.35',\n\t\tp: Buffer.from((\n\t\t    '01ffffff ffffffff ffffffff ffffffff' +\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\n\t\t    'ffff').replace(/ /g, ''), 'hex'),\n\t\ta: Buffer.from(('01FF' +\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tb: Buffer.from(('51' +\n\t\t    '953eb961 8e1c9a1f 929a21a0 b68540ee' +\n\t\t    'a2da725b 99b315f3 b8b48991 8ef109e1' +\n\t\t    '56193951 ec7e937b 1652c0bd 3bb1bf07' +\n\t\t    '3573df88 3d2c34f1 ef451fd4 6b503f00').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\ts: Buffer.from(('00' +\n\t\t    'd09e8800 291cb853 96cc6717 393284aa' +\n\t\t    'a0da64ba').replace(/ /g, ''), 'hex'),\n\t\tn: Buffer.from(('01ff' +\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\n\t\t    'ffffffff ffffffff ffffffff fffffffa' +\n\t\t    '51868783 bf2f966b 7fcc0148 f709a5d0' +\n\t\t    '3bb5c9b8 899c47ae bb6fb71e 91386409').\n\t\t    replace(/ /g, ''), 'hex'),\n\t\tG: Buffer.from(('04' +\n\t\t    '00c6 858e06b7 0404e9cd 9e3ecb66 2395b442' +\n\t\t         '9c648139 053fb521 f828af60 6b4d3dba' +\n\t\t         'a14b5e77 efe75928 fe1dc127 a2ffa8de' +\n\t\t         '3348b3c1 856a429b f97e7e31 c2e5bd66' +\n\t\t    '0118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9' +\n\t\t         '98f54449 579b4468 17afbd17 273e662c' +\n\t\t         '97ee7299 5ef42640 c550b901 3fad0761' +\n\t\t         '353c7086 a272c240 88be9476 9fd16650').\n\t\t    replace(/ /g, ''), 'hex')\n\t}\n};\n\nmodule.exports = {\n\tinfo: algInfo,\n\tprivInfo: algPrivInfo,\n\thashAlgs: hashAlgs,\n\tcurves: curves\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2FsZ3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsYUFBYSw4RkFBOEI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9hbGdzLmpzPzJjYjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG5cbnZhciBhbGdJbmZvID0ge1xuXHQnZHNhJzoge1xuXHRcdHBhcnRzOiBbJ3AnLCAncScsICdnJywgJ3knXSxcblx0XHRzaXplUGFydDogJ3AnXG5cdH0sXG5cdCdyc2EnOiB7XG5cdFx0cGFydHM6IFsnZScsICduJ10sXG5cdFx0c2l6ZVBhcnQ6ICduJ1xuXHR9LFxuXHQnZWNkc2EnOiB7XG5cdFx0cGFydHM6IFsnY3VydmUnLCAnUSddLFxuXHRcdHNpemVQYXJ0OiAnUSdcblx0fSxcblx0J2VkMjU1MTknOiB7XG5cdFx0cGFydHM6IFsnQSddLFxuXHRcdHNpemVQYXJ0OiAnQSdcblx0fVxufTtcbmFsZ0luZm9bJ2N1cnZlMjU1MTknXSA9IGFsZ0luZm9bJ2VkMjU1MTknXTtcblxudmFyIGFsZ1ByaXZJbmZvID0ge1xuXHQnZHNhJzoge1xuXHRcdHBhcnRzOiBbJ3AnLCAncScsICdnJywgJ3knLCAneCddXG5cdH0sXG5cdCdyc2EnOiB7XG5cdFx0cGFydHM6IFsnbicsICdlJywgJ2QnLCAnaXFtcCcsICdwJywgJ3EnXVxuXHR9LFxuXHQnZWNkc2EnOiB7XG5cdFx0cGFydHM6IFsnY3VydmUnLCAnUScsICdkJ11cblx0fSxcblx0J2VkMjU1MTknOiB7XG5cdFx0cGFydHM6IFsnQScsICdrJ11cblx0fVxufTtcbmFsZ1ByaXZJbmZvWydjdXJ2ZTI1NTE5J10gPSBhbGdQcml2SW5mb1snZWQyNTUxOSddO1xuXG52YXIgaGFzaEFsZ3MgPSB7XG5cdCdtZDUnOiB0cnVlLFxuXHQnc2hhMSc6IHRydWUsXG5cdCdzaGEyNTYnOiB0cnVlLFxuXHQnc2hhMzg0JzogdHJ1ZSxcblx0J3NoYTUxMic6IHRydWVcbn07XG5cbi8qXG4gKiBUYWtlbiBmcm9tXG4gKiBodHRwOi8vY3NyYy5uaXN0Lmdvdi9ncm91cHMvU1QvdG9vbGtpdC9kb2N1bWVudHMvZHNzL05JU1RSZUN1ci5wZGZcbiAqL1xudmFyIGN1cnZlcyA9IHtcblx0J25pc3RwMjU2Jzoge1xuXHRcdHNpemU6IDI1Nixcblx0XHRwa2NzOG9pZDogJzEuMi44NDAuMTAwNDUuMy4xLjcnLFxuXHRcdHA6IEJ1ZmZlci5mcm9tKCgnMDAnICtcblx0XHQgICAgJ2ZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwJyArXG5cdFx0ICAgICcwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdGE6IEJ1ZmZlci5mcm9tKCgnMDAnICtcblx0XHQgICAgJ0ZGRkZGRkZGIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwJyArXG5cdFx0ICAgICcwMDAwMDAwMCBGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGQycpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdGI6IEJ1ZmZlci5mcm9tKChcblx0XHQgICAgJzVhYzYzNWQ4IGFhM2E5M2U3IGIzZWJiZDU1IDc2OTg4NmJjJyArXG5cdFx0ICAgICc2NTFkMDZiMCBjYzUzYjBmNiAzYmNlM2MzZSAyN2QyNjA0YicpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdHM6IEJ1ZmZlci5mcm9tKCgnMDAnICtcblx0XHQgICAgJ2M0OWQzNjA4IDg2ZTcwNDkzIDZhNjY3OGUxIDEzOWQyNmI3JyArXG5cdFx0ICAgICc4MTlmN2U5MCcpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdG46IEJ1ZmZlci5mcm9tKCgnMDAnICtcblx0XHQgICAgJ2ZmZmZmZmZmIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmJyArXG5cdFx0ICAgICdiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MScpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdEc6IEJ1ZmZlci5mcm9tKCgnMDQnICtcblx0XHQgICAgJzZiMTdkMWYyIGUxMmM0MjQ3IGY4YmNlNmU1IDYzYTQ0MGYyJyArXG5cdFx0ICAgICc3NzAzN2Q4MSAyZGViMzNhMCBmNGExMzk0NSBkODk4YzI5NicgK1xuXHRcdCAgICAnNGZlMzQyZTIgZmUxYTdmOWIgOGVlN2ViNGEgN2MwZjllMTYnICtcblx0XHQgICAgJzJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1JykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4Jylcblx0fSxcblx0J25pc3RwMzg0Jzoge1xuXHRcdHNpemU6IDM4NCxcblx0XHRwa2NzOG9pZDogJzEuMy4xMzIuMC4zNCcsXG5cdFx0cDogQnVmZmVyLmZyb20oKCcwMCcgK1xuXHRcdCAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnICtcblx0XHQgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlJyArXG5cdFx0ICAgICdmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZicpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdGE6IEJ1ZmZlci5mcm9tKCgnMDAnICtcblx0XHQgICAgJ0ZGRkZGRkZGIEZGRkZGRkZGIEZGRkZGRkZGIEZGRkZGRkZGJyArXG5cdFx0ICAgICdGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGRScgK1xuXHRcdCAgICAnRkZGRkZGRkYgMDAwMDAwMDAgMDAwMDAwMDAgRkZGRkZGRkMnKS5cblx0XHQgICAgcmVwbGFjZSgvIC9nLCAnJyksICdoZXgnKSxcblx0XHRiOiBCdWZmZXIuZnJvbSgoXG5cdFx0ICAgICdiMzMxMmZhNyBlMjNlZTdlNCA5ODhlMDU2YiBlM2Y4MmQxOScgK1xuXHRcdCAgICAnMTgxZDljNmUgZmU4MTQxMTIgMDMxNDA4OGYgNTAxMzg3NWEnICtcblx0XHQgICAgJ2M2NTYzOThkIDhhMmVkMTlkIDJhODVjOGVkIGQzZWMyYWVmJykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0czogQnVmZmVyLmZyb20oKCcwMCcgK1xuXHRcdCAgICAnYTMzNTkyNmEgYTMxOWEyN2EgMWQwMDg5NmEgNjc3M2E0ODInICtcblx0XHQgICAgJzdhY2RhYzczJykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0bjogQnVmZmVyLmZyb20oKCcwMCcgK1xuXHRcdCAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnICtcblx0XHQgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGM3NjM0ZDgxIGY0MzcyZGRmJyArXG5cdFx0ICAgICc1ODFhMGRiMiA0OGIwYTc3YSBlY2VjMTk2YSBjY2M1Mjk3MycpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdEc6IEJ1ZmZlci5mcm9tKCgnMDQnICtcblx0XHQgICAgJ2FhODdjYTIyIGJlOGIwNTM3IDhlYjFjNzFlIGYzMjBhZDc0JyArXG5cdFx0ICAgICc2ZTFkM2I2MiA4YmE3OWI5OCA1OWY3NDFlMCA4MjU0MmEzOCcgK1xuXHRcdCAgICAnNTUwMmYyNWQgYmY1NTI5NmMgM2E1NDVlMzggNzI3NjBhYjcnICtcblx0XHQgICAgJzM2MTdkZTRhIDk2MjYyYzZmIDVkOWU5OGJmIDkyOTJkYzI5JyArXG5cdFx0ICAgICdmOGY0MWRiZCAyODlhMTQ3YyBlOWRhMzExMyBiNWYwYjhjMCcgK1xuXHRcdCAgICAnMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWYnKS5cblx0XHQgICAgcmVwbGFjZSgvIC9nLCAnJyksICdoZXgnKVxuXHR9LFxuXHQnbmlzdHA1MjEnOiB7XG5cdFx0c2l6ZTogNTIxLFxuXHRcdHBrY3M4b2lkOiAnMS4zLjEzMi4wLjM1Jyxcblx0XHRwOiBCdWZmZXIuZnJvbSgoXG5cdFx0ICAgICcwMWZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicgK1xuXHRcdCAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnICtcblx0XHQgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyArXG5cdFx0ICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicgK1xuXHRcdCAgICAnZmZmZicpLnJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0YTogQnVmZmVyLmZyb20oKCcwMUZGJyArXG5cdFx0ICAgICdGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGRicgK1xuXHRcdCAgICAnRkZGRkZGRkYgRkZGRkZGRkYgRkZGRkZGRkYgRkZGRkZGRkYnICtcblx0XHQgICAgJ0ZGRkZGRkZGIEZGRkZGRkZGIEZGRkZGRkZGIEZGRkZGRkZGJyArXG5cdFx0ICAgICdGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGQycpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdGI6IEJ1ZmZlci5mcm9tKCgnNTEnICtcblx0XHQgICAgJzk1M2ViOTYxIDhlMWM5YTFmIDkyOWEyMWEwIGI2ODU0MGVlJyArXG5cdFx0ICAgICdhMmRhNzI1YiA5OWIzMTVmMyBiOGI0ODk5MSA4ZWYxMDllMScgK1xuXHRcdCAgICAnNTYxOTM5NTEgZWM3ZTkzN2IgMTY1MmMwYmQgM2JiMWJmMDcnICtcblx0XHQgICAgJzM1NzNkZjg4IDNkMmMzNGYxIGVmNDUxZmQ0IDZiNTAzZjAwJykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0czogQnVmZmVyLmZyb20oKCcwMCcgK1xuXHRcdCAgICAnZDA5ZTg4MDAgMjkxY2I4NTMgOTZjYzY3MTcgMzkzMjg0YWEnICtcblx0XHQgICAgJ2EwZGE2NGJhJykucmVwbGFjZSgvIC9nLCAnJyksICdoZXgnKSxcblx0XHRuOiBCdWZmZXIuZnJvbSgoJzAxZmYnICtcblx0XHQgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyArXG5cdFx0ICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYScgK1xuXHRcdCAgICAnNTE4Njg3ODMgYmYyZjk2NmIgN2ZjYzAxNDggZjcwOWE1ZDAnICtcblx0XHQgICAgJzNiYjVjOWI4IDg5OWM0N2FlIGJiNmZiNzFlIDkxMzg2NDA5JykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0RzogQnVmZmVyLmZyb20oKCcwNCcgK1xuXHRcdCAgICAnMDBjNiA4NThlMDZiNyAwNDA0ZTljZCA5ZTNlY2I2NiAyMzk1YjQ0MicgK1xuXHRcdCAgICAgICAgICc5YzY0ODEzOSAwNTNmYjUyMSBmODI4YWY2MCA2YjRkM2RiYScgK1xuXHRcdCAgICAgICAgICdhMTRiNWU3NyBlZmU3NTkyOCBmZTFkYzEyNyBhMmZmYThkZScgK1xuXHRcdCAgICAgICAgICczMzQ4YjNjMSA4NTZhNDI5YiBmOTdlN2UzMSBjMmU1YmQ2NicgK1xuXHRcdCAgICAnMDExOCAzOTI5NmE3OCA5YTNiYzAwNCA1YzhhNWZiNCAyYzdkMWJkOScgK1xuXHRcdCAgICAgICAgICc5OGY1NDQ0OSA1NzliNDQ2OCAxN2FmYmQxNyAyNzNlNjYyYycgK1xuXHRcdCAgICAgICAgICc5N2VlNzI5OSA1ZWY0MjY0MCBjNTUwYjkwMSAzZmFkMDc2MScgK1xuXHRcdCAgICAgICAgICczNTNjNzA4NiBhMjcyYzI0MCA4OGJlOTQ3NiA5ZmQxNjY1MCcpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpXG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRpbmZvOiBhbGdJbmZvLFxuXHRwcml2SW5mbzogYWxnUHJpdkluZm8sXG5cdGhhc2hBbGdzOiBoYXNoQWxncyxcblx0Y3VydmVzOiBjdXJ2ZXNcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/algs.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/certificate.js":
/*!***********************************************!*\
  !*** ./node_modules/sshpk/lib/certificate.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2016 Joyent, Inc.\n\nmodule.exports = Certificate;\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ./algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar Fingerprint = __webpack_require__(/*! ./fingerprint */ \"(action-browser)/./node_modules/sshpk/lib/fingerprint.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"(action-browser)/./node_modules/sshpk/lib/signature.js\");\nvar errs = __webpack_require__(/*! ./errors */ \"(action-browser)/./node_modules/sshpk/lib/errors.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar utils = __webpack_require__(/*! ./utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ./key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ./private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\nvar Identity = __webpack_require__(/*! ./identity */ \"(action-browser)/./node_modules/sshpk/lib/identity.js\");\n\nvar formats = {};\nformats['openssh'] = __webpack_require__(/*! ./formats/openssh-cert */ \"(action-browser)/./node_modules/sshpk/lib/formats/openssh-cert.js\");\nformats['x509'] = __webpack_require__(/*! ./formats/x509 */ \"(action-browser)/./node_modules/sshpk/lib/formats/x509.js\");\nformats['pem'] = __webpack_require__(/*! ./formats/x509-pem */ \"(action-browser)/./node_modules/sshpk/lib/formats/x509-pem.js\");\n\nvar CertificateParseError = errs.CertificateParseError;\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\n\nfunction Certificate(opts) {\n\tassert.object(opts, 'options');\n\tassert.arrayOfObject(opts.subjects, 'options.subjects');\n\tutils.assertCompatible(opts.subjects[0], Identity, [1, 0],\n\t    'options.subjects');\n\tutils.assertCompatible(opts.subjectKey, Key, [1, 0],\n\t    'options.subjectKey');\n\tutils.assertCompatible(opts.issuer, Identity, [1, 0], 'options.issuer');\n\tif (opts.issuerKey !== undefined) {\n\t\tutils.assertCompatible(opts.issuerKey, Key, [1, 0],\n\t\t    'options.issuerKey');\n\t}\n\tassert.object(opts.signatures, 'options.signatures');\n\tassert.buffer(opts.serial, 'options.serial');\n\tassert.date(opts.validFrom, 'options.validFrom');\n\tassert.date(opts.validUntil, 'optons.validUntil');\n\n\tassert.optionalArrayOfString(opts.purposes, 'options.purposes');\n\n\tthis._hashCache = {};\n\n\tthis.subjects = opts.subjects;\n\tthis.issuer = opts.issuer;\n\tthis.subjectKey = opts.subjectKey;\n\tthis.issuerKey = opts.issuerKey;\n\tthis.signatures = opts.signatures;\n\tthis.serial = opts.serial;\n\tthis.validFrom = opts.validFrom;\n\tthis.validUntil = opts.validUntil;\n\tthis.purposes = opts.purposes;\n}\n\nCertificate.formats = formats;\n\nCertificate.prototype.toBuffer = function (format, options) {\n\tif (format === undefined)\n\t\tformat = 'x509';\n\tassert.string(format, 'format');\n\tassert.object(formats[format], 'formats[format]');\n\tassert.optionalObject(options, 'options');\n\n\treturn (formats[format].write(this, options));\n};\n\nCertificate.prototype.toString = function (format, options) {\n\tif (format === undefined)\n\t\tformat = 'pem';\n\treturn (this.toBuffer(format, options).toString());\n};\n\nCertificate.prototype.fingerprint = function (algo) {\n\tif (algo === undefined)\n\t\talgo = 'sha256';\n\tassert.string(algo, 'algorithm');\n\tvar opts = {\n\t\ttype: 'certificate',\n\t\thash: this.hash(algo),\n\t\talgorithm: algo\n\t};\n\treturn (new Fingerprint(opts));\n};\n\nCertificate.prototype.hash = function (algo) {\n\tassert.string(algo, 'algorithm');\n\talgo = algo.toLowerCase();\n\tif (algs.hashAlgs[algo] === undefined)\n\t\tthrow (new InvalidAlgorithmError(algo));\n\n\tif (this._hashCache[algo])\n\t\treturn (this._hashCache[algo]);\n\n\tvar hash = crypto.createHash(algo).\n\t    update(this.toBuffer('x509')).digest();\n\tthis._hashCache[algo] = hash;\n\treturn (hash);\n};\n\nCertificate.prototype.isExpired = function (when) {\n\tif (when === undefined)\n\t\twhen = new Date();\n\treturn (!((when.getTime() >= this.validFrom.getTime()) &&\n\t\t(when.getTime() < this.validUntil.getTime())));\n};\n\nCertificate.prototype.isSignedBy = function (issuerCert) {\n\tutils.assertCompatible(issuerCert, Certificate, [1, 0], 'issuer');\n\n\tif (!this.issuer.equals(issuerCert.subjects[0]))\n\t\treturn (false);\n\tif (this.issuer.purposes && this.issuer.purposes.length > 0 &&\n\t    this.issuer.purposes.indexOf('ca') === -1) {\n\t\treturn (false);\n\t}\n\n\treturn (this.isSignedByKey(issuerCert.subjectKey));\n};\n\nCertificate.prototype.getExtension = function (keyOrOid) {\n\tassert.string(keyOrOid, 'keyOrOid');\n\tvar ext = this.getExtensions().filter(function (maybeExt) {\n\t\tif (maybeExt.format === 'x509')\n\t\t\treturn (maybeExt.oid === keyOrOid);\n\t\tif (maybeExt.format === 'openssh')\n\t\t\treturn (maybeExt.name === keyOrOid);\n\t\treturn (false);\n\t})[0];\n\treturn (ext);\n};\n\nCertificate.prototype.getExtensions = function () {\n\tvar exts = [];\n\tvar x509 = this.signatures.x509;\n\tif (x509 && x509.extras && x509.extras.exts) {\n\t\tx509.extras.exts.forEach(function (ext) {\n\t\t\text.format = 'x509';\n\t\t\texts.push(ext);\n\t\t});\n\t}\n\tvar openssh = this.signatures.openssh;\n\tif (openssh && openssh.exts) {\n\t\topenssh.exts.forEach(function (ext) {\n\t\t\text.format = 'openssh';\n\t\t\texts.push(ext);\n\t\t});\n\t}\n\treturn (exts);\n};\n\nCertificate.prototype.isSignedByKey = function (issuerKey) {\n\tutils.assertCompatible(issuerKey, Key, [1, 2], 'issuerKey');\n\n\tif (this.issuerKey !== undefined) {\n\t\treturn (this.issuerKey.\n\t\t    fingerprint('sha512').matches(issuerKey));\n\t}\n\n\tvar fmt = Object.keys(this.signatures)[0];\n\tvar valid = formats[fmt].verify(this, issuerKey);\n\tif (valid)\n\t\tthis.issuerKey = issuerKey;\n\treturn (valid);\n};\n\nCertificate.prototype.signWith = function (key) {\n\tutils.assertCompatible(key, PrivateKey, [1, 2], 'key');\n\tvar fmts = Object.keys(formats);\n\tvar didOne = false;\n\tfor (var i = 0; i < fmts.length; ++i) {\n\t\tif (fmts[i] !== 'pem') {\n\t\t\tvar ret = formats[fmts[i]].sign(this, key);\n\t\t\tif (ret === true)\n\t\t\t\tdidOne = true;\n\t\t}\n\t}\n\tif (!didOne) {\n\t\tthrow (new Error('Failed to sign the certificate for any ' +\n\t\t    'available certificate formats'));\n\t}\n};\n\nCertificate.createSelfSigned = function (subjectOrSubjects, key, options) {\n\tvar subjects;\n\tif (Array.isArray(subjectOrSubjects))\n\t\tsubjects = subjectOrSubjects;\n\telse\n\t\tsubjects = [subjectOrSubjects];\n\n\tassert.arrayOfObject(subjects);\n\tsubjects.forEach(function (subject) {\n\t\tutils.assertCompatible(subject, Identity, [1, 0], 'subject');\n\t});\n\n\tutils.assertCompatible(key, PrivateKey, [1, 2], 'private key');\n\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.optionalObject(options.validFrom, 'options.validFrom');\n\tassert.optionalObject(options.validUntil, 'options.validUntil');\n\tvar validFrom = options.validFrom;\n\tvar validUntil = options.validUntil;\n\tif (validFrom === undefined)\n\t\tvalidFrom = new Date();\n\tif (validUntil === undefined) {\n\t\tassert.optionalNumber(options.lifetime, 'options.lifetime');\n\t\tvar lifetime = options.lifetime;\n\t\tif (lifetime === undefined)\n\t\t\tlifetime = 10*365*24*3600;\n\t\tvalidUntil = new Date();\n\t\tvalidUntil.setTime(validUntil.getTime() + lifetime*1000);\n\t}\n\tassert.optionalBuffer(options.serial, 'options.serial');\n\tvar serial = options.serial;\n\tif (serial === undefined)\n\t\tserial = Buffer.from('0000000000000001', 'hex');\n\n\tvar purposes = options.purposes;\n\tif (purposes === undefined)\n\t\tpurposes = [];\n\n\tif (purposes.indexOf('signature') === -1)\n\t\tpurposes.push('signature');\n\n\t/* Self-signed certs are always CAs. */\n\tif (purposes.indexOf('ca') === -1)\n\t\tpurposes.push('ca');\n\tif (purposes.indexOf('crl') === -1)\n\t\tpurposes.push('crl');\n\n\t/*\n\t * If we weren't explicitly given any other purposes, do the sensible\n\t * thing and add some basic ones depending on the subject type.\n\t */\n\tif (purposes.length <= 3) {\n\t\tvar hostSubjects = subjects.filter(function (subject) {\n\t\t\treturn (subject.type === 'host');\n\t\t});\n\t\tvar userSubjects = subjects.filter(function (subject) {\n\t\t\treturn (subject.type === 'user');\n\t\t});\n\t\tif (hostSubjects.length > 0) {\n\t\t\tif (purposes.indexOf('serverAuth') === -1)\n\t\t\t\tpurposes.push('serverAuth');\n\t\t}\n\t\tif (userSubjects.length > 0) {\n\t\t\tif (purposes.indexOf('clientAuth') === -1)\n\t\t\t\tpurposes.push('clientAuth');\n\t\t}\n\t\tif (userSubjects.length > 0 || hostSubjects.length > 0) {\n\t\t\tif (purposes.indexOf('keyAgreement') === -1)\n\t\t\t\tpurposes.push('keyAgreement');\n\t\t\tif (key.type === 'rsa' &&\n\t\t\t    purposes.indexOf('encryption') === -1)\n\t\t\t\tpurposes.push('encryption');\n\t\t}\n\t}\n\n\tvar cert = new Certificate({\n\t\tsubjects: subjects,\n\t\tissuer: subjects[0],\n\t\tsubjectKey: key.toPublic(),\n\t\tissuerKey: key.toPublic(),\n\t\tsignatures: {},\n\t\tserial: serial,\n\t\tvalidFrom: validFrom,\n\t\tvalidUntil: validUntil,\n\t\tpurposes: purposes\n\t});\n\tcert.signWith(key);\n\n\treturn (cert);\n};\n\nCertificate.create =\n    function (subjectOrSubjects, key, issuer, issuerKey, options) {\n\tvar subjects;\n\tif (Array.isArray(subjectOrSubjects))\n\t\tsubjects = subjectOrSubjects;\n\telse\n\t\tsubjects = [subjectOrSubjects];\n\n\tassert.arrayOfObject(subjects);\n\tsubjects.forEach(function (subject) {\n\t\tutils.assertCompatible(subject, Identity, [1, 0], 'subject');\n\t});\n\n\tutils.assertCompatible(key, Key, [1, 0], 'key');\n\tif (PrivateKey.isPrivateKey(key))\n\t\tkey = key.toPublic();\n\tutils.assertCompatible(issuer, Identity, [1, 0], 'issuer');\n\tutils.assertCompatible(issuerKey, PrivateKey, [1, 2], 'issuer key');\n\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.optionalObject(options.validFrom, 'options.validFrom');\n\tassert.optionalObject(options.validUntil, 'options.validUntil');\n\tvar validFrom = options.validFrom;\n\tvar validUntil = options.validUntil;\n\tif (validFrom === undefined)\n\t\tvalidFrom = new Date();\n\tif (validUntil === undefined) {\n\t\tassert.optionalNumber(options.lifetime, 'options.lifetime');\n\t\tvar lifetime = options.lifetime;\n\t\tif (lifetime === undefined)\n\t\t\tlifetime = 10*365*24*3600;\n\t\tvalidUntil = new Date();\n\t\tvalidUntil.setTime(validUntil.getTime() + lifetime*1000);\n\t}\n\tassert.optionalBuffer(options.serial, 'options.serial');\n\tvar serial = options.serial;\n\tif (serial === undefined)\n\t\tserial = Buffer.from('0000000000000001', 'hex');\n\n\tvar purposes = options.purposes;\n\tif (purposes === undefined)\n\t\tpurposes = [];\n\n\tif (purposes.indexOf('signature') === -1)\n\t\tpurposes.push('signature');\n\n\tif (options.ca === true) {\n\t\tif (purposes.indexOf('ca') === -1)\n\t\t\tpurposes.push('ca');\n\t\tif (purposes.indexOf('crl') === -1)\n\t\t\tpurposes.push('crl');\n\t}\n\n\tvar hostSubjects = subjects.filter(function (subject) {\n\t\treturn (subject.type === 'host');\n\t});\n\tvar userSubjects = subjects.filter(function (subject) {\n\t\treturn (subject.type === 'user');\n\t});\n\tif (hostSubjects.length > 0) {\n\t\tif (purposes.indexOf('serverAuth') === -1)\n\t\t\tpurposes.push('serverAuth');\n\t}\n\tif (userSubjects.length > 0) {\n\t\tif (purposes.indexOf('clientAuth') === -1)\n\t\t\tpurposes.push('clientAuth');\n\t}\n\tif (userSubjects.length > 0 || hostSubjects.length > 0) {\n\t\tif (purposes.indexOf('keyAgreement') === -1)\n\t\t\tpurposes.push('keyAgreement');\n\t\tif (key.type === 'rsa' &&\n\t\t    purposes.indexOf('encryption') === -1)\n\t\t\tpurposes.push('encryption');\n\t}\n\n\tvar cert = new Certificate({\n\t\tsubjects: subjects,\n\t\tissuer: issuer,\n\t\tsubjectKey: key,\n\t\tissuerKey: issuerKey.toPublic(),\n\t\tsignatures: {},\n\t\tserial: serial,\n\t\tvalidFrom: validFrom,\n\t\tvalidUntil: validUntil,\n\t\tpurposes: purposes\n\t});\n\tcert.signWith(issuerKey);\n\n\treturn (cert);\n};\n\nCertificate.parse = function (data, format, options) {\n\tif (typeof (data) !== 'string')\n\t\tassert.buffer(data, 'data');\n\tif (format === undefined)\n\t\tformat = 'auto';\n\tassert.string(format, 'format');\n\tif (typeof (options) === 'string')\n\t\toptions = { filename: options };\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.optionalString(options.filename, 'options.filename');\n\tif (options.filename === undefined)\n\t\toptions.filename = '(unnamed)';\n\n\tassert.object(formats[format], 'formats[format]');\n\n\ttry {\n\t\tvar k = formats[format].read(data, options);\n\t\treturn (k);\n\t} catch (e) {\n\t\tthrow (new CertificateParseError(options.filename, format, e));\n\t}\n};\n\nCertificate.isCertificate = function (obj, ver) {\n\treturn (utils.isCompatible(obj, Certificate, ver));\n};\n\n/*\n * API versions for Certificate:\n * [1,0] -- initial ver\n * [1,1] -- openssh format now unpacks extensions\n */\nCertificate.prototype._sshpkApiVersion = [1, 1];\n\nCertificate._oldVersionDetect = function (obj) {\n\treturn ([1, 0]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvY2VydGlmaWNhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDBFQUFhO0FBQ2xDLGFBQWEseUdBQThCO0FBQzNDLFdBQVcsbUJBQU8sQ0FBQyxpRUFBUTtBQUMzQixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMsK0VBQWU7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsMkVBQWE7QUFDckMsV0FBVyxtQkFBTyxDQUFDLHFFQUFVO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsbUVBQVM7QUFDN0IsVUFBVSxtQkFBTyxDQUFDLCtEQUFPO0FBQ3pCLGlCQUFpQixtQkFBTyxDQUFDLCtFQUFlO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyx5RUFBWTs7QUFFbkM7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxpR0FBd0I7QUFDckQsa0JBQWtCLG1CQUFPLENBQUMsaUZBQWdCO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLHlGQUFvQjs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9jZXJ0aWZpY2F0ZS5qcz9mZWFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE2IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IENlcnRpZmljYXRlO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4vYWxncycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIEZpbmdlcnByaW50ID0gcmVxdWlyZSgnLi9maW5nZXJwcmludCcpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG52YXIgZXJycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBLZXkgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuL3ByaXZhdGUta2V5Jyk7XG52YXIgSWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbnZhciBmb3JtYXRzID0ge307XG5mb3JtYXRzWydvcGVuc3NoJ10gPSByZXF1aXJlKCcuL2Zvcm1hdHMvb3BlbnNzaC1jZXJ0Jyk7XG5mb3JtYXRzWyd4NTA5J10gPSByZXF1aXJlKCcuL2Zvcm1hdHMveDUwOScpO1xuZm9ybWF0c1sncGVtJ10gPSByZXF1aXJlKCcuL2Zvcm1hdHMveDUwOS1wZW0nKTtcblxudmFyIENlcnRpZmljYXRlUGFyc2VFcnJvciA9IGVycnMuQ2VydGlmaWNhdGVQYXJzZUVycm9yO1xudmFyIEludmFsaWRBbGdvcml0aG1FcnJvciA9IGVycnMuSW52YWxpZEFsZ29yaXRobUVycm9yO1xuXG5mdW5jdGlvbiBDZXJ0aWZpY2F0ZShvcHRzKSB7XG5cdGFzc2VydC5vYmplY3Qob3B0cywgJ29wdGlvbnMnKTtcblx0YXNzZXJ0LmFycmF5T2ZPYmplY3Qob3B0cy5zdWJqZWN0cywgJ29wdGlvbnMuc3ViamVjdHMnKTtcblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShvcHRzLnN1YmplY3RzWzBdLCBJZGVudGl0eSwgWzEsIDBdLFxuXHQgICAgJ29wdGlvbnMuc3ViamVjdHMnKTtcblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShvcHRzLnN1YmplY3RLZXksIEtleSwgWzEsIDBdLFxuXHQgICAgJ29wdGlvbnMuc3ViamVjdEtleScpO1xuXHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKG9wdHMuaXNzdWVyLCBJZGVudGl0eSwgWzEsIDBdLCAnb3B0aW9ucy5pc3N1ZXInKTtcblx0aWYgKG9wdHMuaXNzdWVyS2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKG9wdHMuaXNzdWVyS2V5LCBLZXksIFsxLCAwXSxcblx0XHQgICAgJ29wdGlvbnMuaXNzdWVyS2V5Jyk7XG5cdH1cblx0YXNzZXJ0Lm9iamVjdChvcHRzLnNpZ25hdHVyZXMsICdvcHRpb25zLnNpZ25hdHVyZXMnKTtcblx0YXNzZXJ0LmJ1ZmZlcihvcHRzLnNlcmlhbCwgJ29wdGlvbnMuc2VyaWFsJyk7XG5cdGFzc2VydC5kYXRlKG9wdHMudmFsaWRGcm9tLCAnb3B0aW9ucy52YWxpZEZyb20nKTtcblx0YXNzZXJ0LmRhdGUob3B0cy52YWxpZFVudGlsLCAnb3B0b25zLnZhbGlkVW50aWwnKTtcblxuXHRhc3NlcnQub3B0aW9uYWxBcnJheU9mU3RyaW5nKG9wdHMucHVycG9zZXMsICdvcHRpb25zLnB1cnBvc2VzJyk7XG5cblx0dGhpcy5faGFzaENhY2hlID0ge307XG5cblx0dGhpcy5zdWJqZWN0cyA9IG9wdHMuc3ViamVjdHM7XG5cdHRoaXMuaXNzdWVyID0gb3B0cy5pc3N1ZXI7XG5cdHRoaXMuc3ViamVjdEtleSA9IG9wdHMuc3ViamVjdEtleTtcblx0dGhpcy5pc3N1ZXJLZXkgPSBvcHRzLmlzc3VlcktleTtcblx0dGhpcy5zaWduYXR1cmVzID0gb3B0cy5zaWduYXR1cmVzO1xuXHR0aGlzLnNlcmlhbCA9IG9wdHMuc2VyaWFsO1xuXHR0aGlzLnZhbGlkRnJvbSA9IG9wdHMudmFsaWRGcm9tO1xuXHR0aGlzLnZhbGlkVW50aWwgPSBvcHRzLnZhbGlkVW50aWw7XG5cdHRoaXMucHVycG9zZXMgPSBvcHRzLnB1cnBvc2VzO1xufVxuXG5DZXJ0aWZpY2F0ZS5mb3JtYXRzID0gZm9ybWF0cztcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gKGZvcm1hdCwgb3B0aW9ucykge1xuXHRpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpXG5cdFx0Zm9ybWF0ID0gJ3g1MDknO1xuXHRhc3NlcnQuc3RyaW5nKGZvcm1hdCwgJ2Zvcm1hdCcpO1xuXHRhc3NlcnQub2JqZWN0KGZvcm1hdHNbZm9ybWF0XSwgJ2Zvcm1hdHNbZm9ybWF0XScpO1xuXHRhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcblxuXHRyZXR1cm4gKGZvcm1hdHNbZm9ybWF0XS53cml0ZSh0aGlzLCBvcHRpb25zKSk7XG59O1xuXG5DZXJ0aWZpY2F0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZm9ybWF0LCBvcHRpb25zKSB7XG5cdGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZClcblx0XHRmb3JtYXQgPSAncGVtJztcblx0cmV0dXJuICh0aGlzLnRvQnVmZmVyKGZvcm1hdCwgb3B0aW9ucykudG9TdHJpbmcoKSk7XG59O1xuXG5DZXJ0aWZpY2F0ZS5wcm90b3R5cGUuZmluZ2VycHJpbnQgPSBmdW5jdGlvbiAoYWxnbykge1xuXHRpZiAoYWxnbyA9PT0gdW5kZWZpbmVkKVxuXHRcdGFsZ28gPSAnc2hhMjU2Jztcblx0YXNzZXJ0LnN0cmluZyhhbGdvLCAnYWxnb3JpdGhtJyk7XG5cdHZhciBvcHRzID0ge1xuXHRcdHR5cGU6ICdjZXJ0aWZpY2F0ZScsXG5cdFx0aGFzaDogdGhpcy5oYXNoKGFsZ28pLFxuXHRcdGFsZ29yaXRobTogYWxnb1xuXHR9O1xuXHRyZXR1cm4gKG5ldyBGaW5nZXJwcmludChvcHRzKSk7XG59O1xuXG5DZXJ0aWZpY2F0ZS5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uIChhbGdvKSB7XG5cdGFzc2VydC5zdHJpbmcoYWxnbywgJ2FsZ29yaXRobScpO1xuXHRhbGdvID0gYWxnby50b0xvd2VyQ2FzZSgpO1xuXHRpZiAoYWxncy5oYXNoQWxnc1thbGdvXSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKGFsZ28pKTtcblxuXHRpZiAodGhpcy5faGFzaENhY2hlW2FsZ29dKVxuXHRcdHJldHVybiAodGhpcy5faGFzaENhY2hlW2FsZ29dKTtcblxuXHR2YXIgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKGFsZ28pLlxuXHQgICAgdXBkYXRlKHRoaXMudG9CdWZmZXIoJ3g1MDknKSkuZGlnZXN0KCk7XG5cdHRoaXMuX2hhc2hDYWNoZVthbGdvXSA9IGhhc2g7XG5cdHJldHVybiAoaGFzaCk7XG59O1xuXG5DZXJ0aWZpY2F0ZS5wcm90b3R5cGUuaXNFeHBpcmVkID0gZnVuY3Rpb24gKHdoZW4pIHtcblx0aWYgKHdoZW4gPT09IHVuZGVmaW5lZClcblx0XHR3aGVuID0gbmV3IERhdGUoKTtcblx0cmV0dXJuICghKCh3aGVuLmdldFRpbWUoKSA+PSB0aGlzLnZhbGlkRnJvbS5nZXRUaW1lKCkpICYmXG5cdFx0KHdoZW4uZ2V0VGltZSgpIDwgdGhpcy52YWxpZFVudGlsLmdldFRpbWUoKSkpKTtcbn07XG5cbkNlcnRpZmljYXRlLnByb3RvdHlwZS5pc1NpZ25lZEJ5ID0gZnVuY3Rpb24gKGlzc3VlckNlcnQpIHtcblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShpc3N1ZXJDZXJ0LCBDZXJ0aWZpY2F0ZSwgWzEsIDBdLCAnaXNzdWVyJyk7XG5cblx0aWYgKCF0aGlzLmlzc3Vlci5lcXVhbHMoaXNzdWVyQ2VydC5zdWJqZWN0c1swXSkpXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cdGlmICh0aGlzLmlzc3Vlci5wdXJwb3NlcyAmJiB0aGlzLmlzc3Vlci5wdXJwb3Nlcy5sZW5ndGggPiAwICYmXG5cdCAgICB0aGlzLmlzc3Vlci5wdXJwb3Nlcy5pbmRleE9mKCdjYScpID09PSAtMSkge1xuXHRcdHJldHVybiAoZmFsc2UpO1xuXHR9XG5cblx0cmV0dXJuICh0aGlzLmlzU2lnbmVkQnlLZXkoaXNzdWVyQ2VydC5zdWJqZWN0S2V5KSk7XG59O1xuXG5DZXJ0aWZpY2F0ZS5wcm90b3R5cGUuZ2V0RXh0ZW5zaW9uID0gZnVuY3Rpb24gKGtleU9yT2lkKSB7XG5cdGFzc2VydC5zdHJpbmcoa2V5T3JPaWQsICdrZXlPck9pZCcpO1xuXHR2YXIgZXh0ID0gdGhpcy5nZXRFeHRlbnNpb25zKCkuZmlsdGVyKGZ1bmN0aW9uIChtYXliZUV4dCkge1xuXHRcdGlmIChtYXliZUV4dC5mb3JtYXQgPT09ICd4NTA5Jylcblx0XHRcdHJldHVybiAobWF5YmVFeHQub2lkID09PSBrZXlPck9pZCk7XG5cdFx0aWYgKG1heWJlRXh0LmZvcm1hdCA9PT0gJ29wZW5zc2gnKVxuXHRcdFx0cmV0dXJuIChtYXliZUV4dC5uYW1lID09PSBrZXlPck9pZCk7XG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cdH0pWzBdO1xuXHRyZXR1cm4gKGV4dCk7XG59O1xuXG5DZXJ0aWZpY2F0ZS5wcm90b3R5cGUuZ2V0RXh0ZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGV4dHMgPSBbXTtcblx0dmFyIHg1MDkgPSB0aGlzLnNpZ25hdHVyZXMueDUwOTtcblx0aWYgKHg1MDkgJiYgeDUwOS5leHRyYXMgJiYgeDUwOS5leHRyYXMuZXh0cykge1xuXHRcdHg1MDkuZXh0cmFzLmV4dHMuZm9yRWFjaChmdW5jdGlvbiAoZXh0KSB7XG5cdFx0XHRleHQuZm9ybWF0ID0gJ3g1MDknO1xuXHRcdFx0ZXh0cy5wdXNoKGV4dCk7XG5cdFx0fSk7XG5cdH1cblx0dmFyIG9wZW5zc2ggPSB0aGlzLnNpZ25hdHVyZXMub3BlbnNzaDtcblx0aWYgKG9wZW5zc2ggJiYgb3BlbnNzaC5leHRzKSB7XG5cdFx0b3BlbnNzaC5leHRzLmZvckVhY2goZnVuY3Rpb24gKGV4dCkge1xuXHRcdFx0ZXh0LmZvcm1hdCA9ICdvcGVuc3NoJztcblx0XHRcdGV4dHMucHVzaChleHQpO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiAoZXh0cyk7XG59O1xuXG5DZXJ0aWZpY2F0ZS5wcm90b3R5cGUuaXNTaWduZWRCeUtleSA9IGZ1bmN0aW9uIChpc3N1ZXJLZXkpIHtcblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShpc3N1ZXJLZXksIEtleSwgWzEsIDJdLCAnaXNzdWVyS2V5Jyk7XG5cblx0aWYgKHRoaXMuaXNzdWVyS2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gKHRoaXMuaXNzdWVyS2V5LlxuXHRcdCAgICBmaW5nZXJwcmludCgnc2hhNTEyJykubWF0Y2hlcyhpc3N1ZXJLZXkpKTtcblx0fVxuXG5cdHZhciBmbXQgPSBPYmplY3Qua2V5cyh0aGlzLnNpZ25hdHVyZXMpWzBdO1xuXHR2YXIgdmFsaWQgPSBmb3JtYXRzW2ZtdF0udmVyaWZ5KHRoaXMsIGlzc3VlcktleSk7XG5cdGlmICh2YWxpZClcblx0XHR0aGlzLmlzc3VlcktleSA9IGlzc3VlcktleTtcblx0cmV0dXJuICh2YWxpZCk7XG59O1xuXG5DZXJ0aWZpY2F0ZS5wcm90b3R5cGUuc2lnbldpdGggPSBmdW5jdGlvbiAoa2V5KSB7XG5cdHV0aWxzLmFzc2VydENvbXBhdGlibGUoa2V5LCBQcml2YXRlS2V5LCBbMSwgMl0sICdrZXknKTtcblx0dmFyIGZtdHMgPSBPYmplY3Qua2V5cyhmb3JtYXRzKTtcblx0dmFyIGRpZE9uZSA9IGZhbHNlO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGZtdHMubGVuZ3RoOyArK2kpIHtcblx0XHRpZiAoZm10c1tpXSAhPT0gJ3BlbScpIHtcblx0XHRcdHZhciByZXQgPSBmb3JtYXRzW2ZtdHNbaV1dLnNpZ24odGhpcywga2V5KTtcblx0XHRcdGlmIChyZXQgPT09IHRydWUpXG5cdFx0XHRcdGRpZE9uZSA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdGlmICghZGlkT25lKSB7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignRmFpbGVkIHRvIHNpZ24gdGhlIGNlcnRpZmljYXRlIGZvciBhbnkgJyArXG5cdFx0ICAgICdhdmFpbGFibGUgY2VydGlmaWNhdGUgZm9ybWF0cycpKTtcblx0fVxufTtcblxuQ2VydGlmaWNhdGUuY3JlYXRlU2VsZlNpZ25lZCA9IGZ1bmN0aW9uIChzdWJqZWN0T3JTdWJqZWN0cywga2V5LCBvcHRpb25zKSB7XG5cdHZhciBzdWJqZWN0cztcblx0aWYgKEFycmF5LmlzQXJyYXkoc3ViamVjdE9yU3ViamVjdHMpKVxuXHRcdHN1YmplY3RzID0gc3ViamVjdE9yU3ViamVjdHM7XG5cdGVsc2Vcblx0XHRzdWJqZWN0cyA9IFtzdWJqZWN0T3JTdWJqZWN0c107XG5cblx0YXNzZXJ0LmFycmF5T2ZPYmplY3Qoc3ViamVjdHMpO1xuXHRzdWJqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJqZWN0KSB7XG5cdFx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShzdWJqZWN0LCBJZGVudGl0eSwgWzEsIDBdLCAnc3ViamVjdCcpO1xuXHR9KTtcblxuXHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKGtleSwgUHJpdmF0ZUtleSwgWzEsIDJdLCAncHJpdmF0ZSBrZXknKTtcblxuXHRhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcblx0aWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZClcblx0XHRvcHRpb25zID0ge307XG5cdGFzc2VydC5vcHRpb25hbE9iamVjdChvcHRpb25zLnZhbGlkRnJvbSwgJ29wdGlvbnMudmFsaWRGcm9tJyk7XG5cdGFzc2VydC5vcHRpb25hbE9iamVjdChvcHRpb25zLnZhbGlkVW50aWwsICdvcHRpb25zLnZhbGlkVW50aWwnKTtcblx0dmFyIHZhbGlkRnJvbSA9IG9wdGlvbnMudmFsaWRGcm9tO1xuXHR2YXIgdmFsaWRVbnRpbCA9IG9wdGlvbnMudmFsaWRVbnRpbDtcblx0aWYgKHZhbGlkRnJvbSA9PT0gdW5kZWZpbmVkKVxuXHRcdHZhbGlkRnJvbSA9IG5ldyBEYXRlKCk7XG5cdGlmICh2YWxpZFVudGlsID09PSB1bmRlZmluZWQpIHtcblx0XHRhc3NlcnQub3B0aW9uYWxOdW1iZXIob3B0aW9ucy5saWZldGltZSwgJ29wdGlvbnMubGlmZXRpbWUnKTtcblx0XHR2YXIgbGlmZXRpbWUgPSBvcHRpb25zLmxpZmV0aW1lO1xuXHRcdGlmIChsaWZldGltZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0bGlmZXRpbWUgPSAxMCozNjUqMjQqMzYwMDtcblx0XHR2YWxpZFVudGlsID0gbmV3IERhdGUoKTtcblx0XHR2YWxpZFVudGlsLnNldFRpbWUodmFsaWRVbnRpbC5nZXRUaW1lKCkgKyBsaWZldGltZSoxMDAwKTtcblx0fVxuXHRhc3NlcnQub3B0aW9uYWxCdWZmZXIob3B0aW9ucy5zZXJpYWwsICdvcHRpb25zLnNlcmlhbCcpO1xuXHR2YXIgc2VyaWFsID0gb3B0aW9ucy5zZXJpYWw7XG5cdGlmIChzZXJpYWwgPT09IHVuZGVmaW5lZClcblx0XHRzZXJpYWwgPSBCdWZmZXIuZnJvbSgnMDAwMDAwMDAwMDAwMDAwMScsICdoZXgnKTtcblxuXHR2YXIgcHVycG9zZXMgPSBvcHRpb25zLnB1cnBvc2VzO1xuXHRpZiAocHVycG9zZXMgPT09IHVuZGVmaW5lZClcblx0XHRwdXJwb3NlcyA9IFtdO1xuXG5cdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdzaWduYXR1cmUnKSA9PT0gLTEpXG5cdFx0cHVycG9zZXMucHVzaCgnc2lnbmF0dXJlJyk7XG5cblx0LyogU2VsZi1zaWduZWQgY2VydHMgYXJlIGFsd2F5cyBDQXMuICovXG5cdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdjYScpID09PSAtMSlcblx0XHRwdXJwb3Nlcy5wdXNoKCdjYScpO1xuXHRpZiAocHVycG9zZXMuaW5kZXhPZignY3JsJykgPT09IC0xKVxuXHRcdHB1cnBvc2VzLnB1c2goJ2NybCcpO1xuXG5cdC8qXG5cdCAqIElmIHdlIHdlcmVuJ3QgZXhwbGljaXRseSBnaXZlbiBhbnkgb3RoZXIgcHVycG9zZXMsIGRvIHRoZSBzZW5zaWJsZVxuXHQgKiB0aGluZyBhbmQgYWRkIHNvbWUgYmFzaWMgb25lcyBkZXBlbmRpbmcgb24gdGhlIHN1YmplY3QgdHlwZS5cblx0ICovXG5cdGlmIChwdXJwb3Nlcy5sZW5ndGggPD0gMykge1xuXHRcdHZhciBob3N0U3ViamVjdHMgPSBzdWJqZWN0cy5maWx0ZXIoZnVuY3Rpb24gKHN1YmplY3QpIHtcblx0XHRcdHJldHVybiAoc3ViamVjdC50eXBlID09PSAnaG9zdCcpO1xuXHRcdH0pO1xuXHRcdHZhciB1c2VyU3ViamVjdHMgPSBzdWJqZWN0cy5maWx0ZXIoZnVuY3Rpb24gKHN1YmplY3QpIHtcblx0XHRcdHJldHVybiAoc3ViamVjdC50eXBlID09PSAndXNlcicpO1xuXHRcdH0pO1xuXHRcdGlmIChob3N0U3ViamVjdHMubGVuZ3RoID4gMCkge1xuXHRcdFx0aWYgKHB1cnBvc2VzLmluZGV4T2YoJ3NlcnZlckF1dGgnKSA9PT0gLTEpXG5cdFx0XHRcdHB1cnBvc2VzLnB1c2goJ3NlcnZlckF1dGgnKTtcblx0XHR9XG5cdFx0aWYgKHVzZXJTdWJqZWN0cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRpZiAocHVycG9zZXMuaW5kZXhPZignY2xpZW50QXV0aCcpID09PSAtMSlcblx0XHRcdFx0cHVycG9zZXMucHVzaCgnY2xpZW50QXV0aCcpO1xuXHRcdH1cblx0XHRpZiAodXNlclN1YmplY3RzLmxlbmd0aCA+IDAgfHwgaG9zdFN1YmplY3RzLmxlbmd0aCA+IDApIHtcblx0XHRcdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdrZXlBZ3JlZW1lbnQnKSA9PT0gLTEpXG5cdFx0XHRcdHB1cnBvc2VzLnB1c2goJ2tleUFncmVlbWVudCcpO1xuXHRcdFx0aWYgKGtleS50eXBlID09PSAncnNhJyAmJlxuXHRcdFx0ICAgIHB1cnBvc2VzLmluZGV4T2YoJ2VuY3J5cHRpb24nKSA9PT0gLTEpXG5cdFx0XHRcdHB1cnBvc2VzLnB1c2goJ2VuY3J5cHRpb24nKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgY2VydCA9IG5ldyBDZXJ0aWZpY2F0ZSh7XG5cdFx0c3ViamVjdHM6IHN1YmplY3RzLFxuXHRcdGlzc3Vlcjogc3ViamVjdHNbMF0sXG5cdFx0c3ViamVjdEtleToga2V5LnRvUHVibGljKCksXG5cdFx0aXNzdWVyS2V5OiBrZXkudG9QdWJsaWMoKSxcblx0XHRzaWduYXR1cmVzOiB7fSxcblx0XHRzZXJpYWw6IHNlcmlhbCxcblx0XHR2YWxpZEZyb206IHZhbGlkRnJvbSxcblx0XHR2YWxpZFVudGlsOiB2YWxpZFVudGlsLFxuXHRcdHB1cnBvc2VzOiBwdXJwb3Nlc1xuXHR9KTtcblx0Y2VydC5zaWduV2l0aChrZXkpO1xuXG5cdHJldHVybiAoY2VydCk7XG59O1xuXG5DZXJ0aWZpY2F0ZS5jcmVhdGUgPVxuICAgIGZ1bmN0aW9uIChzdWJqZWN0T3JTdWJqZWN0cywga2V5LCBpc3N1ZXIsIGlzc3VlcktleSwgb3B0aW9ucykge1xuXHR2YXIgc3ViamVjdHM7XG5cdGlmIChBcnJheS5pc0FycmF5KHN1YmplY3RPclN1YmplY3RzKSlcblx0XHRzdWJqZWN0cyA9IHN1YmplY3RPclN1YmplY3RzO1xuXHRlbHNlXG5cdFx0c3ViamVjdHMgPSBbc3ViamVjdE9yU3ViamVjdHNdO1xuXG5cdGFzc2VydC5hcnJheU9mT2JqZWN0KHN1YmplY3RzKTtcblx0c3ViamVjdHMuZm9yRWFjaChmdW5jdGlvbiAoc3ViamVjdCkge1xuXHRcdHV0aWxzLmFzc2VydENvbXBhdGlibGUoc3ViamVjdCwgSWRlbnRpdHksIFsxLCAwXSwgJ3N1YmplY3QnKTtcblx0fSk7XG5cblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShrZXksIEtleSwgWzEsIDBdLCAna2V5Jyk7XG5cdGlmIChQcml2YXRlS2V5LmlzUHJpdmF0ZUtleShrZXkpKVxuXHRcdGtleSA9IGtleS50b1B1YmxpYygpO1xuXHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKGlzc3VlciwgSWRlbnRpdHksIFsxLCAwXSwgJ2lzc3VlcicpO1xuXHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKGlzc3VlcktleSwgUHJpdmF0ZUtleSwgWzEsIDJdLCAnaXNzdWVyIGtleScpO1xuXG5cdGFzc2VydC5vcHRpb25hbE9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpO1xuXHRpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxuXHRcdG9wdGlvbnMgPSB7fTtcblx0YXNzZXJ0Lm9wdGlvbmFsT2JqZWN0KG9wdGlvbnMudmFsaWRGcm9tLCAnb3B0aW9ucy52YWxpZEZyb20nKTtcblx0YXNzZXJ0Lm9wdGlvbmFsT2JqZWN0KG9wdGlvbnMudmFsaWRVbnRpbCwgJ29wdGlvbnMudmFsaWRVbnRpbCcpO1xuXHR2YXIgdmFsaWRGcm9tID0gb3B0aW9ucy52YWxpZEZyb207XG5cdHZhciB2YWxpZFVudGlsID0gb3B0aW9ucy52YWxpZFVudGlsO1xuXHRpZiAodmFsaWRGcm9tID09PSB1bmRlZmluZWQpXG5cdFx0dmFsaWRGcm9tID0gbmV3IERhdGUoKTtcblx0aWYgKHZhbGlkVW50aWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdGFzc2VydC5vcHRpb25hbE51bWJlcihvcHRpb25zLmxpZmV0aW1lLCAnb3B0aW9ucy5saWZldGltZScpO1xuXHRcdHZhciBsaWZldGltZSA9IG9wdGlvbnMubGlmZXRpbWU7XG5cdFx0aWYgKGxpZmV0aW1lID09PSB1bmRlZmluZWQpXG5cdFx0XHRsaWZldGltZSA9IDEwKjM2NSoyNCozNjAwO1xuXHRcdHZhbGlkVW50aWwgPSBuZXcgRGF0ZSgpO1xuXHRcdHZhbGlkVW50aWwuc2V0VGltZSh2YWxpZFVudGlsLmdldFRpbWUoKSArIGxpZmV0aW1lKjEwMDApO1xuXHR9XG5cdGFzc2VydC5vcHRpb25hbEJ1ZmZlcihvcHRpb25zLnNlcmlhbCwgJ29wdGlvbnMuc2VyaWFsJyk7XG5cdHZhciBzZXJpYWwgPSBvcHRpb25zLnNlcmlhbDtcblx0aWYgKHNlcmlhbCA9PT0gdW5kZWZpbmVkKVxuXHRcdHNlcmlhbCA9IEJ1ZmZlci5mcm9tKCcwMDAwMDAwMDAwMDAwMDAxJywgJ2hleCcpO1xuXG5cdHZhciBwdXJwb3NlcyA9IG9wdGlvbnMucHVycG9zZXM7XG5cdGlmIChwdXJwb3NlcyA9PT0gdW5kZWZpbmVkKVxuXHRcdHB1cnBvc2VzID0gW107XG5cblx0aWYgKHB1cnBvc2VzLmluZGV4T2YoJ3NpZ25hdHVyZScpID09PSAtMSlcblx0XHRwdXJwb3Nlcy5wdXNoKCdzaWduYXR1cmUnKTtcblxuXHRpZiAob3B0aW9ucy5jYSA9PT0gdHJ1ZSkge1xuXHRcdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdjYScpID09PSAtMSlcblx0XHRcdHB1cnBvc2VzLnB1c2goJ2NhJyk7XG5cdFx0aWYgKHB1cnBvc2VzLmluZGV4T2YoJ2NybCcpID09PSAtMSlcblx0XHRcdHB1cnBvc2VzLnB1c2goJ2NybCcpO1xuXHR9XG5cblx0dmFyIGhvc3RTdWJqZWN0cyA9IHN1YmplY3RzLmZpbHRlcihmdW5jdGlvbiAoc3ViamVjdCkge1xuXHRcdHJldHVybiAoc3ViamVjdC50eXBlID09PSAnaG9zdCcpO1xuXHR9KTtcblx0dmFyIHVzZXJTdWJqZWN0cyA9IHN1YmplY3RzLmZpbHRlcihmdW5jdGlvbiAoc3ViamVjdCkge1xuXHRcdHJldHVybiAoc3ViamVjdC50eXBlID09PSAndXNlcicpO1xuXHR9KTtcblx0aWYgKGhvc3RTdWJqZWN0cy5sZW5ndGggPiAwKSB7XG5cdFx0aWYgKHB1cnBvc2VzLmluZGV4T2YoJ3NlcnZlckF1dGgnKSA9PT0gLTEpXG5cdFx0XHRwdXJwb3Nlcy5wdXNoKCdzZXJ2ZXJBdXRoJyk7XG5cdH1cblx0aWYgKHVzZXJTdWJqZWN0cy5sZW5ndGggPiAwKSB7XG5cdFx0aWYgKHB1cnBvc2VzLmluZGV4T2YoJ2NsaWVudEF1dGgnKSA9PT0gLTEpXG5cdFx0XHRwdXJwb3Nlcy5wdXNoKCdjbGllbnRBdXRoJyk7XG5cdH1cblx0aWYgKHVzZXJTdWJqZWN0cy5sZW5ndGggPiAwIHx8IGhvc3RTdWJqZWN0cy5sZW5ndGggPiAwKSB7XG5cdFx0aWYgKHB1cnBvc2VzLmluZGV4T2YoJ2tleUFncmVlbWVudCcpID09PSAtMSlcblx0XHRcdHB1cnBvc2VzLnB1c2goJ2tleUFncmVlbWVudCcpO1xuXHRcdGlmIChrZXkudHlwZSA9PT0gJ3JzYScgJiZcblx0XHQgICAgcHVycG9zZXMuaW5kZXhPZignZW5jcnlwdGlvbicpID09PSAtMSlcblx0XHRcdHB1cnBvc2VzLnB1c2goJ2VuY3J5cHRpb24nKTtcblx0fVxuXG5cdHZhciBjZXJ0ID0gbmV3IENlcnRpZmljYXRlKHtcblx0XHRzdWJqZWN0czogc3ViamVjdHMsXG5cdFx0aXNzdWVyOiBpc3N1ZXIsXG5cdFx0c3ViamVjdEtleToga2V5LFxuXHRcdGlzc3VlcktleTogaXNzdWVyS2V5LnRvUHVibGljKCksXG5cdFx0c2lnbmF0dXJlczoge30sXG5cdFx0c2VyaWFsOiBzZXJpYWwsXG5cdFx0dmFsaWRGcm9tOiB2YWxpZEZyb20sXG5cdFx0dmFsaWRVbnRpbDogdmFsaWRVbnRpbCxcblx0XHRwdXJwb3NlczogcHVycG9zZXNcblx0fSk7XG5cdGNlcnQuc2lnbldpdGgoaXNzdWVyS2V5KTtcblxuXHRyZXR1cm4gKGNlcnQpO1xufTtcblxuQ2VydGlmaWNhdGUucGFyc2UgPSBmdW5jdGlvbiAoZGF0YSwgZm9ybWF0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgKGRhdGEpICE9PSAnc3RyaW5nJylcblx0XHRhc3NlcnQuYnVmZmVyKGRhdGEsICdkYXRhJyk7XG5cdGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZClcblx0XHRmb3JtYXQgPSAnYXV0byc7XG5cdGFzc2VydC5zdHJpbmcoZm9ybWF0LCAnZm9ybWF0Jyk7XG5cdGlmICh0eXBlb2YgKG9wdGlvbnMpID09PSAnc3RyaW5nJylcblx0XHRvcHRpb25zID0geyBmaWxlbmFtZTogb3B0aW9ucyB9O1xuXHRhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcblx0aWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZClcblx0XHRvcHRpb25zID0ge307XG5cdGFzc2VydC5vcHRpb25hbFN0cmluZyhvcHRpb25zLmZpbGVuYW1lLCAnb3B0aW9ucy5maWxlbmFtZScpO1xuXHRpZiAob3B0aW9ucy5maWxlbmFtZSA9PT0gdW5kZWZpbmVkKVxuXHRcdG9wdGlvbnMuZmlsZW5hbWUgPSAnKHVubmFtZWQpJztcblxuXHRhc3NlcnQub2JqZWN0KGZvcm1hdHNbZm9ybWF0XSwgJ2Zvcm1hdHNbZm9ybWF0XScpO1xuXG5cdHRyeSB7XG5cdFx0dmFyIGsgPSBmb3JtYXRzW2Zvcm1hdF0ucmVhZChkYXRhLCBvcHRpb25zKTtcblx0XHRyZXR1cm4gKGspO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0dGhyb3cgKG5ldyBDZXJ0aWZpY2F0ZVBhcnNlRXJyb3Iob3B0aW9ucy5maWxlbmFtZSwgZm9ybWF0LCBlKSk7XG5cdH1cbn07XG5cbkNlcnRpZmljYXRlLmlzQ2VydGlmaWNhdGUgPSBmdW5jdGlvbiAob2JqLCB2ZXIpIHtcblx0cmV0dXJuICh1dGlscy5pc0NvbXBhdGlibGUob2JqLCBDZXJ0aWZpY2F0ZSwgdmVyKSk7XG59O1xuXG4vKlxuICogQVBJIHZlcnNpb25zIGZvciBDZXJ0aWZpY2F0ZTpcbiAqIFsxLDBdIC0tIGluaXRpYWwgdmVyXG4gKiBbMSwxXSAtLSBvcGVuc3NoIGZvcm1hdCBub3cgdW5wYWNrcyBleHRlbnNpb25zXG4gKi9cbkNlcnRpZmljYXRlLnByb3RvdHlwZS5fc3NocGtBcGlWZXJzaW9uID0gWzEsIDFdO1xuXG5DZXJ0aWZpY2F0ZS5fb2xkVmVyc2lvbkRldGVjdCA9IGZ1bmN0aW9uIChvYmopIHtcblx0cmV0dXJuIChbMSwgMF0pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/certificate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/certificate.js":
/*!***********************************************!*\
  !*** ./node_modules/sshpk/lib/certificate.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2016 Joyent, Inc.\n\nmodule.exports = Certificate;\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ./algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar Fingerprint = __webpack_require__(/*! ./fingerprint */ \"(rsc)/./node_modules/sshpk/lib/fingerprint.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"(rsc)/./node_modules/sshpk/lib/signature.js\");\nvar errs = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/sshpk/lib/errors.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ./key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ./private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\nvar Identity = __webpack_require__(/*! ./identity */ \"(rsc)/./node_modules/sshpk/lib/identity.js\");\n\nvar formats = {};\nformats['openssh'] = __webpack_require__(/*! ./formats/openssh-cert */ \"(rsc)/./node_modules/sshpk/lib/formats/openssh-cert.js\");\nformats['x509'] = __webpack_require__(/*! ./formats/x509 */ \"(rsc)/./node_modules/sshpk/lib/formats/x509.js\");\nformats['pem'] = __webpack_require__(/*! ./formats/x509-pem */ \"(rsc)/./node_modules/sshpk/lib/formats/x509-pem.js\");\n\nvar CertificateParseError = errs.CertificateParseError;\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\n\nfunction Certificate(opts) {\n\tassert.object(opts, 'options');\n\tassert.arrayOfObject(opts.subjects, 'options.subjects');\n\tutils.assertCompatible(opts.subjects[0], Identity, [1, 0],\n\t    'options.subjects');\n\tutils.assertCompatible(opts.subjectKey, Key, [1, 0],\n\t    'options.subjectKey');\n\tutils.assertCompatible(opts.issuer, Identity, [1, 0], 'options.issuer');\n\tif (opts.issuerKey !== undefined) {\n\t\tutils.assertCompatible(opts.issuerKey, Key, [1, 0],\n\t\t    'options.issuerKey');\n\t}\n\tassert.object(opts.signatures, 'options.signatures');\n\tassert.buffer(opts.serial, 'options.serial');\n\tassert.date(opts.validFrom, 'options.validFrom');\n\tassert.date(opts.validUntil, 'optons.validUntil');\n\n\tassert.optionalArrayOfString(opts.purposes, 'options.purposes');\n\n\tthis._hashCache = {};\n\n\tthis.subjects = opts.subjects;\n\tthis.issuer = opts.issuer;\n\tthis.subjectKey = opts.subjectKey;\n\tthis.issuerKey = opts.issuerKey;\n\tthis.signatures = opts.signatures;\n\tthis.serial = opts.serial;\n\tthis.validFrom = opts.validFrom;\n\tthis.validUntil = opts.validUntil;\n\tthis.purposes = opts.purposes;\n}\n\nCertificate.formats = formats;\n\nCertificate.prototype.toBuffer = function (format, options) {\n\tif (format === undefined)\n\t\tformat = 'x509';\n\tassert.string(format, 'format');\n\tassert.object(formats[format], 'formats[format]');\n\tassert.optionalObject(options, 'options');\n\n\treturn (formats[format].write(this, options));\n};\n\nCertificate.prototype.toString = function (format, options) {\n\tif (format === undefined)\n\t\tformat = 'pem';\n\treturn (this.toBuffer(format, options).toString());\n};\n\nCertificate.prototype.fingerprint = function (algo) {\n\tif (algo === undefined)\n\t\talgo = 'sha256';\n\tassert.string(algo, 'algorithm');\n\tvar opts = {\n\t\ttype: 'certificate',\n\t\thash: this.hash(algo),\n\t\talgorithm: algo\n\t};\n\treturn (new Fingerprint(opts));\n};\n\nCertificate.prototype.hash = function (algo) {\n\tassert.string(algo, 'algorithm');\n\talgo = algo.toLowerCase();\n\tif (algs.hashAlgs[algo] === undefined)\n\t\tthrow (new InvalidAlgorithmError(algo));\n\n\tif (this._hashCache[algo])\n\t\treturn (this._hashCache[algo]);\n\n\tvar hash = crypto.createHash(algo).\n\t    update(this.toBuffer('x509')).digest();\n\tthis._hashCache[algo] = hash;\n\treturn (hash);\n};\n\nCertificate.prototype.isExpired = function (when) {\n\tif (when === undefined)\n\t\twhen = new Date();\n\treturn (!((when.getTime() >= this.validFrom.getTime()) &&\n\t\t(when.getTime() < this.validUntil.getTime())));\n};\n\nCertificate.prototype.isSignedBy = function (issuerCert) {\n\tutils.assertCompatible(issuerCert, Certificate, [1, 0], 'issuer');\n\n\tif (!this.issuer.equals(issuerCert.subjects[0]))\n\t\treturn (false);\n\tif (this.issuer.purposes && this.issuer.purposes.length > 0 &&\n\t    this.issuer.purposes.indexOf('ca') === -1) {\n\t\treturn (false);\n\t}\n\n\treturn (this.isSignedByKey(issuerCert.subjectKey));\n};\n\nCertificate.prototype.getExtension = function (keyOrOid) {\n\tassert.string(keyOrOid, 'keyOrOid');\n\tvar ext = this.getExtensions().filter(function (maybeExt) {\n\t\tif (maybeExt.format === 'x509')\n\t\t\treturn (maybeExt.oid === keyOrOid);\n\t\tif (maybeExt.format === 'openssh')\n\t\t\treturn (maybeExt.name === keyOrOid);\n\t\treturn (false);\n\t})[0];\n\treturn (ext);\n};\n\nCertificate.prototype.getExtensions = function () {\n\tvar exts = [];\n\tvar x509 = this.signatures.x509;\n\tif (x509 && x509.extras && x509.extras.exts) {\n\t\tx509.extras.exts.forEach(function (ext) {\n\t\t\text.format = 'x509';\n\t\t\texts.push(ext);\n\t\t});\n\t}\n\tvar openssh = this.signatures.openssh;\n\tif (openssh && openssh.exts) {\n\t\topenssh.exts.forEach(function (ext) {\n\t\t\text.format = 'openssh';\n\t\t\texts.push(ext);\n\t\t});\n\t}\n\treturn (exts);\n};\n\nCertificate.prototype.isSignedByKey = function (issuerKey) {\n\tutils.assertCompatible(issuerKey, Key, [1, 2], 'issuerKey');\n\n\tif (this.issuerKey !== undefined) {\n\t\treturn (this.issuerKey.\n\t\t    fingerprint('sha512').matches(issuerKey));\n\t}\n\n\tvar fmt = Object.keys(this.signatures)[0];\n\tvar valid = formats[fmt].verify(this, issuerKey);\n\tif (valid)\n\t\tthis.issuerKey = issuerKey;\n\treturn (valid);\n};\n\nCertificate.prototype.signWith = function (key) {\n\tutils.assertCompatible(key, PrivateKey, [1, 2], 'key');\n\tvar fmts = Object.keys(formats);\n\tvar didOne = false;\n\tfor (var i = 0; i < fmts.length; ++i) {\n\t\tif (fmts[i] !== 'pem') {\n\t\t\tvar ret = formats[fmts[i]].sign(this, key);\n\t\t\tif (ret === true)\n\t\t\t\tdidOne = true;\n\t\t}\n\t}\n\tif (!didOne) {\n\t\tthrow (new Error('Failed to sign the certificate for any ' +\n\t\t    'available certificate formats'));\n\t}\n};\n\nCertificate.createSelfSigned = function (subjectOrSubjects, key, options) {\n\tvar subjects;\n\tif (Array.isArray(subjectOrSubjects))\n\t\tsubjects = subjectOrSubjects;\n\telse\n\t\tsubjects = [subjectOrSubjects];\n\n\tassert.arrayOfObject(subjects);\n\tsubjects.forEach(function (subject) {\n\t\tutils.assertCompatible(subject, Identity, [1, 0], 'subject');\n\t});\n\n\tutils.assertCompatible(key, PrivateKey, [1, 2], 'private key');\n\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.optionalObject(options.validFrom, 'options.validFrom');\n\tassert.optionalObject(options.validUntil, 'options.validUntil');\n\tvar validFrom = options.validFrom;\n\tvar validUntil = options.validUntil;\n\tif (validFrom === undefined)\n\t\tvalidFrom = new Date();\n\tif (validUntil === undefined) {\n\t\tassert.optionalNumber(options.lifetime, 'options.lifetime');\n\t\tvar lifetime = options.lifetime;\n\t\tif (lifetime === undefined)\n\t\t\tlifetime = 10*365*24*3600;\n\t\tvalidUntil = new Date();\n\t\tvalidUntil.setTime(validUntil.getTime() + lifetime*1000);\n\t}\n\tassert.optionalBuffer(options.serial, 'options.serial');\n\tvar serial = options.serial;\n\tif (serial === undefined)\n\t\tserial = Buffer.from('0000000000000001', 'hex');\n\n\tvar purposes = options.purposes;\n\tif (purposes === undefined)\n\t\tpurposes = [];\n\n\tif (purposes.indexOf('signature') === -1)\n\t\tpurposes.push('signature');\n\n\t/* Self-signed certs are always CAs. */\n\tif (purposes.indexOf('ca') === -1)\n\t\tpurposes.push('ca');\n\tif (purposes.indexOf('crl') === -1)\n\t\tpurposes.push('crl');\n\n\t/*\n\t * If we weren't explicitly given any other purposes, do the sensible\n\t * thing and add some basic ones depending on the subject type.\n\t */\n\tif (purposes.length <= 3) {\n\t\tvar hostSubjects = subjects.filter(function (subject) {\n\t\t\treturn (subject.type === 'host');\n\t\t});\n\t\tvar userSubjects = subjects.filter(function (subject) {\n\t\t\treturn (subject.type === 'user');\n\t\t});\n\t\tif (hostSubjects.length > 0) {\n\t\t\tif (purposes.indexOf('serverAuth') === -1)\n\t\t\t\tpurposes.push('serverAuth');\n\t\t}\n\t\tif (userSubjects.length > 0) {\n\t\t\tif (purposes.indexOf('clientAuth') === -1)\n\t\t\t\tpurposes.push('clientAuth');\n\t\t}\n\t\tif (userSubjects.length > 0 || hostSubjects.length > 0) {\n\t\t\tif (purposes.indexOf('keyAgreement') === -1)\n\t\t\t\tpurposes.push('keyAgreement');\n\t\t\tif (key.type === 'rsa' &&\n\t\t\t    purposes.indexOf('encryption') === -1)\n\t\t\t\tpurposes.push('encryption');\n\t\t}\n\t}\n\n\tvar cert = new Certificate({\n\t\tsubjects: subjects,\n\t\tissuer: subjects[0],\n\t\tsubjectKey: key.toPublic(),\n\t\tissuerKey: key.toPublic(),\n\t\tsignatures: {},\n\t\tserial: serial,\n\t\tvalidFrom: validFrom,\n\t\tvalidUntil: validUntil,\n\t\tpurposes: purposes\n\t});\n\tcert.signWith(key);\n\n\treturn (cert);\n};\n\nCertificate.create =\n    function (subjectOrSubjects, key, issuer, issuerKey, options) {\n\tvar subjects;\n\tif (Array.isArray(subjectOrSubjects))\n\t\tsubjects = subjectOrSubjects;\n\telse\n\t\tsubjects = [subjectOrSubjects];\n\n\tassert.arrayOfObject(subjects);\n\tsubjects.forEach(function (subject) {\n\t\tutils.assertCompatible(subject, Identity, [1, 0], 'subject');\n\t});\n\n\tutils.assertCompatible(key, Key, [1, 0], 'key');\n\tif (PrivateKey.isPrivateKey(key))\n\t\tkey = key.toPublic();\n\tutils.assertCompatible(issuer, Identity, [1, 0], 'issuer');\n\tutils.assertCompatible(issuerKey, PrivateKey, [1, 2], 'issuer key');\n\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.optionalObject(options.validFrom, 'options.validFrom');\n\tassert.optionalObject(options.validUntil, 'options.validUntil');\n\tvar validFrom = options.validFrom;\n\tvar validUntil = options.validUntil;\n\tif (validFrom === undefined)\n\t\tvalidFrom = new Date();\n\tif (validUntil === undefined) {\n\t\tassert.optionalNumber(options.lifetime, 'options.lifetime');\n\t\tvar lifetime = options.lifetime;\n\t\tif (lifetime === undefined)\n\t\t\tlifetime = 10*365*24*3600;\n\t\tvalidUntil = new Date();\n\t\tvalidUntil.setTime(validUntil.getTime() + lifetime*1000);\n\t}\n\tassert.optionalBuffer(options.serial, 'options.serial');\n\tvar serial = options.serial;\n\tif (serial === undefined)\n\t\tserial = Buffer.from('0000000000000001', 'hex');\n\n\tvar purposes = options.purposes;\n\tif (purposes === undefined)\n\t\tpurposes = [];\n\n\tif (purposes.indexOf('signature') === -1)\n\t\tpurposes.push('signature');\n\n\tif (options.ca === true) {\n\t\tif (purposes.indexOf('ca') === -1)\n\t\t\tpurposes.push('ca');\n\t\tif (purposes.indexOf('crl') === -1)\n\t\t\tpurposes.push('crl');\n\t}\n\n\tvar hostSubjects = subjects.filter(function (subject) {\n\t\treturn (subject.type === 'host');\n\t});\n\tvar userSubjects = subjects.filter(function (subject) {\n\t\treturn (subject.type === 'user');\n\t});\n\tif (hostSubjects.length > 0) {\n\t\tif (purposes.indexOf('serverAuth') === -1)\n\t\t\tpurposes.push('serverAuth');\n\t}\n\tif (userSubjects.length > 0) {\n\t\tif (purposes.indexOf('clientAuth') === -1)\n\t\t\tpurposes.push('clientAuth');\n\t}\n\tif (userSubjects.length > 0 || hostSubjects.length > 0) {\n\t\tif (purposes.indexOf('keyAgreement') === -1)\n\t\t\tpurposes.push('keyAgreement');\n\t\tif (key.type === 'rsa' &&\n\t\t    purposes.indexOf('encryption') === -1)\n\t\t\tpurposes.push('encryption');\n\t}\n\n\tvar cert = new Certificate({\n\t\tsubjects: subjects,\n\t\tissuer: issuer,\n\t\tsubjectKey: key,\n\t\tissuerKey: issuerKey.toPublic(),\n\t\tsignatures: {},\n\t\tserial: serial,\n\t\tvalidFrom: validFrom,\n\t\tvalidUntil: validUntil,\n\t\tpurposes: purposes\n\t});\n\tcert.signWith(issuerKey);\n\n\treturn (cert);\n};\n\nCertificate.parse = function (data, format, options) {\n\tif (typeof (data) !== 'string')\n\t\tassert.buffer(data, 'data');\n\tif (format === undefined)\n\t\tformat = 'auto';\n\tassert.string(format, 'format');\n\tif (typeof (options) === 'string')\n\t\toptions = { filename: options };\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.optionalString(options.filename, 'options.filename');\n\tif (options.filename === undefined)\n\t\toptions.filename = '(unnamed)';\n\n\tassert.object(formats[format], 'formats[format]');\n\n\ttry {\n\t\tvar k = formats[format].read(data, options);\n\t\treturn (k);\n\t} catch (e) {\n\t\tthrow (new CertificateParseError(options.filename, format, e));\n\t}\n};\n\nCertificate.isCertificate = function (obj, ver) {\n\treturn (utils.isCompatible(obj, Certificate, ver));\n};\n\n/*\n * API versions for Certificate:\n * [1,0] -- initial ver\n * [1,1] -- openssh format now unpacks extensions\n */\nCertificate.prototype._sshpkApiVersion = [1, 1];\n\nCertificate._oldVersionDetect = function (obj) {\n\treturn ([1, 0]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2NlcnRpZmljYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrREFBYTtBQUNsQyxhQUFhLDhGQUE4QjtBQUMzQyxXQUFXLG1CQUFPLENBQUMsc0RBQVE7QUFDM0IsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGtCQUFrQixtQkFBTyxDQUFDLG9FQUFlO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFhO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQywwREFBVTtBQUM3QixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLHdEQUFTO0FBQzdCLFVBQVUsbUJBQU8sQ0FBQyxvREFBTztBQUN6QixpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBZTtBQUN4QyxlQUFlLG1CQUFPLENBQUMsOERBQVk7O0FBRW5DO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsc0ZBQXdCO0FBQ3JELGtCQUFrQixtQkFBTyxDQUFDLHNFQUFnQjtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBb0I7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvY2VydGlmaWNhdGUuanM/MWY5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNiBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSBDZXJ0aWZpY2F0ZTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuL2FsZ3MnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBGaW5nZXJwcmludCA9IHJlcXVpcmUoJy4vZmluZ2VycHJpbnQnKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xudmFyIGVycnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgS2V5ID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi9wcml2YXRlLWtleScpO1xudmFyIElkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG52YXIgZm9ybWF0cyA9IHt9O1xuZm9ybWF0c1snb3BlbnNzaCddID0gcmVxdWlyZSgnLi9mb3JtYXRzL29wZW5zc2gtY2VydCcpO1xuZm9ybWF0c1sneDUwOSddID0gcmVxdWlyZSgnLi9mb3JtYXRzL3g1MDknKTtcbmZvcm1hdHNbJ3BlbSddID0gcmVxdWlyZSgnLi9mb3JtYXRzL3g1MDktcGVtJyk7XG5cbnZhciBDZXJ0aWZpY2F0ZVBhcnNlRXJyb3IgPSBlcnJzLkNlcnRpZmljYXRlUGFyc2VFcnJvcjtcbnZhciBJbnZhbGlkQWxnb3JpdGhtRXJyb3IgPSBlcnJzLkludmFsaWRBbGdvcml0aG1FcnJvcjtcblxuZnVuY3Rpb24gQ2VydGlmaWNhdGUob3B0cykge1xuXHRhc3NlcnQub2JqZWN0KG9wdHMsICdvcHRpb25zJyk7XG5cdGFzc2VydC5hcnJheU9mT2JqZWN0KG9wdHMuc3ViamVjdHMsICdvcHRpb25zLnN1YmplY3RzJyk7XG5cdHV0aWxzLmFzc2VydENvbXBhdGlibGUob3B0cy5zdWJqZWN0c1swXSwgSWRlbnRpdHksIFsxLCAwXSxcblx0ICAgICdvcHRpb25zLnN1YmplY3RzJyk7XG5cdHV0aWxzLmFzc2VydENvbXBhdGlibGUob3B0cy5zdWJqZWN0S2V5LCBLZXksIFsxLCAwXSxcblx0ICAgICdvcHRpb25zLnN1YmplY3RLZXknKTtcblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShvcHRzLmlzc3VlciwgSWRlbnRpdHksIFsxLCAwXSwgJ29wdGlvbnMuaXNzdWVyJyk7XG5cdGlmIChvcHRzLmlzc3VlcktleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShvcHRzLmlzc3VlcktleSwgS2V5LCBbMSwgMF0sXG5cdFx0ICAgICdvcHRpb25zLmlzc3VlcktleScpO1xuXHR9XG5cdGFzc2VydC5vYmplY3Qob3B0cy5zaWduYXR1cmVzLCAnb3B0aW9ucy5zaWduYXR1cmVzJyk7XG5cdGFzc2VydC5idWZmZXIob3B0cy5zZXJpYWwsICdvcHRpb25zLnNlcmlhbCcpO1xuXHRhc3NlcnQuZGF0ZShvcHRzLnZhbGlkRnJvbSwgJ29wdGlvbnMudmFsaWRGcm9tJyk7XG5cdGFzc2VydC5kYXRlKG9wdHMudmFsaWRVbnRpbCwgJ29wdG9ucy52YWxpZFVudGlsJyk7XG5cblx0YXNzZXJ0Lm9wdGlvbmFsQXJyYXlPZlN0cmluZyhvcHRzLnB1cnBvc2VzLCAnb3B0aW9ucy5wdXJwb3NlcycpO1xuXG5cdHRoaXMuX2hhc2hDYWNoZSA9IHt9O1xuXG5cdHRoaXMuc3ViamVjdHMgPSBvcHRzLnN1YmplY3RzO1xuXHR0aGlzLmlzc3VlciA9IG9wdHMuaXNzdWVyO1xuXHR0aGlzLnN1YmplY3RLZXkgPSBvcHRzLnN1YmplY3RLZXk7XG5cdHRoaXMuaXNzdWVyS2V5ID0gb3B0cy5pc3N1ZXJLZXk7XG5cdHRoaXMuc2lnbmF0dXJlcyA9IG9wdHMuc2lnbmF0dXJlcztcblx0dGhpcy5zZXJpYWwgPSBvcHRzLnNlcmlhbDtcblx0dGhpcy52YWxpZEZyb20gPSBvcHRzLnZhbGlkRnJvbTtcblx0dGhpcy52YWxpZFVudGlsID0gb3B0cy52YWxpZFVudGlsO1xuXHR0aGlzLnB1cnBvc2VzID0gb3B0cy5wdXJwb3Nlcztcbn1cblxuQ2VydGlmaWNhdGUuZm9ybWF0cyA9IGZvcm1hdHM7XG5cbkNlcnRpZmljYXRlLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIChmb3JtYXQsIG9wdGlvbnMpIHtcblx0aWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKVxuXHRcdGZvcm1hdCA9ICd4NTA5Jztcblx0YXNzZXJ0LnN0cmluZyhmb3JtYXQsICdmb3JtYXQnKTtcblx0YXNzZXJ0Lm9iamVjdChmb3JtYXRzW2Zvcm1hdF0sICdmb3JtYXRzW2Zvcm1hdF0nKTtcblx0YXNzZXJ0Lm9wdGlvbmFsT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG5cblx0cmV0dXJuIChmb3JtYXRzW2Zvcm1hdF0ud3JpdGUodGhpcywgb3B0aW9ucykpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGZvcm1hdCwgb3B0aW9ucykge1xuXHRpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpXG5cdFx0Zm9ybWF0ID0gJ3BlbSc7XG5cdHJldHVybiAodGhpcy50b0J1ZmZlcihmb3JtYXQsIG9wdGlvbnMpLnRvU3RyaW5nKCkpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLmZpbmdlcnByaW50ID0gZnVuY3Rpb24gKGFsZ28pIHtcblx0aWYgKGFsZ28gPT09IHVuZGVmaW5lZClcblx0XHRhbGdvID0gJ3NoYTI1Nic7XG5cdGFzc2VydC5zdHJpbmcoYWxnbywgJ2FsZ29yaXRobScpO1xuXHR2YXIgb3B0cyA9IHtcblx0XHR0eXBlOiAnY2VydGlmaWNhdGUnLFxuXHRcdGhhc2g6IHRoaXMuaGFzaChhbGdvKSxcblx0XHRhbGdvcml0aG06IGFsZ29cblx0fTtcblx0cmV0dXJuIChuZXcgRmluZ2VycHJpbnQob3B0cykpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoYWxnbykge1xuXHRhc3NlcnQuc3RyaW5nKGFsZ28sICdhbGdvcml0aG0nKTtcblx0YWxnbyA9IGFsZ28udG9Mb3dlckNhc2UoKTtcblx0aWYgKGFsZ3MuaGFzaEFsZ3NbYWxnb10gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEludmFsaWRBbGdvcml0aG1FcnJvcihhbGdvKSk7XG5cblx0aWYgKHRoaXMuX2hhc2hDYWNoZVthbGdvXSlcblx0XHRyZXR1cm4gKHRoaXMuX2hhc2hDYWNoZVthbGdvXSk7XG5cblx0dmFyIGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvKS5cblx0ICAgIHVwZGF0ZSh0aGlzLnRvQnVmZmVyKCd4NTA5JykpLmRpZ2VzdCgpO1xuXHR0aGlzLl9oYXNoQ2FjaGVbYWxnb10gPSBoYXNoO1xuXHRyZXR1cm4gKGhhc2gpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLmlzRXhwaXJlZCA9IGZ1bmN0aW9uICh3aGVuKSB7XG5cdGlmICh3aGVuID09PSB1bmRlZmluZWQpXG5cdFx0d2hlbiA9IG5ldyBEYXRlKCk7XG5cdHJldHVybiAoISgod2hlbi5nZXRUaW1lKCkgPj0gdGhpcy52YWxpZEZyb20uZ2V0VGltZSgpKSAmJlxuXHRcdCh3aGVuLmdldFRpbWUoKSA8IHRoaXMudmFsaWRVbnRpbC5nZXRUaW1lKCkpKSk7XG59O1xuXG5DZXJ0aWZpY2F0ZS5wcm90b3R5cGUuaXNTaWduZWRCeSA9IGZ1bmN0aW9uIChpc3N1ZXJDZXJ0KSB7XG5cdHV0aWxzLmFzc2VydENvbXBhdGlibGUoaXNzdWVyQ2VydCwgQ2VydGlmaWNhdGUsIFsxLCAwXSwgJ2lzc3VlcicpO1xuXG5cdGlmICghdGhpcy5pc3N1ZXIuZXF1YWxzKGlzc3VlckNlcnQuc3ViamVjdHNbMF0pKVxuXHRcdHJldHVybiAoZmFsc2UpO1xuXHRpZiAodGhpcy5pc3N1ZXIucHVycG9zZXMgJiYgdGhpcy5pc3N1ZXIucHVycG9zZXMubGVuZ3RoID4gMCAmJlxuXHQgICAgdGhpcy5pc3N1ZXIucHVycG9zZXMuaW5kZXhPZignY2EnKSA9PT0gLTEpIHtcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0fVxuXG5cdHJldHVybiAodGhpcy5pc1NpZ25lZEJ5S2V5KGlzc3VlckNlcnQuc3ViamVjdEtleSkpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLmdldEV4dGVuc2lvbiA9IGZ1bmN0aW9uIChrZXlPck9pZCkge1xuXHRhc3NlcnQuc3RyaW5nKGtleU9yT2lkLCAna2V5T3JPaWQnKTtcblx0dmFyIGV4dCA9IHRoaXMuZ2V0RXh0ZW5zaW9ucygpLmZpbHRlcihmdW5jdGlvbiAobWF5YmVFeHQpIHtcblx0XHRpZiAobWF5YmVFeHQuZm9ybWF0ID09PSAneDUwOScpXG5cdFx0XHRyZXR1cm4gKG1heWJlRXh0Lm9pZCA9PT0ga2V5T3JPaWQpO1xuXHRcdGlmIChtYXliZUV4dC5mb3JtYXQgPT09ICdvcGVuc3NoJylcblx0XHRcdHJldHVybiAobWF5YmVFeHQubmFtZSA9PT0ga2V5T3JPaWQpO1xuXHRcdHJldHVybiAoZmFsc2UpO1xuXHR9KVswXTtcblx0cmV0dXJuIChleHQpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLmdldEV4dGVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBleHRzID0gW107XG5cdHZhciB4NTA5ID0gdGhpcy5zaWduYXR1cmVzLng1MDk7XG5cdGlmICh4NTA5ICYmIHg1MDkuZXh0cmFzICYmIHg1MDkuZXh0cmFzLmV4dHMpIHtcblx0XHR4NTA5LmV4dHJhcy5leHRzLmZvckVhY2goZnVuY3Rpb24gKGV4dCkge1xuXHRcdFx0ZXh0LmZvcm1hdCA9ICd4NTA5Jztcblx0XHRcdGV4dHMucHVzaChleHQpO1xuXHRcdH0pO1xuXHR9XG5cdHZhciBvcGVuc3NoID0gdGhpcy5zaWduYXR1cmVzLm9wZW5zc2g7XG5cdGlmIChvcGVuc3NoICYmIG9wZW5zc2guZXh0cykge1xuXHRcdG9wZW5zc2guZXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChleHQpIHtcblx0XHRcdGV4dC5mb3JtYXQgPSAnb3BlbnNzaCc7XG5cdFx0XHRleHRzLnB1c2goZXh0KTtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gKGV4dHMpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLmlzU2lnbmVkQnlLZXkgPSBmdW5jdGlvbiAoaXNzdWVyS2V5KSB7XG5cdHV0aWxzLmFzc2VydENvbXBhdGlibGUoaXNzdWVyS2V5LCBLZXksIFsxLCAyXSwgJ2lzc3VlcktleScpO1xuXG5cdGlmICh0aGlzLmlzc3VlcktleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuICh0aGlzLmlzc3VlcktleS5cblx0XHQgICAgZmluZ2VycHJpbnQoJ3NoYTUxMicpLm1hdGNoZXMoaXNzdWVyS2V5KSk7XG5cdH1cblxuXHR2YXIgZm10ID0gT2JqZWN0LmtleXModGhpcy5zaWduYXR1cmVzKVswXTtcblx0dmFyIHZhbGlkID0gZm9ybWF0c1tmbXRdLnZlcmlmeSh0aGlzLCBpc3N1ZXJLZXkpO1xuXHRpZiAodmFsaWQpXG5cdFx0dGhpcy5pc3N1ZXJLZXkgPSBpc3N1ZXJLZXk7XG5cdHJldHVybiAodmFsaWQpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLnNpZ25XaXRoID0gZnVuY3Rpb24gKGtleSkge1xuXHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKGtleSwgUHJpdmF0ZUtleSwgWzEsIDJdLCAna2V5Jyk7XG5cdHZhciBmbXRzID0gT2JqZWN0LmtleXMoZm9ybWF0cyk7XG5cdHZhciBkaWRPbmUgPSBmYWxzZTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmbXRzLmxlbmd0aDsgKytpKSB7XG5cdFx0aWYgKGZtdHNbaV0gIT09ICdwZW0nKSB7XG5cdFx0XHR2YXIgcmV0ID0gZm9ybWF0c1tmbXRzW2ldXS5zaWduKHRoaXMsIGtleSk7XG5cdFx0XHRpZiAocmV0ID09PSB0cnVlKVxuXHRcdFx0XHRkaWRPbmUgPSB0cnVlO1xuXHRcdH1cblx0fVxuXHRpZiAoIWRpZE9uZSkge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzaWduIHRoZSBjZXJ0aWZpY2F0ZSBmb3IgYW55ICcgK1xuXHRcdCAgICAnYXZhaWxhYmxlIGNlcnRpZmljYXRlIGZvcm1hdHMnKSk7XG5cdH1cbn07XG5cbkNlcnRpZmljYXRlLmNyZWF0ZVNlbGZTaWduZWQgPSBmdW5jdGlvbiAoc3ViamVjdE9yU3ViamVjdHMsIGtleSwgb3B0aW9ucykge1xuXHR2YXIgc3ViamVjdHM7XG5cdGlmIChBcnJheS5pc0FycmF5KHN1YmplY3RPclN1YmplY3RzKSlcblx0XHRzdWJqZWN0cyA9IHN1YmplY3RPclN1YmplY3RzO1xuXHRlbHNlXG5cdFx0c3ViamVjdHMgPSBbc3ViamVjdE9yU3ViamVjdHNdO1xuXG5cdGFzc2VydC5hcnJheU9mT2JqZWN0KHN1YmplY3RzKTtcblx0c3ViamVjdHMuZm9yRWFjaChmdW5jdGlvbiAoc3ViamVjdCkge1xuXHRcdHV0aWxzLmFzc2VydENvbXBhdGlibGUoc3ViamVjdCwgSWRlbnRpdHksIFsxLCAwXSwgJ3N1YmplY3QnKTtcblx0fSk7XG5cblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShrZXksIFByaXZhdGVLZXksIFsxLCAyXSwgJ3ByaXZhdGUga2V5Jyk7XG5cblx0YXNzZXJ0Lm9wdGlvbmFsT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG5cdGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpXG5cdFx0b3B0aW9ucyA9IHt9O1xuXHRhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0aW9ucy52YWxpZEZyb20sICdvcHRpb25zLnZhbGlkRnJvbScpO1xuXHRhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0aW9ucy52YWxpZFVudGlsLCAnb3B0aW9ucy52YWxpZFVudGlsJyk7XG5cdHZhciB2YWxpZEZyb20gPSBvcHRpb25zLnZhbGlkRnJvbTtcblx0dmFyIHZhbGlkVW50aWwgPSBvcHRpb25zLnZhbGlkVW50aWw7XG5cdGlmICh2YWxpZEZyb20gPT09IHVuZGVmaW5lZClcblx0XHR2YWxpZEZyb20gPSBuZXcgRGF0ZSgpO1xuXHRpZiAodmFsaWRVbnRpbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0YXNzZXJ0Lm9wdGlvbmFsTnVtYmVyKG9wdGlvbnMubGlmZXRpbWUsICdvcHRpb25zLmxpZmV0aW1lJyk7XG5cdFx0dmFyIGxpZmV0aW1lID0gb3B0aW9ucy5saWZldGltZTtcblx0XHRpZiAobGlmZXRpbWUgPT09IHVuZGVmaW5lZClcblx0XHRcdGxpZmV0aW1lID0gMTAqMzY1KjI0KjM2MDA7XG5cdFx0dmFsaWRVbnRpbCA9IG5ldyBEYXRlKCk7XG5cdFx0dmFsaWRVbnRpbC5zZXRUaW1lKHZhbGlkVW50aWwuZ2V0VGltZSgpICsgbGlmZXRpbWUqMTAwMCk7XG5cdH1cblx0YXNzZXJ0Lm9wdGlvbmFsQnVmZmVyKG9wdGlvbnMuc2VyaWFsLCAnb3B0aW9ucy5zZXJpYWwnKTtcblx0dmFyIHNlcmlhbCA9IG9wdGlvbnMuc2VyaWFsO1xuXHRpZiAoc2VyaWFsID09PSB1bmRlZmluZWQpXG5cdFx0c2VyaWFsID0gQnVmZmVyLmZyb20oJzAwMDAwMDAwMDAwMDAwMDEnLCAnaGV4Jyk7XG5cblx0dmFyIHB1cnBvc2VzID0gb3B0aW9ucy5wdXJwb3Nlcztcblx0aWYgKHB1cnBvc2VzID09PSB1bmRlZmluZWQpXG5cdFx0cHVycG9zZXMgPSBbXTtcblxuXHRpZiAocHVycG9zZXMuaW5kZXhPZignc2lnbmF0dXJlJykgPT09IC0xKVxuXHRcdHB1cnBvc2VzLnB1c2goJ3NpZ25hdHVyZScpO1xuXG5cdC8qIFNlbGYtc2lnbmVkIGNlcnRzIGFyZSBhbHdheXMgQ0FzLiAqL1xuXHRpZiAocHVycG9zZXMuaW5kZXhPZignY2EnKSA9PT0gLTEpXG5cdFx0cHVycG9zZXMucHVzaCgnY2EnKTtcblx0aWYgKHB1cnBvc2VzLmluZGV4T2YoJ2NybCcpID09PSAtMSlcblx0XHRwdXJwb3Nlcy5wdXNoKCdjcmwnKTtcblxuXHQvKlxuXHQgKiBJZiB3ZSB3ZXJlbid0IGV4cGxpY2l0bHkgZ2l2ZW4gYW55IG90aGVyIHB1cnBvc2VzLCBkbyB0aGUgc2Vuc2libGVcblx0ICogdGhpbmcgYW5kIGFkZCBzb21lIGJhc2ljIG9uZXMgZGVwZW5kaW5nIG9uIHRoZSBzdWJqZWN0IHR5cGUuXG5cdCAqL1xuXHRpZiAocHVycG9zZXMubGVuZ3RoIDw9IDMpIHtcblx0XHR2YXIgaG9zdFN1YmplY3RzID0gc3ViamVjdHMuZmlsdGVyKGZ1bmN0aW9uIChzdWJqZWN0KSB7XG5cdFx0XHRyZXR1cm4gKHN1YmplY3QudHlwZSA9PT0gJ2hvc3QnKTtcblx0XHR9KTtcblx0XHR2YXIgdXNlclN1YmplY3RzID0gc3ViamVjdHMuZmlsdGVyKGZ1bmN0aW9uIChzdWJqZWN0KSB7XG5cdFx0XHRyZXR1cm4gKHN1YmplY3QudHlwZSA9PT0gJ3VzZXInKTtcblx0XHR9KTtcblx0XHRpZiAoaG9zdFN1YmplY3RzLmxlbmd0aCA+IDApIHtcblx0XHRcdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdzZXJ2ZXJBdXRoJykgPT09IC0xKVxuXHRcdFx0XHRwdXJwb3Nlcy5wdXNoKCdzZXJ2ZXJBdXRoJyk7XG5cdFx0fVxuXHRcdGlmICh1c2VyU3ViamVjdHMubGVuZ3RoID4gMCkge1xuXHRcdFx0aWYgKHB1cnBvc2VzLmluZGV4T2YoJ2NsaWVudEF1dGgnKSA9PT0gLTEpXG5cdFx0XHRcdHB1cnBvc2VzLnB1c2goJ2NsaWVudEF1dGgnKTtcblx0XHR9XG5cdFx0aWYgKHVzZXJTdWJqZWN0cy5sZW5ndGggPiAwIHx8IGhvc3RTdWJqZWN0cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRpZiAocHVycG9zZXMuaW5kZXhPZigna2V5QWdyZWVtZW50JykgPT09IC0xKVxuXHRcdFx0XHRwdXJwb3Nlcy5wdXNoKCdrZXlBZ3JlZW1lbnQnKTtcblx0XHRcdGlmIChrZXkudHlwZSA9PT0gJ3JzYScgJiZcblx0XHRcdCAgICBwdXJwb3Nlcy5pbmRleE9mKCdlbmNyeXB0aW9uJykgPT09IC0xKVxuXHRcdFx0XHRwdXJwb3Nlcy5wdXNoKCdlbmNyeXB0aW9uJyk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIGNlcnQgPSBuZXcgQ2VydGlmaWNhdGUoe1xuXHRcdHN1YmplY3RzOiBzdWJqZWN0cyxcblx0XHRpc3N1ZXI6IHN1YmplY3RzWzBdLFxuXHRcdHN1YmplY3RLZXk6IGtleS50b1B1YmxpYygpLFxuXHRcdGlzc3VlcktleToga2V5LnRvUHVibGljKCksXG5cdFx0c2lnbmF0dXJlczoge30sXG5cdFx0c2VyaWFsOiBzZXJpYWwsXG5cdFx0dmFsaWRGcm9tOiB2YWxpZEZyb20sXG5cdFx0dmFsaWRVbnRpbDogdmFsaWRVbnRpbCxcblx0XHRwdXJwb3NlczogcHVycG9zZXNcblx0fSk7XG5cdGNlcnQuc2lnbldpdGgoa2V5KTtcblxuXHRyZXR1cm4gKGNlcnQpO1xufTtcblxuQ2VydGlmaWNhdGUuY3JlYXRlID1cbiAgICBmdW5jdGlvbiAoc3ViamVjdE9yU3ViamVjdHMsIGtleSwgaXNzdWVyLCBpc3N1ZXJLZXksIG9wdGlvbnMpIHtcblx0dmFyIHN1YmplY3RzO1xuXHRpZiAoQXJyYXkuaXNBcnJheShzdWJqZWN0T3JTdWJqZWN0cykpXG5cdFx0c3ViamVjdHMgPSBzdWJqZWN0T3JTdWJqZWN0cztcblx0ZWxzZVxuXHRcdHN1YmplY3RzID0gW3N1YmplY3RPclN1YmplY3RzXTtcblxuXHRhc3NlcnQuYXJyYXlPZk9iamVjdChzdWJqZWN0cyk7XG5cdHN1YmplY3RzLmZvckVhY2goZnVuY3Rpb24gKHN1YmplY3QpIHtcblx0XHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKHN1YmplY3QsIElkZW50aXR5LCBbMSwgMF0sICdzdWJqZWN0Jyk7XG5cdH0pO1xuXG5cdHV0aWxzLmFzc2VydENvbXBhdGlibGUoa2V5LCBLZXksIFsxLCAwXSwgJ2tleScpO1xuXHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSlcblx0XHRrZXkgPSBrZXkudG9QdWJsaWMoKTtcblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShpc3N1ZXIsIElkZW50aXR5LCBbMSwgMF0sICdpc3N1ZXInKTtcblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShpc3N1ZXJLZXksIFByaXZhdGVLZXksIFsxLCAyXSwgJ2lzc3VlciBrZXknKTtcblxuXHRhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcblx0aWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZClcblx0XHRvcHRpb25zID0ge307XG5cdGFzc2VydC5vcHRpb25hbE9iamVjdChvcHRpb25zLnZhbGlkRnJvbSwgJ29wdGlvbnMudmFsaWRGcm9tJyk7XG5cdGFzc2VydC5vcHRpb25hbE9iamVjdChvcHRpb25zLnZhbGlkVW50aWwsICdvcHRpb25zLnZhbGlkVW50aWwnKTtcblx0dmFyIHZhbGlkRnJvbSA9IG9wdGlvbnMudmFsaWRGcm9tO1xuXHR2YXIgdmFsaWRVbnRpbCA9IG9wdGlvbnMudmFsaWRVbnRpbDtcblx0aWYgKHZhbGlkRnJvbSA9PT0gdW5kZWZpbmVkKVxuXHRcdHZhbGlkRnJvbSA9IG5ldyBEYXRlKCk7XG5cdGlmICh2YWxpZFVudGlsID09PSB1bmRlZmluZWQpIHtcblx0XHRhc3NlcnQub3B0aW9uYWxOdW1iZXIob3B0aW9ucy5saWZldGltZSwgJ29wdGlvbnMubGlmZXRpbWUnKTtcblx0XHR2YXIgbGlmZXRpbWUgPSBvcHRpb25zLmxpZmV0aW1lO1xuXHRcdGlmIChsaWZldGltZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0bGlmZXRpbWUgPSAxMCozNjUqMjQqMzYwMDtcblx0XHR2YWxpZFVudGlsID0gbmV3IERhdGUoKTtcblx0XHR2YWxpZFVudGlsLnNldFRpbWUodmFsaWRVbnRpbC5nZXRUaW1lKCkgKyBsaWZldGltZSoxMDAwKTtcblx0fVxuXHRhc3NlcnQub3B0aW9uYWxCdWZmZXIob3B0aW9ucy5zZXJpYWwsICdvcHRpb25zLnNlcmlhbCcpO1xuXHR2YXIgc2VyaWFsID0gb3B0aW9ucy5zZXJpYWw7XG5cdGlmIChzZXJpYWwgPT09IHVuZGVmaW5lZClcblx0XHRzZXJpYWwgPSBCdWZmZXIuZnJvbSgnMDAwMDAwMDAwMDAwMDAwMScsICdoZXgnKTtcblxuXHR2YXIgcHVycG9zZXMgPSBvcHRpb25zLnB1cnBvc2VzO1xuXHRpZiAocHVycG9zZXMgPT09IHVuZGVmaW5lZClcblx0XHRwdXJwb3NlcyA9IFtdO1xuXG5cdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdzaWduYXR1cmUnKSA9PT0gLTEpXG5cdFx0cHVycG9zZXMucHVzaCgnc2lnbmF0dXJlJyk7XG5cblx0aWYgKG9wdGlvbnMuY2EgPT09IHRydWUpIHtcblx0XHRpZiAocHVycG9zZXMuaW5kZXhPZignY2EnKSA9PT0gLTEpXG5cdFx0XHRwdXJwb3Nlcy5wdXNoKCdjYScpO1xuXHRcdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdjcmwnKSA9PT0gLTEpXG5cdFx0XHRwdXJwb3Nlcy5wdXNoKCdjcmwnKTtcblx0fVxuXG5cdHZhciBob3N0U3ViamVjdHMgPSBzdWJqZWN0cy5maWx0ZXIoZnVuY3Rpb24gKHN1YmplY3QpIHtcblx0XHRyZXR1cm4gKHN1YmplY3QudHlwZSA9PT0gJ2hvc3QnKTtcblx0fSk7XG5cdHZhciB1c2VyU3ViamVjdHMgPSBzdWJqZWN0cy5maWx0ZXIoZnVuY3Rpb24gKHN1YmplY3QpIHtcblx0XHRyZXR1cm4gKHN1YmplY3QudHlwZSA9PT0gJ3VzZXInKTtcblx0fSk7XG5cdGlmIChob3N0U3ViamVjdHMubGVuZ3RoID4gMCkge1xuXHRcdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdzZXJ2ZXJBdXRoJykgPT09IC0xKVxuXHRcdFx0cHVycG9zZXMucHVzaCgnc2VydmVyQXV0aCcpO1xuXHR9XG5cdGlmICh1c2VyU3ViamVjdHMubGVuZ3RoID4gMCkge1xuXHRcdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdjbGllbnRBdXRoJykgPT09IC0xKVxuXHRcdFx0cHVycG9zZXMucHVzaCgnY2xpZW50QXV0aCcpO1xuXHR9XG5cdGlmICh1c2VyU3ViamVjdHMubGVuZ3RoID4gMCB8fCBob3N0U3ViamVjdHMubGVuZ3RoID4gMCkge1xuXHRcdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdrZXlBZ3JlZW1lbnQnKSA9PT0gLTEpXG5cdFx0XHRwdXJwb3Nlcy5wdXNoKCdrZXlBZ3JlZW1lbnQnKTtcblx0XHRpZiAoa2V5LnR5cGUgPT09ICdyc2EnICYmXG5cdFx0ICAgIHB1cnBvc2VzLmluZGV4T2YoJ2VuY3J5cHRpb24nKSA9PT0gLTEpXG5cdFx0XHRwdXJwb3Nlcy5wdXNoKCdlbmNyeXB0aW9uJyk7XG5cdH1cblxuXHR2YXIgY2VydCA9IG5ldyBDZXJ0aWZpY2F0ZSh7XG5cdFx0c3ViamVjdHM6IHN1YmplY3RzLFxuXHRcdGlzc3VlcjogaXNzdWVyLFxuXHRcdHN1YmplY3RLZXk6IGtleSxcblx0XHRpc3N1ZXJLZXk6IGlzc3VlcktleS50b1B1YmxpYygpLFxuXHRcdHNpZ25hdHVyZXM6IHt9LFxuXHRcdHNlcmlhbDogc2VyaWFsLFxuXHRcdHZhbGlkRnJvbTogdmFsaWRGcm9tLFxuXHRcdHZhbGlkVW50aWw6IHZhbGlkVW50aWwsXG5cdFx0cHVycG9zZXM6IHB1cnBvc2VzXG5cdH0pO1xuXHRjZXJ0LnNpZ25XaXRoKGlzc3VlcktleSk7XG5cblx0cmV0dXJuIChjZXJ0KTtcbn07XG5cbkNlcnRpZmljYXRlLnBhcnNlID0gZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIChkYXRhKSAhPT0gJ3N0cmluZycpXG5cdFx0YXNzZXJ0LmJ1ZmZlcihkYXRhLCAnZGF0YScpO1xuXHRpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpXG5cdFx0Zm9ybWF0ID0gJ2F1dG8nO1xuXHRhc3NlcnQuc3RyaW5nKGZvcm1hdCwgJ2Zvcm1hdCcpO1xuXHRpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gJ3N0cmluZycpXG5cdFx0b3B0aW9ucyA9IHsgZmlsZW5hbWU6IG9wdGlvbnMgfTtcblx0YXNzZXJ0Lm9wdGlvbmFsT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG5cdGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpXG5cdFx0b3B0aW9ucyA9IHt9O1xuXHRhc3NlcnQub3B0aW9uYWxTdHJpbmcob3B0aW9ucy5maWxlbmFtZSwgJ29wdGlvbnMuZmlsZW5hbWUnKTtcblx0aWYgKG9wdGlvbnMuZmlsZW5hbWUgPT09IHVuZGVmaW5lZClcblx0XHRvcHRpb25zLmZpbGVuYW1lID0gJyh1bm5hbWVkKSc7XG5cblx0YXNzZXJ0Lm9iamVjdChmb3JtYXRzW2Zvcm1hdF0sICdmb3JtYXRzW2Zvcm1hdF0nKTtcblxuXHR0cnkge1xuXHRcdHZhciBrID0gZm9ybWF0c1tmb3JtYXRdLnJlYWQoZGF0YSwgb3B0aW9ucyk7XG5cdFx0cmV0dXJuIChrKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHRocm93IChuZXcgQ2VydGlmaWNhdGVQYXJzZUVycm9yKG9wdGlvbnMuZmlsZW5hbWUsIGZvcm1hdCwgZSkpO1xuXHR9XG59O1xuXG5DZXJ0aWZpY2F0ZS5pc0NlcnRpZmljYXRlID0gZnVuY3Rpb24gKG9iaiwgdmVyKSB7XG5cdHJldHVybiAodXRpbHMuaXNDb21wYXRpYmxlKG9iaiwgQ2VydGlmaWNhdGUsIHZlcikpO1xufTtcblxuLypcbiAqIEFQSSB2ZXJzaW9ucyBmb3IgQ2VydGlmaWNhdGU6XG4gKiBbMSwwXSAtLSBpbml0aWFsIHZlclxuICogWzEsMV0gLS0gb3BlbnNzaCBmb3JtYXQgbm93IHVucGFja3MgZXh0ZW5zaW9uc1xuICovXG5DZXJ0aWZpY2F0ZS5wcm90b3R5cGUuX3NzaHBrQXBpVmVyc2lvbiA9IFsxLCAxXTtcblxuQ2VydGlmaWNhdGUuX29sZFZlcnNpb25EZXRlY3QgPSBmdW5jdGlvbiAob2JqKSB7XG5cdHJldHVybiAoWzEsIDBdKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/certificate.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/dhe.js":
/*!***************************************!*\
  !*** ./node_modules/sshpk/lib/dhe.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2017 Joyent, Inc.\n\nmodule.exports = {\n\tDiffieHellman: DiffieHellman,\n\tgenerateECDSA: generateECDSA,\n\tgenerateED25519: generateED25519\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ./algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar nacl = __webpack_require__(/*! tweetnacl */ \"(action-browser)/./node_modules/tweetnacl/nacl-fast.js\");\n\nvar Key = __webpack_require__(/*! ./key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ./private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\n\nvar CRYPTO_HAVE_ECDH = (crypto.createECDH !== undefined);\n\nvar ecdh = __webpack_require__(/*! ecc-jsbn */ \"(action-browser)/./node_modules/ecc-jsbn/index.js\");\nvar ec = __webpack_require__(/*! ecc-jsbn/lib/ec */ \"(action-browser)/./node_modules/ecc-jsbn/lib/ec.js\");\nvar jsbn = (__webpack_require__(/*! jsbn */ \"(action-browser)/./node_modules/sshpk/node_modules/jsbn/index.js\").BigInteger);\n\nfunction DiffieHellman(key) {\n\tutils.assertCompatible(key, Key, [1, 4], 'key');\n\tthis._isPriv = PrivateKey.isPrivateKey(key, [1, 3]);\n\tthis._algo = key.type;\n\tthis._curve = key.curve;\n\tthis._key = key;\n\tif (key.type === 'dsa') {\n\t\tif (!CRYPTO_HAVE_ECDH) {\n\t\t\tthrow (new Error('Due to bugs in the node 0.10 ' +\n\t\t\t    'crypto API, node 0.12.x or later is required ' +\n\t\t\t    'to use DH'));\n\t\t}\n\t\tthis._dh = crypto.createDiffieHellman(\n\t\t    key.part.p.data, undefined,\n\t\t    key.part.g.data, undefined);\n\t\tthis._p = key.part.p;\n\t\tthis._g = key.part.g;\n\t\tif (this._isPriv)\n\t\t\tthis._dh.setPrivateKey(key.part.x.data);\n\t\tthis._dh.setPublicKey(key.part.y.data);\n\n\t} else if (key.type === 'ecdsa') {\n\t\tif (!CRYPTO_HAVE_ECDH) {\n\t\t\tthis._ecParams = new X9ECParameters(this._curve);\n\n\t\t\tif (this._isPriv) {\n\t\t\t\tthis._priv = new ECPrivate(\n\t\t\t\t    this._ecParams, key.part.d.data);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar curve = {\n\t\t\t'nistp256': 'prime256v1',\n\t\t\t'nistp384': 'secp384r1',\n\t\t\t'nistp521': 'secp521r1'\n\t\t}[key.curve];\n\t\tthis._dh = crypto.createECDH(curve);\n\t\tif (typeof (this._dh) !== 'object' ||\n\t\t    typeof (this._dh.setPrivateKey) !== 'function') {\n\t\t\tCRYPTO_HAVE_ECDH = false;\n\t\t\tDiffieHellman.call(this, key);\n\t\t\treturn;\n\t\t}\n\t\tif (this._isPriv)\n\t\t\tthis._dh.setPrivateKey(key.part.d.data);\n\t\tthis._dh.setPublicKey(key.part.Q.data);\n\n\t} else if (key.type === 'curve25519') {\n\t\tif (this._isPriv) {\n\t\t\tutils.assertCompatible(key, PrivateKey, [1, 5], 'key');\n\t\t\tthis._priv = key.part.k.data;\n\t\t}\n\n\t} else {\n\t\tthrow (new Error('DH not supported for ' + key.type + ' keys'));\n\t}\n}\n\nDiffieHellman.prototype.getPublicKey = function () {\n\tif (this._isPriv)\n\t\treturn (this._key.toPublic());\n\treturn (this._key);\n};\n\nDiffieHellman.prototype.getPrivateKey = function () {\n\tif (this._isPriv)\n\t\treturn (this._key);\n\telse\n\t\treturn (undefined);\n};\nDiffieHellman.prototype.getKey = DiffieHellman.prototype.getPrivateKey;\n\nDiffieHellman.prototype._keyCheck = function (pk, isPub) {\n\tassert.object(pk, 'key');\n\tif (!isPub)\n\t\tutils.assertCompatible(pk, PrivateKey, [1, 3], 'key');\n\tutils.assertCompatible(pk, Key, [1, 4], 'key');\n\n\tif (pk.type !== this._algo) {\n\t\tthrow (new Error('A ' + pk.type + ' key cannot be used in ' +\n\t\t    this._algo + ' Diffie-Hellman'));\n\t}\n\n\tif (pk.curve !== this._curve) {\n\t\tthrow (new Error('A key from the ' + pk.curve + ' curve ' +\n\t\t    'cannot be used with a ' + this._curve +\n\t\t    ' Diffie-Hellman'));\n\t}\n\n\tif (pk.type === 'dsa') {\n\t\tassert.deepEqual(pk.part.p, this._p,\n\t\t    'DSA key prime does not match');\n\t\tassert.deepEqual(pk.part.g, this._g,\n\t\t    'DSA key generator does not match');\n\t}\n};\n\nDiffieHellman.prototype.setKey = function (pk) {\n\tthis._keyCheck(pk);\n\n\tif (pk.type === 'dsa') {\n\t\tthis._dh.setPrivateKey(pk.part.x.data);\n\t\tthis._dh.setPublicKey(pk.part.y.data);\n\n\t} else if (pk.type === 'ecdsa') {\n\t\tif (CRYPTO_HAVE_ECDH) {\n\t\t\tthis._dh.setPrivateKey(pk.part.d.data);\n\t\t\tthis._dh.setPublicKey(pk.part.Q.data);\n\t\t} else {\n\t\t\tthis._priv = new ECPrivate(\n\t\t\t    this._ecParams, pk.part.d.data);\n\t\t}\n\n\t} else if (pk.type === 'curve25519') {\n\t\tvar k = pk.part.k;\n\t\tif (!pk.part.k)\n\t\t\tk = pk.part.r;\n\t\tthis._priv = k.data;\n\t\tif (this._priv[0] === 0x00)\n\t\t\tthis._priv = this._priv.slice(1);\n\t\tthis._priv = this._priv.slice(0, 32);\n\t}\n\tthis._key = pk;\n\tthis._isPriv = true;\n};\nDiffieHellman.prototype.setPrivateKey = DiffieHellman.prototype.setKey;\n\nDiffieHellman.prototype.computeSecret = function (otherpk) {\n\tthis._keyCheck(otherpk, true);\n\tif (!this._isPriv)\n\t\tthrow (new Error('DH exchange has not been initialized with ' +\n\t\t    'a private key yet'));\n\n\tvar pub;\n\tif (this._algo === 'dsa') {\n\t\treturn (this._dh.computeSecret(\n\t\t    otherpk.part.y.data));\n\n\t} else if (this._algo === 'ecdsa') {\n\t\tif (CRYPTO_HAVE_ECDH) {\n\t\t\treturn (this._dh.computeSecret(\n\t\t\t    otherpk.part.Q.data));\n\t\t} else {\n\t\t\tpub = new ECPublic(\n\t\t\t    this._ecParams, otherpk.part.Q.data);\n\t\t\treturn (this._priv.deriveSharedSecret(pub));\n\t\t}\n\n\t} else if (this._algo === 'curve25519') {\n\t\tpub = otherpk.part.A.data;\n\t\twhile (pub[0] === 0x00 && pub.length > 32)\n\t\t\tpub = pub.slice(1);\n\t\tvar priv = this._priv;\n\t\tassert.strictEqual(pub.length, 32);\n\t\tassert.strictEqual(priv.length, 32);\n\n\t\tvar secret = nacl.box.before(new Uint8Array(pub),\n\t\t    new Uint8Array(priv));\n\n\t\treturn (Buffer.from(secret));\n\t}\n\n\tthrow (new Error('Invalid algorithm: ' + this._algo));\n};\n\nDiffieHellman.prototype.generateKey = function () {\n\tvar parts = [];\n\tvar priv, pub;\n\tif (this._algo === 'dsa') {\n\t\tthis._dh.generateKeys();\n\n\t\tparts.push({name: 'p', data: this._p.data});\n\t\tparts.push({name: 'q', data: this._key.part.q.data});\n\t\tparts.push({name: 'g', data: this._g.data});\n\t\tparts.push({name: 'y', data: this._dh.getPublicKey()});\n\t\tparts.push({name: 'x', data: this._dh.getPrivateKey()});\n\t\tthis._key = new PrivateKey({\n\t\t\ttype: 'dsa',\n\t\t\tparts: parts\n\t\t});\n\t\tthis._isPriv = true;\n\t\treturn (this._key);\n\n\t} else if (this._algo === 'ecdsa') {\n\t\tif (CRYPTO_HAVE_ECDH) {\n\t\t\tthis._dh.generateKeys();\n\n\t\t\tparts.push({name: 'curve',\n\t\t\t    data: Buffer.from(this._curve)});\n\t\t\tparts.push({name: 'Q', data: this._dh.getPublicKey()});\n\t\t\tparts.push({name: 'd', data: this._dh.getPrivateKey()});\n\t\t\tthis._key = new PrivateKey({\n\t\t\t\ttype: 'ecdsa',\n\t\t\t\tcurve: this._curve,\n\t\t\t\tparts: parts\n\t\t\t});\n\t\t\tthis._isPriv = true;\n\t\t\treturn (this._key);\n\n\t\t} else {\n\t\t\tvar n = this._ecParams.getN();\n\t\t\tvar r = new jsbn(crypto.randomBytes(n.bitLength()));\n\t\t\tvar n1 = n.subtract(jsbn.ONE);\n\t\t\tpriv = r.mod(n1).add(jsbn.ONE);\n\t\t\tpub = this._ecParams.getG().multiply(priv);\n\n\t\t\tpriv = Buffer.from(priv.toByteArray());\n\t\t\tpub = Buffer.from(this._ecParams.getCurve().\n\t\t\t    encodePointHex(pub), 'hex');\n\n\t\t\tthis._priv = new ECPrivate(this._ecParams, priv);\n\n\t\t\tparts.push({name: 'curve',\n\t\t\t    data: Buffer.from(this._curve)});\n\t\t\tparts.push({name: 'Q', data: pub});\n\t\t\tparts.push({name: 'd', data: priv});\n\n\t\t\tthis._key = new PrivateKey({\n\t\t\t\ttype: 'ecdsa',\n\t\t\t\tcurve: this._curve,\n\t\t\t\tparts: parts\n\t\t\t});\n\t\t\tthis._isPriv = true;\n\t\t\treturn (this._key);\n\t\t}\n\n\t} else if (this._algo === 'curve25519') {\n\t\tvar pair = nacl.box.keyPair();\n\t\tpriv = Buffer.from(pair.secretKey);\n\t\tpub = Buffer.from(pair.publicKey);\n\t\tpriv = Buffer.concat([priv, pub]);\n\t\tassert.strictEqual(priv.length, 64);\n\t\tassert.strictEqual(pub.length, 32);\n\n\t\tparts.push({name: 'A', data: pub});\n\t\tparts.push({name: 'k', data: priv});\n\t\tthis._key = new PrivateKey({\n\t\t\ttype: 'curve25519',\n\t\t\tparts: parts\n\t\t});\n\t\tthis._isPriv = true;\n\t\treturn (this._key);\n\t}\n\n\tthrow (new Error('Invalid algorithm: ' + this._algo));\n};\nDiffieHellman.prototype.generateKeys = DiffieHellman.prototype.generateKey;\n\n/* These are helpers for using ecc-jsbn (for node 0.10 compatibility). */\n\nfunction X9ECParameters(name) {\n\tvar params = algs.curves[name];\n\tassert.object(params);\n\n\tvar p = new jsbn(params.p);\n\tvar a = new jsbn(params.a);\n\tvar b = new jsbn(params.b);\n\tvar n = new jsbn(params.n);\n\tvar h = jsbn.ONE;\n\tvar curve = new ec.ECCurveFp(p, a, b);\n\tvar G = curve.decodePointHex(params.G.toString('hex'));\n\n\tthis.curve = curve;\n\tthis.g = G;\n\tthis.n = n;\n\tthis.h = h;\n}\nX9ECParameters.prototype.getCurve = function () { return (this.curve); };\nX9ECParameters.prototype.getG = function () { return (this.g); };\nX9ECParameters.prototype.getN = function () { return (this.n); };\nX9ECParameters.prototype.getH = function () { return (this.h); };\n\nfunction ECPublic(params, buffer) {\n\tthis._params = params;\n\tif (buffer[0] === 0x00)\n\t\tbuffer = buffer.slice(1);\n\tthis._pub = params.getCurve().decodePointHex(buffer.toString('hex'));\n}\n\nfunction ECPrivate(params, buffer) {\n\tthis._params = params;\n\tthis._priv = new jsbn(utils.mpNormalize(buffer));\n}\nECPrivate.prototype.deriveSharedSecret = function (pubKey) {\n\tassert.ok(pubKey instanceof ECPublic);\n\tvar S = pubKey._pub.multiply(this._priv);\n\treturn (Buffer.from(S.getX().toBigInteger().toByteArray()));\n};\n\nfunction generateED25519() {\n\tvar pair = nacl.sign.keyPair();\n\tvar priv = Buffer.from(pair.secretKey);\n\tvar pub = Buffer.from(pair.publicKey);\n\tassert.strictEqual(priv.length, 64);\n\tassert.strictEqual(pub.length, 32);\n\n\tvar parts = [];\n\tparts.push({name: 'A', data: pub});\n\tparts.push({name: 'k', data: priv.slice(0, 32)});\n\tvar key = new PrivateKey({\n\t\ttype: 'ed25519',\n\t\tparts: parts\n\t});\n\treturn (key);\n}\n\n/* Generates a new ECDSA private key on a given curve. */\nfunction generateECDSA(curve) {\n\tvar parts = [];\n\tvar key;\n\n\tif (CRYPTO_HAVE_ECDH) {\n\t\t/*\n\t\t * Node crypto doesn't expose key generation directly, but the\n\t\t * ECDH instances can generate keys. It turns out this just\n\t\t * calls into the OpenSSL generic key generator, and we can\n\t\t * read its output happily without doing an actual DH. So we\n\t\t * use that here.\n\t\t */\n\t\tvar osCurve = {\n\t\t\t'nistp256': 'prime256v1',\n\t\t\t'nistp384': 'secp384r1',\n\t\t\t'nistp521': 'secp521r1'\n\t\t}[curve];\n\n\t\tvar dh = crypto.createECDH(osCurve);\n\t\tdh.generateKeys();\n\n\t\tparts.push({name: 'curve',\n\t\t    data: Buffer.from(curve)});\n\t\tparts.push({name: 'Q', data: dh.getPublicKey()});\n\t\tparts.push({name: 'd', data: dh.getPrivateKey()});\n\n\t\tkey = new PrivateKey({\n\t\t\ttype: 'ecdsa',\n\t\t\tcurve: curve,\n\t\t\tparts: parts\n\t\t});\n\t\treturn (key);\n\t} else {\n\n\t\tvar ecParams = new X9ECParameters(curve);\n\n\t\t/* This algorithm taken from FIPS PUB 186-4 (section B.4.1) */\n\t\tvar n = ecParams.getN();\n\t\t/*\n\t\t * The crypto.randomBytes() function can only give us whole\n\t\t * bytes, so taking a nod from X9.62, we round up.\n\t\t */\n\t\tvar cByteLen = Math.ceil((n.bitLength() + 64) / 8);\n\t\tvar c = new jsbn(crypto.randomBytes(cByteLen));\n\n\t\tvar n1 = n.subtract(jsbn.ONE);\n\t\tvar priv = c.mod(n1).add(jsbn.ONE);\n\t\tvar pub = ecParams.getG().multiply(priv);\n\n\t\tpriv = Buffer.from(priv.toByteArray());\n\t\tpub = Buffer.from(ecParams.getCurve().\n\t\t    encodePointHex(pub), 'hex');\n\n\t\tparts.push({name: 'curve', data: Buffer.from(curve)});\n\t\tparts.push({name: 'Q', data: pub});\n\t\tparts.push({name: 'd', data: priv});\n\n\t\tkey = new PrivateKey({\n\t\t\ttype: 'ecdsa',\n\t\t\tcurve: curve,\n\t\t\tparts: parts\n\t\t});\n\t\treturn (key);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZGhlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDBFQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixhQUFhLHlHQUE4QjtBQUMzQyxXQUFXLG1CQUFPLENBQUMsaUVBQVE7QUFDM0IsWUFBWSxtQkFBTyxDQUFDLG1FQUFTO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyx5RUFBVzs7QUFFOUIsVUFBVSxtQkFBTyxDQUFDLCtEQUFPO0FBQ3pCLGlCQUFpQixtQkFBTyxDQUFDLCtFQUFlOztBQUV4Qzs7QUFFQSxXQUFXLG1CQUFPLENBQUMsbUVBQVU7QUFDN0IsU0FBUyxtQkFBTyxDQUFDLDJFQUFpQjtBQUNsQyxXQUFXLGdIQUEwQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsdUNBQXVDO0FBQ3JELGNBQWMsOEJBQThCO0FBQzVDLGNBQWMseUNBQXlDO0FBQ3ZELGNBQWMsMENBQTBDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBOztBQUVBLGVBQWU7QUFDZixzQ0FBc0M7QUFDdEMsZUFBZSx5Q0FBeUM7QUFDeEQsZUFBZSwwQ0FBMEM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZTtBQUNmLHNDQUFzQztBQUN0QyxlQUFlLHFCQUFxQjtBQUNwQyxlQUFlLHNCQUFzQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxxQkFBcUI7QUFDbkMsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5Qyw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEMsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLGNBQWM7QUFDZCwrQkFBK0I7QUFDL0IsY0FBYyxtQ0FBbUM7QUFDakQsY0FBYyxvQ0FBb0M7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx3Q0FBd0M7QUFDdEQsY0FBYyxxQkFBcUI7QUFDbkMsY0FBYyxzQkFBc0I7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2RoZS5qcz82ODk5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE3IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0RGlmZmllSGVsbG1hbjogRGlmZmllSGVsbG1hbixcblx0Z2VuZXJhdGVFQ0RTQTogZ2VuZXJhdGVFQ0RTQSxcblx0Z2VuZXJhdGVFRDI1NTE5OiBnZW5lcmF0ZUVEMjU1MTlcbn07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBhbGdzID0gcmVxdWlyZSgnLi9hbGdzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbmFjbCA9IHJlcXVpcmUoJ3R3ZWV0bmFjbCcpO1xuXG52YXIgS2V5ID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi9wcml2YXRlLWtleScpO1xuXG52YXIgQ1JZUFRPX0hBVkVfRUNESCA9IChjcnlwdG8uY3JlYXRlRUNESCAhPT0gdW5kZWZpbmVkKTtcblxudmFyIGVjZGggPSByZXF1aXJlKCdlY2MtanNibicpO1xudmFyIGVjID0gcmVxdWlyZSgnZWNjLWpzYm4vbGliL2VjJyk7XG52YXIganNibiA9IHJlcXVpcmUoJ2pzYm4nKS5CaWdJbnRlZ2VyO1xuXG5mdW5jdGlvbiBEaWZmaWVIZWxsbWFuKGtleSkge1xuXHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKGtleSwgS2V5LCBbMSwgNF0sICdrZXknKTtcblx0dGhpcy5faXNQcml2ID0gUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5LCBbMSwgM10pO1xuXHR0aGlzLl9hbGdvID0ga2V5LnR5cGU7XG5cdHRoaXMuX2N1cnZlID0ga2V5LmN1cnZlO1xuXHR0aGlzLl9rZXkgPSBrZXk7XG5cdGlmIChrZXkudHlwZSA9PT0gJ2RzYScpIHtcblx0XHRpZiAoIUNSWVBUT19IQVZFX0VDREgpIHtcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ0R1ZSB0byBidWdzIGluIHRoZSBub2RlIDAuMTAgJyArXG5cdFx0XHQgICAgJ2NyeXB0byBBUEksIG5vZGUgMC4xMi54IG9yIGxhdGVyIGlzIHJlcXVpcmVkICcgK1xuXHRcdFx0ICAgICd0byB1c2UgREgnKSk7XG5cdFx0fVxuXHRcdHRoaXMuX2RoID0gY3J5cHRvLmNyZWF0ZURpZmZpZUhlbGxtYW4oXG5cdFx0ICAgIGtleS5wYXJ0LnAuZGF0YSwgdW5kZWZpbmVkLFxuXHRcdCAgICBrZXkucGFydC5nLmRhdGEsIHVuZGVmaW5lZCk7XG5cdFx0dGhpcy5fcCA9IGtleS5wYXJ0LnA7XG5cdFx0dGhpcy5fZyA9IGtleS5wYXJ0Lmc7XG5cdFx0aWYgKHRoaXMuX2lzUHJpdilcblx0XHRcdHRoaXMuX2RoLnNldFByaXZhdGVLZXkoa2V5LnBhcnQueC5kYXRhKTtcblx0XHR0aGlzLl9kaC5zZXRQdWJsaWNLZXkoa2V5LnBhcnQueS5kYXRhKTtcblxuXHR9IGVsc2UgaWYgKGtleS50eXBlID09PSAnZWNkc2EnKSB7XG5cdFx0aWYgKCFDUllQVE9fSEFWRV9FQ0RIKSB7XG5cdFx0XHR0aGlzLl9lY1BhcmFtcyA9IG5ldyBYOUVDUGFyYW1ldGVycyh0aGlzLl9jdXJ2ZSk7XG5cblx0XHRcdGlmICh0aGlzLl9pc1ByaXYpIHtcblx0XHRcdFx0dGhpcy5fcHJpdiA9IG5ldyBFQ1ByaXZhdGUoXG5cdFx0XHRcdCAgICB0aGlzLl9lY1BhcmFtcywga2V5LnBhcnQuZC5kYXRhKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY3VydmUgPSB7XG5cdFx0XHQnbmlzdHAyNTYnOiAncHJpbWUyNTZ2MScsXG5cdFx0XHQnbmlzdHAzODQnOiAnc2VjcDM4NHIxJyxcblx0XHRcdCduaXN0cDUyMSc6ICdzZWNwNTIxcjEnXG5cdFx0fVtrZXkuY3VydmVdO1xuXHRcdHRoaXMuX2RoID0gY3J5cHRvLmNyZWF0ZUVDREgoY3VydmUpO1xuXHRcdGlmICh0eXBlb2YgKHRoaXMuX2RoKSAhPT0gJ29iamVjdCcgfHxcblx0XHQgICAgdHlwZW9mICh0aGlzLl9kaC5zZXRQcml2YXRlS2V5KSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Q1JZUFRPX0hBVkVfRUNESCA9IGZhbHNlO1xuXHRcdFx0RGlmZmllSGVsbG1hbi5jYWxsKHRoaXMsIGtleSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9pc1ByaXYpXG5cdFx0XHR0aGlzLl9kaC5zZXRQcml2YXRlS2V5KGtleS5wYXJ0LmQuZGF0YSk7XG5cdFx0dGhpcy5fZGguc2V0UHVibGljS2V5KGtleS5wYXJ0LlEuZGF0YSk7XG5cblx0fSBlbHNlIGlmIChrZXkudHlwZSA9PT0gJ2N1cnZlMjU1MTknKSB7XG5cdFx0aWYgKHRoaXMuX2lzUHJpdikge1xuXHRcdFx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShrZXksIFByaXZhdGVLZXksIFsxLCA1XSwgJ2tleScpO1xuXHRcdFx0dGhpcy5fcHJpdiA9IGtleS5wYXJ0LmsuZGF0YTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdESCBub3Qgc3VwcG9ydGVkIGZvciAnICsga2V5LnR5cGUgKyAnIGtleXMnKSk7XG5cdH1cbn1cblxuRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodGhpcy5faXNQcml2KVxuXHRcdHJldHVybiAodGhpcy5fa2V5LnRvUHVibGljKCkpO1xuXHRyZXR1cm4gKHRoaXMuX2tleSk7XG59O1xuXG5EaWZmaWVIZWxsbWFuLnByb3RvdHlwZS5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodGhpcy5faXNQcml2KVxuXHRcdHJldHVybiAodGhpcy5fa2V5KTtcblx0ZWxzZVxuXHRcdHJldHVybiAodW5kZWZpbmVkKTtcbn07XG5EaWZmaWVIZWxsbWFuLnByb3RvdHlwZS5nZXRLZXkgPSBEaWZmaWVIZWxsbWFuLnByb3RvdHlwZS5nZXRQcml2YXRlS2V5O1xuXG5EaWZmaWVIZWxsbWFuLnByb3RvdHlwZS5fa2V5Q2hlY2sgPSBmdW5jdGlvbiAocGssIGlzUHViKSB7XG5cdGFzc2VydC5vYmplY3QocGssICdrZXknKTtcblx0aWYgKCFpc1B1Yilcblx0XHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKHBrLCBQcml2YXRlS2V5LCBbMSwgM10sICdrZXknKTtcblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShwaywgS2V5LCBbMSwgNF0sICdrZXknKTtcblxuXHRpZiAocGsudHlwZSAhPT0gdGhpcy5fYWxnbykge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ0EgJyArIHBrLnR5cGUgKyAnIGtleSBjYW5ub3QgYmUgdXNlZCBpbiAnICtcblx0XHQgICAgdGhpcy5fYWxnbyArICcgRGlmZmllLUhlbGxtYW4nKSk7XG5cdH1cblxuXHRpZiAocGsuY3VydmUgIT09IHRoaXMuX2N1cnZlKSB7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignQSBrZXkgZnJvbSB0aGUgJyArIHBrLmN1cnZlICsgJyBjdXJ2ZSAnICtcblx0XHQgICAgJ2Nhbm5vdCBiZSB1c2VkIHdpdGggYSAnICsgdGhpcy5fY3VydmUgK1xuXHRcdCAgICAnIERpZmZpZS1IZWxsbWFuJykpO1xuXHR9XG5cblx0aWYgKHBrLnR5cGUgPT09ICdkc2EnKSB7XG5cdFx0YXNzZXJ0LmRlZXBFcXVhbChway5wYXJ0LnAsIHRoaXMuX3AsXG5cdFx0ICAgICdEU0Ega2V5IHByaW1lIGRvZXMgbm90IG1hdGNoJyk7XG5cdFx0YXNzZXJ0LmRlZXBFcXVhbChway5wYXJ0LmcsIHRoaXMuX2csXG5cdFx0ICAgICdEU0Ega2V5IGdlbmVyYXRvciBkb2VzIG5vdCBtYXRjaCcpO1xuXHR9XG59O1xuXG5EaWZmaWVIZWxsbWFuLnByb3RvdHlwZS5zZXRLZXkgPSBmdW5jdGlvbiAocGspIHtcblx0dGhpcy5fa2V5Q2hlY2socGspO1xuXG5cdGlmIChway50eXBlID09PSAnZHNhJykge1xuXHRcdHRoaXMuX2RoLnNldFByaXZhdGVLZXkocGsucGFydC54LmRhdGEpO1xuXHRcdHRoaXMuX2RoLnNldFB1YmxpY0tleShway5wYXJ0LnkuZGF0YSk7XG5cblx0fSBlbHNlIGlmIChway50eXBlID09PSAnZWNkc2EnKSB7XG5cdFx0aWYgKENSWVBUT19IQVZFX0VDREgpIHtcblx0XHRcdHRoaXMuX2RoLnNldFByaXZhdGVLZXkocGsucGFydC5kLmRhdGEpO1xuXHRcdFx0dGhpcy5fZGguc2V0UHVibGljS2V5KHBrLnBhcnQuUS5kYXRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcHJpdiA9IG5ldyBFQ1ByaXZhdGUoXG5cdFx0XHQgICAgdGhpcy5fZWNQYXJhbXMsIHBrLnBhcnQuZC5kYXRhKTtcblx0XHR9XG5cblx0fSBlbHNlIGlmIChway50eXBlID09PSAnY3VydmUyNTUxOScpIHtcblx0XHR2YXIgayA9IHBrLnBhcnQuaztcblx0XHRpZiAoIXBrLnBhcnQuaylcblx0XHRcdGsgPSBway5wYXJ0LnI7XG5cdFx0dGhpcy5fcHJpdiA9IGsuZGF0YTtcblx0XHRpZiAodGhpcy5fcHJpdlswXSA9PT0gMHgwMClcblx0XHRcdHRoaXMuX3ByaXYgPSB0aGlzLl9wcml2LnNsaWNlKDEpO1xuXHRcdHRoaXMuX3ByaXYgPSB0aGlzLl9wcml2LnNsaWNlKDAsIDMyKTtcblx0fVxuXHR0aGlzLl9rZXkgPSBwaztcblx0dGhpcy5faXNQcml2ID0gdHJ1ZTtcbn07XG5EaWZmaWVIZWxsbWFuLnByb3RvdHlwZS5zZXRQcml2YXRlS2V5ID0gRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuc2V0S2V5O1xuXG5EaWZmaWVIZWxsbWFuLnByb3RvdHlwZS5jb21wdXRlU2VjcmV0ID0gZnVuY3Rpb24gKG90aGVycGspIHtcblx0dGhpcy5fa2V5Q2hlY2sob3RoZXJwaywgdHJ1ZSk7XG5cdGlmICghdGhpcy5faXNQcml2KVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0RIIGV4Y2hhbmdlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB3aXRoICcgK1xuXHRcdCAgICAnYSBwcml2YXRlIGtleSB5ZXQnKSk7XG5cblx0dmFyIHB1Yjtcblx0aWYgKHRoaXMuX2FsZ28gPT09ICdkc2EnKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9kaC5jb21wdXRlU2VjcmV0KFxuXHRcdCAgICBvdGhlcnBrLnBhcnQueS5kYXRhKSk7XG5cblx0fSBlbHNlIGlmICh0aGlzLl9hbGdvID09PSAnZWNkc2EnKSB7XG5cdFx0aWYgKENSWVBUT19IQVZFX0VDREgpIHtcblx0XHRcdHJldHVybiAodGhpcy5fZGguY29tcHV0ZVNlY3JldChcblx0XHRcdCAgICBvdGhlcnBrLnBhcnQuUS5kYXRhKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHB1YiA9IG5ldyBFQ1B1YmxpYyhcblx0XHRcdCAgICB0aGlzLl9lY1BhcmFtcywgb3RoZXJway5wYXJ0LlEuZGF0YSk7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX3ByaXYuZGVyaXZlU2hhcmVkU2VjcmV0KHB1YikpO1xuXHRcdH1cblxuXHR9IGVsc2UgaWYgKHRoaXMuX2FsZ28gPT09ICdjdXJ2ZTI1NTE5Jykge1xuXHRcdHB1YiA9IG90aGVycGsucGFydC5BLmRhdGE7XG5cdFx0d2hpbGUgKHB1YlswXSA9PT0gMHgwMCAmJiBwdWIubGVuZ3RoID4gMzIpXG5cdFx0XHRwdWIgPSBwdWIuc2xpY2UoMSk7XG5cdFx0dmFyIHByaXYgPSB0aGlzLl9wcml2O1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChwdWIubGVuZ3RoLCAzMik7XG5cdFx0YXNzZXJ0LnN0cmljdEVxdWFsKHByaXYubGVuZ3RoLCAzMik7XG5cblx0XHR2YXIgc2VjcmV0ID0gbmFjbC5ib3guYmVmb3JlKG5ldyBVaW50OEFycmF5KHB1YiksXG5cdFx0ICAgIG5ldyBVaW50OEFycmF5KHByaXYpKTtcblxuXHRcdHJldHVybiAoQnVmZmVyLmZyb20oc2VjcmV0KSk7XG5cdH1cblxuXHR0aHJvdyAobmV3IEVycm9yKCdJbnZhbGlkIGFsZ29yaXRobTogJyArIHRoaXMuX2FsZ28pKTtcbn07XG5cbkRpZmZpZUhlbGxtYW4ucHJvdG90eXBlLmdlbmVyYXRlS2V5ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgcGFydHMgPSBbXTtcblx0dmFyIHByaXYsIHB1Yjtcblx0aWYgKHRoaXMuX2FsZ28gPT09ICdkc2EnKSB7XG5cdFx0dGhpcy5fZGguZ2VuZXJhdGVLZXlzKCk7XG5cblx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAncCcsIGRhdGE6IHRoaXMuX3AuZGF0YX0pO1xuXHRcdHBhcnRzLnB1c2goe25hbWU6ICdxJywgZGF0YTogdGhpcy5fa2V5LnBhcnQucS5kYXRhfSk7XG5cdFx0cGFydHMucHVzaCh7bmFtZTogJ2cnLCBkYXRhOiB0aGlzLl9nLmRhdGF9KTtcblx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAneScsIGRhdGE6IHRoaXMuX2RoLmdldFB1YmxpY0tleSgpfSk7XG5cdFx0cGFydHMucHVzaCh7bmFtZTogJ3gnLCBkYXRhOiB0aGlzLl9kaC5nZXRQcml2YXRlS2V5KCl9KTtcblx0XHR0aGlzLl9rZXkgPSBuZXcgUHJpdmF0ZUtleSh7XG5cdFx0XHR0eXBlOiAnZHNhJyxcblx0XHRcdHBhcnRzOiBwYXJ0c1xuXHRcdH0pO1xuXHRcdHRoaXMuX2lzUHJpdiA9IHRydWU7XG5cdFx0cmV0dXJuICh0aGlzLl9rZXkpO1xuXG5cdH0gZWxzZSBpZiAodGhpcy5fYWxnbyA9PT0gJ2VjZHNhJykge1xuXHRcdGlmIChDUllQVE9fSEFWRV9FQ0RIKSB7XG5cdFx0XHR0aGlzLl9kaC5nZW5lcmF0ZUtleXMoKTtcblxuXHRcdFx0cGFydHMucHVzaCh7bmFtZTogJ2N1cnZlJyxcblx0XHRcdCAgICBkYXRhOiBCdWZmZXIuZnJvbSh0aGlzLl9jdXJ2ZSl9KTtcblx0XHRcdHBhcnRzLnB1c2goe25hbWU6ICdRJywgZGF0YTogdGhpcy5fZGguZ2V0UHVibGljS2V5KCl9KTtcblx0XHRcdHBhcnRzLnB1c2goe25hbWU6ICdkJywgZGF0YTogdGhpcy5fZGguZ2V0UHJpdmF0ZUtleSgpfSk7XG5cdFx0XHR0aGlzLl9rZXkgPSBuZXcgUHJpdmF0ZUtleSh7XG5cdFx0XHRcdHR5cGU6ICdlY2RzYScsXG5cdFx0XHRcdGN1cnZlOiB0aGlzLl9jdXJ2ZSxcblx0XHRcdFx0cGFydHM6IHBhcnRzXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuX2lzUHJpdiA9IHRydWU7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX2tleSk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG4gPSB0aGlzLl9lY1BhcmFtcy5nZXROKCk7XG5cdFx0XHR2YXIgciA9IG5ldyBqc2JuKGNyeXB0by5yYW5kb21CeXRlcyhuLmJpdExlbmd0aCgpKSk7XG5cdFx0XHR2YXIgbjEgPSBuLnN1YnRyYWN0KGpzYm4uT05FKTtcblx0XHRcdHByaXYgPSByLm1vZChuMSkuYWRkKGpzYm4uT05FKTtcblx0XHRcdHB1YiA9IHRoaXMuX2VjUGFyYW1zLmdldEcoKS5tdWx0aXBseShwcml2KTtcblxuXHRcdFx0cHJpdiA9IEJ1ZmZlci5mcm9tKHByaXYudG9CeXRlQXJyYXkoKSk7XG5cdFx0XHRwdWIgPSBCdWZmZXIuZnJvbSh0aGlzLl9lY1BhcmFtcy5nZXRDdXJ2ZSgpLlxuXHRcdFx0ICAgIGVuY29kZVBvaW50SGV4KHB1YiksICdoZXgnKTtcblxuXHRcdFx0dGhpcy5fcHJpdiA9IG5ldyBFQ1ByaXZhdGUodGhpcy5fZWNQYXJhbXMsIHByaXYpO1xuXG5cdFx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnY3VydmUnLFxuXHRcdFx0ICAgIGRhdGE6IEJ1ZmZlci5mcm9tKHRoaXMuX2N1cnZlKX0pO1xuXHRcdFx0cGFydHMucHVzaCh7bmFtZTogJ1EnLCBkYXRhOiBwdWJ9KTtcblx0XHRcdHBhcnRzLnB1c2goe25hbWU6ICdkJywgZGF0YTogcHJpdn0pO1xuXG5cdFx0XHR0aGlzLl9rZXkgPSBuZXcgUHJpdmF0ZUtleSh7XG5cdFx0XHRcdHR5cGU6ICdlY2RzYScsXG5cdFx0XHRcdGN1cnZlOiB0aGlzLl9jdXJ2ZSxcblx0XHRcdFx0cGFydHM6IHBhcnRzXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuX2lzUHJpdiA9IHRydWU7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX2tleSk7XG5cdFx0fVxuXG5cdH0gZWxzZSBpZiAodGhpcy5fYWxnbyA9PT0gJ2N1cnZlMjU1MTknKSB7XG5cdFx0dmFyIHBhaXIgPSBuYWNsLmJveC5rZXlQYWlyKCk7XG5cdFx0cHJpdiA9IEJ1ZmZlci5mcm9tKHBhaXIuc2VjcmV0S2V5KTtcblx0XHRwdWIgPSBCdWZmZXIuZnJvbShwYWlyLnB1YmxpY0tleSk7XG5cdFx0cHJpdiA9IEJ1ZmZlci5jb25jYXQoW3ByaXYsIHB1Yl0pO1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChwcml2Lmxlbmd0aCwgNjQpO1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChwdWIubGVuZ3RoLCAzMik7XG5cblx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnQScsIGRhdGE6IHB1Yn0pO1xuXHRcdHBhcnRzLnB1c2goe25hbWU6ICdrJywgZGF0YTogcHJpdn0pO1xuXHRcdHRoaXMuX2tleSA9IG5ldyBQcml2YXRlS2V5KHtcblx0XHRcdHR5cGU6ICdjdXJ2ZTI1NTE5Jyxcblx0XHRcdHBhcnRzOiBwYXJ0c1xuXHRcdH0pO1xuXHRcdHRoaXMuX2lzUHJpdiA9IHRydWU7XG5cdFx0cmV0dXJuICh0aGlzLl9rZXkpO1xuXHR9XG5cblx0dGhyb3cgKG5ldyBFcnJvcignSW52YWxpZCBhbGdvcml0aG06ICcgKyB0aGlzLl9hbGdvKSk7XG59O1xuRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuZ2VuZXJhdGVLZXlzID0gRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuZ2VuZXJhdGVLZXk7XG5cbi8qIFRoZXNlIGFyZSBoZWxwZXJzIGZvciB1c2luZyBlY2MtanNibiAoZm9yIG5vZGUgMC4xMCBjb21wYXRpYmlsaXR5KS4gKi9cblxuZnVuY3Rpb24gWDlFQ1BhcmFtZXRlcnMobmFtZSkge1xuXHR2YXIgcGFyYW1zID0gYWxncy5jdXJ2ZXNbbmFtZV07XG5cdGFzc2VydC5vYmplY3QocGFyYW1zKTtcblxuXHR2YXIgcCA9IG5ldyBqc2JuKHBhcmFtcy5wKTtcblx0dmFyIGEgPSBuZXcganNibihwYXJhbXMuYSk7XG5cdHZhciBiID0gbmV3IGpzYm4ocGFyYW1zLmIpO1xuXHR2YXIgbiA9IG5ldyBqc2JuKHBhcmFtcy5uKTtcblx0dmFyIGggPSBqc2JuLk9ORTtcblx0dmFyIGN1cnZlID0gbmV3IGVjLkVDQ3VydmVGcChwLCBhLCBiKTtcblx0dmFyIEcgPSBjdXJ2ZS5kZWNvZGVQb2ludEhleChwYXJhbXMuRy50b1N0cmluZygnaGV4JykpO1xuXG5cdHRoaXMuY3VydmUgPSBjdXJ2ZTtcblx0dGhpcy5nID0gRztcblx0dGhpcy5uID0gbjtcblx0dGhpcy5oID0gaDtcbn1cblg5RUNQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRDdXJ2ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnZlKTsgfTtcblg5RUNQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRHID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuZyk7IH07XG5YOUVDUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0TiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLm4pOyB9O1xuWDlFQ1BhcmFtZXRlcnMucHJvdG90eXBlLmdldEggPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5oKTsgfTtcblxuZnVuY3Rpb24gRUNQdWJsaWMocGFyYW1zLCBidWZmZXIpIHtcblx0dGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuXHRpZiAoYnVmZmVyWzBdID09PSAweDAwKVxuXHRcdGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgxKTtcblx0dGhpcy5fcHViID0gcGFyYW1zLmdldEN1cnZlKCkuZGVjb2RlUG9pbnRIZXgoYnVmZmVyLnRvU3RyaW5nKCdoZXgnKSk7XG59XG5cbmZ1bmN0aW9uIEVDUHJpdmF0ZShwYXJhbXMsIGJ1ZmZlcikge1xuXHR0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XG5cdHRoaXMuX3ByaXYgPSBuZXcganNibih1dGlscy5tcE5vcm1hbGl6ZShidWZmZXIpKTtcbn1cbkVDUHJpdmF0ZS5wcm90b3R5cGUuZGVyaXZlU2hhcmVkU2VjcmV0ID0gZnVuY3Rpb24gKHB1YktleSkge1xuXHRhc3NlcnQub2socHViS2V5IGluc3RhbmNlb2YgRUNQdWJsaWMpO1xuXHR2YXIgUyA9IHB1YktleS5fcHViLm11bHRpcGx5KHRoaXMuX3ByaXYpO1xuXHRyZXR1cm4gKEJ1ZmZlci5mcm9tKFMuZ2V0WCgpLnRvQmlnSW50ZWdlcigpLnRvQnl0ZUFycmF5KCkpKTtcbn07XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRUQyNTUxOSgpIHtcblx0dmFyIHBhaXIgPSBuYWNsLnNpZ24ua2V5UGFpcigpO1xuXHR2YXIgcHJpdiA9IEJ1ZmZlci5mcm9tKHBhaXIuc2VjcmV0S2V5KTtcblx0dmFyIHB1YiA9IEJ1ZmZlci5mcm9tKHBhaXIucHVibGljS2V5KTtcblx0YXNzZXJ0LnN0cmljdEVxdWFsKHByaXYubGVuZ3RoLCA2NCk7XG5cdGFzc2VydC5zdHJpY3RFcXVhbChwdWIubGVuZ3RoLCAzMik7XG5cblx0dmFyIHBhcnRzID0gW107XG5cdHBhcnRzLnB1c2goe25hbWU6ICdBJywgZGF0YTogcHVifSk7XG5cdHBhcnRzLnB1c2goe25hbWU6ICdrJywgZGF0YTogcHJpdi5zbGljZSgwLCAzMil9KTtcblx0dmFyIGtleSA9IG5ldyBQcml2YXRlS2V5KHtcblx0XHR0eXBlOiAnZWQyNTUxOScsXG5cdFx0cGFydHM6IHBhcnRzXG5cdH0pO1xuXHRyZXR1cm4gKGtleSk7XG59XG5cbi8qIEdlbmVyYXRlcyBhIG5ldyBFQ0RTQSBwcml2YXRlIGtleSBvbiBhIGdpdmVuIGN1cnZlLiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVFQ0RTQShjdXJ2ZSkge1xuXHR2YXIgcGFydHMgPSBbXTtcblx0dmFyIGtleTtcblxuXHRpZiAoQ1JZUFRPX0hBVkVfRUNESCkge1xuXHRcdC8qXG5cdFx0ICogTm9kZSBjcnlwdG8gZG9lc24ndCBleHBvc2Uga2V5IGdlbmVyYXRpb24gZGlyZWN0bHksIGJ1dCB0aGVcblx0XHQgKiBFQ0RIIGluc3RhbmNlcyBjYW4gZ2VuZXJhdGUga2V5cy4gSXQgdHVybnMgb3V0IHRoaXMganVzdFxuXHRcdCAqIGNhbGxzIGludG8gdGhlIE9wZW5TU0wgZ2VuZXJpYyBrZXkgZ2VuZXJhdG9yLCBhbmQgd2UgY2FuXG5cdFx0ICogcmVhZCBpdHMgb3V0cHV0IGhhcHBpbHkgd2l0aG91dCBkb2luZyBhbiBhY3R1YWwgREguIFNvIHdlXG5cdFx0ICogdXNlIHRoYXQgaGVyZS5cblx0XHQgKi9cblx0XHR2YXIgb3NDdXJ2ZSA9IHtcblx0XHRcdCduaXN0cDI1Nic6ICdwcmltZTI1NnYxJyxcblx0XHRcdCduaXN0cDM4NCc6ICdzZWNwMzg0cjEnLFxuXHRcdFx0J25pc3RwNTIxJzogJ3NlY3A1MjFyMSdcblx0XHR9W2N1cnZlXTtcblxuXHRcdHZhciBkaCA9IGNyeXB0by5jcmVhdGVFQ0RIKG9zQ3VydmUpO1xuXHRcdGRoLmdlbmVyYXRlS2V5cygpO1xuXG5cdFx0cGFydHMucHVzaCh7bmFtZTogJ2N1cnZlJyxcblx0XHQgICAgZGF0YTogQnVmZmVyLmZyb20oY3VydmUpfSk7XG5cdFx0cGFydHMucHVzaCh7bmFtZTogJ1EnLCBkYXRhOiBkaC5nZXRQdWJsaWNLZXkoKX0pO1xuXHRcdHBhcnRzLnB1c2goe25hbWU6ICdkJywgZGF0YTogZGguZ2V0UHJpdmF0ZUtleSgpfSk7XG5cblx0XHRrZXkgPSBuZXcgUHJpdmF0ZUtleSh7XG5cdFx0XHR0eXBlOiAnZWNkc2EnLFxuXHRcdFx0Y3VydmU6IGN1cnZlLFxuXHRcdFx0cGFydHM6IHBhcnRzXG5cdFx0fSk7XG5cdFx0cmV0dXJuIChrZXkpO1xuXHR9IGVsc2Uge1xuXG5cdFx0dmFyIGVjUGFyYW1zID0gbmV3IFg5RUNQYXJhbWV0ZXJzKGN1cnZlKTtcblxuXHRcdC8qIFRoaXMgYWxnb3JpdGhtIHRha2VuIGZyb20gRklQUyBQVUIgMTg2LTQgKHNlY3Rpb24gQi40LjEpICovXG5cdFx0dmFyIG4gPSBlY1BhcmFtcy5nZXROKCk7XG5cdFx0Lypcblx0XHQgKiBUaGUgY3J5cHRvLnJhbmRvbUJ5dGVzKCkgZnVuY3Rpb24gY2FuIG9ubHkgZ2l2ZSB1cyB3aG9sZVxuXHRcdCAqIGJ5dGVzLCBzbyB0YWtpbmcgYSBub2QgZnJvbSBYOS42Miwgd2Ugcm91bmQgdXAuXG5cdFx0ICovXG5cdFx0dmFyIGNCeXRlTGVuID0gTWF0aC5jZWlsKChuLmJpdExlbmd0aCgpICsgNjQpIC8gOCk7XG5cdFx0dmFyIGMgPSBuZXcganNibihjcnlwdG8ucmFuZG9tQnl0ZXMoY0J5dGVMZW4pKTtcblxuXHRcdHZhciBuMSA9IG4uc3VidHJhY3QoanNibi5PTkUpO1xuXHRcdHZhciBwcml2ID0gYy5tb2QobjEpLmFkZChqc2JuLk9ORSk7XG5cdFx0dmFyIHB1YiA9IGVjUGFyYW1zLmdldEcoKS5tdWx0aXBseShwcml2KTtcblxuXHRcdHByaXYgPSBCdWZmZXIuZnJvbShwcml2LnRvQnl0ZUFycmF5KCkpO1xuXHRcdHB1YiA9IEJ1ZmZlci5mcm9tKGVjUGFyYW1zLmdldEN1cnZlKCkuXG5cdFx0ICAgIGVuY29kZVBvaW50SGV4KHB1YiksICdoZXgnKTtcblxuXHRcdHBhcnRzLnB1c2goe25hbWU6ICdjdXJ2ZScsIGRhdGE6IEJ1ZmZlci5mcm9tKGN1cnZlKX0pO1xuXHRcdHBhcnRzLnB1c2goe25hbWU6ICdRJywgZGF0YTogcHVifSk7XG5cdFx0cGFydHMucHVzaCh7bmFtZTogJ2QnLCBkYXRhOiBwcml2fSk7XG5cblx0XHRrZXkgPSBuZXcgUHJpdmF0ZUtleSh7XG5cdFx0XHR0eXBlOiAnZWNkc2EnLFxuXHRcdFx0Y3VydmU6IGN1cnZlLFxuXHRcdFx0cGFydHM6IHBhcnRzXG5cdFx0fSk7XG5cdFx0cmV0dXJuIChrZXkpO1xuXHR9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/dhe.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/dhe.js":
/*!***************************************!*\
  !*** ./node_modules/sshpk/lib/dhe.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2017 Joyent, Inc.\n\nmodule.exports = {\n\tDiffieHellman: DiffieHellman,\n\tgenerateECDSA: generateECDSA,\n\tgenerateED25519: generateED25519\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ./algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar nacl = __webpack_require__(/*! tweetnacl */ \"(rsc)/./node_modules/tweetnacl/nacl-fast.js\");\n\nvar Key = __webpack_require__(/*! ./key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ./private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\n\nvar CRYPTO_HAVE_ECDH = (crypto.createECDH !== undefined);\n\nvar ecdh = __webpack_require__(/*! ecc-jsbn */ \"(rsc)/./node_modules/ecc-jsbn/index.js\");\nvar ec = __webpack_require__(/*! ecc-jsbn/lib/ec */ \"(rsc)/./node_modules/ecc-jsbn/lib/ec.js\");\nvar jsbn = (__webpack_require__(/*! jsbn */ \"(rsc)/./node_modules/sshpk/node_modules/jsbn/index.js\").BigInteger);\n\nfunction DiffieHellman(key) {\n\tutils.assertCompatible(key, Key, [1, 4], 'key');\n\tthis._isPriv = PrivateKey.isPrivateKey(key, [1, 3]);\n\tthis._algo = key.type;\n\tthis._curve = key.curve;\n\tthis._key = key;\n\tif (key.type === 'dsa') {\n\t\tif (!CRYPTO_HAVE_ECDH) {\n\t\t\tthrow (new Error('Due to bugs in the node 0.10 ' +\n\t\t\t    'crypto API, node 0.12.x or later is required ' +\n\t\t\t    'to use DH'));\n\t\t}\n\t\tthis._dh = crypto.createDiffieHellman(\n\t\t    key.part.p.data, undefined,\n\t\t    key.part.g.data, undefined);\n\t\tthis._p = key.part.p;\n\t\tthis._g = key.part.g;\n\t\tif (this._isPriv)\n\t\t\tthis._dh.setPrivateKey(key.part.x.data);\n\t\tthis._dh.setPublicKey(key.part.y.data);\n\n\t} else if (key.type === 'ecdsa') {\n\t\tif (!CRYPTO_HAVE_ECDH) {\n\t\t\tthis._ecParams = new X9ECParameters(this._curve);\n\n\t\t\tif (this._isPriv) {\n\t\t\t\tthis._priv = new ECPrivate(\n\t\t\t\t    this._ecParams, key.part.d.data);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar curve = {\n\t\t\t'nistp256': 'prime256v1',\n\t\t\t'nistp384': 'secp384r1',\n\t\t\t'nistp521': 'secp521r1'\n\t\t}[key.curve];\n\t\tthis._dh = crypto.createECDH(curve);\n\t\tif (typeof (this._dh) !== 'object' ||\n\t\t    typeof (this._dh.setPrivateKey) !== 'function') {\n\t\t\tCRYPTO_HAVE_ECDH = false;\n\t\t\tDiffieHellman.call(this, key);\n\t\t\treturn;\n\t\t}\n\t\tif (this._isPriv)\n\t\t\tthis._dh.setPrivateKey(key.part.d.data);\n\t\tthis._dh.setPublicKey(key.part.Q.data);\n\n\t} else if (key.type === 'curve25519') {\n\t\tif (this._isPriv) {\n\t\t\tutils.assertCompatible(key, PrivateKey, [1, 5], 'key');\n\t\t\tthis._priv = key.part.k.data;\n\t\t}\n\n\t} else {\n\t\tthrow (new Error('DH not supported for ' + key.type + ' keys'));\n\t}\n}\n\nDiffieHellman.prototype.getPublicKey = function () {\n\tif (this._isPriv)\n\t\treturn (this._key.toPublic());\n\treturn (this._key);\n};\n\nDiffieHellman.prototype.getPrivateKey = function () {\n\tif (this._isPriv)\n\t\treturn (this._key);\n\telse\n\t\treturn (undefined);\n};\nDiffieHellman.prototype.getKey = DiffieHellman.prototype.getPrivateKey;\n\nDiffieHellman.prototype._keyCheck = function (pk, isPub) {\n\tassert.object(pk, 'key');\n\tif (!isPub)\n\t\tutils.assertCompatible(pk, PrivateKey, [1, 3], 'key');\n\tutils.assertCompatible(pk, Key, [1, 4], 'key');\n\n\tif (pk.type !== this._algo) {\n\t\tthrow (new Error('A ' + pk.type + ' key cannot be used in ' +\n\t\t    this._algo + ' Diffie-Hellman'));\n\t}\n\n\tif (pk.curve !== this._curve) {\n\t\tthrow (new Error('A key from the ' + pk.curve + ' curve ' +\n\t\t    'cannot be used with a ' + this._curve +\n\t\t    ' Diffie-Hellman'));\n\t}\n\n\tif (pk.type === 'dsa') {\n\t\tassert.deepEqual(pk.part.p, this._p,\n\t\t    'DSA key prime does not match');\n\t\tassert.deepEqual(pk.part.g, this._g,\n\t\t    'DSA key generator does not match');\n\t}\n};\n\nDiffieHellman.prototype.setKey = function (pk) {\n\tthis._keyCheck(pk);\n\n\tif (pk.type === 'dsa') {\n\t\tthis._dh.setPrivateKey(pk.part.x.data);\n\t\tthis._dh.setPublicKey(pk.part.y.data);\n\n\t} else if (pk.type === 'ecdsa') {\n\t\tif (CRYPTO_HAVE_ECDH) {\n\t\t\tthis._dh.setPrivateKey(pk.part.d.data);\n\t\t\tthis._dh.setPublicKey(pk.part.Q.data);\n\t\t} else {\n\t\t\tthis._priv = new ECPrivate(\n\t\t\t    this._ecParams, pk.part.d.data);\n\t\t}\n\n\t} else if (pk.type === 'curve25519') {\n\t\tvar k = pk.part.k;\n\t\tif (!pk.part.k)\n\t\t\tk = pk.part.r;\n\t\tthis._priv = k.data;\n\t\tif (this._priv[0] === 0x00)\n\t\t\tthis._priv = this._priv.slice(1);\n\t\tthis._priv = this._priv.slice(0, 32);\n\t}\n\tthis._key = pk;\n\tthis._isPriv = true;\n};\nDiffieHellman.prototype.setPrivateKey = DiffieHellman.prototype.setKey;\n\nDiffieHellman.prototype.computeSecret = function (otherpk) {\n\tthis._keyCheck(otherpk, true);\n\tif (!this._isPriv)\n\t\tthrow (new Error('DH exchange has not been initialized with ' +\n\t\t    'a private key yet'));\n\n\tvar pub;\n\tif (this._algo === 'dsa') {\n\t\treturn (this._dh.computeSecret(\n\t\t    otherpk.part.y.data));\n\n\t} else if (this._algo === 'ecdsa') {\n\t\tif (CRYPTO_HAVE_ECDH) {\n\t\t\treturn (this._dh.computeSecret(\n\t\t\t    otherpk.part.Q.data));\n\t\t} else {\n\t\t\tpub = new ECPublic(\n\t\t\t    this._ecParams, otherpk.part.Q.data);\n\t\t\treturn (this._priv.deriveSharedSecret(pub));\n\t\t}\n\n\t} else if (this._algo === 'curve25519') {\n\t\tpub = otherpk.part.A.data;\n\t\twhile (pub[0] === 0x00 && pub.length > 32)\n\t\t\tpub = pub.slice(1);\n\t\tvar priv = this._priv;\n\t\tassert.strictEqual(pub.length, 32);\n\t\tassert.strictEqual(priv.length, 32);\n\n\t\tvar secret = nacl.box.before(new Uint8Array(pub),\n\t\t    new Uint8Array(priv));\n\n\t\treturn (Buffer.from(secret));\n\t}\n\n\tthrow (new Error('Invalid algorithm: ' + this._algo));\n};\n\nDiffieHellman.prototype.generateKey = function () {\n\tvar parts = [];\n\tvar priv, pub;\n\tif (this._algo === 'dsa') {\n\t\tthis._dh.generateKeys();\n\n\t\tparts.push({name: 'p', data: this._p.data});\n\t\tparts.push({name: 'q', data: this._key.part.q.data});\n\t\tparts.push({name: 'g', data: this._g.data});\n\t\tparts.push({name: 'y', data: this._dh.getPublicKey()});\n\t\tparts.push({name: 'x', data: this._dh.getPrivateKey()});\n\t\tthis._key = new PrivateKey({\n\t\t\ttype: 'dsa',\n\t\t\tparts: parts\n\t\t});\n\t\tthis._isPriv = true;\n\t\treturn (this._key);\n\n\t} else if (this._algo === 'ecdsa') {\n\t\tif (CRYPTO_HAVE_ECDH) {\n\t\t\tthis._dh.generateKeys();\n\n\t\t\tparts.push({name: 'curve',\n\t\t\t    data: Buffer.from(this._curve)});\n\t\t\tparts.push({name: 'Q', data: this._dh.getPublicKey()});\n\t\t\tparts.push({name: 'd', data: this._dh.getPrivateKey()});\n\t\t\tthis._key = new PrivateKey({\n\t\t\t\ttype: 'ecdsa',\n\t\t\t\tcurve: this._curve,\n\t\t\t\tparts: parts\n\t\t\t});\n\t\t\tthis._isPriv = true;\n\t\t\treturn (this._key);\n\n\t\t} else {\n\t\t\tvar n = this._ecParams.getN();\n\t\t\tvar r = new jsbn(crypto.randomBytes(n.bitLength()));\n\t\t\tvar n1 = n.subtract(jsbn.ONE);\n\t\t\tpriv = r.mod(n1).add(jsbn.ONE);\n\t\t\tpub = this._ecParams.getG().multiply(priv);\n\n\t\t\tpriv = Buffer.from(priv.toByteArray());\n\t\t\tpub = Buffer.from(this._ecParams.getCurve().\n\t\t\t    encodePointHex(pub), 'hex');\n\n\t\t\tthis._priv = new ECPrivate(this._ecParams, priv);\n\n\t\t\tparts.push({name: 'curve',\n\t\t\t    data: Buffer.from(this._curve)});\n\t\t\tparts.push({name: 'Q', data: pub});\n\t\t\tparts.push({name: 'd', data: priv});\n\n\t\t\tthis._key = new PrivateKey({\n\t\t\t\ttype: 'ecdsa',\n\t\t\t\tcurve: this._curve,\n\t\t\t\tparts: parts\n\t\t\t});\n\t\t\tthis._isPriv = true;\n\t\t\treturn (this._key);\n\t\t}\n\n\t} else if (this._algo === 'curve25519') {\n\t\tvar pair = nacl.box.keyPair();\n\t\tpriv = Buffer.from(pair.secretKey);\n\t\tpub = Buffer.from(pair.publicKey);\n\t\tpriv = Buffer.concat([priv, pub]);\n\t\tassert.strictEqual(priv.length, 64);\n\t\tassert.strictEqual(pub.length, 32);\n\n\t\tparts.push({name: 'A', data: pub});\n\t\tparts.push({name: 'k', data: priv});\n\t\tthis._key = new PrivateKey({\n\t\t\ttype: 'curve25519',\n\t\t\tparts: parts\n\t\t});\n\t\tthis._isPriv = true;\n\t\treturn (this._key);\n\t}\n\n\tthrow (new Error('Invalid algorithm: ' + this._algo));\n};\nDiffieHellman.prototype.generateKeys = DiffieHellman.prototype.generateKey;\n\n/* These are helpers for using ecc-jsbn (for node 0.10 compatibility). */\n\nfunction X9ECParameters(name) {\n\tvar params = algs.curves[name];\n\tassert.object(params);\n\n\tvar p = new jsbn(params.p);\n\tvar a = new jsbn(params.a);\n\tvar b = new jsbn(params.b);\n\tvar n = new jsbn(params.n);\n\tvar h = jsbn.ONE;\n\tvar curve = new ec.ECCurveFp(p, a, b);\n\tvar G = curve.decodePointHex(params.G.toString('hex'));\n\n\tthis.curve = curve;\n\tthis.g = G;\n\tthis.n = n;\n\tthis.h = h;\n}\nX9ECParameters.prototype.getCurve = function () { return (this.curve); };\nX9ECParameters.prototype.getG = function () { return (this.g); };\nX9ECParameters.prototype.getN = function () { return (this.n); };\nX9ECParameters.prototype.getH = function () { return (this.h); };\n\nfunction ECPublic(params, buffer) {\n\tthis._params = params;\n\tif (buffer[0] === 0x00)\n\t\tbuffer = buffer.slice(1);\n\tthis._pub = params.getCurve().decodePointHex(buffer.toString('hex'));\n}\n\nfunction ECPrivate(params, buffer) {\n\tthis._params = params;\n\tthis._priv = new jsbn(utils.mpNormalize(buffer));\n}\nECPrivate.prototype.deriveSharedSecret = function (pubKey) {\n\tassert.ok(pubKey instanceof ECPublic);\n\tvar S = pubKey._pub.multiply(this._priv);\n\treturn (Buffer.from(S.getX().toBigInteger().toByteArray()));\n};\n\nfunction generateED25519() {\n\tvar pair = nacl.sign.keyPair();\n\tvar priv = Buffer.from(pair.secretKey);\n\tvar pub = Buffer.from(pair.publicKey);\n\tassert.strictEqual(priv.length, 64);\n\tassert.strictEqual(pub.length, 32);\n\n\tvar parts = [];\n\tparts.push({name: 'A', data: pub});\n\tparts.push({name: 'k', data: priv.slice(0, 32)});\n\tvar key = new PrivateKey({\n\t\ttype: 'ed25519',\n\t\tparts: parts\n\t});\n\treturn (key);\n}\n\n/* Generates a new ECDSA private key on a given curve. */\nfunction generateECDSA(curve) {\n\tvar parts = [];\n\tvar key;\n\n\tif (CRYPTO_HAVE_ECDH) {\n\t\t/*\n\t\t * Node crypto doesn't expose key generation directly, but the\n\t\t * ECDH instances can generate keys. It turns out this just\n\t\t * calls into the OpenSSL generic key generator, and we can\n\t\t * read its output happily without doing an actual DH. So we\n\t\t * use that here.\n\t\t */\n\t\tvar osCurve = {\n\t\t\t'nistp256': 'prime256v1',\n\t\t\t'nistp384': 'secp384r1',\n\t\t\t'nistp521': 'secp521r1'\n\t\t}[curve];\n\n\t\tvar dh = crypto.createECDH(osCurve);\n\t\tdh.generateKeys();\n\n\t\tparts.push({name: 'curve',\n\t\t    data: Buffer.from(curve)});\n\t\tparts.push({name: 'Q', data: dh.getPublicKey()});\n\t\tparts.push({name: 'd', data: dh.getPrivateKey()});\n\n\t\tkey = new PrivateKey({\n\t\t\ttype: 'ecdsa',\n\t\t\tcurve: curve,\n\t\t\tparts: parts\n\t\t});\n\t\treturn (key);\n\t} else {\n\n\t\tvar ecParams = new X9ECParameters(curve);\n\n\t\t/* This algorithm taken from FIPS PUB 186-4 (section B.4.1) */\n\t\tvar n = ecParams.getN();\n\t\t/*\n\t\t * The crypto.randomBytes() function can only give us whole\n\t\t * bytes, so taking a nod from X9.62, we round up.\n\t\t */\n\t\tvar cByteLen = Math.ceil((n.bitLength() + 64) / 8);\n\t\tvar c = new jsbn(crypto.randomBytes(cByteLen));\n\n\t\tvar n1 = n.subtract(jsbn.ONE);\n\t\tvar priv = c.mod(n1).add(jsbn.ONE);\n\t\tvar pub = ecParams.getG().multiply(priv);\n\n\t\tpriv = Buffer.from(priv.toByteArray());\n\t\tpub = Buffer.from(ecParams.getCurve().\n\t\t    encodePointHex(pub), 'hex');\n\n\t\tparts.push({name: 'curve', data: Buffer.from(curve)});\n\t\tparts.push({name: 'Q', data: pub});\n\t\tparts.push({name: 'd', data: priv});\n\n\t\tkey = new PrivateKey({\n\t\t\ttype: 'ecdsa',\n\t\t\tcurve: curve,\n\t\t\tparts: parts\n\t\t});\n\t\treturn (key);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2RoZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrREFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsYUFBYSw4RkFBOEI7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLHNEQUFRO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyx3REFBUztBQUM3QixXQUFXLG1CQUFPLENBQUMsOERBQVc7O0FBRTlCLFVBQVUsbUJBQU8sQ0FBQyxvREFBTztBQUN6QixpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBZTs7QUFFeEM7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLHdEQUFVO0FBQzdCLFNBQVMsbUJBQU8sQ0FBQyxnRUFBaUI7QUFDbEMsV0FBVyxxR0FBMEI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLDhCQUE4QjtBQUM1QyxjQUFjLHVDQUF1QztBQUNyRCxjQUFjLDhCQUE4QjtBQUM1QyxjQUFjLHlDQUF5QztBQUN2RCxjQUFjLDBDQUEwQztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxlQUFlO0FBQ2Ysc0NBQXNDO0FBQ3RDLGVBQWUseUNBQXlDO0FBQ3hELGVBQWUsMENBQTBDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWU7QUFDZixzQ0FBc0M7QUFDdEMsZUFBZSxxQkFBcUI7QUFDcEMsZUFBZSxzQkFBc0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMscUJBQXFCO0FBQ25DLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUMsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSxjQUFjO0FBQ2QsK0JBQStCO0FBQy9CLGNBQWMsbUNBQW1DO0FBQ2pELGNBQWMsb0NBQW9DOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsd0NBQXdDO0FBQ3RELGNBQWMscUJBQXFCO0FBQ25DLGNBQWMsc0JBQXNCOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9kaGUuanM/NWJlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNyBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdERpZmZpZUhlbGxtYW46IERpZmZpZUhlbGxtYW4sXG5cdGdlbmVyYXRlRUNEU0E6IGdlbmVyYXRlRUNEU0EsXG5cdGdlbmVyYXRlRUQyNTUxOTogZ2VuZXJhdGVFRDI1NTE5XG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4vYWxncycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5hY2wgPSByZXF1aXJlKCd0d2VldG5hY2wnKTtcblxudmFyIEtleSA9IHJlcXVpcmUoJy4va2V5Jyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vcHJpdmF0ZS1rZXknKTtcblxudmFyIENSWVBUT19IQVZFX0VDREggPSAoY3J5cHRvLmNyZWF0ZUVDREggIT09IHVuZGVmaW5lZCk7XG5cbnZhciBlY2RoID0gcmVxdWlyZSgnZWNjLWpzYm4nKTtcbnZhciBlYyA9IHJlcXVpcmUoJ2VjYy1qc2JuL2xpYi9lYycpO1xudmFyIGpzYm4gPSByZXF1aXJlKCdqc2JuJykuQmlnSW50ZWdlcjtcblxuZnVuY3Rpb24gRGlmZmllSGVsbG1hbihrZXkpIHtcblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShrZXksIEtleSwgWzEsIDRdLCAna2V5Jyk7XG5cdHRoaXMuX2lzUHJpdiA9IFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSwgWzEsIDNdKTtcblx0dGhpcy5fYWxnbyA9IGtleS50eXBlO1xuXHR0aGlzLl9jdXJ2ZSA9IGtleS5jdXJ2ZTtcblx0dGhpcy5fa2V5ID0ga2V5O1xuXHRpZiAoa2V5LnR5cGUgPT09ICdkc2EnKSB7XG5cdFx0aWYgKCFDUllQVE9fSEFWRV9FQ0RIKSB7XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdEdWUgdG8gYnVncyBpbiB0aGUgbm9kZSAwLjEwICcgK1xuXHRcdFx0ICAgICdjcnlwdG8gQVBJLCBub2RlIDAuMTIueCBvciBsYXRlciBpcyByZXF1aXJlZCAnICtcblx0XHRcdCAgICAndG8gdXNlIERIJykpO1xuXHRcdH1cblx0XHR0aGlzLl9kaCA9IGNyeXB0by5jcmVhdGVEaWZmaWVIZWxsbWFuKFxuXHRcdCAgICBrZXkucGFydC5wLmRhdGEsIHVuZGVmaW5lZCxcblx0XHQgICAga2V5LnBhcnQuZy5kYXRhLCB1bmRlZmluZWQpO1xuXHRcdHRoaXMuX3AgPSBrZXkucGFydC5wO1xuXHRcdHRoaXMuX2cgPSBrZXkucGFydC5nO1xuXHRcdGlmICh0aGlzLl9pc1ByaXYpXG5cdFx0XHR0aGlzLl9kaC5zZXRQcml2YXRlS2V5KGtleS5wYXJ0LnguZGF0YSk7XG5cdFx0dGhpcy5fZGguc2V0UHVibGljS2V5KGtleS5wYXJ0LnkuZGF0YSk7XG5cblx0fSBlbHNlIGlmIChrZXkudHlwZSA9PT0gJ2VjZHNhJykge1xuXHRcdGlmICghQ1JZUFRPX0hBVkVfRUNESCkge1xuXHRcdFx0dGhpcy5fZWNQYXJhbXMgPSBuZXcgWDlFQ1BhcmFtZXRlcnModGhpcy5fY3VydmUpO1xuXG5cdFx0XHRpZiAodGhpcy5faXNQcml2KSB7XG5cdFx0XHRcdHRoaXMuX3ByaXYgPSBuZXcgRUNQcml2YXRlKFxuXHRcdFx0XHQgICAgdGhpcy5fZWNQYXJhbXMsIGtleS5wYXJ0LmQuZGF0YSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGN1cnZlID0ge1xuXHRcdFx0J25pc3RwMjU2JzogJ3ByaW1lMjU2djEnLFxuXHRcdFx0J25pc3RwMzg0JzogJ3NlY3AzODRyMScsXG5cdFx0XHQnbmlzdHA1MjEnOiAnc2VjcDUyMXIxJ1xuXHRcdH1ba2V5LmN1cnZlXTtcblx0XHR0aGlzLl9kaCA9IGNyeXB0by5jcmVhdGVFQ0RIKGN1cnZlKTtcblx0XHRpZiAodHlwZW9mICh0aGlzLl9kaCkgIT09ICdvYmplY3QnIHx8XG5cdFx0ICAgIHR5cGVvZiAodGhpcy5fZGguc2V0UHJpdmF0ZUtleSkgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdENSWVBUT19IQVZFX0VDREggPSBmYWxzZTtcblx0XHRcdERpZmZpZUhlbGxtYW4uY2FsbCh0aGlzLCBrZXkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAodGhpcy5faXNQcml2KVxuXHRcdFx0dGhpcy5fZGguc2V0UHJpdmF0ZUtleShrZXkucGFydC5kLmRhdGEpO1xuXHRcdHRoaXMuX2RoLnNldFB1YmxpY0tleShrZXkucGFydC5RLmRhdGEpO1xuXG5cdH0gZWxzZSBpZiAoa2V5LnR5cGUgPT09ICdjdXJ2ZTI1NTE5Jykge1xuXHRcdGlmICh0aGlzLl9pc1ByaXYpIHtcblx0XHRcdHV0aWxzLmFzc2VydENvbXBhdGlibGUoa2V5LCBQcml2YXRlS2V5LCBbMSwgNV0sICdrZXknKTtcblx0XHRcdHRoaXMuX3ByaXYgPSBrZXkucGFydC5rLmRhdGE7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignREggbm90IHN1cHBvcnRlZCBmb3IgJyArIGtleS50eXBlICsgJyBrZXlzJykpO1xuXHR9XG59XG5cbkRpZmZpZUhlbGxtYW4ucHJvdG90eXBlLmdldFB1YmxpY0tleSA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKHRoaXMuX2lzUHJpdilcblx0XHRyZXR1cm4gKHRoaXMuX2tleS50b1B1YmxpYygpKTtcblx0cmV0dXJuICh0aGlzLl9rZXkpO1xufTtcblxuRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKHRoaXMuX2lzUHJpdilcblx0XHRyZXR1cm4gKHRoaXMuX2tleSk7XG5cdGVsc2Vcblx0XHRyZXR1cm4gKHVuZGVmaW5lZCk7XG59O1xuRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuZ2V0S2V5ID0gRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleTtcblxuRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuX2tleUNoZWNrID0gZnVuY3Rpb24gKHBrLCBpc1B1Yikge1xuXHRhc3NlcnQub2JqZWN0KHBrLCAna2V5Jyk7XG5cdGlmICghaXNQdWIpXG5cdFx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShwaywgUHJpdmF0ZUtleSwgWzEsIDNdLCAna2V5Jyk7XG5cdHV0aWxzLmFzc2VydENvbXBhdGlibGUocGssIEtleSwgWzEsIDRdLCAna2V5Jyk7XG5cblx0aWYgKHBrLnR5cGUgIT09IHRoaXMuX2FsZ28pIHtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdBICcgKyBway50eXBlICsgJyBrZXkgY2Fubm90IGJlIHVzZWQgaW4gJyArXG5cdFx0ICAgIHRoaXMuX2FsZ28gKyAnIERpZmZpZS1IZWxsbWFuJykpO1xuXHR9XG5cblx0aWYgKHBrLmN1cnZlICE9PSB0aGlzLl9jdXJ2ZSkge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ0Ega2V5IGZyb20gdGhlICcgKyBway5jdXJ2ZSArICcgY3VydmUgJyArXG5cdFx0ICAgICdjYW5ub3QgYmUgdXNlZCB3aXRoIGEgJyArIHRoaXMuX2N1cnZlICtcblx0XHQgICAgJyBEaWZmaWUtSGVsbG1hbicpKTtcblx0fVxuXG5cdGlmIChway50eXBlID09PSAnZHNhJykge1xuXHRcdGFzc2VydC5kZWVwRXF1YWwocGsucGFydC5wLCB0aGlzLl9wLFxuXHRcdCAgICAnRFNBIGtleSBwcmltZSBkb2VzIG5vdCBtYXRjaCcpO1xuXHRcdGFzc2VydC5kZWVwRXF1YWwocGsucGFydC5nLCB0aGlzLl9nLFxuXHRcdCAgICAnRFNBIGtleSBnZW5lcmF0b3IgZG9lcyBub3QgbWF0Y2gnKTtcblx0fVxufTtcblxuRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuc2V0S2V5ID0gZnVuY3Rpb24gKHBrKSB7XG5cdHRoaXMuX2tleUNoZWNrKHBrKTtcblxuXHRpZiAocGsudHlwZSA9PT0gJ2RzYScpIHtcblx0XHR0aGlzLl9kaC5zZXRQcml2YXRlS2V5KHBrLnBhcnQueC5kYXRhKTtcblx0XHR0aGlzLl9kaC5zZXRQdWJsaWNLZXkocGsucGFydC55LmRhdGEpO1xuXG5cdH0gZWxzZSBpZiAocGsudHlwZSA9PT0gJ2VjZHNhJykge1xuXHRcdGlmIChDUllQVE9fSEFWRV9FQ0RIKSB7XG5cdFx0XHR0aGlzLl9kaC5zZXRQcml2YXRlS2V5KHBrLnBhcnQuZC5kYXRhKTtcblx0XHRcdHRoaXMuX2RoLnNldFB1YmxpY0tleShway5wYXJ0LlEuZGF0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3ByaXYgPSBuZXcgRUNQcml2YXRlKFxuXHRcdFx0ICAgIHRoaXMuX2VjUGFyYW1zLCBway5wYXJ0LmQuZGF0YSk7XG5cdFx0fVxuXG5cdH0gZWxzZSBpZiAocGsudHlwZSA9PT0gJ2N1cnZlMjU1MTknKSB7XG5cdFx0dmFyIGsgPSBway5wYXJ0Lms7XG5cdFx0aWYgKCFway5wYXJ0LmspXG5cdFx0XHRrID0gcGsucGFydC5yO1xuXHRcdHRoaXMuX3ByaXYgPSBrLmRhdGE7XG5cdFx0aWYgKHRoaXMuX3ByaXZbMF0gPT09IDB4MDApXG5cdFx0XHR0aGlzLl9wcml2ID0gdGhpcy5fcHJpdi5zbGljZSgxKTtcblx0XHR0aGlzLl9wcml2ID0gdGhpcy5fcHJpdi5zbGljZSgwLCAzMik7XG5cdH1cblx0dGhpcy5fa2V5ID0gcGs7XG5cdHRoaXMuX2lzUHJpdiA9IHRydWU7XG59O1xuRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuc2V0UHJpdmF0ZUtleSA9IERpZmZpZUhlbGxtYW4ucHJvdG90eXBlLnNldEtleTtcblxuRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuY29tcHV0ZVNlY3JldCA9IGZ1bmN0aW9uIChvdGhlcnBrKSB7XG5cdHRoaXMuX2tleUNoZWNrKG90aGVycGssIHRydWUpO1xuXHRpZiAoIXRoaXMuX2lzUHJpdilcblx0XHR0aHJvdyAobmV3IEVycm9yKCdESCBleGNoYW5nZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgd2l0aCAnICtcblx0XHQgICAgJ2EgcHJpdmF0ZSBrZXkgeWV0JykpO1xuXG5cdHZhciBwdWI7XG5cdGlmICh0aGlzLl9hbGdvID09PSAnZHNhJykge1xuXHRcdHJldHVybiAodGhpcy5fZGguY29tcHV0ZVNlY3JldChcblx0XHQgICAgb3RoZXJway5wYXJ0LnkuZGF0YSkpO1xuXG5cdH0gZWxzZSBpZiAodGhpcy5fYWxnbyA9PT0gJ2VjZHNhJykge1xuXHRcdGlmIChDUllQVE9fSEFWRV9FQ0RIKSB7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX2RoLmNvbXB1dGVTZWNyZXQoXG5cdFx0XHQgICAgb3RoZXJway5wYXJ0LlEuZGF0YSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwdWIgPSBuZXcgRUNQdWJsaWMoXG5cdFx0XHQgICAgdGhpcy5fZWNQYXJhbXMsIG90aGVycGsucGFydC5RLmRhdGEpO1xuXHRcdFx0cmV0dXJuICh0aGlzLl9wcml2LmRlcml2ZVNoYXJlZFNlY3JldChwdWIpKTtcblx0XHR9XG5cblx0fSBlbHNlIGlmICh0aGlzLl9hbGdvID09PSAnY3VydmUyNTUxOScpIHtcblx0XHRwdWIgPSBvdGhlcnBrLnBhcnQuQS5kYXRhO1xuXHRcdHdoaWxlIChwdWJbMF0gPT09IDB4MDAgJiYgcHViLmxlbmd0aCA+IDMyKVxuXHRcdFx0cHViID0gcHViLnNsaWNlKDEpO1xuXHRcdHZhciBwcml2ID0gdGhpcy5fcHJpdjtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwocHViLmxlbmd0aCwgMzIpO1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChwcml2Lmxlbmd0aCwgMzIpO1xuXG5cdFx0dmFyIHNlY3JldCA9IG5hY2wuYm94LmJlZm9yZShuZXcgVWludDhBcnJheShwdWIpLFxuXHRcdCAgICBuZXcgVWludDhBcnJheShwcml2KSk7XG5cblx0XHRyZXR1cm4gKEJ1ZmZlci5mcm9tKHNlY3JldCkpO1xuXHR9XG5cblx0dGhyb3cgKG5ldyBFcnJvcignSW52YWxpZCBhbGdvcml0aG06ICcgKyB0aGlzLl9hbGdvKSk7XG59O1xuXG5EaWZmaWVIZWxsbWFuLnByb3RvdHlwZS5nZW5lcmF0ZUtleSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHBhcnRzID0gW107XG5cdHZhciBwcml2LCBwdWI7XG5cdGlmICh0aGlzLl9hbGdvID09PSAnZHNhJykge1xuXHRcdHRoaXMuX2RoLmdlbmVyYXRlS2V5cygpO1xuXG5cdFx0cGFydHMucHVzaCh7bmFtZTogJ3AnLCBkYXRhOiB0aGlzLl9wLmRhdGF9KTtcblx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAncScsIGRhdGE6IHRoaXMuX2tleS5wYXJ0LnEuZGF0YX0pO1xuXHRcdHBhcnRzLnB1c2goe25hbWU6ICdnJywgZGF0YTogdGhpcy5fZy5kYXRhfSk7XG5cdFx0cGFydHMucHVzaCh7bmFtZTogJ3knLCBkYXRhOiB0aGlzLl9kaC5nZXRQdWJsaWNLZXkoKX0pO1xuXHRcdHBhcnRzLnB1c2goe25hbWU6ICd4JywgZGF0YTogdGhpcy5fZGguZ2V0UHJpdmF0ZUtleSgpfSk7XG5cdFx0dGhpcy5fa2V5ID0gbmV3IFByaXZhdGVLZXkoe1xuXHRcdFx0dHlwZTogJ2RzYScsXG5cdFx0XHRwYXJ0czogcGFydHNcblx0XHR9KTtcblx0XHR0aGlzLl9pc1ByaXYgPSB0cnVlO1xuXHRcdHJldHVybiAodGhpcy5fa2V5KTtcblxuXHR9IGVsc2UgaWYgKHRoaXMuX2FsZ28gPT09ICdlY2RzYScpIHtcblx0XHRpZiAoQ1JZUFRPX0hBVkVfRUNESCkge1xuXHRcdFx0dGhpcy5fZGguZ2VuZXJhdGVLZXlzKCk7XG5cblx0XHRcdHBhcnRzLnB1c2goe25hbWU6ICdjdXJ2ZScsXG5cdFx0XHQgICAgZGF0YTogQnVmZmVyLmZyb20odGhpcy5fY3VydmUpfSk7XG5cdFx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnUScsIGRhdGE6IHRoaXMuX2RoLmdldFB1YmxpY0tleSgpfSk7XG5cdFx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnZCcsIGRhdGE6IHRoaXMuX2RoLmdldFByaXZhdGVLZXkoKX0pO1xuXHRcdFx0dGhpcy5fa2V5ID0gbmV3IFByaXZhdGVLZXkoe1xuXHRcdFx0XHR0eXBlOiAnZWNkc2EnLFxuXHRcdFx0XHRjdXJ2ZTogdGhpcy5fY3VydmUsXG5cdFx0XHRcdHBhcnRzOiBwYXJ0c1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLl9pc1ByaXYgPSB0cnVlO1xuXHRcdFx0cmV0dXJuICh0aGlzLl9rZXkpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBuID0gdGhpcy5fZWNQYXJhbXMuZ2V0TigpO1xuXHRcdFx0dmFyIHIgPSBuZXcganNibihjcnlwdG8ucmFuZG9tQnl0ZXMobi5iaXRMZW5ndGgoKSkpO1xuXHRcdFx0dmFyIG4xID0gbi5zdWJ0cmFjdChqc2JuLk9ORSk7XG5cdFx0XHRwcml2ID0gci5tb2QobjEpLmFkZChqc2JuLk9ORSk7XG5cdFx0XHRwdWIgPSB0aGlzLl9lY1BhcmFtcy5nZXRHKCkubXVsdGlwbHkocHJpdik7XG5cblx0XHRcdHByaXYgPSBCdWZmZXIuZnJvbShwcml2LnRvQnl0ZUFycmF5KCkpO1xuXHRcdFx0cHViID0gQnVmZmVyLmZyb20odGhpcy5fZWNQYXJhbXMuZ2V0Q3VydmUoKS5cblx0XHRcdCAgICBlbmNvZGVQb2ludEhleChwdWIpLCAnaGV4Jyk7XG5cblx0XHRcdHRoaXMuX3ByaXYgPSBuZXcgRUNQcml2YXRlKHRoaXMuX2VjUGFyYW1zLCBwcml2KTtcblxuXHRcdFx0cGFydHMucHVzaCh7bmFtZTogJ2N1cnZlJyxcblx0XHRcdCAgICBkYXRhOiBCdWZmZXIuZnJvbSh0aGlzLl9jdXJ2ZSl9KTtcblx0XHRcdHBhcnRzLnB1c2goe25hbWU6ICdRJywgZGF0YTogcHVifSk7XG5cdFx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnZCcsIGRhdGE6IHByaXZ9KTtcblxuXHRcdFx0dGhpcy5fa2V5ID0gbmV3IFByaXZhdGVLZXkoe1xuXHRcdFx0XHR0eXBlOiAnZWNkc2EnLFxuXHRcdFx0XHRjdXJ2ZTogdGhpcy5fY3VydmUsXG5cdFx0XHRcdHBhcnRzOiBwYXJ0c1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLl9pc1ByaXYgPSB0cnVlO1xuXHRcdFx0cmV0dXJuICh0aGlzLl9rZXkpO1xuXHRcdH1cblxuXHR9IGVsc2UgaWYgKHRoaXMuX2FsZ28gPT09ICdjdXJ2ZTI1NTE5Jykge1xuXHRcdHZhciBwYWlyID0gbmFjbC5ib3gua2V5UGFpcigpO1xuXHRcdHByaXYgPSBCdWZmZXIuZnJvbShwYWlyLnNlY3JldEtleSk7XG5cdFx0cHViID0gQnVmZmVyLmZyb20ocGFpci5wdWJsaWNLZXkpO1xuXHRcdHByaXYgPSBCdWZmZXIuY29uY2F0KFtwcml2LCBwdWJdKTtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwocHJpdi5sZW5ndGgsIDY0KTtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwocHViLmxlbmd0aCwgMzIpO1xuXG5cdFx0cGFydHMucHVzaCh7bmFtZTogJ0EnLCBkYXRhOiBwdWJ9KTtcblx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnaycsIGRhdGE6IHByaXZ9KTtcblx0XHR0aGlzLl9rZXkgPSBuZXcgUHJpdmF0ZUtleSh7XG5cdFx0XHR0eXBlOiAnY3VydmUyNTUxOScsXG5cdFx0XHRwYXJ0czogcGFydHNcblx0XHR9KTtcblx0XHR0aGlzLl9pc1ByaXYgPSB0cnVlO1xuXHRcdHJldHVybiAodGhpcy5fa2V5KTtcblx0fVxuXG5cdHRocm93IChuZXcgRXJyb3IoJ0ludmFsaWQgYWxnb3JpdGhtOiAnICsgdGhpcy5fYWxnbykpO1xufTtcbkRpZmZpZUhlbGxtYW4ucHJvdG90eXBlLmdlbmVyYXRlS2V5cyA9IERpZmZpZUhlbGxtYW4ucHJvdG90eXBlLmdlbmVyYXRlS2V5O1xuXG4vKiBUaGVzZSBhcmUgaGVscGVycyBmb3IgdXNpbmcgZWNjLWpzYm4gKGZvciBub2RlIDAuMTAgY29tcGF0aWJpbGl0eSkuICovXG5cbmZ1bmN0aW9uIFg5RUNQYXJhbWV0ZXJzKG5hbWUpIHtcblx0dmFyIHBhcmFtcyA9IGFsZ3MuY3VydmVzW25hbWVdO1xuXHRhc3NlcnQub2JqZWN0KHBhcmFtcyk7XG5cblx0dmFyIHAgPSBuZXcganNibihwYXJhbXMucCk7XG5cdHZhciBhID0gbmV3IGpzYm4ocGFyYW1zLmEpO1xuXHR2YXIgYiA9IG5ldyBqc2JuKHBhcmFtcy5iKTtcblx0dmFyIG4gPSBuZXcganNibihwYXJhbXMubik7XG5cdHZhciBoID0ganNibi5PTkU7XG5cdHZhciBjdXJ2ZSA9IG5ldyBlYy5FQ0N1cnZlRnAocCwgYSwgYik7XG5cdHZhciBHID0gY3VydmUuZGVjb2RlUG9pbnRIZXgocGFyYW1zLkcudG9TdHJpbmcoJ2hleCcpKTtcblxuXHR0aGlzLmN1cnZlID0gY3VydmU7XG5cdHRoaXMuZyA9IEc7XG5cdHRoaXMubiA9IG47XG5cdHRoaXMuaCA9IGg7XG59XG5YOUVDUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0Q3VydmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJ2ZSk7IH07XG5YOUVDUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0RyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmcpOyB9O1xuWDlFQ1BhcmFtZXRlcnMucHJvdG90eXBlLmdldE4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5uKTsgfTtcblg5RUNQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRIID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuaCk7IH07XG5cbmZ1bmN0aW9uIEVDUHVibGljKHBhcmFtcywgYnVmZmVyKSB7XG5cdHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcblx0aWYgKGJ1ZmZlclswXSA9PT0gMHgwMClcblx0XHRidWZmZXIgPSBidWZmZXIuc2xpY2UoMSk7XG5cdHRoaXMuX3B1YiA9IHBhcmFtcy5nZXRDdXJ2ZSgpLmRlY29kZVBvaW50SGV4KGJ1ZmZlci50b1N0cmluZygnaGV4JykpO1xufVxuXG5mdW5jdGlvbiBFQ1ByaXZhdGUocGFyYW1zLCBidWZmZXIpIHtcblx0dGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuXHR0aGlzLl9wcml2ID0gbmV3IGpzYm4odXRpbHMubXBOb3JtYWxpemUoYnVmZmVyKSk7XG59XG5FQ1ByaXZhdGUucHJvdG90eXBlLmRlcml2ZVNoYXJlZFNlY3JldCA9IGZ1bmN0aW9uIChwdWJLZXkpIHtcblx0YXNzZXJ0Lm9rKHB1YktleSBpbnN0YW5jZW9mIEVDUHVibGljKTtcblx0dmFyIFMgPSBwdWJLZXkuX3B1Yi5tdWx0aXBseSh0aGlzLl9wcml2KTtcblx0cmV0dXJuIChCdWZmZXIuZnJvbShTLmdldFgoKS50b0JpZ0ludGVnZXIoKS50b0J5dGVBcnJheSgpKSk7XG59O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUVEMjU1MTkoKSB7XG5cdHZhciBwYWlyID0gbmFjbC5zaWduLmtleVBhaXIoKTtcblx0dmFyIHByaXYgPSBCdWZmZXIuZnJvbShwYWlyLnNlY3JldEtleSk7XG5cdHZhciBwdWIgPSBCdWZmZXIuZnJvbShwYWlyLnB1YmxpY0tleSk7XG5cdGFzc2VydC5zdHJpY3RFcXVhbChwcml2Lmxlbmd0aCwgNjQpO1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwocHViLmxlbmd0aCwgMzIpO1xuXG5cdHZhciBwYXJ0cyA9IFtdO1xuXHRwYXJ0cy5wdXNoKHtuYW1lOiAnQScsIGRhdGE6IHB1Yn0pO1xuXHRwYXJ0cy5wdXNoKHtuYW1lOiAnaycsIGRhdGE6IHByaXYuc2xpY2UoMCwgMzIpfSk7XG5cdHZhciBrZXkgPSBuZXcgUHJpdmF0ZUtleSh7XG5cdFx0dHlwZTogJ2VkMjU1MTknLFxuXHRcdHBhcnRzOiBwYXJ0c1xuXHR9KTtcblx0cmV0dXJuIChrZXkpO1xufVxuXG4vKiBHZW5lcmF0ZXMgYSBuZXcgRUNEU0EgcHJpdmF0ZSBrZXkgb24gYSBnaXZlbiBjdXJ2ZS4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlRUNEU0EoY3VydmUpIHtcblx0dmFyIHBhcnRzID0gW107XG5cdHZhciBrZXk7XG5cblx0aWYgKENSWVBUT19IQVZFX0VDREgpIHtcblx0XHQvKlxuXHRcdCAqIE5vZGUgY3J5cHRvIGRvZXNuJ3QgZXhwb3NlIGtleSBnZW5lcmF0aW9uIGRpcmVjdGx5LCBidXQgdGhlXG5cdFx0ICogRUNESCBpbnN0YW5jZXMgY2FuIGdlbmVyYXRlIGtleXMuIEl0IHR1cm5zIG91dCB0aGlzIGp1c3Rcblx0XHQgKiBjYWxscyBpbnRvIHRoZSBPcGVuU1NMIGdlbmVyaWMga2V5IGdlbmVyYXRvciwgYW5kIHdlIGNhblxuXHRcdCAqIHJlYWQgaXRzIG91dHB1dCBoYXBwaWx5IHdpdGhvdXQgZG9pbmcgYW4gYWN0dWFsIERILiBTbyB3ZVxuXHRcdCAqIHVzZSB0aGF0IGhlcmUuXG5cdFx0ICovXG5cdFx0dmFyIG9zQ3VydmUgPSB7XG5cdFx0XHQnbmlzdHAyNTYnOiAncHJpbWUyNTZ2MScsXG5cdFx0XHQnbmlzdHAzODQnOiAnc2VjcDM4NHIxJyxcblx0XHRcdCduaXN0cDUyMSc6ICdzZWNwNTIxcjEnXG5cdFx0fVtjdXJ2ZV07XG5cblx0XHR2YXIgZGggPSBjcnlwdG8uY3JlYXRlRUNESChvc0N1cnZlKTtcblx0XHRkaC5nZW5lcmF0ZUtleXMoKTtcblxuXHRcdHBhcnRzLnB1c2goe25hbWU6ICdjdXJ2ZScsXG5cdFx0ICAgIGRhdGE6IEJ1ZmZlci5mcm9tKGN1cnZlKX0pO1xuXHRcdHBhcnRzLnB1c2goe25hbWU6ICdRJywgZGF0YTogZGguZ2V0UHVibGljS2V5KCl9KTtcblx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnZCcsIGRhdGE6IGRoLmdldFByaXZhdGVLZXkoKX0pO1xuXG5cdFx0a2V5ID0gbmV3IFByaXZhdGVLZXkoe1xuXHRcdFx0dHlwZTogJ2VjZHNhJyxcblx0XHRcdGN1cnZlOiBjdXJ2ZSxcblx0XHRcdHBhcnRzOiBwYXJ0c1xuXHRcdH0pO1xuXHRcdHJldHVybiAoa2V5KTtcblx0fSBlbHNlIHtcblxuXHRcdHZhciBlY1BhcmFtcyA9IG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSk7XG5cblx0XHQvKiBUaGlzIGFsZ29yaXRobSB0YWtlbiBmcm9tIEZJUFMgUFVCIDE4Ni00IChzZWN0aW9uIEIuNC4xKSAqL1xuXHRcdHZhciBuID0gZWNQYXJhbXMuZ2V0TigpO1xuXHRcdC8qXG5cdFx0ICogVGhlIGNyeXB0by5yYW5kb21CeXRlcygpIGZ1bmN0aW9uIGNhbiBvbmx5IGdpdmUgdXMgd2hvbGVcblx0XHQgKiBieXRlcywgc28gdGFraW5nIGEgbm9kIGZyb20gWDkuNjIsIHdlIHJvdW5kIHVwLlxuXHRcdCAqL1xuXHRcdHZhciBjQnl0ZUxlbiA9IE1hdGguY2VpbCgobi5iaXRMZW5ndGgoKSArIDY0KSAvIDgpO1xuXHRcdHZhciBjID0gbmV3IGpzYm4oY3J5cHRvLnJhbmRvbUJ5dGVzKGNCeXRlTGVuKSk7XG5cblx0XHR2YXIgbjEgPSBuLnN1YnRyYWN0KGpzYm4uT05FKTtcblx0XHR2YXIgcHJpdiA9IGMubW9kKG4xKS5hZGQoanNibi5PTkUpO1xuXHRcdHZhciBwdWIgPSBlY1BhcmFtcy5nZXRHKCkubXVsdGlwbHkocHJpdik7XG5cblx0XHRwcml2ID0gQnVmZmVyLmZyb20ocHJpdi50b0J5dGVBcnJheSgpKTtcblx0XHRwdWIgPSBCdWZmZXIuZnJvbShlY1BhcmFtcy5nZXRDdXJ2ZSgpLlxuXHRcdCAgICBlbmNvZGVQb2ludEhleChwdWIpLCAnaGV4Jyk7XG5cblx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnY3VydmUnLCBkYXRhOiBCdWZmZXIuZnJvbShjdXJ2ZSl9KTtcblx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnUScsIGRhdGE6IHB1Yn0pO1xuXHRcdHBhcnRzLnB1c2goe25hbWU6ICdkJywgZGF0YTogcHJpdn0pO1xuXG5cdFx0a2V5ID0gbmV3IFByaXZhdGVLZXkoe1xuXHRcdFx0dHlwZTogJ2VjZHNhJyxcblx0XHRcdGN1cnZlOiBjdXJ2ZSxcblx0XHRcdHBhcnRzOiBwYXJ0c1xuXHRcdH0pO1xuXHRcdHJldHVybiAoa2V5KTtcblx0fVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/dhe.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/ed-compat.js":
/*!*********************************************!*\
  !*** ./node_modules/sshpk/lib/ed-compat.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tVerifier: Verifier,\n\tSigner: Signer\n};\n\nvar nacl = __webpack_require__(/*! tweetnacl */ \"(action-browser)/./node_modules/tweetnacl/nacl-fast.js\");\nvar stream = __webpack_require__(/*! stream */ \"stream\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar Signature = __webpack_require__(/*! ./signature */ \"(action-browser)/./node_modules/sshpk/lib/signature.js\");\n\nfunction Verifier(key, hashAlgo) {\n\tif (hashAlgo.toLowerCase() !== 'sha512')\n\t\tthrow (new Error('ED25519 only supports the use of ' +\n\t\t    'SHA-512 hashes'));\n\n\tthis.key = key;\n\tthis.chunks = [];\n\n\tstream.Writable.call(this, {});\n}\nutil.inherits(Verifier, stream.Writable);\n\nVerifier.prototype._write = function (chunk, enc, cb) {\n\tthis.chunks.push(chunk);\n\tcb();\n};\n\nVerifier.prototype.update = function (chunk) {\n\tif (typeof (chunk) === 'string')\n\t\tchunk = Buffer.from(chunk, 'binary');\n\tthis.chunks.push(chunk);\n};\n\nVerifier.prototype.verify = function (signature, fmt) {\n\tvar sig;\n\tif (Signature.isSignature(signature, [2, 0])) {\n\t\tif (signature.type !== 'ed25519')\n\t\t\treturn (false);\n\t\tsig = signature.toBuffer('raw');\n\n\t} else if (typeof (signature) === 'string') {\n\t\tsig = Buffer.from(signature, 'base64');\n\n\t} else if (Signature.isSignature(signature, [1, 0])) {\n\t\tthrow (new Error('signature was created by too old ' +\n\t\t    'a version of sshpk and cannot be verified'));\n\t}\n\n\tassert.buffer(sig);\n\treturn (nacl.sign.detached.verify(\n\t    new Uint8Array(Buffer.concat(this.chunks)),\n\t    new Uint8Array(sig),\n\t    new Uint8Array(this.key.part.A.data)));\n};\n\nfunction Signer(key, hashAlgo) {\n\tif (hashAlgo.toLowerCase() !== 'sha512')\n\t\tthrow (new Error('ED25519 only supports the use of ' +\n\t\t    'SHA-512 hashes'));\n\n\tthis.key = key;\n\tthis.chunks = [];\n\n\tstream.Writable.call(this, {});\n}\nutil.inherits(Signer, stream.Writable);\n\nSigner.prototype._write = function (chunk, enc, cb) {\n\tthis.chunks.push(chunk);\n\tcb();\n};\n\nSigner.prototype.update = function (chunk) {\n\tif (typeof (chunk) === 'string')\n\t\tchunk = Buffer.from(chunk, 'binary');\n\tthis.chunks.push(chunk);\n};\n\nSigner.prototype.sign = function () {\n\tvar sig = nacl.sign.detached(\n\t    new Uint8Array(Buffer.concat(this.chunks)),\n\t    new Uint8Array(Buffer.concat([\n\t\tthis.key.part.k.data, this.key.part.A.data])));\n\tvar sigBuf = Buffer.from(sig);\n\tvar sigObj = Signature.parse(sigBuf, 'ed25519', 'raw');\n\tsigObj.hashAlgorithm = 'sha512';\n\treturn (sigObj);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZWQtY29tcGF0LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyx5RUFBVztBQUM5QixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQywwRUFBYTtBQUNsQyxhQUFhLHlHQUE4QjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBYTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZWQtY29tcGF0LmpzP2I5MjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRWZXJpZmllcjogVmVyaWZpZXIsXG5cdFNpZ25lcjogU2lnbmVyXG59O1xuXG52YXIgbmFjbCA9IHJlcXVpcmUoJ3R3ZWV0bmFjbCcpO1xudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcblxuZnVuY3Rpb24gVmVyaWZpZXIoa2V5LCBoYXNoQWxnbykge1xuXHRpZiAoaGFzaEFsZ28udG9Mb3dlckNhc2UoKSAhPT0gJ3NoYTUxMicpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignRUQyNTUxOSBvbmx5IHN1cHBvcnRzIHRoZSB1c2Ugb2YgJyArXG5cdFx0ICAgICdTSEEtNTEyIGhhc2hlcycpKTtcblxuXHR0aGlzLmtleSA9IGtleTtcblx0dGhpcy5jaHVua3MgPSBbXTtcblxuXHRzdHJlYW0uV3JpdGFibGUuY2FsbCh0aGlzLCB7fSk7XG59XG51dGlsLmluaGVyaXRzKFZlcmlmaWVyLCBzdHJlYW0uV3JpdGFibGUpO1xuXG5WZXJpZmllci5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmMsIGNiKSB7XG5cdHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuXHRjYigpO1xufTtcblxuVmVyaWZpZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuXHRpZiAodHlwZW9mIChjaHVuaykgPT09ICdzdHJpbmcnKVxuXHRcdGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssICdiaW5hcnknKTtcblx0dGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5WZXJpZmllci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gKHNpZ25hdHVyZSwgZm10KSB7XG5cdHZhciBzaWc7XG5cdGlmIChTaWduYXR1cmUuaXNTaWduYXR1cmUoc2lnbmF0dXJlLCBbMiwgMF0pKSB7XG5cdFx0aWYgKHNpZ25hdHVyZS50eXBlICE9PSAnZWQyNTUxOScpXG5cdFx0XHRyZXR1cm4gKGZhbHNlKTtcblx0XHRzaWcgPSBzaWduYXR1cmUudG9CdWZmZXIoJ3JhdycpO1xuXG5cdH0gZWxzZSBpZiAodHlwZW9mIChzaWduYXR1cmUpID09PSAnc3RyaW5nJykge1xuXHRcdHNpZyA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSwgJ2Jhc2U2NCcpO1xuXG5cdH0gZWxzZSBpZiAoU2lnbmF0dXJlLmlzU2lnbmF0dXJlKHNpZ25hdHVyZSwgWzEsIDBdKSkge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ3NpZ25hdHVyZSB3YXMgY3JlYXRlZCBieSB0b28gb2xkICcgK1xuXHRcdCAgICAnYSB2ZXJzaW9uIG9mIHNzaHBrIGFuZCBjYW5ub3QgYmUgdmVyaWZpZWQnKSk7XG5cdH1cblxuXHRhc3NlcnQuYnVmZmVyKHNpZyk7XG5cdHJldHVybiAobmFjbC5zaWduLmRldGFjaGVkLnZlcmlmeShcblx0ICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQodGhpcy5jaHVua3MpKSxcblx0ICAgIG5ldyBVaW50OEFycmF5KHNpZyksXG5cdCAgICBuZXcgVWludDhBcnJheSh0aGlzLmtleS5wYXJ0LkEuZGF0YSkpKTtcbn07XG5cbmZ1bmN0aW9uIFNpZ25lcihrZXksIGhhc2hBbGdvKSB7XG5cdGlmIChoYXNoQWxnby50b0xvd2VyQ2FzZSgpICE9PSAnc2hhNTEyJylcblx0XHR0aHJvdyAobmV3IEVycm9yKCdFRDI1NTE5IG9ubHkgc3VwcG9ydHMgdGhlIHVzZSBvZiAnICtcblx0XHQgICAgJ1NIQS01MTIgaGFzaGVzJykpO1xuXG5cdHRoaXMua2V5ID0ga2V5O1xuXHR0aGlzLmNodW5rcyA9IFtdO1xuXG5cdHN0cmVhbS5Xcml0YWJsZS5jYWxsKHRoaXMsIHt9KTtcbn1cbnV0aWwuaW5oZXJpdHMoU2lnbmVyLCBzdHJlYW0uV3JpdGFibGUpO1xuXG5TaWduZXIucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jLCBjYikge1xuXHR0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcblx0Y2IoKTtcbn07XG5cblNpZ25lci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cdGlmICh0eXBlb2YgKGNodW5rKSA9PT0gJ3N0cmluZycpXG5cdFx0Y2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgJ2JpbmFyeScpO1xuXHR0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblNpZ25lci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNpZyA9IG5hY2wuc2lnbi5kZXRhY2hlZChcblx0ICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQodGhpcy5jaHVua3MpKSxcblx0ICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQoW1xuXHRcdHRoaXMua2V5LnBhcnQuay5kYXRhLCB0aGlzLmtleS5wYXJ0LkEuZGF0YV0pKSk7XG5cdHZhciBzaWdCdWYgPSBCdWZmZXIuZnJvbShzaWcpO1xuXHR2YXIgc2lnT2JqID0gU2lnbmF0dXJlLnBhcnNlKHNpZ0J1ZiwgJ2VkMjU1MTknLCAncmF3Jyk7XG5cdHNpZ09iai5oYXNoQWxnb3JpdGhtID0gJ3NoYTUxMic7XG5cdHJldHVybiAoc2lnT2JqKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/ed-compat.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/ed-compat.js":
/*!*********************************************!*\
  !*** ./node_modules/sshpk/lib/ed-compat.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tVerifier: Verifier,\n\tSigner: Signer\n};\n\nvar nacl = __webpack_require__(/*! tweetnacl */ \"(rsc)/./node_modules/tweetnacl/nacl-fast.js\");\nvar stream = __webpack_require__(/*! stream */ \"stream\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar Signature = __webpack_require__(/*! ./signature */ \"(rsc)/./node_modules/sshpk/lib/signature.js\");\n\nfunction Verifier(key, hashAlgo) {\n\tif (hashAlgo.toLowerCase() !== 'sha512')\n\t\tthrow (new Error('ED25519 only supports the use of ' +\n\t\t    'SHA-512 hashes'));\n\n\tthis.key = key;\n\tthis.chunks = [];\n\n\tstream.Writable.call(this, {});\n}\nutil.inherits(Verifier, stream.Writable);\n\nVerifier.prototype._write = function (chunk, enc, cb) {\n\tthis.chunks.push(chunk);\n\tcb();\n};\n\nVerifier.prototype.update = function (chunk) {\n\tif (typeof (chunk) === 'string')\n\t\tchunk = Buffer.from(chunk, 'binary');\n\tthis.chunks.push(chunk);\n};\n\nVerifier.prototype.verify = function (signature, fmt) {\n\tvar sig;\n\tif (Signature.isSignature(signature, [2, 0])) {\n\t\tif (signature.type !== 'ed25519')\n\t\t\treturn (false);\n\t\tsig = signature.toBuffer('raw');\n\n\t} else if (typeof (signature) === 'string') {\n\t\tsig = Buffer.from(signature, 'base64');\n\n\t} else if (Signature.isSignature(signature, [1, 0])) {\n\t\tthrow (new Error('signature was created by too old ' +\n\t\t    'a version of sshpk and cannot be verified'));\n\t}\n\n\tassert.buffer(sig);\n\treturn (nacl.sign.detached.verify(\n\t    new Uint8Array(Buffer.concat(this.chunks)),\n\t    new Uint8Array(sig),\n\t    new Uint8Array(this.key.part.A.data)));\n};\n\nfunction Signer(key, hashAlgo) {\n\tif (hashAlgo.toLowerCase() !== 'sha512')\n\t\tthrow (new Error('ED25519 only supports the use of ' +\n\t\t    'SHA-512 hashes'));\n\n\tthis.key = key;\n\tthis.chunks = [];\n\n\tstream.Writable.call(this, {});\n}\nutil.inherits(Signer, stream.Writable);\n\nSigner.prototype._write = function (chunk, enc, cb) {\n\tthis.chunks.push(chunk);\n\tcb();\n};\n\nSigner.prototype.update = function (chunk) {\n\tif (typeof (chunk) === 'string')\n\t\tchunk = Buffer.from(chunk, 'binary');\n\tthis.chunks.push(chunk);\n};\n\nSigner.prototype.sign = function () {\n\tvar sig = nacl.sign.detached(\n\t    new Uint8Array(Buffer.concat(this.chunks)),\n\t    new Uint8Array(Buffer.concat([\n\t\tthis.key.part.k.data, this.key.part.A.data])));\n\tvar sigBuf = Buffer.from(sig);\n\tvar sigObj = Signature.parse(sigBuf, 'ed25519', 'raw');\n\tsigObj.hashAlgorithm = 'sha512';\n\treturn (sigObj);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2VkLWNvbXBhdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsOERBQVc7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixhQUFhLG1CQUFPLENBQUMsK0RBQWE7QUFDbEMsYUFBYSw4RkFBOEI7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsZ0VBQWE7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2VkLWNvbXBhdC5qcz9hZDUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0VmVyaWZpZXI6IFZlcmlmaWVyLFxuXHRTaWduZXI6IFNpZ25lclxufTtcblxudmFyIG5hY2wgPSByZXF1aXJlKCd0d2VldG5hY2wnKTtcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG5cbmZ1bmN0aW9uIFZlcmlmaWVyKGtleSwgaGFzaEFsZ28pIHtcblx0aWYgKGhhc2hBbGdvLnRvTG93ZXJDYXNlKCkgIT09ICdzaGE1MTInKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0VEMjU1MTkgb25seSBzdXBwb3J0cyB0aGUgdXNlIG9mICcgK1xuXHRcdCAgICAnU0hBLTUxMiBoYXNoZXMnKSk7XG5cblx0dGhpcy5rZXkgPSBrZXk7XG5cdHRoaXMuY2h1bmtzID0gW107XG5cblx0c3RyZWFtLldyaXRhYmxlLmNhbGwodGhpcywge30pO1xufVxudXRpbC5pbmhlcml0cyhWZXJpZmllciwgc3RyZWFtLldyaXRhYmxlKTtcblxuVmVyaWZpZXIucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jLCBjYikge1xuXHR0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcblx0Y2IoKTtcbn07XG5cblZlcmlmaWVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcblx0aWYgKHR5cGVvZiAoY2h1bmspID09PSAnc3RyaW5nJylcblx0XHRjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCAnYmluYXJ5Jyk7XG5cdHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuVmVyaWZpZXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIChzaWduYXR1cmUsIGZtdCkge1xuXHR2YXIgc2lnO1xuXHRpZiAoU2lnbmF0dXJlLmlzU2lnbmF0dXJlKHNpZ25hdHVyZSwgWzIsIDBdKSkge1xuXHRcdGlmIChzaWduYXR1cmUudHlwZSAhPT0gJ2VkMjU1MTknKVxuXHRcdFx0cmV0dXJuIChmYWxzZSk7XG5cdFx0c2lnID0gc2lnbmF0dXJlLnRvQnVmZmVyKCdyYXcnKTtcblxuXHR9IGVsc2UgaWYgKHR5cGVvZiAoc2lnbmF0dXJlKSA9PT0gJ3N0cmluZycpIHtcblx0XHRzaWcgPSBCdWZmZXIuZnJvbShzaWduYXR1cmUsICdiYXNlNjQnKTtcblxuXHR9IGVsc2UgaWYgKFNpZ25hdHVyZS5pc1NpZ25hdHVyZShzaWduYXR1cmUsIFsxLCAwXSkpIHtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdzaWduYXR1cmUgd2FzIGNyZWF0ZWQgYnkgdG9vIG9sZCAnICtcblx0XHQgICAgJ2EgdmVyc2lvbiBvZiBzc2hwayBhbmQgY2Fubm90IGJlIHZlcmlmaWVkJykpO1xuXHR9XG5cblx0YXNzZXJ0LmJ1ZmZlcihzaWcpO1xuXHRyZXR1cm4gKG5hY2wuc2lnbi5kZXRhY2hlZC52ZXJpZnkoXG5cdCAgICBuZXcgVWludDhBcnJheShCdWZmZXIuY29uY2F0KHRoaXMuY2h1bmtzKSksXG5cdCAgICBuZXcgVWludDhBcnJheShzaWcpLFxuXHQgICAgbmV3IFVpbnQ4QXJyYXkodGhpcy5rZXkucGFydC5BLmRhdGEpKSk7XG59O1xuXG5mdW5jdGlvbiBTaWduZXIoa2V5LCBoYXNoQWxnbykge1xuXHRpZiAoaGFzaEFsZ28udG9Mb3dlckNhc2UoKSAhPT0gJ3NoYTUxMicpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignRUQyNTUxOSBvbmx5IHN1cHBvcnRzIHRoZSB1c2Ugb2YgJyArXG5cdFx0ICAgICdTSEEtNTEyIGhhc2hlcycpKTtcblxuXHR0aGlzLmtleSA9IGtleTtcblx0dGhpcy5jaHVua3MgPSBbXTtcblxuXHRzdHJlYW0uV3JpdGFibGUuY2FsbCh0aGlzLCB7fSk7XG59XG51dGlsLmluaGVyaXRzKFNpZ25lciwgc3RyZWFtLldyaXRhYmxlKTtcblxuU2lnbmVyLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuYywgY2IpIHtcblx0dGhpcy5jaHVua3MucHVzaChjaHVuayk7XG5cdGNiKCk7XG59O1xuXG5TaWduZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuXHRpZiAodHlwZW9mIChjaHVuaykgPT09ICdzdHJpbmcnKVxuXHRcdGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssICdiaW5hcnknKTtcblx0dGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5TaWduZXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzaWcgPSBuYWNsLnNpZ24uZGV0YWNoZWQoXG5cdCAgICBuZXcgVWludDhBcnJheShCdWZmZXIuY29uY2F0KHRoaXMuY2h1bmtzKSksXG5cdCAgICBuZXcgVWludDhBcnJheShCdWZmZXIuY29uY2F0KFtcblx0XHR0aGlzLmtleS5wYXJ0LmsuZGF0YSwgdGhpcy5rZXkucGFydC5BLmRhdGFdKSkpO1xuXHR2YXIgc2lnQnVmID0gQnVmZmVyLmZyb20oc2lnKTtcblx0dmFyIHNpZ09iaiA9IFNpZ25hdHVyZS5wYXJzZShzaWdCdWYsICdlZDI1NTE5JywgJ3JhdycpO1xuXHRzaWdPYmouaGFzaEFsZ29yaXRobSA9ICdzaGE1MTInO1xuXHRyZXR1cm4gKHNpZ09iaik7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/ed-compat.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/errors.js":
/*!******************************************!*\
  !*** ./node_modules/sshpk/lib/errors.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\nfunction FingerprintFormatError(fp, format) {\n\tif (Error.captureStackTrace)\n\t\tError.captureStackTrace(this, FingerprintFormatError);\n\tthis.name = 'FingerprintFormatError';\n\tthis.fingerprint = fp;\n\tthis.format = format;\n\tthis.message = 'Fingerprint format is not supported, or is invalid: ';\n\tif (fp !== undefined)\n\t\tthis.message += ' fingerprint = ' + fp;\n\tif (format !== undefined)\n\t\tthis.message += ' format = ' + format;\n}\nutil.inherits(FingerprintFormatError, Error);\n\nfunction InvalidAlgorithmError(alg) {\n\tif (Error.captureStackTrace)\n\t\tError.captureStackTrace(this, InvalidAlgorithmError);\n\tthis.name = 'InvalidAlgorithmError';\n\tthis.algorithm = alg;\n\tthis.message = 'Algorithm \"' + alg + '\" is not supported';\n}\nutil.inherits(InvalidAlgorithmError, Error);\n\nfunction KeyParseError(name, format, innerErr) {\n\tif (Error.captureStackTrace)\n\t\tError.captureStackTrace(this, KeyParseError);\n\tthis.name = 'KeyParseError';\n\tthis.format = format;\n\tthis.keyName = name;\n\tthis.innerErr = innerErr;\n\tthis.message = 'Failed to parse ' + name + ' as a valid ' + format +\n\t    ' format key: ' + innerErr.message;\n}\nutil.inherits(KeyParseError, Error);\n\nfunction SignatureParseError(type, format, innerErr) {\n\tif (Error.captureStackTrace)\n\t\tError.captureStackTrace(this, SignatureParseError);\n\tthis.name = 'SignatureParseError';\n\tthis.type = type;\n\tthis.format = format;\n\tthis.innerErr = innerErr;\n\tthis.message = 'Failed to parse the given data as a ' + type +\n\t    ' signature in ' + format + ' format: ' + innerErr.message;\n}\nutil.inherits(SignatureParseError, Error);\n\nfunction CertificateParseError(name, format, innerErr) {\n\tif (Error.captureStackTrace)\n\t\tError.captureStackTrace(this, CertificateParseError);\n\tthis.name = 'CertificateParseError';\n\tthis.format = format;\n\tthis.certName = name;\n\tthis.innerErr = innerErr;\n\tthis.message = 'Failed to parse ' + name + ' as a valid ' + format +\n\t    ' format certificate: ' + innerErr.message;\n}\nutil.inherits(CertificateParseError, Error);\n\nfunction KeyEncryptedError(name, format) {\n\tif (Error.captureStackTrace)\n\t\tError.captureStackTrace(this, KeyEncryptedError);\n\tthis.name = 'KeyEncryptedError';\n\tthis.format = format;\n\tthis.keyName = name;\n\tthis.message = 'The ' + format + ' format key ' + name + ' is ' +\n\t    'encrypted (password-protected), and no passphrase was ' +\n\t    'provided in `options`';\n}\nutil.inherits(KeyEncryptedError, Error);\n\nmodule.exports = {\n\tFingerprintFormatError: FingerprintFormatError,\n\tInvalidAlgorithmError: InvalidAlgorithmError,\n\tKeyParseError: KeyParseError,\n\tSignatureParseError: SignatureParseError,\n\tKeyEncryptedError: KeyEncryptedError,\n\tCertificateParseError: CertificateParseError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywwRUFBYTtBQUNsQyxXQUFXLG1CQUFPLENBQUMsa0JBQU07O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZXJyb3JzLmpzPzU0ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIEZpbmdlcnByaW50Rm9ybWF0RXJyb3IoZnAsIGZvcm1hdCkge1xuXHRpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG5cdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRmluZ2VycHJpbnRGb3JtYXRFcnJvcik7XG5cdHRoaXMubmFtZSA9ICdGaW5nZXJwcmludEZvcm1hdEVycm9yJztcblx0dGhpcy5maW5nZXJwcmludCA9IGZwO1xuXHR0aGlzLmZvcm1hdCA9IGZvcm1hdDtcblx0dGhpcy5tZXNzYWdlID0gJ0ZpbmdlcnByaW50IGZvcm1hdCBpcyBub3Qgc3VwcG9ydGVkLCBvciBpcyBpbnZhbGlkOiAnO1xuXHRpZiAoZnAgIT09IHVuZGVmaW5lZClcblx0XHR0aGlzLm1lc3NhZ2UgKz0gJyBmaW5nZXJwcmludCA9ICcgKyBmcDtcblx0aWYgKGZvcm1hdCAhPT0gdW5kZWZpbmVkKVxuXHRcdHRoaXMubWVzc2FnZSArPSAnIGZvcm1hdCA9ICcgKyBmb3JtYXQ7XG59XG51dGlsLmluaGVyaXRzKEZpbmdlcnByaW50Rm9ybWF0RXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gSW52YWxpZEFsZ29yaXRobUVycm9yKGFsZykge1xuXHRpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG5cdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW52YWxpZEFsZ29yaXRobUVycm9yKTtcblx0dGhpcy5uYW1lID0gJ0ludmFsaWRBbGdvcml0aG1FcnJvcic7XG5cdHRoaXMuYWxnb3JpdGhtID0gYWxnO1xuXHR0aGlzLm1lc3NhZ2UgPSAnQWxnb3JpdGhtIFwiJyArIGFsZyArICdcIiBpcyBub3Qgc3VwcG9ydGVkJztcbn1cbnV0aWwuaW5oZXJpdHMoSW52YWxpZEFsZ29yaXRobUVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIEtleVBhcnNlRXJyb3IobmFtZSwgZm9ybWF0LCBpbm5lckVycikge1xuXHRpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG5cdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgS2V5UGFyc2VFcnJvcik7XG5cdHRoaXMubmFtZSA9ICdLZXlQYXJzZUVycm9yJztcblx0dGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG5cdHRoaXMua2V5TmFtZSA9IG5hbWU7XG5cdHRoaXMuaW5uZXJFcnIgPSBpbm5lckVycjtcblx0dGhpcy5tZXNzYWdlID0gJ0ZhaWxlZCB0byBwYXJzZSAnICsgbmFtZSArICcgYXMgYSB2YWxpZCAnICsgZm9ybWF0ICtcblx0ICAgICcgZm9ybWF0IGtleTogJyArIGlubmVyRXJyLm1lc3NhZ2U7XG59XG51dGlsLmluaGVyaXRzKEtleVBhcnNlRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gU2lnbmF0dXJlUGFyc2VFcnJvcih0eXBlLCBmb3JtYXQsIGlubmVyRXJyKSB7XG5cdGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcblx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBTaWduYXR1cmVQYXJzZUVycm9yKTtcblx0dGhpcy5uYW1lID0gJ1NpZ25hdHVyZVBhcnNlRXJyb3InO1xuXHR0aGlzLnR5cGUgPSB0eXBlO1xuXHR0aGlzLmZvcm1hdCA9IGZvcm1hdDtcblx0dGhpcy5pbm5lckVyciA9IGlubmVyRXJyO1xuXHR0aGlzLm1lc3NhZ2UgPSAnRmFpbGVkIHRvIHBhcnNlIHRoZSBnaXZlbiBkYXRhIGFzIGEgJyArIHR5cGUgK1xuXHQgICAgJyBzaWduYXR1cmUgaW4gJyArIGZvcm1hdCArICcgZm9ybWF0OiAnICsgaW5uZXJFcnIubWVzc2FnZTtcbn1cbnV0aWwuaW5oZXJpdHMoU2lnbmF0dXJlUGFyc2VFcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiBDZXJ0aWZpY2F0ZVBhcnNlRXJyb3IobmFtZSwgZm9ybWF0LCBpbm5lckVycikge1xuXHRpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG5cdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ2VydGlmaWNhdGVQYXJzZUVycm9yKTtcblx0dGhpcy5uYW1lID0gJ0NlcnRpZmljYXRlUGFyc2VFcnJvcic7XG5cdHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuXHR0aGlzLmNlcnROYW1lID0gbmFtZTtcblx0dGhpcy5pbm5lckVyciA9IGlubmVyRXJyO1xuXHR0aGlzLm1lc3NhZ2UgPSAnRmFpbGVkIHRvIHBhcnNlICcgKyBuYW1lICsgJyBhcyBhIHZhbGlkICcgKyBmb3JtYXQgK1xuXHQgICAgJyBmb3JtYXQgY2VydGlmaWNhdGU6ICcgKyBpbm5lckVyci5tZXNzYWdlO1xufVxudXRpbC5pbmhlcml0cyhDZXJ0aWZpY2F0ZVBhcnNlRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gS2V5RW5jcnlwdGVkRXJyb3IobmFtZSwgZm9ybWF0KSB7XG5cdGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcblx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBLZXlFbmNyeXB0ZWRFcnJvcik7XG5cdHRoaXMubmFtZSA9ICdLZXlFbmNyeXB0ZWRFcnJvcic7XG5cdHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuXHR0aGlzLmtleU5hbWUgPSBuYW1lO1xuXHR0aGlzLm1lc3NhZ2UgPSAnVGhlICcgKyBmb3JtYXQgKyAnIGZvcm1hdCBrZXkgJyArIG5hbWUgKyAnIGlzICcgK1xuXHQgICAgJ2VuY3J5cHRlZCAocGFzc3dvcmQtcHJvdGVjdGVkKSwgYW5kIG5vIHBhc3NwaHJhc2Ugd2FzICcgK1xuXHQgICAgJ3Byb3ZpZGVkIGluIGBvcHRpb25zYCc7XG59XG51dGlsLmluaGVyaXRzKEtleUVuY3J5cHRlZEVycm9yLCBFcnJvcik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRGaW5nZXJwcmludEZvcm1hdEVycm9yOiBGaW5nZXJwcmludEZvcm1hdEVycm9yLFxuXHRJbnZhbGlkQWxnb3JpdGhtRXJyb3I6IEludmFsaWRBbGdvcml0aG1FcnJvcixcblx0S2V5UGFyc2VFcnJvcjogS2V5UGFyc2VFcnJvcixcblx0U2lnbmF0dXJlUGFyc2VFcnJvcjogU2lnbmF0dXJlUGFyc2VFcnJvcixcblx0S2V5RW5jcnlwdGVkRXJyb3I6IEtleUVuY3J5cHRlZEVycm9yLFxuXHRDZXJ0aWZpY2F0ZVBhcnNlRXJyb3I6IENlcnRpZmljYXRlUGFyc2VFcnJvclxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/errors.js":
/*!******************************************!*\
  !*** ./node_modules/sshpk/lib/errors.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\nfunction FingerprintFormatError(fp, format) {\n\tif (Error.captureStackTrace)\n\t\tError.captureStackTrace(this, FingerprintFormatError);\n\tthis.name = 'FingerprintFormatError';\n\tthis.fingerprint = fp;\n\tthis.format = format;\n\tthis.message = 'Fingerprint format is not supported, or is invalid: ';\n\tif (fp !== undefined)\n\t\tthis.message += ' fingerprint = ' + fp;\n\tif (format !== undefined)\n\t\tthis.message += ' format = ' + format;\n}\nutil.inherits(FingerprintFormatError, Error);\n\nfunction InvalidAlgorithmError(alg) {\n\tif (Error.captureStackTrace)\n\t\tError.captureStackTrace(this, InvalidAlgorithmError);\n\tthis.name = 'InvalidAlgorithmError';\n\tthis.algorithm = alg;\n\tthis.message = 'Algorithm \"' + alg + '\" is not supported';\n}\nutil.inherits(InvalidAlgorithmError, Error);\n\nfunction KeyParseError(name, format, innerErr) {\n\tif (Error.captureStackTrace)\n\t\tError.captureStackTrace(this, KeyParseError);\n\tthis.name = 'KeyParseError';\n\tthis.format = format;\n\tthis.keyName = name;\n\tthis.innerErr = innerErr;\n\tthis.message = 'Failed to parse ' + name + ' as a valid ' + format +\n\t    ' format key: ' + innerErr.message;\n}\nutil.inherits(KeyParseError, Error);\n\nfunction SignatureParseError(type, format, innerErr) {\n\tif (Error.captureStackTrace)\n\t\tError.captureStackTrace(this, SignatureParseError);\n\tthis.name = 'SignatureParseError';\n\tthis.type = type;\n\tthis.format = format;\n\tthis.innerErr = innerErr;\n\tthis.message = 'Failed to parse the given data as a ' + type +\n\t    ' signature in ' + format + ' format: ' + innerErr.message;\n}\nutil.inherits(SignatureParseError, Error);\n\nfunction CertificateParseError(name, format, innerErr) {\n\tif (Error.captureStackTrace)\n\t\tError.captureStackTrace(this, CertificateParseError);\n\tthis.name = 'CertificateParseError';\n\tthis.format = format;\n\tthis.certName = name;\n\tthis.innerErr = innerErr;\n\tthis.message = 'Failed to parse ' + name + ' as a valid ' + format +\n\t    ' format certificate: ' + innerErr.message;\n}\nutil.inherits(CertificateParseError, Error);\n\nfunction KeyEncryptedError(name, format) {\n\tif (Error.captureStackTrace)\n\t\tError.captureStackTrace(this, KeyEncryptedError);\n\tthis.name = 'KeyEncryptedError';\n\tthis.format = format;\n\tthis.keyName = name;\n\tthis.message = 'The ' + format + ' format key ' + name + ' is ' +\n\t    'encrypted (password-protected), and no passphrase was ' +\n\t    'provided in `options`';\n}\nutil.inherits(KeyEncryptedError, Error);\n\nmodule.exports = {\n\tFingerprintFormatError: FingerprintFormatError,\n\tInvalidAlgorithmError: InvalidAlgorithmError,\n\tKeyParseError: KeyParseError,\n\tSignatureParseError: SignatureParseError,\n\tKeyEncryptedError: KeyEncryptedError,\n\tCertificateParseError: CertificateParseError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsK0RBQWE7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLGtCQUFNOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Vycm9ycy5qcz9jNDFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1IEpveWVudCwgSW5jLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBGaW5nZXJwcmludEZvcm1hdEVycm9yKGZwLCBmb3JtYXQpIHtcblx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEZpbmdlcnByaW50Rm9ybWF0RXJyb3IpO1xuXHR0aGlzLm5hbWUgPSAnRmluZ2VycHJpbnRGb3JtYXRFcnJvcic7XG5cdHRoaXMuZmluZ2VycHJpbnQgPSBmcDtcblx0dGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG5cdHRoaXMubWVzc2FnZSA9ICdGaW5nZXJwcmludCBmb3JtYXQgaXMgbm90IHN1cHBvcnRlZCwgb3IgaXMgaW52YWxpZDogJztcblx0aWYgKGZwICE9PSB1bmRlZmluZWQpXG5cdFx0dGhpcy5tZXNzYWdlICs9ICcgZmluZ2VycHJpbnQgPSAnICsgZnA7XG5cdGlmIChmb3JtYXQgIT09IHVuZGVmaW5lZClcblx0XHR0aGlzLm1lc3NhZ2UgKz0gJyBmb3JtYXQgPSAnICsgZm9ybWF0O1xufVxudXRpbC5pbmhlcml0cyhGaW5nZXJwcmludEZvcm1hdEVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIEludmFsaWRBbGdvcml0aG1FcnJvcihhbGcpIHtcblx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEludmFsaWRBbGdvcml0aG1FcnJvcik7XG5cdHRoaXMubmFtZSA9ICdJbnZhbGlkQWxnb3JpdGhtRXJyb3InO1xuXHR0aGlzLmFsZ29yaXRobSA9IGFsZztcblx0dGhpcy5tZXNzYWdlID0gJ0FsZ29yaXRobSBcIicgKyBhbGcgKyAnXCIgaXMgbm90IHN1cHBvcnRlZCc7XG59XG51dGlsLmluaGVyaXRzKEludmFsaWRBbGdvcml0aG1FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiBLZXlQYXJzZUVycm9yKG5hbWUsIGZvcm1hdCwgaW5uZXJFcnIpIHtcblx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEtleVBhcnNlRXJyb3IpO1xuXHR0aGlzLm5hbWUgPSAnS2V5UGFyc2VFcnJvcic7XG5cdHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuXHR0aGlzLmtleU5hbWUgPSBuYW1lO1xuXHR0aGlzLmlubmVyRXJyID0gaW5uZXJFcnI7XG5cdHRoaXMubWVzc2FnZSA9ICdGYWlsZWQgdG8gcGFyc2UgJyArIG5hbWUgKyAnIGFzIGEgdmFsaWQgJyArIGZvcm1hdCArXG5cdCAgICAnIGZvcm1hdCBrZXk6ICcgKyBpbm5lckVyci5tZXNzYWdlO1xufVxudXRpbC5pbmhlcml0cyhLZXlQYXJzZUVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIFNpZ25hdHVyZVBhcnNlRXJyb3IodHlwZSwgZm9ybWF0LCBpbm5lckVycikge1xuXHRpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG5cdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgU2lnbmF0dXJlUGFyc2VFcnJvcik7XG5cdHRoaXMubmFtZSA9ICdTaWduYXR1cmVQYXJzZUVycm9yJztcblx0dGhpcy50eXBlID0gdHlwZTtcblx0dGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG5cdHRoaXMuaW5uZXJFcnIgPSBpbm5lckVycjtcblx0dGhpcy5tZXNzYWdlID0gJ0ZhaWxlZCB0byBwYXJzZSB0aGUgZ2l2ZW4gZGF0YSBhcyBhICcgKyB0eXBlICtcblx0ICAgICcgc2lnbmF0dXJlIGluICcgKyBmb3JtYXQgKyAnIGZvcm1hdDogJyArIGlubmVyRXJyLm1lc3NhZ2U7XG59XG51dGlsLmluaGVyaXRzKFNpZ25hdHVyZVBhcnNlRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gQ2VydGlmaWNhdGVQYXJzZUVycm9yKG5hbWUsIGZvcm1hdCwgaW5uZXJFcnIpIHtcblx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENlcnRpZmljYXRlUGFyc2VFcnJvcik7XG5cdHRoaXMubmFtZSA9ICdDZXJ0aWZpY2F0ZVBhcnNlRXJyb3InO1xuXHR0aGlzLmZvcm1hdCA9IGZvcm1hdDtcblx0dGhpcy5jZXJ0TmFtZSA9IG5hbWU7XG5cdHRoaXMuaW5uZXJFcnIgPSBpbm5lckVycjtcblx0dGhpcy5tZXNzYWdlID0gJ0ZhaWxlZCB0byBwYXJzZSAnICsgbmFtZSArICcgYXMgYSB2YWxpZCAnICsgZm9ybWF0ICtcblx0ICAgICcgZm9ybWF0IGNlcnRpZmljYXRlOiAnICsgaW5uZXJFcnIubWVzc2FnZTtcbn1cbnV0aWwuaW5oZXJpdHMoQ2VydGlmaWNhdGVQYXJzZUVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIEtleUVuY3J5cHRlZEVycm9yKG5hbWUsIGZvcm1hdCkge1xuXHRpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG5cdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgS2V5RW5jcnlwdGVkRXJyb3IpO1xuXHR0aGlzLm5hbWUgPSAnS2V5RW5jcnlwdGVkRXJyb3InO1xuXHR0aGlzLmZvcm1hdCA9IGZvcm1hdDtcblx0dGhpcy5rZXlOYW1lID0gbmFtZTtcblx0dGhpcy5tZXNzYWdlID0gJ1RoZSAnICsgZm9ybWF0ICsgJyBmb3JtYXQga2V5ICcgKyBuYW1lICsgJyBpcyAnICtcblx0ICAgICdlbmNyeXB0ZWQgKHBhc3N3b3JkLXByb3RlY3RlZCksIGFuZCBubyBwYXNzcGhyYXNlIHdhcyAnICtcblx0ICAgICdwcm92aWRlZCBpbiBgb3B0aW9uc2AnO1xufVxudXRpbC5pbmhlcml0cyhLZXlFbmNyeXB0ZWRFcnJvciwgRXJyb3IpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0RmluZ2VycHJpbnRGb3JtYXRFcnJvcjogRmluZ2VycHJpbnRGb3JtYXRFcnJvcixcblx0SW52YWxpZEFsZ29yaXRobUVycm9yOiBJbnZhbGlkQWxnb3JpdGhtRXJyb3IsXG5cdEtleVBhcnNlRXJyb3I6IEtleVBhcnNlRXJyb3IsXG5cdFNpZ25hdHVyZVBhcnNlRXJyb3I6IFNpZ25hdHVyZVBhcnNlRXJyb3IsXG5cdEtleUVuY3J5cHRlZEVycm9yOiBLZXlFbmNyeXB0ZWRFcnJvcixcblx0Q2VydGlmaWNhdGVQYXJzZUVycm9yOiBDZXJ0aWZpY2F0ZVBhcnNlRXJyb3Jcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/errors.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/fingerprint.js":
/*!***********************************************!*\
  !*** ./node_modules/sshpk/lib/fingerprint.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2018 Joyent, Inc.\n\nmodule.exports = Fingerprint;\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ./algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar errs = __webpack_require__(/*! ./errors */ \"(action-browser)/./node_modules/sshpk/lib/errors.js\");\nvar Key = __webpack_require__(/*! ./key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ./private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\nvar Certificate = __webpack_require__(/*! ./certificate */ \"(action-browser)/./node_modules/sshpk/lib/certificate.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\n\nvar FingerprintFormatError = errs.FingerprintFormatError;\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\n\nfunction Fingerprint(opts) {\n\tassert.object(opts, 'options');\n\tassert.string(opts.type, 'options.type');\n\tassert.buffer(opts.hash, 'options.hash');\n\tassert.string(opts.algorithm, 'options.algorithm');\n\n\tthis.algorithm = opts.algorithm.toLowerCase();\n\tif (algs.hashAlgs[this.algorithm] !== true)\n\t\tthrow (new InvalidAlgorithmError(this.algorithm));\n\n\tthis.hash = opts.hash;\n\tthis.type = opts.type;\n\tthis.hashType = opts.hashType;\n}\n\nFingerprint.prototype.toString = function (format) {\n\tif (format === undefined) {\n\t\tif (this.algorithm === 'md5' || this.hashType === 'spki')\n\t\t\tformat = 'hex';\n\t\telse\n\t\t\tformat = 'base64';\n\t}\n\tassert.string(format);\n\n\tswitch (format) {\n\tcase 'hex':\n\t\tif (this.hashType === 'spki')\n\t\t\treturn (this.hash.toString('hex'));\n\t\treturn (addColons(this.hash.toString('hex')));\n\tcase 'base64':\n\t\tif (this.hashType === 'spki')\n\t\t\treturn (this.hash.toString('base64'));\n\t\treturn (sshBase64Format(this.algorithm,\n\t\t    this.hash.toString('base64')));\n\tdefault:\n\t\tthrow (new FingerprintFormatError(undefined, format));\n\t}\n};\n\nFingerprint.prototype.matches = function (other) {\n\tassert.object(other, 'key or certificate');\n\tif (this.type === 'key' && this.hashType !== 'ssh') {\n\t\tutils.assertCompatible(other, Key, [1, 7], 'key with spki');\n\t\tif (PrivateKey.isPrivateKey(other)) {\n\t\t\tutils.assertCompatible(other, PrivateKey, [1, 6],\n\t\t\t    'privatekey with spki support');\n\t\t}\n\t} else if (this.type === 'key') {\n\t\tutils.assertCompatible(other, Key, [1, 0], 'key');\n\t} else {\n\t\tutils.assertCompatible(other, Certificate, [1, 0],\n\t\t    'certificate');\n\t}\n\n\tvar theirHash = other.hash(this.algorithm, this.hashType);\n\tvar theirHash2 = crypto.createHash(this.algorithm).\n\t    update(theirHash).digest('base64');\n\n\tif (this.hash2 === undefined)\n\t\tthis.hash2 = crypto.createHash(this.algorithm).\n\t\t    update(this.hash).digest('base64');\n\n\treturn (this.hash2 === theirHash2);\n};\n\n/*JSSTYLED*/\nvar base64RE = /^[A-Za-z0-9+\\/=]+$/;\n/*JSSTYLED*/\nvar hexRE = /^[a-fA-F0-9]+$/;\n\nFingerprint.parse = function (fp, options) {\n\tassert.string(fp, 'fingerprint');\n\n\tvar alg, hash, enAlgs;\n\tif (Array.isArray(options)) {\n\t\tenAlgs = options;\n\t\toptions = {};\n\t}\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tif (options.enAlgs !== undefined)\n\t\tenAlgs = options.enAlgs;\n\tif (options.algorithms !== undefined)\n\t\tenAlgs = options.algorithms;\n\tassert.optionalArrayOfString(enAlgs, 'algorithms');\n\n\tvar hashType = 'ssh';\n\tif (options.hashType !== undefined)\n\t\thashType = options.hashType;\n\tassert.string(hashType, 'options.hashType');\n\n\tvar parts = fp.split(':');\n\tif (parts.length == 2) {\n\t\talg = parts[0].toLowerCase();\n\t\tif (!base64RE.test(parts[1]))\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\ttry {\n\t\t\thash = Buffer.from(parts[1], 'base64');\n\t\t} catch (e) {\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t}\n\t} else if (parts.length > 2) {\n\t\talg = 'md5';\n\t\tif (parts[0].toLowerCase() === 'md5')\n\t\t\tparts = parts.slice(1);\n\t\tparts = parts.map(function (p) {\n\t\t\twhile (p.length < 2)\n\t\t\t\tp = '0' + p;\n\t\t\tif (p.length > 2)\n\t\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t\treturn (p);\n\t\t});\n\t\tparts = parts.join('');\n\t\tif (!hexRE.test(parts) || parts.length % 2 !== 0)\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\ttry {\n\t\t\thash = Buffer.from(parts, 'hex');\n\t\t} catch (e) {\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t}\n\t} else {\n\t\tif (hexRE.test(fp)) {\n\t\t\thash = Buffer.from(fp, 'hex');\n\t\t} else if (base64RE.test(fp)) {\n\t\t\thash = Buffer.from(fp, 'base64');\n\t\t} else {\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t}\n\n\t\tswitch (hash.length) {\n\t\tcase 32:\n\t\t\talg = 'sha256';\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\talg = 'md5';\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\talg = 'sha1';\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\talg = 'sha512';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t}\n\n\t\t/* Plain hex/base64: guess it's probably SPKI unless told. */\n\t\tif (options.hashType === undefined)\n\t\t\thashType = 'spki';\n\t}\n\n\tif (alg === undefined)\n\t\tthrow (new FingerprintFormatError(fp));\n\n\tif (algs.hashAlgs[alg] === undefined)\n\t\tthrow (new InvalidAlgorithmError(alg));\n\n\tif (enAlgs !== undefined) {\n\t\tenAlgs = enAlgs.map(function (a) { return a.toLowerCase(); });\n\t\tif (enAlgs.indexOf(alg) === -1)\n\t\t\tthrow (new InvalidAlgorithmError(alg));\n\t}\n\n\treturn (new Fingerprint({\n\t\talgorithm: alg,\n\t\thash: hash,\n\t\ttype: options.type || 'key',\n\t\thashType: hashType\n\t}));\n};\n\nfunction addColons(s) {\n\t/*JSSTYLED*/\n\treturn (s.replace(/(.{2})(?=.)/g, '$1:'));\n}\n\nfunction base64Strip(s) {\n\t/*JSSTYLED*/\n\treturn (s.replace(/=*$/, ''));\n}\n\nfunction sshBase64Format(alg, h) {\n\treturn (alg.toUpperCase() + ':' + base64Strip(h));\n}\n\nFingerprint.isFingerprint = function (obj, ver) {\n\treturn (utils.isCompatible(obj, Fingerprint, ver));\n};\n\n/*\n * API versions for Fingerprint:\n * [1,0] -- initial ver\n * [1,1] -- first tagged ver\n * [1,2] -- hashType and spki support\n */\nFingerprint.prototype._sshpkApiVersion = [1, 2];\n\nFingerprint._oldVersionDetect = function (obj) {\n\tassert.func(obj.toString);\n\tassert.func(obj.matches);\n\treturn ([1, 0]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZmluZ2VycHJpbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDBFQUFhO0FBQ2xDLGFBQWEseUdBQThCO0FBQzNDLFdBQVcsbUJBQU8sQ0FBQyxpRUFBUTtBQUMzQixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLHFFQUFVO0FBQzdCLFVBQVUsbUJBQU8sQ0FBQywrREFBTztBQUN6QixpQkFBaUIsbUJBQU8sQ0FBQywrRUFBZTtBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBZTtBQUN6QyxZQUFZLG1CQUFPLENBQUMsbUVBQVM7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLHlCQUF5QjtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLEVBQUU7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZmluZ2VycHJpbnQuanM/YTQ1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOCBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSBGaW5nZXJwcmludDtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuL2FsZ3MnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBlcnJzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbnZhciBLZXkgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuL3ByaXZhdGUta2V5Jyk7XG52YXIgQ2VydGlmaWNhdGUgPSByZXF1aXJlKCcuL2NlcnRpZmljYXRlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBGaW5nZXJwcmludEZvcm1hdEVycm9yID0gZXJycy5GaW5nZXJwcmludEZvcm1hdEVycm9yO1xudmFyIEludmFsaWRBbGdvcml0aG1FcnJvciA9IGVycnMuSW52YWxpZEFsZ29yaXRobUVycm9yO1xuXG5mdW5jdGlvbiBGaW5nZXJwcmludChvcHRzKSB7XG5cdGFzc2VydC5vYmplY3Qob3B0cywgJ29wdGlvbnMnKTtcblx0YXNzZXJ0LnN0cmluZyhvcHRzLnR5cGUsICdvcHRpb25zLnR5cGUnKTtcblx0YXNzZXJ0LmJ1ZmZlcihvcHRzLmhhc2gsICdvcHRpb25zLmhhc2gnKTtcblx0YXNzZXJ0LnN0cmluZyhvcHRzLmFsZ29yaXRobSwgJ29wdGlvbnMuYWxnb3JpdGhtJyk7XG5cblx0dGhpcy5hbGdvcml0aG0gPSBvcHRzLmFsZ29yaXRobS50b0xvd2VyQ2FzZSgpO1xuXHRpZiAoYWxncy5oYXNoQWxnc1t0aGlzLmFsZ29yaXRobV0gIT09IHRydWUpXG5cdFx0dGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3IodGhpcy5hbGdvcml0aG0pKTtcblxuXHR0aGlzLmhhc2ggPSBvcHRzLmhhc2g7XG5cdHRoaXMudHlwZSA9IG9wdHMudHlwZTtcblx0dGhpcy5oYXNoVHlwZSA9IG9wdHMuaGFzaFR5cGU7XG59XG5cbkZpbmdlcnByaW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcblx0aWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKHRoaXMuYWxnb3JpdGhtID09PSAnbWQ1JyB8fCB0aGlzLmhhc2hUeXBlID09PSAnc3BraScpXG5cdFx0XHRmb3JtYXQgPSAnaGV4Jztcblx0XHRlbHNlXG5cdFx0XHRmb3JtYXQgPSAnYmFzZTY0Jztcblx0fVxuXHRhc3NlcnQuc3RyaW5nKGZvcm1hdCk7XG5cblx0c3dpdGNoIChmb3JtYXQpIHtcblx0Y2FzZSAnaGV4Jzpcblx0XHRpZiAodGhpcy5oYXNoVHlwZSA9PT0gJ3Nwa2knKVxuXHRcdFx0cmV0dXJuICh0aGlzLmhhc2gudG9TdHJpbmcoJ2hleCcpKTtcblx0XHRyZXR1cm4gKGFkZENvbG9ucyh0aGlzLmhhc2gudG9TdHJpbmcoJ2hleCcpKSk7XG5cdGNhc2UgJ2Jhc2U2NCc6XG5cdFx0aWYgKHRoaXMuaGFzaFR5cGUgPT09ICdzcGtpJylcblx0XHRcdHJldHVybiAodGhpcy5oYXNoLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG5cdFx0cmV0dXJuIChzc2hCYXNlNjRGb3JtYXQodGhpcy5hbGdvcml0aG0sXG5cdFx0ICAgIHRoaXMuaGFzaC50b1N0cmluZygnYmFzZTY0JykpKTtcblx0ZGVmYXVsdDpcblx0XHR0aHJvdyAobmV3IEZpbmdlcnByaW50Rm9ybWF0RXJyb3IodW5kZWZpbmVkLCBmb3JtYXQpKTtcblx0fVxufTtcblxuRmluZ2VycHJpbnQucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0YXNzZXJ0Lm9iamVjdChvdGhlciwgJ2tleSBvciBjZXJ0aWZpY2F0ZScpO1xuXHRpZiAodGhpcy50eXBlID09PSAna2V5JyAmJiB0aGlzLmhhc2hUeXBlICE9PSAnc3NoJykge1xuXHRcdHV0aWxzLmFzc2VydENvbXBhdGlibGUob3RoZXIsIEtleSwgWzEsIDddLCAna2V5IHdpdGggc3BraScpO1xuXHRcdGlmIChQcml2YXRlS2V5LmlzUHJpdmF0ZUtleShvdGhlcikpIHtcblx0XHRcdHV0aWxzLmFzc2VydENvbXBhdGlibGUob3RoZXIsIFByaXZhdGVLZXksIFsxLCA2XSxcblx0XHRcdCAgICAncHJpdmF0ZWtleSB3aXRoIHNwa2kgc3VwcG9ydCcpO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdrZXknKSB7XG5cdFx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShvdGhlciwgS2V5LCBbMSwgMF0sICdrZXknKTtcblx0fSBlbHNlIHtcblx0XHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKG90aGVyLCBDZXJ0aWZpY2F0ZSwgWzEsIDBdLFxuXHRcdCAgICAnY2VydGlmaWNhdGUnKTtcblx0fVxuXG5cdHZhciB0aGVpckhhc2ggPSBvdGhlci5oYXNoKHRoaXMuYWxnb3JpdGhtLCB0aGlzLmhhc2hUeXBlKTtcblx0dmFyIHRoZWlySGFzaDIgPSBjcnlwdG8uY3JlYXRlSGFzaCh0aGlzLmFsZ29yaXRobSkuXG5cdCAgICB1cGRhdGUodGhlaXJIYXNoKS5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG5cdGlmICh0aGlzLmhhc2gyID09PSB1bmRlZmluZWQpXG5cdFx0dGhpcy5oYXNoMiA9IGNyeXB0by5jcmVhdGVIYXNoKHRoaXMuYWxnb3JpdGhtKS5cblx0XHQgICAgdXBkYXRlKHRoaXMuaGFzaCkuZGlnZXN0KCdiYXNlNjQnKTtcblxuXHRyZXR1cm4gKHRoaXMuaGFzaDIgPT09IHRoZWlySGFzaDIpO1xufTtcblxuLypKU1NUWUxFRCovXG52YXIgYmFzZTY0UkUgPSAvXltBLVphLXowLTkrXFwvPV0rJC87XG4vKkpTU1RZTEVEKi9cbnZhciBoZXhSRSA9IC9eW2EtZkEtRjAtOV0rJC87XG5cbkZpbmdlcnByaW50LnBhcnNlID0gZnVuY3Rpb24gKGZwLCBvcHRpb25zKSB7XG5cdGFzc2VydC5zdHJpbmcoZnAsICdmaW5nZXJwcmludCcpO1xuXG5cdHZhciBhbGcsIGhhc2gsIGVuQWxncztcblx0aWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcblx0XHRlbkFsZ3MgPSBvcHRpb25zO1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0fVxuXHRhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcblx0aWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZClcblx0XHRvcHRpb25zID0ge307XG5cdGlmIChvcHRpb25zLmVuQWxncyAhPT0gdW5kZWZpbmVkKVxuXHRcdGVuQWxncyA9IG9wdGlvbnMuZW5BbGdzO1xuXHRpZiAob3B0aW9ucy5hbGdvcml0aG1zICE9PSB1bmRlZmluZWQpXG5cdFx0ZW5BbGdzID0gb3B0aW9ucy5hbGdvcml0aG1zO1xuXHRhc3NlcnQub3B0aW9uYWxBcnJheU9mU3RyaW5nKGVuQWxncywgJ2FsZ29yaXRobXMnKTtcblxuXHR2YXIgaGFzaFR5cGUgPSAnc3NoJztcblx0aWYgKG9wdGlvbnMuaGFzaFR5cGUgIT09IHVuZGVmaW5lZClcblx0XHRoYXNoVHlwZSA9IG9wdGlvbnMuaGFzaFR5cGU7XG5cdGFzc2VydC5zdHJpbmcoaGFzaFR5cGUsICdvcHRpb25zLmhhc2hUeXBlJyk7XG5cblx0dmFyIHBhcnRzID0gZnAuc3BsaXQoJzonKTtcblx0aWYgKHBhcnRzLmxlbmd0aCA9PSAyKSB7XG5cdFx0YWxnID0gcGFydHNbMF0udG9Mb3dlckNhc2UoKTtcblx0XHRpZiAoIWJhc2U2NFJFLnRlc3QocGFydHNbMV0pKVxuXHRcdFx0dGhyb3cgKG5ldyBGaW5nZXJwcmludEZvcm1hdEVycm9yKGZwKSk7XG5cdFx0dHJ5IHtcblx0XHRcdGhhc2ggPSBCdWZmZXIuZnJvbShwYXJ0c1sxXSwgJ2Jhc2U2NCcpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHRocm93IChuZXcgRmluZ2VycHJpbnRGb3JtYXRFcnJvcihmcCkpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPiAyKSB7XG5cdFx0YWxnID0gJ21kNSc7XG5cdFx0aWYgKHBhcnRzWzBdLnRvTG93ZXJDYXNlKCkgPT09ICdtZDUnKVxuXHRcdFx0cGFydHMgPSBwYXJ0cy5zbGljZSgxKTtcblx0XHRwYXJ0cyA9IHBhcnRzLm1hcChmdW5jdGlvbiAocCkge1xuXHRcdFx0d2hpbGUgKHAubGVuZ3RoIDwgMilcblx0XHRcdFx0cCA9ICcwJyArIHA7XG5cdFx0XHRpZiAocC5sZW5ndGggPiAyKVxuXHRcdFx0XHR0aHJvdyAobmV3IEZpbmdlcnByaW50Rm9ybWF0RXJyb3IoZnApKTtcblx0XHRcdHJldHVybiAocCk7XG5cdFx0fSk7XG5cdFx0cGFydHMgPSBwYXJ0cy5qb2luKCcnKTtcblx0XHRpZiAoIWhleFJFLnRlc3QocGFydHMpIHx8IHBhcnRzLmxlbmd0aCAlIDIgIT09IDApXG5cdFx0XHR0aHJvdyAobmV3IEZpbmdlcnByaW50Rm9ybWF0RXJyb3IoZnApKTtcblx0XHR0cnkge1xuXHRcdFx0aGFzaCA9IEJ1ZmZlci5mcm9tKHBhcnRzLCAnaGV4Jyk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0dGhyb3cgKG5ldyBGaW5nZXJwcmludEZvcm1hdEVycm9yKGZwKSk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmIChoZXhSRS50ZXN0KGZwKSkge1xuXHRcdFx0aGFzaCA9IEJ1ZmZlci5mcm9tKGZwLCAnaGV4Jyk7XG5cdFx0fSBlbHNlIGlmIChiYXNlNjRSRS50ZXN0KGZwKSkge1xuXHRcdFx0aGFzaCA9IEJ1ZmZlci5mcm9tKGZwLCAnYmFzZTY0Jyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IChuZXcgRmluZ2VycHJpbnRGb3JtYXRFcnJvcihmcCkpO1xuXHRcdH1cblxuXHRcdHN3aXRjaCAoaGFzaC5sZW5ndGgpIHtcblx0XHRjYXNlIDMyOlxuXHRcdFx0YWxnID0gJ3NoYTI1Nic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDE2OlxuXHRcdFx0YWxnID0gJ21kNSc7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDIwOlxuXHRcdFx0YWxnID0gJ3NoYTEnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSA2NDpcblx0XHRcdGFsZyA9ICdzaGE1MTInO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IChuZXcgRmluZ2VycHJpbnRGb3JtYXRFcnJvcihmcCkpO1xuXHRcdH1cblxuXHRcdC8qIFBsYWluIGhleC9iYXNlNjQ6IGd1ZXNzIGl0J3MgcHJvYmFibHkgU1BLSSB1bmxlc3MgdG9sZC4gKi9cblx0XHRpZiAob3B0aW9ucy5oYXNoVHlwZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0aGFzaFR5cGUgPSAnc3BraSc7XG5cdH1cblxuXHRpZiAoYWxnID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBGaW5nZXJwcmludEZvcm1hdEVycm9yKGZwKSk7XG5cblx0aWYgKGFsZ3MuaGFzaEFsZ3NbYWxnXSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKGFsZykpO1xuXG5cdGlmIChlbkFsZ3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdGVuQWxncyA9IGVuQWxncy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEudG9Mb3dlckNhc2UoKTsgfSk7XG5cdFx0aWYgKGVuQWxncy5pbmRleE9mKGFsZykgPT09IC0xKVxuXHRcdFx0dGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3IoYWxnKSk7XG5cdH1cblxuXHRyZXR1cm4gKG5ldyBGaW5nZXJwcmludCh7XG5cdFx0YWxnb3JpdGhtOiBhbGcsXG5cdFx0aGFzaDogaGFzaCxcblx0XHR0eXBlOiBvcHRpb25zLnR5cGUgfHwgJ2tleScsXG5cdFx0aGFzaFR5cGU6IGhhc2hUeXBlXG5cdH0pKTtcbn07XG5cbmZ1bmN0aW9uIGFkZENvbG9ucyhzKSB7XG5cdC8qSlNTVFlMRUQqL1xuXHRyZXR1cm4gKHMucmVwbGFjZSgvKC57Mn0pKD89LikvZywgJyQxOicpKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0U3RyaXAocykge1xuXHQvKkpTU1RZTEVEKi9cblx0cmV0dXJuIChzLnJlcGxhY2UoLz0qJC8sICcnKSk7XG59XG5cbmZ1bmN0aW9uIHNzaEJhc2U2NEZvcm1hdChhbGcsIGgpIHtcblx0cmV0dXJuIChhbGcudG9VcHBlckNhc2UoKSArICc6JyArIGJhc2U2NFN0cmlwKGgpKTtcbn1cblxuRmluZ2VycHJpbnQuaXNGaW5nZXJwcmludCA9IGZ1bmN0aW9uIChvYmosIHZlcikge1xuXHRyZXR1cm4gKHV0aWxzLmlzQ29tcGF0aWJsZShvYmosIEZpbmdlcnByaW50LCB2ZXIpKTtcbn07XG5cbi8qXG4gKiBBUEkgdmVyc2lvbnMgZm9yIEZpbmdlcnByaW50OlxuICogWzEsMF0gLS0gaW5pdGlhbCB2ZXJcbiAqIFsxLDFdIC0tIGZpcnN0IHRhZ2dlZCB2ZXJcbiAqIFsxLDJdIC0tIGhhc2hUeXBlIGFuZCBzcGtpIHN1cHBvcnRcbiAqL1xuRmluZ2VycHJpbnQucHJvdG90eXBlLl9zc2hwa0FwaVZlcnNpb24gPSBbMSwgMl07XG5cbkZpbmdlcnByaW50Ll9vbGRWZXJzaW9uRGV0ZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuXHRhc3NlcnQuZnVuYyhvYmoudG9TdHJpbmcpO1xuXHRhc3NlcnQuZnVuYyhvYmoubWF0Y2hlcyk7XG5cdHJldHVybiAoWzEsIDBdKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/fingerprint.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/fingerprint.js":
/*!***********************************************!*\
  !*** ./node_modules/sshpk/lib/fingerprint.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2018 Joyent, Inc.\n\nmodule.exports = Fingerprint;\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ./algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar errs = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/sshpk/lib/errors.js\");\nvar Key = __webpack_require__(/*! ./key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ./private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\nvar Certificate = __webpack_require__(/*! ./certificate */ \"(rsc)/./node_modules/sshpk/lib/certificate.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\n\nvar FingerprintFormatError = errs.FingerprintFormatError;\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\n\nfunction Fingerprint(opts) {\n\tassert.object(opts, 'options');\n\tassert.string(opts.type, 'options.type');\n\tassert.buffer(opts.hash, 'options.hash');\n\tassert.string(opts.algorithm, 'options.algorithm');\n\n\tthis.algorithm = opts.algorithm.toLowerCase();\n\tif (algs.hashAlgs[this.algorithm] !== true)\n\t\tthrow (new InvalidAlgorithmError(this.algorithm));\n\n\tthis.hash = opts.hash;\n\tthis.type = opts.type;\n\tthis.hashType = opts.hashType;\n}\n\nFingerprint.prototype.toString = function (format) {\n\tif (format === undefined) {\n\t\tif (this.algorithm === 'md5' || this.hashType === 'spki')\n\t\t\tformat = 'hex';\n\t\telse\n\t\t\tformat = 'base64';\n\t}\n\tassert.string(format);\n\n\tswitch (format) {\n\tcase 'hex':\n\t\tif (this.hashType === 'spki')\n\t\t\treturn (this.hash.toString('hex'));\n\t\treturn (addColons(this.hash.toString('hex')));\n\tcase 'base64':\n\t\tif (this.hashType === 'spki')\n\t\t\treturn (this.hash.toString('base64'));\n\t\treturn (sshBase64Format(this.algorithm,\n\t\t    this.hash.toString('base64')));\n\tdefault:\n\t\tthrow (new FingerprintFormatError(undefined, format));\n\t}\n};\n\nFingerprint.prototype.matches = function (other) {\n\tassert.object(other, 'key or certificate');\n\tif (this.type === 'key' && this.hashType !== 'ssh') {\n\t\tutils.assertCompatible(other, Key, [1, 7], 'key with spki');\n\t\tif (PrivateKey.isPrivateKey(other)) {\n\t\t\tutils.assertCompatible(other, PrivateKey, [1, 6],\n\t\t\t    'privatekey with spki support');\n\t\t}\n\t} else if (this.type === 'key') {\n\t\tutils.assertCompatible(other, Key, [1, 0], 'key');\n\t} else {\n\t\tutils.assertCompatible(other, Certificate, [1, 0],\n\t\t    'certificate');\n\t}\n\n\tvar theirHash = other.hash(this.algorithm, this.hashType);\n\tvar theirHash2 = crypto.createHash(this.algorithm).\n\t    update(theirHash).digest('base64');\n\n\tif (this.hash2 === undefined)\n\t\tthis.hash2 = crypto.createHash(this.algorithm).\n\t\t    update(this.hash).digest('base64');\n\n\treturn (this.hash2 === theirHash2);\n};\n\n/*JSSTYLED*/\nvar base64RE = /^[A-Za-z0-9+\\/=]+$/;\n/*JSSTYLED*/\nvar hexRE = /^[a-fA-F0-9]+$/;\n\nFingerprint.parse = function (fp, options) {\n\tassert.string(fp, 'fingerprint');\n\n\tvar alg, hash, enAlgs;\n\tif (Array.isArray(options)) {\n\t\tenAlgs = options;\n\t\toptions = {};\n\t}\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tif (options.enAlgs !== undefined)\n\t\tenAlgs = options.enAlgs;\n\tif (options.algorithms !== undefined)\n\t\tenAlgs = options.algorithms;\n\tassert.optionalArrayOfString(enAlgs, 'algorithms');\n\n\tvar hashType = 'ssh';\n\tif (options.hashType !== undefined)\n\t\thashType = options.hashType;\n\tassert.string(hashType, 'options.hashType');\n\n\tvar parts = fp.split(':');\n\tif (parts.length == 2) {\n\t\talg = parts[0].toLowerCase();\n\t\tif (!base64RE.test(parts[1]))\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\ttry {\n\t\t\thash = Buffer.from(parts[1], 'base64');\n\t\t} catch (e) {\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t}\n\t} else if (parts.length > 2) {\n\t\talg = 'md5';\n\t\tif (parts[0].toLowerCase() === 'md5')\n\t\t\tparts = parts.slice(1);\n\t\tparts = parts.map(function (p) {\n\t\t\twhile (p.length < 2)\n\t\t\t\tp = '0' + p;\n\t\t\tif (p.length > 2)\n\t\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t\treturn (p);\n\t\t});\n\t\tparts = parts.join('');\n\t\tif (!hexRE.test(parts) || parts.length % 2 !== 0)\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\ttry {\n\t\t\thash = Buffer.from(parts, 'hex');\n\t\t} catch (e) {\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t}\n\t} else {\n\t\tif (hexRE.test(fp)) {\n\t\t\thash = Buffer.from(fp, 'hex');\n\t\t} else if (base64RE.test(fp)) {\n\t\t\thash = Buffer.from(fp, 'base64');\n\t\t} else {\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t}\n\n\t\tswitch (hash.length) {\n\t\tcase 32:\n\t\t\talg = 'sha256';\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\talg = 'md5';\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\talg = 'sha1';\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\talg = 'sha512';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t}\n\n\t\t/* Plain hex/base64: guess it's probably SPKI unless told. */\n\t\tif (options.hashType === undefined)\n\t\t\thashType = 'spki';\n\t}\n\n\tif (alg === undefined)\n\t\tthrow (new FingerprintFormatError(fp));\n\n\tif (algs.hashAlgs[alg] === undefined)\n\t\tthrow (new InvalidAlgorithmError(alg));\n\n\tif (enAlgs !== undefined) {\n\t\tenAlgs = enAlgs.map(function (a) { return a.toLowerCase(); });\n\t\tif (enAlgs.indexOf(alg) === -1)\n\t\t\tthrow (new InvalidAlgorithmError(alg));\n\t}\n\n\treturn (new Fingerprint({\n\t\talgorithm: alg,\n\t\thash: hash,\n\t\ttype: options.type || 'key',\n\t\thashType: hashType\n\t}));\n};\n\nfunction addColons(s) {\n\t/*JSSTYLED*/\n\treturn (s.replace(/(.{2})(?=.)/g, '$1:'));\n}\n\nfunction base64Strip(s) {\n\t/*JSSTYLED*/\n\treturn (s.replace(/=*$/, ''));\n}\n\nfunction sshBase64Format(alg, h) {\n\treturn (alg.toUpperCase() + ':' + base64Strip(h));\n}\n\nFingerprint.isFingerprint = function (obj, ver) {\n\treturn (utils.isCompatible(obj, Fingerprint, ver));\n};\n\n/*\n * API versions for Fingerprint:\n * [1,0] -- initial ver\n * [1,1] -- first tagged ver\n * [1,2] -- hashType and spki support\n */\nFingerprint.prototype._sshpkApiVersion = [1, 2];\n\nFingerprint._oldVersionDetect = function (obj) {\n\tassert.func(obj.toString);\n\tassert.func(obj.matches);\n\treturn ([1, 0]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2ZpbmdlcnByaW50LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrREFBYTtBQUNsQyxhQUFhLDhGQUE4QjtBQUMzQyxXQUFXLG1CQUFPLENBQUMsc0RBQVE7QUFDM0IsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQywwREFBVTtBQUM3QixVQUFVLG1CQUFPLENBQUMsb0RBQU87QUFDekIsaUJBQWlCLG1CQUFPLENBQUMsb0VBQWU7QUFDeEMsa0JBQWtCLG1CQUFPLENBQUMsb0VBQWU7QUFDekMsWUFBWSxtQkFBTyxDQUFDLHdEQUFTOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyx5QkFBeUI7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixFQUFFO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2ZpbmdlcnByaW50LmpzPzY0ODYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTggSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0gRmluZ2VycHJpbnQ7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBhbGdzID0gcmVxdWlyZSgnLi9hbGdzJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgZXJycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgS2V5ID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi9wcml2YXRlLWtleScpO1xudmFyIENlcnRpZmljYXRlID0gcmVxdWlyZSgnLi9jZXJ0aWZpY2F0ZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgRmluZ2VycHJpbnRGb3JtYXRFcnJvciA9IGVycnMuRmluZ2VycHJpbnRGb3JtYXRFcnJvcjtcbnZhciBJbnZhbGlkQWxnb3JpdGhtRXJyb3IgPSBlcnJzLkludmFsaWRBbGdvcml0aG1FcnJvcjtcblxuZnVuY3Rpb24gRmluZ2VycHJpbnQob3B0cykge1xuXHRhc3NlcnQub2JqZWN0KG9wdHMsICdvcHRpb25zJyk7XG5cdGFzc2VydC5zdHJpbmcob3B0cy50eXBlLCAnb3B0aW9ucy50eXBlJyk7XG5cdGFzc2VydC5idWZmZXIob3B0cy5oYXNoLCAnb3B0aW9ucy5oYXNoJyk7XG5cdGFzc2VydC5zdHJpbmcob3B0cy5hbGdvcml0aG0sICdvcHRpb25zLmFsZ29yaXRobScpO1xuXG5cdHRoaXMuYWxnb3JpdGhtID0gb3B0cy5hbGdvcml0aG0udG9Mb3dlckNhc2UoKTtcblx0aWYgKGFsZ3MuaGFzaEFsZ3NbdGhpcy5hbGdvcml0aG1dICE9PSB0cnVlKVxuXHRcdHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKHRoaXMuYWxnb3JpdGhtKSk7XG5cblx0dGhpcy5oYXNoID0gb3B0cy5oYXNoO1xuXHR0aGlzLnR5cGUgPSBvcHRzLnR5cGU7XG5cdHRoaXMuaGFzaFR5cGUgPSBvcHRzLmhhc2hUeXBlO1xufVxuXG5GaW5nZXJwcmludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuXHRcdGlmICh0aGlzLmFsZ29yaXRobSA9PT0gJ21kNScgfHwgdGhpcy5oYXNoVHlwZSA9PT0gJ3Nwa2knKVxuXHRcdFx0Zm9ybWF0ID0gJ2hleCc7XG5cdFx0ZWxzZVxuXHRcdFx0Zm9ybWF0ID0gJ2Jhc2U2NCc7XG5cdH1cblx0YXNzZXJ0LnN0cmluZyhmb3JtYXQpO1xuXG5cdHN3aXRjaCAoZm9ybWF0KSB7XG5cdGNhc2UgJ2hleCc6XG5cdFx0aWYgKHRoaXMuaGFzaFR5cGUgPT09ICdzcGtpJylcblx0XHRcdHJldHVybiAodGhpcy5oYXNoLnRvU3RyaW5nKCdoZXgnKSk7XG5cdFx0cmV0dXJuIChhZGRDb2xvbnModGhpcy5oYXNoLnRvU3RyaW5nKCdoZXgnKSkpO1xuXHRjYXNlICdiYXNlNjQnOlxuXHRcdGlmICh0aGlzLmhhc2hUeXBlID09PSAnc3BraScpXG5cdFx0XHRyZXR1cm4gKHRoaXMuaGFzaC50b1N0cmluZygnYmFzZTY0JykpO1xuXHRcdHJldHVybiAoc3NoQmFzZTY0Rm9ybWF0KHRoaXMuYWxnb3JpdGhtLFxuXHRcdCAgICB0aGlzLmhhc2gudG9TdHJpbmcoJ2Jhc2U2NCcpKSk7XG5cdGRlZmF1bHQ6XG5cdFx0dGhyb3cgKG5ldyBGaW5nZXJwcmludEZvcm1hdEVycm9yKHVuZGVmaW5lZCwgZm9ybWF0KSk7XG5cdH1cbn07XG5cbkZpbmdlcnByaW50LnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdGFzc2VydC5vYmplY3Qob3RoZXIsICdrZXkgb3IgY2VydGlmaWNhdGUnKTtcblx0aWYgKHRoaXMudHlwZSA9PT0gJ2tleScgJiYgdGhpcy5oYXNoVHlwZSAhPT0gJ3NzaCcpIHtcblx0XHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKG90aGVyLCBLZXksIFsxLCA3XSwgJ2tleSB3aXRoIHNwa2knKTtcblx0XHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkob3RoZXIpKSB7XG5cdFx0XHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKG90aGVyLCBQcml2YXRlS2V5LCBbMSwgNl0sXG5cdFx0XHQgICAgJ3ByaXZhdGVrZXkgd2l0aCBzcGtpIHN1cHBvcnQnKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodGhpcy50eXBlID09PSAna2V5Jykge1xuXHRcdHV0aWxzLmFzc2VydENvbXBhdGlibGUob3RoZXIsIEtleSwgWzEsIDBdLCAna2V5Jyk7XG5cdH0gZWxzZSB7XG5cdFx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShvdGhlciwgQ2VydGlmaWNhdGUsIFsxLCAwXSxcblx0XHQgICAgJ2NlcnRpZmljYXRlJyk7XG5cdH1cblxuXHR2YXIgdGhlaXJIYXNoID0gb3RoZXIuaGFzaCh0aGlzLmFsZ29yaXRobSwgdGhpcy5oYXNoVHlwZSk7XG5cdHZhciB0aGVpckhhc2gyID0gY3J5cHRvLmNyZWF0ZUhhc2godGhpcy5hbGdvcml0aG0pLlxuXHQgICAgdXBkYXRlKHRoZWlySGFzaCkuZGlnZXN0KCdiYXNlNjQnKTtcblxuXHRpZiAodGhpcy5oYXNoMiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRoaXMuaGFzaDIgPSBjcnlwdG8uY3JlYXRlSGFzaCh0aGlzLmFsZ29yaXRobSkuXG5cdFx0ICAgIHVwZGF0ZSh0aGlzLmhhc2gpLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cblx0cmV0dXJuICh0aGlzLmhhc2gyID09PSB0aGVpckhhc2gyKTtcbn07XG5cbi8qSlNTVFlMRUQqL1xudmFyIGJhc2U2NFJFID0gL15bQS1aYS16MC05K1xcLz1dKyQvO1xuLypKU1NUWUxFRCovXG52YXIgaGV4UkUgPSAvXlthLWZBLUYwLTldKyQvO1xuXG5GaW5nZXJwcmludC5wYXJzZSA9IGZ1bmN0aW9uIChmcCwgb3B0aW9ucykge1xuXHRhc3NlcnQuc3RyaW5nKGZwLCAnZmluZ2VycHJpbnQnKTtcblxuXHR2YXIgYWxnLCBoYXNoLCBlbkFsZ3M7XG5cdGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG5cdFx0ZW5BbGdzID0gb3B0aW9ucztcblx0XHRvcHRpb25zID0ge307XG5cdH1cblx0YXNzZXJ0Lm9wdGlvbmFsT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG5cdGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpXG5cdFx0b3B0aW9ucyA9IHt9O1xuXHRpZiAob3B0aW9ucy5lbkFsZ3MgIT09IHVuZGVmaW5lZClcblx0XHRlbkFsZ3MgPSBvcHRpb25zLmVuQWxncztcblx0aWYgKG9wdGlvbnMuYWxnb3JpdGhtcyAhPT0gdW5kZWZpbmVkKVxuXHRcdGVuQWxncyA9IG9wdGlvbnMuYWxnb3JpdGhtcztcblx0YXNzZXJ0Lm9wdGlvbmFsQXJyYXlPZlN0cmluZyhlbkFsZ3MsICdhbGdvcml0aG1zJyk7XG5cblx0dmFyIGhhc2hUeXBlID0gJ3NzaCc7XG5cdGlmIChvcHRpb25zLmhhc2hUeXBlICE9PSB1bmRlZmluZWQpXG5cdFx0aGFzaFR5cGUgPSBvcHRpb25zLmhhc2hUeXBlO1xuXHRhc3NlcnQuc3RyaW5nKGhhc2hUeXBlLCAnb3B0aW9ucy5oYXNoVHlwZScpO1xuXG5cdHZhciBwYXJ0cyA9IGZwLnNwbGl0KCc6Jyk7XG5cdGlmIChwYXJ0cy5sZW5ndGggPT0gMikge1xuXHRcdGFsZyA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKCFiYXNlNjRSRS50ZXN0KHBhcnRzWzFdKSlcblx0XHRcdHRocm93IChuZXcgRmluZ2VycHJpbnRGb3JtYXRFcnJvcihmcCkpO1xuXHRcdHRyeSB7XG5cdFx0XHRoYXNoID0gQnVmZmVyLmZyb20ocGFydHNbMV0sICdiYXNlNjQnKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR0aHJvdyAobmV3IEZpbmdlcnByaW50Rm9ybWF0RXJyb3IoZnApKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAocGFydHMubGVuZ3RoID4gMikge1xuXHRcdGFsZyA9ICdtZDUnO1xuXHRcdGlmIChwYXJ0c1swXS50b0xvd2VyQ2FzZSgpID09PSAnbWQ1Jylcblx0XHRcdHBhcnRzID0gcGFydHMuc2xpY2UoMSk7XG5cdFx0cGFydHMgPSBwYXJ0cy5tYXAoZnVuY3Rpb24gKHApIHtcblx0XHRcdHdoaWxlIChwLmxlbmd0aCA8IDIpXG5cdFx0XHRcdHAgPSAnMCcgKyBwO1xuXHRcdFx0aWYgKHAubGVuZ3RoID4gMilcblx0XHRcdFx0dGhyb3cgKG5ldyBGaW5nZXJwcmludEZvcm1hdEVycm9yKGZwKSk7XG5cdFx0XHRyZXR1cm4gKHApO1xuXHRcdH0pO1xuXHRcdHBhcnRzID0gcGFydHMuam9pbignJyk7XG5cdFx0aWYgKCFoZXhSRS50ZXN0KHBhcnRzKSB8fCBwYXJ0cy5sZW5ndGggJSAyICE9PSAwKVxuXHRcdFx0dGhyb3cgKG5ldyBGaW5nZXJwcmludEZvcm1hdEVycm9yKGZwKSk7XG5cdFx0dHJ5IHtcblx0XHRcdGhhc2ggPSBCdWZmZXIuZnJvbShwYXJ0cywgJ2hleCcpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHRocm93IChuZXcgRmluZ2VycHJpbnRGb3JtYXRFcnJvcihmcCkpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAoaGV4UkUudGVzdChmcCkpIHtcblx0XHRcdGhhc2ggPSBCdWZmZXIuZnJvbShmcCwgJ2hleCcpO1xuXHRcdH0gZWxzZSBpZiAoYmFzZTY0UkUudGVzdChmcCkpIHtcblx0XHRcdGhhc2ggPSBCdWZmZXIuZnJvbShmcCwgJ2Jhc2U2NCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyAobmV3IEZpbmdlcnByaW50Rm9ybWF0RXJyb3IoZnApKTtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKGhhc2gubGVuZ3RoKSB7XG5cdFx0Y2FzZSAzMjpcblx0XHRcdGFsZyA9ICdzaGEyNTYnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAxNjpcblx0XHRcdGFsZyA9ICdtZDUnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAyMDpcblx0XHRcdGFsZyA9ICdzaGExJztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgNjQ6XG5cdFx0XHRhbGcgPSAnc2hhNTEyJztcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyAobmV3IEZpbmdlcnByaW50Rm9ybWF0RXJyb3IoZnApKTtcblx0XHR9XG5cblx0XHQvKiBQbGFpbiBoZXgvYmFzZTY0OiBndWVzcyBpdCdzIHByb2JhYmx5IFNQS0kgdW5sZXNzIHRvbGQuICovXG5cdFx0aWYgKG9wdGlvbnMuaGFzaFR5cGUgPT09IHVuZGVmaW5lZClcblx0XHRcdGhhc2hUeXBlID0gJ3Nwa2knO1xuXHR9XG5cblx0aWYgKGFsZyA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRmluZ2VycHJpbnRGb3JtYXRFcnJvcihmcCkpO1xuXG5cdGlmIChhbGdzLmhhc2hBbGdzW2FsZ10gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEludmFsaWRBbGdvcml0aG1FcnJvcihhbGcpKTtcblxuXHRpZiAoZW5BbGdzICE9PSB1bmRlZmluZWQpIHtcblx0XHRlbkFsZ3MgPSBlbkFsZ3MubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnRvTG93ZXJDYXNlKCk7IH0pO1xuXHRcdGlmIChlbkFsZ3MuaW5kZXhPZihhbGcpID09PSAtMSlcblx0XHRcdHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKGFsZykpO1xuXHR9XG5cblx0cmV0dXJuIChuZXcgRmluZ2VycHJpbnQoe1xuXHRcdGFsZ29yaXRobTogYWxnLFxuXHRcdGhhc2g6IGhhc2gsXG5cdFx0dHlwZTogb3B0aW9ucy50eXBlIHx8ICdrZXknLFxuXHRcdGhhc2hUeXBlOiBoYXNoVHlwZVxuXHR9KSk7XG59O1xuXG5mdW5jdGlvbiBhZGRDb2xvbnMocykge1xuXHQvKkpTU1RZTEVEKi9cblx0cmV0dXJuIChzLnJlcGxhY2UoLyguezJ9KSg/PS4pL2csICckMTonKSk7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFN0cmlwKHMpIHtcblx0LypKU1NUWUxFRCovXG5cdHJldHVybiAocy5yZXBsYWNlKC89KiQvLCAnJykpO1xufVxuXG5mdW5jdGlvbiBzc2hCYXNlNjRGb3JtYXQoYWxnLCBoKSB7XG5cdHJldHVybiAoYWxnLnRvVXBwZXJDYXNlKCkgKyAnOicgKyBiYXNlNjRTdHJpcChoKSk7XG59XG5cbkZpbmdlcnByaW50LmlzRmluZ2VycHJpbnQgPSBmdW5jdGlvbiAob2JqLCB2ZXIpIHtcblx0cmV0dXJuICh1dGlscy5pc0NvbXBhdGlibGUob2JqLCBGaW5nZXJwcmludCwgdmVyKSk7XG59O1xuXG4vKlxuICogQVBJIHZlcnNpb25zIGZvciBGaW5nZXJwcmludDpcbiAqIFsxLDBdIC0tIGluaXRpYWwgdmVyXG4gKiBbMSwxXSAtLSBmaXJzdCB0YWdnZWQgdmVyXG4gKiBbMSwyXSAtLSBoYXNoVHlwZSBhbmQgc3BraSBzdXBwb3J0XG4gKi9cbkZpbmdlcnByaW50LnByb3RvdHlwZS5fc3NocGtBcGlWZXJzaW9uID0gWzEsIDJdO1xuXG5GaW5nZXJwcmludC5fb2xkVmVyc2lvbkRldGVjdCA9IGZ1bmN0aW9uIChvYmopIHtcblx0YXNzZXJ0LmZ1bmMob2JqLnRvU3RyaW5nKTtcblx0YXNzZXJ0LmZ1bmMob2JqLm1hdGNoZXMpO1xuXHRyZXR1cm4gKFsxLCAwXSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/fingerprint.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/formats/auto.js":
/*!************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/auto.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2018 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar utils = __webpack_require__(/*! ../utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\n\nvar pem = __webpack_require__(/*! ./pem */ \"(action-browser)/./node_modules/sshpk/lib/formats/pem.js\");\nvar ssh = __webpack_require__(/*! ./ssh */ \"(action-browser)/./node_modules/sshpk/lib/formats/ssh.js\");\nvar rfc4253 = __webpack_require__(/*! ./rfc4253 */ \"(action-browser)/./node_modules/sshpk/lib/formats/rfc4253.js\");\nvar dnssec = __webpack_require__(/*! ./dnssec */ \"(action-browser)/./node_modules/sshpk/lib/formats/dnssec.js\");\nvar putty = __webpack_require__(/*! ./putty */ \"(action-browser)/./node_modules/sshpk/lib/formats/putty.js\");\n\nvar DNSSEC_PRIVKEY_HEADER_PREFIX = 'Private-key-format: v1';\n\nfunction read(buf, options) {\n\tif (typeof (buf) === 'string') {\n\t\tif (buf.trim().match(/^[-]+[ ]*BEGIN/))\n\t\t\treturn (pem.read(buf, options));\n\t\tif (buf.match(/^\\s*ssh-[a-z]/))\n\t\t\treturn (ssh.read(buf, options));\n\t\tif (buf.match(/^\\s*ecdsa-/))\n\t\t\treturn (ssh.read(buf, options));\n\t\tif (buf.match(/^putty-user-key-file-2:/i))\n\t\t\treturn (putty.read(buf, options));\n\t\tif (findDNSSECHeader(buf))\n\t\t\treturn (dnssec.read(buf, options));\n\t\tbuf = Buffer.from(buf, 'binary');\n\t} else {\n\t\tassert.buffer(buf);\n\t\tif (findPEMHeader(buf))\n\t\t\treturn (pem.read(buf, options));\n\t\tif (findSSHHeader(buf))\n\t\t\treturn (ssh.read(buf, options));\n\t\tif (findPuTTYHeader(buf))\n\t\t\treturn (putty.read(buf, options));\n\t\tif (findDNSSECHeader(buf))\n\t\t\treturn (dnssec.read(buf, options));\n\t}\n\tif (buf.readUInt32BE(0) < buf.length)\n\t\treturn (rfc4253.read(buf, options));\n\tthrow (new Error('Failed to auto-detect format of key'));\n}\n\nfunction findPuTTYHeader(buf) {\n\tvar offset = 0;\n\twhile (offset < buf.length &&\n\t    (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))\n\t\t++offset;\n\tif (offset + 22 <= buf.length &&\n\t    buf.slice(offset, offset + 22).toString('ascii').toLowerCase() ===\n\t    'putty-user-key-file-2:')\n\t\treturn (true);\n\treturn (false);\n}\n\nfunction findSSHHeader(buf) {\n\tvar offset = 0;\n\twhile (offset < buf.length &&\n\t    (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))\n\t\t++offset;\n\tif (offset + 4 <= buf.length &&\n\t    buf.slice(offset, offset + 4).toString('ascii') === 'ssh-')\n\t\treturn (true);\n\tif (offset + 6 <= buf.length &&\n\t    buf.slice(offset, offset + 6).toString('ascii') === 'ecdsa-')\n\t\treturn (true);\n\treturn (false);\n}\n\nfunction findPEMHeader(buf) {\n\tvar offset = 0;\n\twhile (offset < buf.length &&\n\t    (buf[offset] === 32 || buf[offset] === 10))\n\t\t++offset;\n\tif (buf[offset] !== 45)\n\t\treturn (false);\n\twhile (offset < buf.length &&\n\t    (buf[offset] === 45))\n\t\t++offset;\n\twhile (offset < buf.length &&\n\t    (buf[offset] === 32))\n\t\t++offset;\n\tif (offset + 5 > buf.length ||\n\t    buf.slice(offset, offset + 5).toString('ascii') !== 'BEGIN')\n\t\treturn (false);\n\treturn (true);\n}\n\nfunction findDNSSECHeader(buf) {\n\t// private case first\n\tif (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length)\n\t\treturn (false);\n\tvar headerCheck = buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length);\n\tif (headerCheck.toString('ascii') === DNSSEC_PRIVKEY_HEADER_PREFIX)\n\t\treturn (true);\n\n\t// public-key RFC3110 ?\n\t// 'domain.com. IN KEY ...' or 'domain.com. IN DNSKEY ...'\n\t// skip any comment-lines\n\tif (typeof (buf) !== 'string') {\n\t\tbuf = buf.toString('ascii');\n\t}\n\tvar lines = buf.split('\\n');\n\tvar line = 0;\n\t/* JSSTYLED */\n\twhile (lines[line].match(/^\\;/))\n\t\tline++;\n\tif (lines[line].toString('ascii').match(/\\. IN KEY /))\n\t\treturn (true);\n\tif (lines[line].toString('ascii').match(/\\. IN DNSKEY /))\n\t\treturn (true);\n\treturn (false);\n}\n\nfunction write(key, options) {\n\tthrow (new Error('\"auto\" format cannot be used for writing'));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9hdXRvLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywwRUFBYTtBQUNsQyxhQUFhLHlHQUE4QjtBQUMzQyxZQUFZLG1CQUFPLENBQUMsb0VBQVU7QUFDOUIsVUFBVSxtQkFBTyxDQUFDLGdFQUFRO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLGdGQUFnQjs7QUFFekMsVUFBVSxtQkFBTyxDQUFDLHVFQUFPO0FBQ3pCLFVBQVUsbUJBQU8sQ0FBQyx1RUFBTztBQUN6QixjQUFjLG1CQUFPLENBQUMsK0VBQVc7QUFDakMsYUFBYSxtQkFBTyxDQUFDLDZFQUFVO0FBQy9CLFlBQVksbUJBQU8sQ0FBQywyRUFBUzs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9hdXRvLmpzP2VlNDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTggSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRyZWFkOiByZWFkLFxuXHR3cml0ZTogd3JpdGVcbn07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgS2V5ID0gcmVxdWlyZSgnLi4va2V5Jyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uL3ByaXZhdGUta2V5Jyk7XG5cbnZhciBwZW0gPSByZXF1aXJlKCcuL3BlbScpO1xudmFyIHNzaCA9IHJlcXVpcmUoJy4vc3NoJyk7XG52YXIgcmZjNDI1MyA9IHJlcXVpcmUoJy4vcmZjNDI1MycpO1xudmFyIGRuc3NlYyA9IHJlcXVpcmUoJy4vZG5zc2VjJyk7XG52YXIgcHV0dHkgPSByZXF1aXJlKCcuL3B1dHR5Jyk7XG5cbnZhciBETlNTRUNfUFJJVktFWV9IRUFERVJfUFJFRklYID0gJ1ByaXZhdGUta2V5LWZvcm1hdDogdjEnO1xuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIChidWYpID09PSAnc3RyaW5nJykge1xuXHRcdGlmIChidWYudHJpbSgpLm1hdGNoKC9eWy1dK1sgXSpCRUdJTi8pKVxuXHRcdFx0cmV0dXJuIChwZW0ucmVhZChidWYsIG9wdGlvbnMpKTtcblx0XHRpZiAoYnVmLm1hdGNoKC9eXFxzKnNzaC1bYS16XS8pKVxuXHRcdFx0cmV0dXJuIChzc2gucmVhZChidWYsIG9wdGlvbnMpKTtcblx0XHRpZiAoYnVmLm1hdGNoKC9eXFxzKmVjZHNhLS8pKVxuXHRcdFx0cmV0dXJuIChzc2gucmVhZChidWYsIG9wdGlvbnMpKTtcblx0XHRpZiAoYnVmLm1hdGNoKC9ecHV0dHktdXNlci1rZXktZmlsZS0yOi9pKSlcblx0XHRcdHJldHVybiAocHV0dHkucmVhZChidWYsIG9wdGlvbnMpKTtcblx0XHRpZiAoZmluZEROU1NFQ0hlYWRlcihidWYpKVxuXHRcdFx0cmV0dXJuIChkbnNzZWMucmVhZChidWYsIG9wdGlvbnMpKTtcblx0XHRidWYgPSBCdWZmZXIuZnJvbShidWYsICdiaW5hcnknKTtcblx0fSBlbHNlIHtcblx0XHRhc3NlcnQuYnVmZmVyKGJ1Zik7XG5cdFx0aWYgKGZpbmRQRU1IZWFkZXIoYnVmKSlcblx0XHRcdHJldHVybiAocGVtLnJlYWQoYnVmLCBvcHRpb25zKSk7XG5cdFx0aWYgKGZpbmRTU0hIZWFkZXIoYnVmKSlcblx0XHRcdHJldHVybiAoc3NoLnJlYWQoYnVmLCBvcHRpb25zKSk7XG5cdFx0aWYgKGZpbmRQdVRUWUhlYWRlcihidWYpKVxuXHRcdFx0cmV0dXJuIChwdXR0eS5yZWFkKGJ1Ziwgb3B0aW9ucykpO1xuXHRcdGlmIChmaW5kRE5TU0VDSGVhZGVyKGJ1ZikpXG5cdFx0XHRyZXR1cm4gKGRuc3NlYy5yZWFkKGJ1Ziwgb3B0aW9ucykpO1xuXHR9XG5cdGlmIChidWYucmVhZFVJbnQzMkJFKDApIDwgYnVmLmxlbmd0aClcblx0XHRyZXR1cm4gKHJmYzQyNTMucmVhZChidWYsIG9wdGlvbnMpKTtcblx0dGhyb3cgKG5ldyBFcnJvcignRmFpbGVkIHRvIGF1dG8tZGV0ZWN0IGZvcm1hdCBvZiBrZXknKSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRQdVRUWUhlYWRlcihidWYpIHtcblx0dmFyIG9mZnNldCA9IDA7XG5cdHdoaWxlIChvZmZzZXQgPCBidWYubGVuZ3RoICYmXG5cdCAgICAoYnVmW29mZnNldF0gPT09IDMyIHx8IGJ1ZltvZmZzZXRdID09PSAxMCB8fCBidWZbb2Zmc2V0XSA9PT0gOSkpXG5cdFx0KytvZmZzZXQ7XG5cdGlmIChvZmZzZXQgKyAyMiA8PSBidWYubGVuZ3RoICYmXG5cdCAgICBidWYuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyAyMikudG9TdHJpbmcoJ2FzY2lpJykudG9Mb3dlckNhc2UoKSA9PT1cblx0ICAgICdwdXR0eS11c2VyLWtleS1maWxlLTI6Jylcblx0XHRyZXR1cm4gKHRydWUpO1xuXHRyZXR1cm4gKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZmluZFNTSEhlYWRlcihidWYpIHtcblx0dmFyIG9mZnNldCA9IDA7XG5cdHdoaWxlIChvZmZzZXQgPCBidWYubGVuZ3RoICYmXG5cdCAgICAoYnVmW29mZnNldF0gPT09IDMyIHx8IGJ1ZltvZmZzZXRdID09PSAxMCB8fCBidWZbb2Zmc2V0XSA9PT0gOSkpXG5cdFx0KytvZmZzZXQ7XG5cdGlmIChvZmZzZXQgKyA0IDw9IGJ1Zi5sZW5ndGggJiZcblx0ICAgIGJ1Zi5zbGljZShvZmZzZXQsIG9mZnNldCArIDQpLnRvU3RyaW5nKCdhc2NpaScpID09PSAnc3NoLScpXG5cdFx0cmV0dXJuICh0cnVlKTtcblx0aWYgKG9mZnNldCArIDYgPD0gYnVmLmxlbmd0aCAmJlxuXHQgICAgYnVmLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgNikudG9TdHJpbmcoJ2FzY2lpJykgPT09ICdlY2RzYS0nKVxuXHRcdHJldHVybiAodHJ1ZSk7XG5cdHJldHVybiAoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBmaW5kUEVNSGVhZGVyKGJ1Zikge1xuXHR2YXIgb2Zmc2V0ID0gMDtcblx0d2hpbGUgKG9mZnNldCA8IGJ1Zi5sZW5ndGggJiZcblx0ICAgIChidWZbb2Zmc2V0XSA9PT0gMzIgfHwgYnVmW29mZnNldF0gPT09IDEwKSlcblx0XHQrK29mZnNldDtcblx0aWYgKGJ1ZltvZmZzZXRdICE9PSA0NSlcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0d2hpbGUgKG9mZnNldCA8IGJ1Zi5sZW5ndGggJiZcblx0ICAgIChidWZbb2Zmc2V0XSA9PT0gNDUpKVxuXHRcdCsrb2Zmc2V0O1xuXHR3aGlsZSAob2Zmc2V0IDwgYnVmLmxlbmd0aCAmJlxuXHQgICAgKGJ1ZltvZmZzZXRdID09PSAzMikpXG5cdFx0KytvZmZzZXQ7XG5cdGlmIChvZmZzZXQgKyA1ID4gYnVmLmxlbmd0aCB8fFxuXHQgICAgYnVmLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgNSkudG9TdHJpbmcoJ2FzY2lpJykgIT09ICdCRUdJTicpXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cdHJldHVybiAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRETlNTRUNIZWFkZXIoYnVmKSB7XG5cdC8vIHByaXZhdGUgY2FzZSBmaXJzdFxuXHRpZiAoYnVmLmxlbmd0aCA8PSBETlNTRUNfUFJJVktFWV9IRUFERVJfUFJFRklYLmxlbmd0aClcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0dmFyIGhlYWRlckNoZWNrID0gYnVmLnNsaWNlKDAsIEROU1NFQ19QUklWS0VZX0hFQURFUl9QUkVGSVgubGVuZ3RoKTtcblx0aWYgKGhlYWRlckNoZWNrLnRvU3RyaW5nKCdhc2NpaScpID09PSBETlNTRUNfUFJJVktFWV9IRUFERVJfUFJFRklYKVxuXHRcdHJldHVybiAodHJ1ZSk7XG5cblx0Ly8gcHVibGljLWtleSBSRkMzMTEwID9cblx0Ly8gJ2RvbWFpbi5jb20uIElOIEtFWSAuLi4nIG9yICdkb21haW4uY29tLiBJTiBETlNLRVkgLi4uJ1xuXHQvLyBza2lwIGFueSBjb21tZW50LWxpbmVzXG5cdGlmICh0eXBlb2YgKGJ1ZikgIT09ICdzdHJpbmcnKSB7XG5cdFx0YnVmID0gYnVmLnRvU3RyaW5nKCdhc2NpaScpO1xuXHR9XG5cdHZhciBsaW5lcyA9IGJ1Zi5zcGxpdCgnXFxuJyk7XG5cdHZhciBsaW5lID0gMDtcblx0LyogSlNTVFlMRUQgKi9cblx0d2hpbGUgKGxpbmVzW2xpbmVdLm1hdGNoKC9eXFw7LykpXG5cdFx0bGluZSsrO1xuXHRpZiAobGluZXNbbGluZV0udG9TdHJpbmcoJ2FzY2lpJykubWF0Y2goL1xcLiBJTiBLRVkgLykpXG5cdFx0cmV0dXJuICh0cnVlKTtcblx0aWYgKGxpbmVzW2xpbmVdLnRvU3RyaW5nKCdhc2NpaScpLm1hdGNoKC9cXC4gSU4gRE5TS0VZIC8pKVxuXHRcdHJldHVybiAodHJ1ZSk7XG5cdHJldHVybiAoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIG9wdGlvbnMpIHtcblx0dGhyb3cgKG5ldyBFcnJvcignXCJhdXRvXCIgZm9ybWF0IGNhbm5vdCBiZSB1c2VkIGZvciB3cml0aW5nJykpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/formats/auto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/formats/auto.js":
/*!************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/auto.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2018 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\n\nvar pem = __webpack_require__(/*! ./pem */ \"(rsc)/./node_modules/sshpk/lib/formats/pem.js\");\nvar ssh = __webpack_require__(/*! ./ssh */ \"(rsc)/./node_modules/sshpk/lib/formats/ssh.js\");\nvar rfc4253 = __webpack_require__(/*! ./rfc4253 */ \"(rsc)/./node_modules/sshpk/lib/formats/rfc4253.js\");\nvar dnssec = __webpack_require__(/*! ./dnssec */ \"(rsc)/./node_modules/sshpk/lib/formats/dnssec.js\");\nvar putty = __webpack_require__(/*! ./putty */ \"(rsc)/./node_modules/sshpk/lib/formats/putty.js\");\n\nvar DNSSEC_PRIVKEY_HEADER_PREFIX = 'Private-key-format: v1';\n\nfunction read(buf, options) {\n\tif (typeof (buf) === 'string') {\n\t\tif (buf.trim().match(/^[-]+[ ]*BEGIN/))\n\t\t\treturn (pem.read(buf, options));\n\t\tif (buf.match(/^\\s*ssh-[a-z]/))\n\t\t\treturn (ssh.read(buf, options));\n\t\tif (buf.match(/^\\s*ecdsa-/))\n\t\t\treturn (ssh.read(buf, options));\n\t\tif (buf.match(/^putty-user-key-file-2:/i))\n\t\t\treturn (putty.read(buf, options));\n\t\tif (findDNSSECHeader(buf))\n\t\t\treturn (dnssec.read(buf, options));\n\t\tbuf = Buffer.from(buf, 'binary');\n\t} else {\n\t\tassert.buffer(buf);\n\t\tif (findPEMHeader(buf))\n\t\t\treturn (pem.read(buf, options));\n\t\tif (findSSHHeader(buf))\n\t\t\treturn (ssh.read(buf, options));\n\t\tif (findPuTTYHeader(buf))\n\t\t\treturn (putty.read(buf, options));\n\t\tif (findDNSSECHeader(buf))\n\t\t\treturn (dnssec.read(buf, options));\n\t}\n\tif (buf.readUInt32BE(0) < buf.length)\n\t\treturn (rfc4253.read(buf, options));\n\tthrow (new Error('Failed to auto-detect format of key'));\n}\n\nfunction findPuTTYHeader(buf) {\n\tvar offset = 0;\n\twhile (offset < buf.length &&\n\t    (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))\n\t\t++offset;\n\tif (offset + 22 <= buf.length &&\n\t    buf.slice(offset, offset + 22).toString('ascii').toLowerCase() ===\n\t    'putty-user-key-file-2:')\n\t\treturn (true);\n\treturn (false);\n}\n\nfunction findSSHHeader(buf) {\n\tvar offset = 0;\n\twhile (offset < buf.length &&\n\t    (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))\n\t\t++offset;\n\tif (offset + 4 <= buf.length &&\n\t    buf.slice(offset, offset + 4).toString('ascii') === 'ssh-')\n\t\treturn (true);\n\tif (offset + 6 <= buf.length &&\n\t    buf.slice(offset, offset + 6).toString('ascii') === 'ecdsa-')\n\t\treturn (true);\n\treturn (false);\n}\n\nfunction findPEMHeader(buf) {\n\tvar offset = 0;\n\twhile (offset < buf.length &&\n\t    (buf[offset] === 32 || buf[offset] === 10))\n\t\t++offset;\n\tif (buf[offset] !== 45)\n\t\treturn (false);\n\twhile (offset < buf.length &&\n\t    (buf[offset] === 45))\n\t\t++offset;\n\twhile (offset < buf.length &&\n\t    (buf[offset] === 32))\n\t\t++offset;\n\tif (offset + 5 > buf.length ||\n\t    buf.slice(offset, offset + 5).toString('ascii') !== 'BEGIN')\n\t\treturn (false);\n\treturn (true);\n}\n\nfunction findDNSSECHeader(buf) {\n\t// private case first\n\tif (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length)\n\t\treturn (false);\n\tvar headerCheck = buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length);\n\tif (headerCheck.toString('ascii') === DNSSEC_PRIVKEY_HEADER_PREFIX)\n\t\treturn (true);\n\n\t// public-key RFC3110 ?\n\t// 'domain.com. IN KEY ...' or 'domain.com. IN DNSKEY ...'\n\t// skip any comment-lines\n\tif (typeof (buf) !== 'string') {\n\t\tbuf = buf.toString('ascii');\n\t}\n\tvar lines = buf.split('\\n');\n\tvar line = 0;\n\t/* JSSTYLED */\n\twhile (lines[line].match(/^\\;/))\n\t\tline++;\n\tif (lines[line].toString('ascii').match(/\\. IN KEY /))\n\t\treturn (true);\n\tif (lines[line].toString('ascii').match(/\\. IN DNSKEY /))\n\t\treturn (true);\n\treturn (false);\n}\n\nfunction write(key, options) {\n\tthrow (new Error('\"auto\" format cannot be used for writing'));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvYXV0by5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsK0RBQWE7QUFDbEMsYUFBYSw4RkFBOEI7QUFDM0MsWUFBWSxtQkFBTyxDQUFDLHlEQUFVO0FBQzlCLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixpQkFBaUIsbUJBQU8sQ0FBQyxxRUFBZ0I7O0FBRXpDLFVBQVUsbUJBQU8sQ0FBQyw0REFBTztBQUN6QixVQUFVLG1CQUFPLENBQUMsNERBQU87QUFDekIsY0FBYyxtQkFBTyxDQUFDLG9FQUFXO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxrRUFBVTtBQUMvQixZQUFZLG1CQUFPLENBQUMsZ0VBQVM7O0FBRTdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvYXV0by5qcz81YTRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE4IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEtleSA9IHJlcXVpcmUoJy4uL2tleScpO1xudmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuLi9wcml2YXRlLWtleScpO1xuXG52YXIgcGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcbnZhciBzc2ggPSByZXF1aXJlKCcuL3NzaCcpO1xudmFyIHJmYzQyNTMgPSByZXF1aXJlKCcuL3JmYzQyNTMnKTtcbnZhciBkbnNzZWMgPSByZXF1aXJlKCcuL2Ruc3NlYycpO1xudmFyIHB1dHR5ID0gcmVxdWlyZSgnLi9wdXR0eScpO1xuXG52YXIgRE5TU0VDX1BSSVZLRVlfSEVBREVSX1BSRUZJWCA9ICdQcml2YXRlLWtleS1mb3JtYXQ6IHYxJztcblxuZnVuY3Rpb24gcmVhZChidWYsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiAoYnVmKSA9PT0gJ3N0cmluZycpIHtcblx0XHRpZiAoYnVmLnRyaW0oKS5tYXRjaCgvXlstXStbIF0qQkVHSU4vKSlcblx0XHRcdHJldHVybiAocGVtLnJlYWQoYnVmLCBvcHRpb25zKSk7XG5cdFx0aWYgKGJ1Zi5tYXRjaCgvXlxccypzc2gtW2Etel0vKSlcblx0XHRcdHJldHVybiAoc3NoLnJlYWQoYnVmLCBvcHRpb25zKSk7XG5cdFx0aWYgKGJ1Zi5tYXRjaCgvXlxccyplY2RzYS0vKSlcblx0XHRcdHJldHVybiAoc3NoLnJlYWQoYnVmLCBvcHRpb25zKSk7XG5cdFx0aWYgKGJ1Zi5tYXRjaCgvXnB1dHR5LXVzZXIta2V5LWZpbGUtMjovaSkpXG5cdFx0XHRyZXR1cm4gKHB1dHR5LnJlYWQoYnVmLCBvcHRpb25zKSk7XG5cdFx0aWYgKGZpbmRETlNTRUNIZWFkZXIoYnVmKSlcblx0XHRcdHJldHVybiAoZG5zc2VjLnJlYWQoYnVmLCBvcHRpb25zKSk7XG5cdFx0YnVmID0gQnVmZmVyLmZyb20oYnVmLCAnYmluYXJ5Jyk7XG5cdH0gZWxzZSB7XG5cdFx0YXNzZXJ0LmJ1ZmZlcihidWYpO1xuXHRcdGlmIChmaW5kUEVNSGVhZGVyKGJ1ZikpXG5cdFx0XHRyZXR1cm4gKHBlbS5yZWFkKGJ1Ziwgb3B0aW9ucykpO1xuXHRcdGlmIChmaW5kU1NISGVhZGVyKGJ1ZikpXG5cdFx0XHRyZXR1cm4gKHNzaC5yZWFkKGJ1Ziwgb3B0aW9ucykpO1xuXHRcdGlmIChmaW5kUHVUVFlIZWFkZXIoYnVmKSlcblx0XHRcdHJldHVybiAocHV0dHkucmVhZChidWYsIG9wdGlvbnMpKTtcblx0XHRpZiAoZmluZEROU1NFQ0hlYWRlcihidWYpKVxuXHRcdFx0cmV0dXJuIChkbnNzZWMucmVhZChidWYsIG9wdGlvbnMpKTtcblx0fVxuXHRpZiAoYnVmLnJlYWRVSW50MzJCRSgwKSA8IGJ1Zi5sZW5ndGgpXG5cdFx0cmV0dXJuIChyZmM0MjUzLnJlYWQoYnVmLCBvcHRpb25zKSk7XG5cdHRocm93IChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBhdXRvLWRldGVjdCBmb3JtYXQgb2Yga2V5JykpO1xufVxuXG5mdW5jdGlvbiBmaW5kUHVUVFlIZWFkZXIoYnVmKSB7XG5cdHZhciBvZmZzZXQgPSAwO1xuXHR3aGlsZSAob2Zmc2V0IDwgYnVmLmxlbmd0aCAmJlxuXHQgICAgKGJ1ZltvZmZzZXRdID09PSAzMiB8fCBidWZbb2Zmc2V0XSA9PT0gMTAgfHwgYnVmW29mZnNldF0gPT09IDkpKVxuXHRcdCsrb2Zmc2V0O1xuXHRpZiAob2Zmc2V0ICsgMjIgPD0gYnVmLmxlbmd0aCAmJlxuXHQgICAgYnVmLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgMjIpLnRvU3RyaW5nKCdhc2NpaScpLnRvTG93ZXJDYXNlKCkgPT09XG5cdCAgICAncHV0dHktdXNlci1rZXktZmlsZS0yOicpXG5cdFx0cmV0dXJuICh0cnVlKTtcblx0cmV0dXJuIChmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRTU0hIZWFkZXIoYnVmKSB7XG5cdHZhciBvZmZzZXQgPSAwO1xuXHR3aGlsZSAob2Zmc2V0IDwgYnVmLmxlbmd0aCAmJlxuXHQgICAgKGJ1ZltvZmZzZXRdID09PSAzMiB8fCBidWZbb2Zmc2V0XSA9PT0gMTAgfHwgYnVmW29mZnNldF0gPT09IDkpKVxuXHRcdCsrb2Zmc2V0O1xuXHRpZiAob2Zmc2V0ICsgNCA8PSBidWYubGVuZ3RoICYmXG5cdCAgICBidWYuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyA0KS50b1N0cmluZygnYXNjaWknKSA9PT0gJ3NzaC0nKVxuXHRcdHJldHVybiAodHJ1ZSk7XG5cdGlmIChvZmZzZXQgKyA2IDw9IGJ1Zi5sZW5ndGggJiZcblx0ICAgIGJ1Zi5zbGljZShvZmZzZXQsIG9mZnNldCArIDYpLnRvU3RyaW5nKCdhc2NpaScpID09PSAnZWNkc2EtJylcblx0XHRyZXR1cm4gKHRydWUpO1xuXHRyZXR1cm4gKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZmluZFBFTUhlYWRlcihidWYpIHtcblx0dmFyIG9mZnNldCA9IDA7XG5cdHdoaWxlIChvZmZzZXQgPCBidWYubGVuZ3RoICYmXG5cdCAgICAoYnVmW29mZnNldF0gPT09IDMyIHx8IGJ1ZltvZmZzZXRdID09PSAxMCkpXG5cdFx0KytvZmZzZXQ7XG5cdGlmIChidWZbb2Zmc2V0XSAhPT0gNDUpXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cdHdoaWxlIChvZmZzZXQgPCBidWYubGVuZ3RoICYmXG5cdCAgICAoYnVmW29mZnNldF0gPT09IDQ1KSlcblx0XHQrK29mZnNldDtcblx0d2hpbGUgKG9mZnNldCA8IGJ1Zi5sZW5ndGggJiZcblx0ICAgIChidWZbb2Zmc2V0XSA9PT0gMzIpKVxuXHRcdCsrb2Zmc2V0O1xuXHRpZiAob2Zmc2V0ICsgNSA+IGJ1Zi5sZW5ndGggfHxcblx0ICAgIGJ1Zi5zbGljZShvZmZzZXQsIG9mZnNldCArIDUpLnRvU3RyaW5nKCdhc2NpaScpICE9PSAnQkVHSU4nKVxuXHRcdHJldHVybiAoZmFsc2UpO1xuXHRyZXR1cm4gKHRydWUpO1xufVxuXG5mdW5jdGlvbiBmaW5kRE5TU0VDSGVhZGVyKGJ1Zikge1xuXHQvLyBwcml2YXRlIGNhc2UgZmlyc3Rcblx0aWYgKGJ1Zi5sZW5ndGggPD0gRE5TU0VDX1BSSVZLRVlfSEVBREVSX1BSRUZJWC5sZW5ndGgpXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cdHZhciBoZWFkZXJDaGVjayA9IGJ1Zi5zbGljZSgwLCBETlNTRUNfUFJJVktFWV9IRUFERVJfUFJFRklYLmxlbmd0aCk7XG5cdGlmIChoZWFkZXJDaGVjay50b1N0cmluZygnYXNjaWknKSA9PT0gRE5TU0VDX1BSSVZLRVlfSEVBREVSX1BSRUZJWClcblx0XHRyZXR1cm4gKHRydWUpO1xuXG5cdC8vIHB1YmxpYy1rZXkgUkZDMzExMCA/XG5cdC8vICdkb21haW4uY29tLiBJTiBLRVkgLi4uJyBvciAnZG9tYWluLmNvbS4gSU4gRE5TS0VZIC4uLidcblx0Ly8gc2tpcCBhbnkgY29tbWVudC1saW5lc1xuXHRpZiAodHlwZW9mIChidWYpICE9PSAnc3RyaW5nJykge1xuXHRcdGJ1ZiA9IGJ1Zi50b1N0cmluZygnYXNjaWknKTtcblx0fVxuXHR2YXIgbGluZXMgPSBidWYuc3BsaXQoJ1xcbicpO1xuXHR2YXIgbGluZSA9IDA7XG5cdC8qIEpTU1RZTEVEICovXG5cdHdoaWxlIChsaW5lc1tsaW5lXS5tYXRjaCgvXlxcOy8pKVxuXHRcdGxpbmUrKztcblx0aWYgKGxpbmVzW2xpbmVdLnRvU3RyaW5nKCdhc2NpaScpLm1hdGNoKC9cXC4gSU4gS0VZIC8pKVxuXHRcdHJldHVybiAodHJ1ZSk7XG5cdGlmIChsaW5lc1tsaW5lXS50b1N0cmluZygnYXNjaWknKS5tYXRjaCgvXFwuIElOIEROU0tFWSAvKSlcblx0XHRyZXR1cm4gKHRydWUpO1xuXHRyZXR1cm4gKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBvcHRpb25zKSB7XG5cdHRocm93IChuZXcgRXJyb3IoJ1wiYXV0b1wiIGZvcm1hdCBjYW5ub3QgYmUgdXNlZCBmb3Igd3JpdGluZycpKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/formats/auto.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/formats/dnssec.js":
/*!**************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/dnssec.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2017 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar Key = __webpack_require__(/*! ../key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ \"(action-browser)/./node_modules/sshpk/lib/ssh-buffer.js\");\nvar Dhe = __webpack_require__(/*! ../dhe */ \"(action-browser)/./node_modules/sshpk/lib/dhe.js\");\n\nvar supportedAlgos = {\n\t'rsa-sha1' : 5,\n\t'rsa-sha256' : 8,\n\t'rsa-sha512' : 10,\n\t'ecdsa-p256-sha256' : 13,\n\t'ecdsa-p384-sha384' : 14\n\t/*\n\t * ed25519 is hypothetically supported with id 15\n\t * but the common tools available don't appear to be\n\t * capable of generating/using ed25519 keys\n\t */\n};\n\nvar supportedAlgosById = {};\nObject.keys(supportedAlgos).forEach(function (k) {\n\tsupportedAlgosById[supportedAlgos[k]] = k.toUpperCase();\n});\n\nfunction read(buf, options) {\n\tif (typeof (buf) !== 'string') {\n\t\tassert.buffer(buf, 'buf');\n\t\tbuf = buf.toString('ascii');\n\t}\n\tvar lines = buf.split('\\n');\n\tif (lines[0].match(/^Private-key-format\\: v1/)) {\n\t\tvar algElems = lines[1].split(' ');\n\t\tvar algoNum = parseInt(algElems[1], 10);\n\t\tvar algoName = algElems[2];\n\t\tif (!supportedAlgosById[algoNum])\n\t\t\tthrow (new Error('Unsupported algorithm: ' + algoName));\n\t\treturn (readDNSSECPrivateKey(algoNum, lines.slice(2)));\n\t}\n\n\t// skip any comment-lines\n\tvar line = 0;\n\t/* JSSTYLED */\n\twhile (lines[line].match(/^\\;/))\n\t\tline++;\n\t// we should now have *one single* line left with our KEY on it.\n\tif ((lines[line].match(/\\. IN KEY /) ||\n\t    lines[line].match(/\\. IN DNSKEY /)) && lines[line+1].length === 0) {\n\t\treturn (readRFC3110(lines[line]));\n\t}\n\tthrow (new Error('Cannot parse dnssec key'));\n}\n\nfunction readRFC3110(keyString) {\n\tvar elems = keyString.split(' ');\n\t//unused var flags = parseInt(elems[3], 10);\n\t//unused var protocol = parseInt(elems[4], 10);\n\tvar algorithm = parseInt(elems[5], 10);\n\tif (!supportedAlgosById[algorithm])\n\t\tthrow (new Error('Unsupported algorithm: ' + algorithm));\n\tvar base64key = elems.slice(6, elems.length).join();\n\tvar keyBuffer = Buffer.from(base64key, 'base64');\n\tif (supportedAlgosById[algorithm].match(/^RSA-/)) {\n\t\t// join the rest of the body into a single base64-blob\n\t\tvar publicExponentLen = keyBuffer.readUInt8(0);\n\t\tif (publicExponentLen != 3 && publicExponentLen != 1)\n\t\t\tthrow (new Error('Cannot parse dnssec key: ' +\n\t\t\t    'unsupported exponent length'));\n\n\t\tvar publicExponent = keyBuffer.slice(1, publicExponentLen+1);\n\t\tpublicExponent = utils.mpNormalize(publicExponent);\n\t\tvar modulus = keyBuffer.slice(1+publicExponentLen);\n\t\tmodulus = utils.mpNormalize(modulus);\n\t\t// now, make the key\n\t\tvar rsaKey = {\n\t\t\ttype: 'rsa',\n\t\t\tparts: []\n\t\t};\n\t\trsaKey.parts.push({ name: 'e', data: publicExponent});\n\t\trsaKey.parts.push({ name: 'n', data: modulus});\n\t\treturn (new Key(rsaKey));\n\t}\n\tif (supportedAlgosById[algorithm] === 'ECDSA-P384-SHA384' ||\n\t    supportedAlgosById[algorithm] === 'ECDSA-P256-SHA256') {\n\t\tvar curve = 'nistp384';\n\t\tvar size = 384;\n\t\tif (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {\n\t\t\tcurve = 'nistp256';\n\t\t\tsize = 256;\n\t\t}\n\n\t\tvar ecdsaKey = {\n\t\t\ttype: 'ecdsa',\n\t\t\tcurve: curve,\n\t\t\tsize: size,\n\t\t\tparts: [\n\t\t\t\t{name: 'curve', data: Buffer.from(curve) },\n\t\t\t\t{name: 'Q', data: utils.ecNormalize(keyBuffer) }\n\t\t\t]\n\t\t};\n\t\treturn (new Key(ecdsaKey));\n\t}\n\tthrow (new Error('Unsupported algorithm: ' +\n\t    supportedAlgosById[algorithm]));\n}\n\nfunction elementToBuf(e) {\n\treturn (Buffer.from(e.split(' ')[1], 'base64'));\n}\n\nfunction readDNSSECRSAPrivateKey(elements) {\n\tvar rsaParams = {};\n\telements.forEach(function (element) {\n\t\tif (element.split(' ')[0] === 'Modulus:')\n\t\t\trsaParams['n'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'PublicExponent:')\n\t\t\trsaParams['e'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'PrivateExponent:')\n\t\t\trsaParams['d'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'Prime1:')\n\t\t\trsaParams['p'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'Prime2:')\n\t\t\trsaParams['q'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'Exponent1:')\n\t\t\trsaParams['dmodp'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'Exponent2:')\n\t\t\trsaParams['dmodq'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'Coefficient:')\n\t\t\trsaParams['iqmp'] = elementToBuf(element);\n\t});\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'rsa',\n\t\tparts: [\n\t\t\t{ name: 'e', data: utils.mpNormalize(rsaParams['e'])},\n\t\t\t{ name: 'n', data: utils.mpNormalize(rsaParams['n'])},\n\t\t\t{ name: 'd', data: utils.mpNormalize(rsaParams['d'])},\n\t\t\t{ name: 'p', data: utils.mpNormalize(rsaParams['p'])},\n\t\t\t{ name: 'q', data: utils.mpNormalize(rsaParams['q'])},\n\t\t\t{ name: 'dmodp',\n\t\t\t    data: utils.mpNormalize(rsaParams['dmodp'])},\n\t\t\t{ name: 'dmodq',\n\t\t\t    data: utils.mpNormalize(rsaParams['dmodq'])},\n\t\t\t{ name: 'iqmp',\n\t\t\t    data: utils.mpNormalize(rsaParams['iqmp'])}\n\t\t]\n\t};\n\treturn (new PrivateKey(key));\n}\n\nfunction readDNSSECPrivateKey(alg, elements) {\n\tif (supportedAlgosById[alg].match(/^RSA-/)) {\n\t\treturn (readDNSSECRSAPrivateKey(elements));\n\t}\n\tif (supportedAlgosById[alg] === 'ECDSA-P384-SHA384' ||\n\t    supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {\n\t\tvar d = Buffer.from(elements[0].split(' ')[1], 'base64');\n\t\tvar curve = 'nistp384';\n\t\tvar size = 384;\n\t\tif (supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {\n\t\t\tcurve = 'nistp256';\n\t\t\tsize = 256;\n\t\t}\n\t\t// DNSSEC generates the public-key on the fly (go calculate it)\n\t\tvar publicKey = utils.publicFromPrivateECDSA(curve, d);\n\t\tvar Q = publicKey.part['Q'].data;\n\t\tvar ecdsaKey = {\n\t\t\ttype: 'ecdsa',\n\t\t\tcurve: curve,\n\t\t\tsize: size,\n\t\t\tparts: [\n\t\t\t\t{name: 'curve', data: Buffer.from(curve) },\n\t\t\t\t{name: 'd', data: d },\n\t\t\t\t{name: 'Q', data: Q }\n\t\t\t]\n\t\t};\n\t\treturn (new PrivateKey(ecdsaKey));\n\t}\n\tthrow (new Error('Unsupported algorithm: ' + supportedAlgosById[alg]));\n}\n\nfunction dnssecTimestamp(date) {\n\tvar year = date.getFullYear() + ''; //stringify\n\tvar month = (date.getMonth() + 1);\n\tvar timestampStr = year + month + date.getUTCDate();\n\ttimestampStr += '' + date.getUTCHours() + date.getUTCMinutes();\n\ttimestampStr += date.getUTCSeconds();\n\treturn (timestampStr);\n}\n\nfunction rsaAlgFromOptions(opts) {\n\tif (!opts || !opts.hashAlgo || opts.hashAlgo === 'sha1')\n\t\treturn ('5 (RSASHA1)');\n\telse if (opts.hashAlgo === 'sha256')\n\t\treturn ('8 (RSASHA256)');\n\telse if (opts.hashAlgo === 'sha512')\n\t\treturn ('10 (RSASHA512)');\n\telse\n\t\tthrow (new Error('Unknown or unsupported hash: ' +\n\t\t    opts.hashAlgo));\n}\n\nfunction writeRSA(key, options) {\n\t// if we're missing parts, add them.\n\tif (!key.part.dmodp || !key.part.dmodq) {\n\t\tutils.addRSAMissing(key);\n\t}\n\n\tvar out = '';\n\tout += 'Private-key-format: v1.3\\n';\n\tout += 'Algorithm: ' + rsaAlgFromOptions(options) + '\\n';\n\tvar n = utils.mpDenormalize(key.part['n'].data);\n\tout += 'Modulus: ' + n.toString('base64') + '\\n';\n\tvar e = utils.mpDenormalize(key.part['e'].data);\n\tout += 'PublicExponent: ' + e.toString('base64') + '\\n';\n\tvar d = utils.mpDenormalize(key.part['d'].data);\n\tout += 'PrivateExponent: ' + d.toString('base64') + '\\n';\n\tvar p = utils.mpDenormalize(key.part['p'].data);\n\tout += 'Prime1: ' + p.toString('base64') + '\\n';\n\tvar q = utils.mpDenormalize(key.part['q'].data);\n\tout += 'Prime2: ' + q.toString('base64') + '\\n';\n\tvar dmodp = utils.mpDenormalize(key.part['dmodp'].data);\n\tout += 'Exponent1: ' + dmodp.toString('base64') + '\\n';\n\tvar dmodq = utils.mpDenormalize(key.part['dmodq'].data);\n\tout += 'Exponent2: ' + dmodq.toString('base64') + '\\n';\n\tvar iqmp = utils.mpDenormalize(key.part['iqmp'].data);\n\tout += 'Coefficient: ' + iqmp.toString('base64') + '\\n';\n\t// Assume that we're valid as-of now\n\tvar timestamp = new Date();\n\tout += 'Created: ' + dnssecTimestamp(timestamp) + '\\n';\n\tout += 'Publish: ' + dnssecTimestamp(timestamp) + '\\n';\n\tout += 'Activate: ' + dnssecTimestamp(timestamp) + '\\n';\n\treturn (Buffer.from(out, 'ascii'));\n}\n\nfunction writeECDSA(key, options) {\n\tvar out = '';\n\tout += 'Private-key-format: v1.3\\n';\n\n\tif (key.curve === 'nistp256') {\n\t\tout += 'Algorithm: 13 (ECDSAP256SHA256)\\n';\n\t} else if (key.curve === 'nistp384') {\n\t\tout += 'Algorithm: 14 (ECDSAP384SHA384)\\n';\n\t} else {\n\t\tthrow (new Error('Unsupported curve'));\n\t}\n\tvar base64Key = key.part['d'].data.toString('base64');\n\tout += 'PrivateKey: ' + base64Key + '\\n';\n\n\t// Assume that we're valid as-of now\n\tvar timestamp = new Date();\n\tout += 'Created: ' + dnssecTimestamp(timestamp) + '\\n';\n\tout += 'Publish: ' + dnssecTimestamp(timestamp) + '\\n';\n\tout += 'Activate: ' + dnssecTimestamp(timestamp) + '\\n';\n\n\treturn (Buffer.from(out, 'ascii'));\n}\n\nfunction write(key, options) {\n\tif (PrivateKey.isPrivateKey(key)) {\n\t\tif (key.type === 'rsa') {\n\t\t\treturn (writeRSA(key, options));\n\t\t} else if (key.type === 'ecdsa') {\n\t\t\treturn (writeECDSA(key, options));\n\t\t} else {\n\t\t\tthrow (new Error('Unsupported algorithm: ' + key.type));\n\t\t}\n\t} else if (Key.isKey(key)) {\n\t\t/*\n\t\t * RFC3110 requires a keyname, and a keytype, which we\n\t\t * don't really have a mechanism for specifying such\n\t\t * additional metadata.\n\t\t */\n\t\tthrow (new Error('Format \"dnssec\" only supports ' +\n\t\t    'writing private keys'));\n\t} else {\n\t\tthrow (new Error('key is not a Key or PrivateKey'));\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9kbnNzZWMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDBFQUFhO0FBQ2xDLGFBQWEseUdBQThCO0FBQzNDLFVBQVUsbUJBQU8sQ0FBQyxnRUFBUTtBQUMxQixpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBZ0I7QUFDekMsWUFBWSxtQkFBTyxDQUFDLG9FQUFVO0FBQzlCLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFlO0FBQ3ZDLFVBQVUsbUJBQU8sQ0FBQyxnRUFBUTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RCxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHlDQUF5QztBQUM5QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxtREFBbUQ7QUFDeEQsS0FBSyxtREFBbUQ7QUFDeEQsS0FBSyxtREFBbUQ7QUFDeEQsS0FBSyxtREFBbUQ7QUFDeEQsS0FBSyxtREFBbUQ7QUFDeEQsS0FBSztBQUNMLG1EQUFtRDtBQUNuRCxLQUFLO0FBQ0wsbURBQW1EO0FBQ25ELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsseUNBQXlDO0FBQzlDLEtBQUssb0JBQW9CO0FBQ3pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvZG5zc2VjLmpzP2NiMjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTcgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRyZWFkOiByZWFkLFxuXHR3cml0ZTogd3JpdGVcbn07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBLZXkgPSByZXF1aXJlKCcuLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZS1rZXknKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgU1NIQnVmZmVyID0gcmVxdWlyZSgnLi4vc3NoLWJ1ZmZlcicpO1xudmFyIERoZSA9IHJlcXVpcmUoJy4uL2RoZScpO1xuXG52YXIgc3VwcG9ydGVkQWxnb3MgPSB7XG5cdCdyc2Etc2hhMScgOiA1LFxuXHQncnNhLXNoYTI1NicgOiA4LFxuXHQncnNhLXNoYTUxMicgOiAxMCxcblx0J2VjZHNhLXAyNTYtc2hhMjU2JyA6IDEzLFxuXHQnZWNkc2EtcDM4NC1zaGEzODQnIDogMTRcblx0Lypcblx0ICogZWQyNTUxOSBpcyBoeXBvdGhldGljYWxseSBzdXBwb3J0ZWQgd2l0aCBpZCAxNVxuXHQgKiBidXQgdGhlIGNvbW1vbiB0b29scyBhdmFpbGFibGUgZG9uJ3QgYXBwZWFyIHRvIGJlXG5cdCAqIGNhcGFibGUgb2YgZ2VuZXJhdGluZy91c2luZyBlZDI1NTE5IGtleXNcblx0ICovXG59O1xuXG52YXIgc3VwcG9ydGVkQWxnb3NCeUlkID0ge307XG5PYmplY3Qua2V5cyhzdXBwb3J0ZWRBbGdvcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRzdXBwb3J0ZWRBbGdvc0J5SWRbc3VwcG9ydGVkQWxnb3Nba11dID0gay50b1VwcGVyQ2FzZSgpO1xufSk7XG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgKGJ1ZikgIT09ICdzdHJpbmcnKSB7XG5cdFx0YXNzZXJ0LmJ1ZmZlcihidWYsICdidWYnKTtcblx0XHRidWYgPSBidWYudG9TdHJpbmcoJ2FzY2lpJyk7XG5cdH1cblx0dmFyIGxpbmVzID0gYnVmLnNwbGl0KCdcXG4nKTtcblx0aWYgKGxpbmVzWzBdLm1hdGNoKC9eUHJpdmF0ZS1rZXktZm9ybWF0XFw6IHYxLykpIHtcblx0XHR2YXIgYWxnRWxlbXMgPSBsaW5lc1sxXS5zcGxpdCgnICcpO1xuXHRcdHZhciBhbGdvTnVtID0gcGFyc2VJbnQoYWxnRWxlbXNbMV0sIDEwKTtcblx0XHR2YXIgYWxnb05hbWUgPSBhbGdFbGVtc1syXTtcblx0XHRpZiAoIXN1cHBvcnRlZEFsZ29zQnlJZFthbGdvTnVtXSlcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFsZ29yaXRobTogJyArIGFsZ29OYW1lKSk7XG5cdFx0cmV0dXJuIChyZWFkRE5TU0VDUHJpdmF0ZUtleShhbGdvTnVtLCBsaW5lcy5zbGljZSgyKSkpO1xuXHR9XG5cblx0Ly8gc2tpcCBhbnkgY29tbWVudC1saW5lc1xuXHR2YXIgbGluZSA9IDA7XG5cdC8qIEpTU1RZTEVEICovXG5cdHdoaWxlIChsaW5lc1tsaW5lXS5tYXRjaCgvXlxcOy8pKVxuXHRcdGxpbmUrKztcblx0Ly8gd2Ugc2hvdWxkIG5vdyBoYXZlICpvbmUgc2luZ2xlKiBsaW5lIGxlZnQgd2l0aCBvdXIgS0VZIG9uIGl0LlxuXHRpZiAoKGxpbmVzW2xpbmVdLm1hdGNoKC9cXC4gSU4gS0VZIC8pIHx8XG5cdCAgICBsaW5lc1tsaW5lXS5tYXRjaCgvXFwuIElOIEROU0tFWSAvKSkgJiYgbGluZXNbbGluZSsxXS5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gKHJlYWRSRkMzMTEwKGxpbmVzW2xpbmVdKSk7XG5cdH1cblx0dGhyb3cgKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIGRuc3NlYyBrZXknKSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRSRkMzMTEwKGtleVN0cmluZykge1xuXHR2YXIgZWxlbXMgPSBrZXlTdHJpbmcuc3BsaXQoJyAnKTtcblx0Ly91bnVzZWQgdmFyIGZsYWdzID0gcGFyc2VJbnQoZWxlbXNbM10sIDEwKTtcblx0Ly91bnVzZWQgdmFyIHByb3RvY29sID0gcGFyc2VJbnQoZWxlbXNbNF0sIDEwKTtcblx0dmFyIGFsZ29yaXRobSA9IHBhcnNlSW50KGVsZW1zWzVdLCAxMCk7XG5cdGlmICghc3VwcG9ydGVkQWxnb3NCeUlkW2FsZ29yaXRobV0pXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKSk7XG5cdHZhciBiYXNlNjRrZXkgPSBlbGVtcy5zbGljZSg2LCBlbGVtcy5sZW5ndGgpLmpvaW4oKTtcblx0dmFyIGtleUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJhc2U2NGtleSwgJ2Jhc2U2NCcpO1xuXHRpZiAoc3VwcG9ydGVkQWxnb3NCeUlkW2FsZ29yaXRobV0ubWF0Y2goL15SU0EtLykpIHtcblx0XHQvLyBqb2luIHRoZSByZXN0IG9mIHRoZSBib2R5IGludG8gYSBzaW5nbGUgYmFzZTY0LWJsb2Jcblx0XHR2YXIgcHVibGljRXhwb25lbnRMZW4gPSBrZXlCdWZmZXIucmVhZFVJbnQ4KDApO1xuXHRcdGlmIChwdWJsaWNFeHBvbmVudExlbiAhPSAzICYmIHB1YmxpY0V4cG9uZW50TGVuICE9IDEpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgZG5zc2VjIGtleTogJyArXG5cdFx0XHQgICAgJ3Vuc3VwcG9ydGVkIGV4cG9uZW50IGxlbmd0aCcpKTtcblxuXHRcdHZhciBwdWJsaWNFeHBvbmVudCA9IGtleUJ1ZmZlci5zbGljZSgxLCBwdWJsaWNFeHBvbmVudExlbisxKTtcblx0XHRwdWJsaWNFeHBvbmVudCA9IHV0aWxzLm1wTm9ybWFsaXplKHB1YmxpY0V4cG9uZW50KTtcblx0XHR2YXIgbW9kdWx1cyA9IGtleUJ1ZmZlci5zbGljZSgxK3B1YmxpY0V4cG9uZW50TGVuKTtcblx0XHRtb2R1bHVzID0gdXRpbHMubXBOb3JtYWxpemUobW9kdWx1cyk7XG5cdFx0Ly8gbm93LCBtYWtlIHRoZSBrZXlcblx0XHR2YXIgcnNhS2V5ID0ge1xuXHRcdFx0dHlwZTogJ3JzYScsXG5cdFx0XHRwYXJ0czogW11cblx0XHR9O1xuXHRcdHJzYUtleS5wYXJ0cy5wdXNoKHsgbmFtZTogJ2UnLCBkYXRhOiBwdWJsaWNFeHBvbmVudH0pO1xuXHRcdHJzYUtleS5wYXJ0cy5wdXNoKHsgbmFtZTogJ24nLCBkYXRhOiBtb2R1bHVzfSk7XG5cdFx0cmV0dXJuIChuZXcgS2V5KHJzYUtleSkpO1xuXHR9XG5cdGlmIChzdXBwb3J0ZWRBbGdvc0J5SWRbYWxnb3JpdGhtXSA9PT0gJ0VDRFNBLVAzODQtU0hBMzg0JyB8fFxuXHQgICAgc3VwcG9ydGVkQWxnb3NCeUlkW2FsZ29yaXRobV0gPT09ICdFQ0RTQS1QMjU2LVNIQTI1NicpIHtcblx0XHR2YXIgY3VydmUgPSAnbmlzdHAzODQnO1xuXHRcdHZhciBzaXplID0gMzg0O1xuXHRcdGlmIChzdXBwb3J0ZWRBbGdvc0J5SWRbYWxnb3JpdGhtXS5tYXRjaCgvXkVDRFNBLVAyNTYtU0hBMjU2LykpIHtcblx0XHRcdGN1cnZlID0gJ25pc3RwMjU2Jztcblx0XHRcdHNpemUgPSAyNTY7XG5cdFx0fVxuXG5cdFx0dmFyIGVjZHNhS2V5ID0ge1xuXHRcdFx0dHlwZTogJ2VjZHNhJyxcblx0XHRcdGN1cnZlOiBjdXJ2ZSxcblx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRwYXJ0czogW1xuXHRcdFx0XHR7bmFtZTogJ2N1cnZlJywgZGF0YTogQnVmZmVyLmZyb20oY3VydmUpIH0sXG5cdFx0XHRcdHtuYW1lOiAnUScsIGRhdGE6IHV0aWxzLmVjTm9ybWFsaXplKGtleUJ1ZmZlcikgfVxuXHRcdFx0XVxuXHRcdH07XG5cdFx0cmV0dXJuIChuZXcgS2V5KGVjZHNhS2V5KSk7XG5cdH1cblx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiAnICtcblx0ICAgIHN1cHBvcnRlZEFsZ29zQnlJZFthbGdvcml0aG1dKSk7XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRUb0J1ZihlKSB7XG5cdHJldHVybiAoQnVmZmVyLmZyb20oZS5zcGxpdCgnICcpWzFdLCAnYmFzZTY0JykpO1xufVxuXG5mdW5jdGlvbiByZWFkRE5TU0VDUlNBUHJpdmF0ZUtleShlbGVtZW50cykge1xuXHR2YXIgcnNhUGFyYW1zID0ge307XG5cdGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRpZiAoZWxlbWVudC5zcGxpdCgnICcpWzBdID09PSAnTW9kdWx1czonKVxuXHRcdFx0cnNhUGFyYW1zWyduJ10gPSBlbGVtZW50VG9CdWYoZWxlbWVudCk7XG5cdFx0ZWxzZSBpZiAoZWxlbWVudC5zcGxpdCgnICcpWzBdID09PSAnUHVibGljRXhwb25lbnQ6Jylcblx0XHRcdHJzYVBhcmFtc1snZSddID0gZWxlbWVudFRvQnVmKGVsZW1lbnQpO1xuXHRcdGVsc2UgaWYgKGVsZW1lbnQuc3BsaXQoJyAnKVswXSA9PT0gJ1ByaXZhdGVFeHBvbmVudDonKVxuXHRcdFx0cnNhUGFyYW1zWydkJ10gPSBlbGVtZW50VG9CdWYoZWxlbWVudCk7XG5cdFx0ZWxzZSBpZiAoZWxlbWVudC5zcGxpdCgnICcpWzBdID09PSAnUHJpbWUxOicpXG5cdFx0XHRyc2FQYXJhbXNbJ3AnXSA9IGVsZW1lbnRUb0J1ZihlbGVtZW50KTtcblx0XHRlbHNlIGlmIChlbGVtZW50LnNwbGl0KCcgJylbMF0gPT09ICdQcmltZTI6Jylcblx0XHRcdHJzYVBhcmFtc1sncSddID0gZWxlbWVudFRvQnVmKGVsZW1lbnQpO1xuXHRcdGVsc2UgaWYgKGVsZW1lbnQuc3BsaXQoJyAnKVswXSA9PT0gJ0V4cG9uZW50MTonKVxuXHRcdFx0cnNhUGFyYW1zWydkbW9kcCddID0gZWxlbWVudFRvQnVmKGVsZW1lbnQpO1xuXHRcdGVsc2UgaWYgKGVsZW1lbnQuc3BsaXQoJyAnKVswXSA9PT0gJ0V4cG9uZW50MjonKVxuXHRcdFx0cnNhUGFyYW1zWydkbW9kcSddID0gZWxlbWVudFRvQnVmKGVsZW1lbnQpO1xuXHRcdGVsc2UgaWYgKGVsZW1lbnQuc3BsaXQoJyAnKVswXSA9PT0gJ0NvZWZmaWNpZW50OicpXG5cdFx0XHRyc2FQYXJhbXNbJ2lxbXAnXSA9IGVsZW1lbnRUb0J1ZihlbGVtZW50KTtcblx0fSk7XG5cdC8vIG5vdywgbWFrZSB0aGUga2V5XG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ3JzYScsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ2UnLCBkYXRhOiB1dGlscy5tcE5vcm1hbGl6ZShyc2FQYXJhbXNbJ2UnXSl9LFxuXHRcdFx0eyBuYW1lOiAnbicsIGRhdGE6IHV0aWxzLm1wTm9ybWFsaXplKHJzYVBhcmFtc1snbiddKX0sXG5cdFx0XHR7IG5hbWU6ICdkJywgZGF0YTogdXRpbHMubXBOb3JtYWxpemUocnNhUGFyYW1zWydkJ10pfSxcblx0XHRcdHsgbmFtZTogJ3AnLCBkYXRhOiB1dGlscy5tcE5vcm1hbGl6ZShyc2FQYXJhbXNbJ3AnXSl9LFxuXHRcdFx0eyBuYW1lOiAncScsIGRhdGE6IHV0aWxzLm1wTm9ybWFsaXplKHJzYVBhcmFtc1sncSddKX0sXG5cdFx0XHR7IG5hbWU6ICdkbW9kcCcsXG5cdFx0XHQgICAgZGF0YTogdXRpbHMubXBOb3JtYWxpemUocnNhUGFyYW1zWydkbW9kcCddKX0sXG5cdFx0XHR7IG5hbWU6ICdkbW9kcScsXG5cdFx0XHQgICAgZGF0YTogdXRpbHMubXBOb3JtYWxpemUocnNhUGFyYW1zWydkbW9kcSddKX0sXG5cdFx0XHR7IG5hbWU6ICdpcW1wJyxcblx0XHRcdCAgICBkYXRhOiB1dGlscy5tcE5vcm1hbGl6ZShyc2FQYXJhbXNbJ2lxbXAnXSl9XG5cdFx0XVxuXHR9O1xuXHRyZXR1cm4gKG5ldyBQcml2YXRlS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiByZWFkRE5TU0VDUHJpdmF0ZUtleShhbGcsIGVsZW1lbnRzKSB7XG5cdGlmIChzdXBwb3J0ZWRBbGdvc0J5SWRbYWxnXS5tYXRjaCgvXlJTQS0vKSkge1xuXHRcdHJldHVybiAocmVhZEROU1NFQ1JTQVByaXZhdGVLZXkoZWxlbWVudHMpKTtcblx0fVxuXHRpZiAoc3VwcG9ydGVkQWxnb3NCeUlkW2FsZ10gPT09ICdFQ0RTQS1QMzg0LVNIQTM4NCcgfHxcblx0ICAgIHN1cHBvcnRlZEFsZ29zQnlJZFthbGddID09PSAnRUNEU0EtUDI1Ni1TSEEyNTYnKSB7XG5cdFx0dmFyIGQgPSBCdWZmZXIuZnJvbShlbGVtZW50c1swXS5zcGxpdCgnICcpWzFdLCAnYmFzZTY0Jyk7XG5cdFx0dmFyIGN1cnZlID0gJ25pc3RwMzg0Jztcblx0XHR2YXIgc2l6ZSA9IDM4NDtcblx0XHRpZiAoc3VwcG9ydGVkQWxnb3NCeUlkW2FsZ10gPT09ICdFQ0RTQS1QMjU2LVNIQTI1NicpIHtcblx0XHRcdGN1cnZlID0gJ25pc3RwMjU2Jztcblx0XHRcdHNpemUgPSAyNTY7XG5cdFx0fVxuXHRcdC8vIEROU1NFQyBnZW5lcmF0ZXMgdGhlIHB1YmxpYy1rZXkgb24gdGhlIGZseSAoZ28gY2FsY3VsYXRlIGl0KVxuXHRcdHZhciBwdWJsaWNLZXkgPSB1dGlscy5wdWJsaWNGcm9tUHJpdmF0ZUVDRFNBKGN1cnZlLCBkKTtcblx0XHR2YXIgUSA9IHB1YmxpY0tleS5wYXJ0WydRJ10uZGF0YTtcblx0XHR2YXIgZWNkc2FLZXkgPSB7XG5cdFx0XHR0eXBlOiAnZWNkc2EnLFxuXHRcdFx0Y3VydmU6IGN1cnZlLFxuXHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdHBhcnRzOiBbXG5cdFx0XHRcdHtuYW1lOiAnY3VydmUnLCBkYXRhOiBCdWZmZXIuZnJvbShjdXJ2ZSkgfSxcblx0XHRcdFx0e25hbWU6ICdkJywgZGF0YTogZCB9LFxuXHRcdFx0XHR7bmFtZTogJ1EnLCBkYXRhOiBRIH1cblx0XHRcdF1cblx0XHR9O1xuXHRcdHJldHVybiAobmV3IFByaXZhdGVLZXkoZWNkc2FLZXkpKTtcblx0fVxuXHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBhbGdvcml0aG06ICcgKyBzdXBwb3J0ZWRBbGdvc0J5SWRbYWxnXSkpO1xufVxuXG5mdW5jdGlvbiBkbnNzZWNUaW1lc3RhbXAoZGF0ZSkge1xuXHR2YXIgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKSArICcnOyAvL3N0cmluZ2lmeVxuXHR2YXIgbW9udGggPSAoZGF0ZS5nZXRNb250aCgpICsgMSk7XG5cdHZhciB0aW1lc3RhbXBTdHIgPSB5ZWFyICsgbW9udGggKyBkYXRlLmdldFVUQ0RhdGUoKTtcblx0dGltZXN0YW1wU3RyICs9ICcnICsgZGF0ZS5nZXRVVENIb3VycygpICsgZGF0ZS5nZXRVVENNaW51dGVzKCk7XG5cdHRpbWVzdGFtcFN0ciArPSBkYXRlLmdldFVUQ1NlY29uZHMoKTtcblx0cmV0dXJuICh0aW1lc3RhbXBTdHIpO1xufVxuXG5mdW5jdGlvbiByc2FBbGdGcm9tT3B0aW9ucyhvcHRzKSB7XG5cdGlmICghb3B0cyB8fCAhb3B0cy5oYXNoQWxnbyB8fCBvcHRzLmhhc2hBbGdvID09PSAnc2hhMScpXG5cdFx0cmV0dXJuICgnNSAoUlNBU0hBMSknKTtcblx0ZWxzZSBpZiAob3B0cy5oYXNoQWxnbyA9PT0gJ3NoYTI1NicpXG5cdFx0cmV0dXJuICgnOCAoUlNBU0hBMjU2KScpO1xuXHRlbHNlIGlmIChvcHRzLmhhc2hBbGdvID09PSAnc2hhNTEyJylcblx0XHRyZXR1cm4gKCcxMCAoUlNBU0hBNTEyKScpO1xuXHRlbHNlXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biBvciB1bnN1cHBvcnRlZCBoYXNoOiAnICtcblx0XHQgICAgb3B0cy5oYXNoQWxnbykpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVJTQShrZXksIG9wdGlvbnMpIHtcblx0Ly8gaWYgd2UncmUgbWlzc2luZyBwYXJ0cywgYWRkIHRoZW0uXG5cdGlmICgha2V5LnBhcnQuZG1vZHAgfHwgIWtleS5wYXJ0LmRtb2RxKSB7XG5cdFx0dXRpbHMuYWRkUlNBTWlzc2luZyhrZXkpO1xuXHR9XG5cblx0dmFyIG91dCA9ICcnO1xuXHRvdXQgKz0gJ1ByaXZhdGUta2V5LWZvcm1hdDogdjEuM1xcbic7XG5cdG91dCArPSAnQWxnb3JpdGhtOiAnICsgcnNhQWxnRnJvbU9wdGlvbnMob3B0aW9ucykgKyAnXFxuJztcblx0dmFyIG4gPSB1dGlscy5tcERlbm9ybWFsaXplKGtleS5wYXJ0WyduJ10uZGF0YSk7XG5cdG91dCArPSAnTW9kdWx1czogJyArIG4udG9TdHJpbmcoJ2Jhc2U2NCcpICsgJ1xcbic7XG5cdHZhciBlID0gdXRpbHMubXBEZW5vcm1hbGl6ZShrZXkucGFydFsnZSddLmRhdGEpO1xuXHRvdXQgKz0gJ1B1YmxpY0V4cG9uZW50OiAnICsgZS50b1N0cmluZygnYmFzZTY0JykgKyAnXFxuJztcblx0dmFyIGQgPSB1dGlscy5tcERlbm9ybWFsaXplKGtleS5wYXJ0WydkJ10uZGF0YSk7XG5cdG91dCArPSAnUHJpdmF0ZUV4cG9uZW50OiAnICsgZC50b1N0cmluZygnYmFzZTY0JykgKyAnXFxuJztcblx0dmFyIHAgPSB1dGlscy5tcERlbm9ybWFsaXplKGtleS5wYXJ0WydwJ10uZGF0YSk7XG5cdG91dCArPSAnUHJpbWUxOiAnICsgcC50b1N0cmluZygnYmFzZTY0JykgKyAnXFxuJztcblx0dmFyIHEgPSB1dGlscy5tcERlbm9ybWFsaXplKGtleS5wYXJ0WydxJ10uZGF0YSk7XG5cdG91dCArPSAnUHJpbWUyOiAnICsgcS50b1N0cmluZygnYmFzZTY0JykgKyAnXFxuJztcblx0dmFyIGRtb2RwID0gdXRpbHMubXBEZW5vcm1hbGl6ZShrZXkucGFydFsnZG1vZHAnXS5kYXRhKTtcblx0b3V0ICs9ICdFeHBvbmVudDE6ICcgKyBkbW9kcC50b1N0cmluZygnYmFzZTY0JykgKyAnXFxuJztcblx0dmFyIGRtb2RxID0gdXRpbHMubXBEZW5vcm1hbGl6ZShrZXkucGFydFsnZG1vZHEnXS5kYXRhKTtcblx0b3V0ICs9ICdFeHBvbmVudDI6ICcgKyBkbW9kcS50b1N0cmluZygnYmFzZTY0JykgKyAnXFxuJztcblx0dmFyIGlxbXAgPSB1dGlscy5tcERlbm9ybWFsaXplKGtleS5wYXJ0WydpcW1wJ10uZGF0YSk7XG5cdG91dCArPSAnQ29lZmZpY2llbnQ6ICcgKyBpcW1wLnRvU3RyaW5nKCdiYXNlNjQnKSArICdcXG4nO1xuXHQvLyBBc3N1bWUgdGhhdCB3ZSdyZSB2YWxpZCBhcy1vZiBub3dcblx0dmFyIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG5cdG91dCArPSAnQ3JlYXRlZDogJyArIGRuc3NlY1RpbWVzdGFtcCh0aW1lc3RhbXApICsgJ1xcbic7XG5cdG91dCArPSAnUHVibGlzaDogJyArIGRuc3NlY1RpbWVzdGFtcCh0aW1lc3RhbXApICsgJ1xcbic7XG5cdG91dCArPSAnQWN0aXZhdGU6ICcgKyBkbnNzZWNUaW1lc3RhbXAodGltZXN0YW1wKSArICdcXG4nO1xuXHRyZXR1cm4gKEJ1ZmZlci5mcm9tKG91dCwgJ2FzY2lpJykpO1xufVxuXG5mdW5jdGlvbiB3cml0ZUVDRFNBKGtleSwgb3B0aW9ucykge1xuXHR2YXIgb3V0ID0gJyc7XG5cdG91dCArPSAnUHJpdmF0ZS1rZXktZm9ybWF0OiB2MS4zXFxuJztcblxuXHRpZiAoa2V5LmN1cnZlID09PSAnbmlzdHAyNTYnKSB7XG5cdFx0b3V0ICs9ICdBbGdvcml0aG06IDEzIChFQ0RTQVAyNTZTSEEyNTYpXFxuJztcblx0fSBlbHNlIGlmIChrZXkuY3VydmUgPT09ICduaXN0cDM4NCcpIHtcblx0XHRvdXQgKz0gJ0FsZ29yaXRobTogMTQgKEVDRFNBUDM4NFNIQTM4NClcXG4nO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGN1cnZlJykpO1xuXHR9XG5cdHZhciBiYXNlNjRLZXkgPSBrZXkucGFydFsnZCddLmRhdGEudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXHRvdXQgKz0gJ1ByaXZhdGVLZXk6ICcgKyBiYXNlNjRLZXkgKyAnXFxuJztcblxuXHQvLyBBc3N1bWUgdGhhdCB3ZSdyZSB2YWxpZCBhcy1vZiBub3dcblx0dmFyIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG5cdG91dCArPSAnQ3JlYXRlZDogJyArIGRuc3NlY1RpbWVzdGFtcCh0aW1lc3RhbXApICsgJ1xcbic7XG5cdG91dCArPSAnUHVibGlzaDogJyArIGRuc3NlY1RpbWVzdGFtcCh0aW1lc3RhbXApICsgJ1xcbic7XG5cdG91dCArPSAnQWN0aXZhdGU6ICcgKyBkbnNzZWNUaW1lc3RhbXAodGltZXN0YW1wKSArICdcXG4nO1xuXG5cdHJldHVybiAoQnVmZmVyLmZyb20ob3V0LCAnYXNjaWknKSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgb3B0aW9ucykge1xuXHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSkge1xuXHRcdGlmIChrZXkudHlwZSA9PT0gJ3JzYScpIHtcblx0XHRcdHJldHVybiAod3JpdGVSU0Eoa2V5LCBvcHRpb25zKSk7XG5cdFx0fSBlbHNlIGlmIChrZXkudHlwZSA9PT0gJ2VjZHNhJykge1xuXHRcdFx0cmV0dXJuICh3cml0ZUVDRFNBKGtleSwgb3B0aW9ucykpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBhbGdvcml0aG06ICcgKyBrZXkudHlwZSkpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChLZXkuaXNLZXkoa2V5KSkge1xuXHRcdC8qXG5cdFx0ICogUkZDMzExMCByZXF1aXJlcyBhIGtleW5hbWUsIGFuZCBhIGtleXR5cGUsIHdoaWNoIHdlXG5cdFx0ICogZG9uJ3QgcmVhbGx5IGhhdmUgYSBtZWNoYW5pc20gZm9yIHNwZWNpZnlpbmcgc3VjaFxuXHRcdCAqIGFkZGl0aW9uYWwgbWV0YWRhdGEuXG5cdFx0ICovXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignRm9ybWF0IFwiZG5zc2VjXCIgb25seSBzdXBwb3J0cyAnICtcblx0XHQgICAgJ3dyaXRpbmcgcHJpdmF0ZSBrZXlzJykpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ2tleSBpcyBub3QgYSBLZXkgb3IgUHJpdmF0ZUtleScpKTtcblx0fVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/formats/dnssec.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/formats/dnssec.js":
/*!**************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/dnssec.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2017 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar Key = __webpack_require__(/*! ../key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ \"(rsc)/./node_modules/sshpk/lib/ssh-buffer.js\");\nvar Dhe = __webpack_require__(/*! ../dhe */ \"(rsc)/./node_modules/sshpk/lib/dhe.js\");\n\nvar supportedAlgos = {\n\t'rsa-sha1' : 5,\n\t'rsa-sha256' : 8,\n\t'rsa-sha512' : 10,\n\t'ecdsa-p256-sha256' : 13,\n\t'ecdsa-p384-sha384' : 14\n\t/*\n\t * ed25519 is hypothetically supported with id 15\n\t * but the common tools available don't appear to be\n\t * capable of generating/using ed25519 keys\n\t */\n};\n\nvar supportedAlgosById = {};\nObject.keys(supportedAlgos).forEach(function (k) {\n\tsupportedAlgosById[supportedAlgos[k]] = k.toUpperCase();\n});\n\nfunction read(buf, options) {\n\tif (typeof (buf) !== 'string') {\n\t\tassert.buffer(buf, 'buf');\n\t\tbuf = buf.toString('ascii');\n\t}\n\tvar lines = buf.split('\\n');\n\tif (lines[0].match(/^Private-key-format\\: v1/)) {\n\t\tvar algElems = lines[1].split(' ');\n\t\tvar algoNum = parseInt(algElems[1], 10);\n\t\tvar algoName = algElems[2];\n\t\tif (!supportedAlgosById[algoNum])\n\t\t\tthrow (new Error('Unsupported algorithm: ' + algoName));\n\t\treturn (readDNSSECPrivateKey(algoNum, lines.slice(2)));\n\t}\n\n\t// skip any comment-lines\n\tvar line = 0;\n\t/* JSSTYLED */\n\twhile (lines[line].match(/^\\;/))\n\t\tline++;\n\t// we should now have *one single* line left with our KEY on it.\n\tif ((lines[line].match(/\\. IN KEY /) ||\n\t    lines[line].match(/\\. IN DNSKEY /)) && lines[line+1].length === 0) {\n\t\treturn (readRFC3110(lines[line]));\n\t}\n\tthrow (new Error('Cannot parse dnssec key'));\n}\n\nfunction readRFC3110(keyString) {\n\tvar elems = keyString.split(' ');\n\t//unused var flags = parseInt(elems[3], 10);\n\t//unused var protocol = parseInt(elems[4], 10);\n\tvar algorithm = parseInt(elems[5], 10);\n\tif (!supportedAlgosById[algorithm])\n\t\tthrow (new Error('Unsupported algorithm: ' + algorithm));\n\tvar base64key = elems.slice(6, elems.length).join();\n\tvar keyBuffer = Buffer.from(base64key, 'base64');\n\tif (supportedAlgosById[algorithm].match(/^RSA-/)) {\n\t\t// join the rest of the body into a single base64-blob\n\t\tvar publicExponentLen = keyBuffer.readUInt8(0);\n\t\tif (publicExponentLen != 3 && publicExponentLen != 1)\n\t\t\tthrow (new Error('Cannot parse dnssec key: ' +\n\t\t\t    'unsupported exponent length'));\n\n\t\tvar publicExponent = keyBuffer.slice(1, publicExponentLen+1);\n\t\tpublicExponent = utils.mpNormalize(publicExponent);\n\t\tvar modulus = keyBuffer.slice(1+publicExponentLen);\n\t\tmodulus = utils.mpNormalize(modulus);\n\t\t// now, make the key\n\t\tvar rsaKey = {\n\t\t\ttype: 'rsa',\n\t\t\tparts: []\n\t\t};\n\t\trsaKey.parts.push({ name: 'e', data: publicExponent});\n\t\trsaKey.parts.push({ name: 'n', data: modulus});\n\t\treturn (new Key(rsaKey));\n\t}\n\tif (supportedAlgosById[algorithm] === 'ECDSA-P384-SHA384' ||\n\t    supportedAlgosById[algorithm] === 'ECDSA-P256-SHA256') {\n\t\tvar curve = 'nistp384';\n\t\tvar size = 384;\n\t\tif (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {\n\t\t\tcurve = 'nistp256';\n\t\t\tsize = 256;\n\t\t}\n\n\t\tvar ecdsaKey = {\n\t\t\ttype: 'ecdsa',\n\t\t\tcurve: curve,\n\t\t\tsize: size,\n\t\t\tparts: [\n\t\t\t\t{name: 'curve', data: Buffer.from(curve) },\n\t\t\t\t{name: 'Q', data: utils.ecNormalize(keyBuffer) }\n\t\t\t]\n\t\t};\n\t\treturn (new Key(ecdsaKey));\n\t}\n\tthrow (new Error('Unsupported algorithm: ' +\n\t    supportedAlgosById[algorithm]));\n}\n\nfunction elementToBuf(e) {\n\treturn (Buffer.from(e.split(' ')[1], 'base64'));\n}\n\nfunction readDNSSECRSAPrivateKey(elements) {\n\tvar rsaParams = {};\n\telements.forEach(function (element) {\n\t\tif (element.split(' ')[0] === 'Modulus:')\n\t\t\trsaParams['n'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'PublicExponent:')\n\t\t\trsaParams['e'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'PrivateExponent:')\n\t\t\trsaParams['d'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'Prime1:')\n\t\t\trsaParams['p'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'Prime2:')\n\t\t\trsaParams['q'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'Exponent1:')\n\t\t\trsaParams['dmodp'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'Exponent2:')\n\t\t\trsaParams['dmodq'] = elementToBuf(element);\n\t\telse if (element.split(' ')[0] === 'Coefficient:')\n\t\t\trsaParams['iqmp'] = elementToBuf(element);\n\t});\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'rsa',\n\t\tparts: [\n\t\t\t{ name: 'e', data: utils.mpNormalize(rsaParams['e'])},\n\t\t\t{ name: 'n', data: utils.mpNormalize(rsaParams['n'])},\n\t\t\t{ name: 'd', data: utils.mpNormalize(rsaParams['d'])},\n\t\t\t{ name: 'p', data: utils.mpNormalize(rsaParams['p'])},\n\t\t\t{ name: 'q', data: utils.mpNormalize(rsaParams['q'])},\n\t\t\t{ name: 'dmodp',\n\t\t\t    data: utils.mpNormalize(rsaParams['dmodp'])},\n\t\t\t{ name: 'dmodq',\n\t\t\t    data: utils.mpNormalize(rsaParams['dmodq'])},\n\t\t\t{ name: 'iqmp',\n\t\t\t    data: utils.mpNormalize(rsaParams['iqmp'])}\n\t\t]\n\t};\n\treturn (new PrivateKey(key));\n}\n\nfunction readDNSSECPrivateKey(alg, elements) {\n\tif (supportedAlgosById[alg].match(/^RSA-/)) {\n\t\treturn (readDNSSECRSAPrivateKey(elements));\n\t}\n\tif (supportedAlgosById[alg] === 'ECDSA-P384-SHA384' ||\n\t    supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {\n\t\tvar d = Buffer.from(elements[0].split(' ')[1], 'base64');\n\t\tvar curve = 'nistp384';\n\t\tvar size = 384;\n\t\tif (supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {\n\t\t\tcurve = 'nistp256';\n\t\t\tsize = 256;\n\t\t}\n\t\t// DNSSEC generates the public-key on the fly (go calculate it)\n\t\tvar publicKey = utils.publicFromPrivateECDSA(curve, d);\n\t\tvar Q = publicKey.part['Q'].data;\n\t\tvar ecdsaKey = {\n\t\t\ttype: 'ecdsa',\n\t\t\tcurve: curve,\n\t\t\tsize: size,\n\t\t\tparts: [\n\t\t\t\t{name: 'curve', data: Buffer.from(curve) },\n\t\t\t\t{name: 'd', data: d },\n\t\t\t\t{name: 'Q', data: Q }\n\t\t\t]\n\t\t};\n\t\treturn (new PrivateKey(ecdsaKey));\n\t}\n\tthrow (new Error('Unsupported algorithm: ' + supportedAlgosById[alg]));\n}\n\nfunction dnssecTimestamp(date) {\n\tvar year = date.getFullYear() + ''; //stringify\n\tvar month = (date.getMonth() + 1);\n\tvar timestampStr = year + month + date.getUTCDate();\n\ttimestampStr += '' + date.getUTCHours() + date.getUTCMinutes();\n\ttimestampStr += date.getUTCSeconds();\n\treturn (timestampStr);\n}\n\nfunction rsaAlgFromOptions(opts) {\n\tif (!opts || !opts.hashAlgo || opts.hashAlgo === 'sha1')\n\t\treturn ('5 (RSASHA1)');\n\telse if (opts.hashAlgo === 'sha256')\n\t\treturn ('8 (RSASHA256)');\n\telse if (opts.hashAlgo === 'sha512')\n\t\treturn ('10 (RSASHA512)');\n\telse\n\t\tthrow (new Error('Unknown or unsupported hash: ' +\n\t\t    opts.hashAlgo));\n}\n\nfunction writeRSA(key, options) {\n\t// if we're missing parts, add them.\n\tif (!key.part.dmodp || !key.part.dmodq) {\n\t\tutils.addRSAMissing(key);\n\t}\n\n\tvar out = '';\n\tout += 'Private-key-format: v1.3\\n';\n\tout += 'Algorithm: ' + rsaAlgFromOptions(options) + '\\n';\n\tvar n = utils.mpDenormalize(key.part['n'].data);\n\tout += 'Modulus: ' + n.toString('base64') + '\\n';\n\tvar e = utils.mpDenormalize(key.part['e'].data);\n\tout += 'PublicExponent: ' + e.toString('base64') + '\\n';\n\tvar d = utils.mpDenormalize(key.part['d'].data);\n\tout += 'PrivateExponent: ' + d.toString('base64') + '\\n';\n\tvar p = utils.mpDenormalize(key.part['p'].data);\n\tout += 'Prime1: ' + p.toString('base64') + '\\n';\n\tvar q = utils.mpDenormalize(key.part['q'].data);\n\tout += 'Prime2: ' + q.toString('base64') + '\\n';\n\tvar dmodp = utils.mpDenormalize(key.part['dmodp'].data);\n\tout += 'Exponent1: ' + dmodp.toString('base64') + '\\n';\n\tvar dmodq = utils.mpDenormalize(key.part['dmodq'].data);\n\tout += 'Exponent2: ' + dmodq.toString('base64') + '\\n';\n\tvar iqmp = utils.mpDenormalize(key.part['iqmp'].data);\n\tout += 'Coefficient: ' + iqmp.toString('base64') + '\\n';\n\t// Assume that we're valid as-of now\n\tvar timestamp = new Date();\n\tout += 'Created: ' + dnssecTimestamp(timestamp) + '\\n';\n\tout += 'Publish: ' + dnssecTimestamp(timestamp) + '\\n';\n\tout += 'Activate: ' + dnssecTimestamp(timestamp) + '\\n';\n\treturn (Buffer.from(out, 'ascii'));\n}\n\nfunction writeECDSA(key, options) {\n\tvar out = '';\n\tout += 'Private-key-format: v1.3\\n';\n\n\tif (key.curve === 'nistp256') {\n\t\tout += 'Algorithm: 13 (ECDSAP256SHA256)\\n';\n\t} else if (key.curve === 'nistp384') {\n\t\tout += 'Algorithm: 14 (ECDSAP384SHA384)\\n';\n\t} else {\n\t\tthrow (new Error('Unsupported curve'));\n\t}\n\tvar base64Key = key.part['d'].data.toString('base64');\n\tout += 'PrivateKey: ' + base64Key + '\\n';\n\n\t// Assume that we're valid as-of now\n\tvar timestamp = new Date();\n\tout += 'Created: ' + dnssecTimestamp(timestamp) + '\\n';\n\tout += 'Publish: ' + dnssecTimestamp(timestamp) + '\\n';\n\tout += 'Activate: ' + dnssecTimestamp(timestamp) + '\\n';\n\n\treturn (Buffer.from(out, 'ascii'));\n}\n\nfunction write(key, options) {\n\tif (PrivateKey.isPrivateKey(key)) {\n\t\tif (key.type === 'rsa') {\n\t\t\treturn (writeRSA(key, options));\n\t\t} else if (key.type === 'ecdsa') {\n\t\t\treturn (writeECDSA(key, options));\n\t\t} else {\n\t\t\tthrow (new Error('Unsupported algorithm: ' + key.type));\n\t\t}\n\t} else if (Key.isKey(key)) {\n\t\t/*\n\t\t * RFC3110 requires a keyname, and a keytype, which we\n\t\t * don't really have a mechanism for specifying such\n\t\t * additional metadata.\n\t\t */\n\t\tthrow (new Error('Format \"dnssec\" only supports ' +\n\t\t    'writing private keys'));\n\t} else {\n\t\tthrow (new Error('key is not a Key or PrivateKey'));\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvZG5zc2VjLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrREFBYTtBQUNsQyxhQUFhLDhGQUE4QjtBQUMzQyxVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMscUVBQWdCO0FBQ3pDLFlBQVksbUJBQU8sQ0FBQyx5REFBVTtBQUM5QixnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBZTtBQUN2QyxVQUFVLG1CQUFPLENBQUMscURBQVE7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQsc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx5Q0FBeUM7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssbURBQW1EO0FBQ3hELEtBQUssbURBQW1EO0FBQ3hELEtBQUssbURBQW1EO0FBQ3hELEtBQUssbURBQW1EO0FBQ3hELEtBQUssbURBQW1EO0FBQ3hELEtBQUs7QUFDTCxtREFBbUQ7QUFDbkQsS0FBSztBQUNMLG1EQUFtRDtBQUNuRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHlDQUF5QztBQUM5QyxLQUFLLG9CQUFvQjtBQUN6QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9mb3JtYXRzL2Ruc3NlYy5qcz9lODkwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE3IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgS2V5ID0gcmVxdWlyZSgnLi4va2V5Jyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uL3ByaXZhdGUta2V5Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIFNTSEJ1ZmZlciA9IHJlcXVpcmUoJy4uL3NzaC1idWZmZXInKTtcbnZhciBEaGUgPSByZXF1aXJlKCcuLi9kaGUnKTtcblxudmFyIHN1cHBvcnRlZEFsZ29zID0ge1xuXHQncnNhLXNoYTEnIDogNSxcblx0J3JzYS1zaGEyNTYnIDogOCxcblx0J3JzYS1zaGE1MTInIDogMTAsXG5cdCdlY2RzYS1wMjU2LXNoYTI1NicgOiAxMyxcblx0J2VjZHNhLXAzODQtc2hhMzg0JyA6IDE0XG5cdC8qXG5cdCAqIGVkMjU1MTkgaXMgaHlwb3RoZXRpY2FsbHkgc3VwcG9ydGVkIHdpdGggaWQgMTVcblx0ICogYnV0IHRoZSBjb21tb24gdG9vbHMgYXZhaWxhYmxlIGRvbid0IGFwcGVhciB0byBiZVxuXHQgKiBjYXBhYmxlIG9mIGdlbmVyYXRpbmcvdXNpbmcgZWQyNTUxOSBrZXlzXG5cdCAqL1xufTtcblxudmFyIHN1cHBvcnRlZEFsZ29zQnlJZCA9IHt9O1xuT2JqZWN0LmtleXMoc3VwcG9ydGVkQWxnb3MpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0c3VwcG9ydGVkQWxnb3NCeUlkW3N1cHBvcnRlZEFsZ29zW2tdXSA9IGsudG9VcHBlckNhc2UoKTtcbn0pO1xuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIChidWYpICE9PSAnc3RyaW5nJykge1xuXHRcdGFzc2VydC5idWZmZXIoYnVmLCAnYnVmJyk7XG5cdFx0YnVmID0gYnVmLnRvU3RyaW5nKCdhc2NpaScpO1xuXHR9XG5cdHZhciBsaW5lcyA9IGJ1Zi5zcGxpdCgnXFxuJyk7XG5cdGlmIChsaW5lc1swXS5tYXRjaCgvXlByaXZhdGUta2V5LWZvcm1hdFxcOiB2MS8pKSB7XG5cdFx0dmFyIGFsZ0VsZW1zID0gbGluZXNbMV0uc3BsaXQoJyAnKTtcblx0XHR2YXIgYWxnb051bSA9IHBhcnNlSW50KGFsZ0VsZW1zWzFdLCAxMCk7XG5cdFx0dmFyIGFsZ29OYW1lID0gYWxnRWxlbXNbMl07XG5cdFx0aWYgKCFzdXBwb3J0ZWRBbGdvc0J5SWRbYWxnb051bV0pXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBhbGdvcml0aG06ICcgKyBhbGdvTmFtZSkpO1xuXHRcdHJldHVybiAocmVhZEROU1NFQ1ByaXZhdGVLZXkoYWxnb051bSwgbGluZXMuc2xpY2UoMikpKTtcblx0fVxuXG5cdC8vIHNraXAgYW55IGNvbW1lbnQtbGluZXNcblx0dmFyIGxpbmUgPSAwO1xuXHQvKiBKU1NUWUxFRCAqL1xuXHR3aGlsZSAobGluZXNbbGluZV0ubWF0Y2goL15cXDsvKSlcblx0XHRsaW5lKys7XG5cdC8vIHdlIHNob3VsZCBub3cgaGF2ZSAqb25lIHNpbmdsZSogbGluZSBsZWZ0IHdpdGggb3VyIEtFWSBvbiBpdC5cblx0aWYgKChsaW5lc1tsaW5lXS5tYXRjaCgvXFwuIElOIEtFWSAvKSB8fFxuXHQgICAgbGluZXNbbGluZV0ubWF0Y2goL1xcLiBJTiBETlNLRVkgLykpICYmIGxpbmVzW2xpbmUrMV0ubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIChyZWFkUkZDMzExMChsaW5lc1tsaW5lXSkpO1xuXHR9XG5cdHRocm93IChuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBkbnNzZWMga2V5JykpO1xufVxuXG5mdW5jdGlvbiByZWFkUkZDMzExMChrZXlTdHJpbmcpIHtcblx0dmFyIGVsZW1zID0ga2V5U3RyaW5nLnNwbGl0KCcgJyk7XG5cdC8vdW51c2VkIHZhciBmbGFncyA9IHBhcnNlSW50KGVsZW1zWzNdLCAxMCk7XG5cdC8vdW51c2VkIHZhciBwcm90b2NvbCA9IHBhcnNlSW50KGVsZW1zWzRdLCAxMCk7XG5cdHZhciBhbGdvcml0aG0gPSBwYXJzZUludChlbGVtc1s1XSwgMTApO1xuXHRpZiAoIXN1cHBvcnRlZEFsZ29zQnlJZFthbGdvcml0aG1dKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSkpO1xuXHR2YXIgYmFzZTY0a2V5ID0gZWxlbXMuc2xpY2UoNiwgZWxlbXMubGVuZ3RoKS5qb2luKCk7XG5cdHZhciBrZXlCdWZmZXIgPSBCdWZmZXIuZnJvbShiYXNlNjRrZXksICdiYXNlNjQnKTtcblx0aWYgKHN1cHBvcnRlZEFsZ29zQnlJZFthbGdvcml0aG1dLm1hdGNoKC9eUlNBLS8pKSB7XG5cdFx0Ly8gam9pbiB0aGUgcmVzdCBvZiB0aGUgYm9keSBpbnRvIGEgc2luZ2xlIGJhc2U2NC1ibG9iXG5cdFx0dmFyIHB1YmxpY0V4cG9uZW50TGVuID0ga2V5QnVmZmVyLnJlYWRVSW50OCgwKTtcblx0XHRpZiAocHVibGljRXhwb25lbnRMZW4gIT0gMyAmJiBwdWJsaWNFeHBvbmVudExlbiAhPSAxKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIGRuc3NlYyBrZXk6ICcgK1xuXHRcdFx0ICAgICd1bnN1cHBvcnRlZCBleHBvbmVudCBsZW5ndGgnKSk7XG5cblx0XHR2YXIgcHVibGljRXhwb25lbnQgPSBrZXlCdWZmZXIuc2xpY2UoMSwgcHVibGljRXhwb25lbnRMZW4rMSk7XG5cdFx0cHVibGljRXhwb25lbnQgPSB1dGlscy5tcE5vcm1hbGl6ZShwdWJsaWNFeHBvbmVudCk7XG5cdFx0dmFyIG1vZHVsdXMgPSBrZXlCdWZmZXIuc2xpY2UoMStwdWJsaWNFeHBvbmVudExlbik7XG5cdFx0bW9kdWx1cyA9IHV0aWxzLm1wTm9ybWFsaXplKG1vZHVsdXMpO1xuXHRcdC8vIG5vdywgbWFrZSB0aGUga2V5XG5cdFx0dmFyIHJzYUtleSA9IHtcblx0XHRcdHR5cGU6ICdyc2EnLFxuXHRcdFx0cGFydHM6IFtdXG5cdFx0fTtcblx0XHRyc2FLZXkucGFydHMucHVzaCh7IG5hbWU6ICdlJywgZGF0YTogcHVibGljRXhwb25lbnR9KTtcblx0XHRyc2FLZXkucGFydHMucHVzaCh7IG5hbWU6ICduJywgZGF0YTogbW9kdWx1c30pO1xuXHRcdHJldHVybiAobmV3IEtleShyc2FLZXkpKTtcblx0fVxuXHRpZiAoc3VwcG9ydGVkQWxnb3NCeUlkW2FsZ29yaXRobV0gPT09ICdFQ0RTQS1QMzg0LVNIQTM4NCcgfHxcblx0ICAgIHN1cHBvcnRlZEFsZ29zQnlJZFthbGdvcml0aG1dID09PSAnRUNEU0EtUDI1Ni1TSEEyNTYnKSB7XG5cdFx0dmFyIGN1cnZlID0gJ25pc3RwMzg0Jztcblx0XHR2YXIgc2l6ZSA9IDM4NDtcblx0XHRpZiAoc3VwcG9ydGVkQWxnb3NCeUlkW2FsZ29yaXRobV0ubWF0Y2goL15FQ0RTQS1QMjU2LVNIQTI1Ni8pKSB7XG5cdFx0XHRjdXJ2ZSA9ICduaXN0cDI1Nic7XG5cdFx0XHRzaXplID0gMjU2O1xuXHRcdH1cblxuXHRcdHZhciBlY2RzYUtleSA9IHtcblx0XHRcdHR5cGU6ICdlY2RzYScsXG5cdFx0XHRjdXJ2ZTogY3VydmUsXG5cdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0cGFydHM6IFtcblx0XHRcdFx0e25hbWU6ICdjdXJ2ZScsIGRhdGE6IEJ1ZmZlci5mcm9tKGN1cnZlKSB9LFxuXHRcdFx0XHR7bmFtZTogJ1EnLCBkYXRhOiB1dGlscy5lY05vcm1hbGl6ZShrZXlCdWZmZXIpIH1cblx0XHRcdF1cblx0XHR9O1xuXHRcdHJldHVybiAobmV3IEtleShlY2RzYUtleSkpO1xuXHR9XG5cdHRocm93IChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFsZ29yaXRobTogJyArXG5cdCAgICBzdXBwb3J0ZWRBbGdvc0J5SWRbYWxnb3JpdGhtXSkpO1xufVxuXG5mdW5jdGlvbiBlbGVtZW50VG9CdWYoZSkge1xuXHRyZXR1cm4gKEJ1ZmZlci5mcm9tKGUuc3BsaXQoJyAnKVsxXSwgJ2Jhc2U2NCcpKTtcbn1cblxuZnVuY3Rpb24gcmVhZEROU1NFQ1JTQVByaXZhdGVLZXkoZWxlbWVudHMpIHtcblx0dmFyIHJzYVBhcmFtcyA9IHt9O1xuXHRlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0aWYgKGVsZW1lbnQuc3BsaXQoJyAnKVswXSA9PT0gJ01vZHVsdXM6Jylcblx0XHRcdHJzYVBhcmFtc1snbiddID0gZWxlbWVudFRvQnVmKGVsZW1lbnQpO1xuXHRcdGVsc2UgaWYgKGVsZW1lbnQuc3BsaXQoJyAnKVswXSA9PT0gJ1B1YmxpY0V4cG9uZW50OicpXG5cdFx0XHRyc2FQYXJhbXNbJ2UnXSA9IGVsZW1lbnRUb0J1ZihlbGVtZW50KTtcblx0XHRlbHNlIGlmIChlbGVtZW50LnNwbGl0KCcgJylbMF0gPT09ICdQcml2YXRlRXhwb25lbnQ6Jylcblx0XHRcdHJzYVBhcmFtc1snZCddID0gZWxlbWVudFRvQnVmKGVsZW1lbnQpO1xuXHRcdGVsc2UgaWYgKGVsZW1lbnQuc3BsaXQoJyAnKVswXSA9PT0gJ1ByaW1lMTonKVxuXHRcdFx0cnNhUGFyYW1zWydwJ10gPSBlbGVtZW50VG9CdWYoZWxlbWVudCk7XG5cdFx0ZWxzZSBpZiAoZWxlbWVudC5zcGxpdCgnICcpWzBdID09PSAnUHJpbWUyOicpXG5cdFx0XHRyc2FQYXJhbXNbJ3EnXSA9IGVsZW1lbnRUb0J1ZihlbGVtZW50KTtcblx0XHRlbHNlIGlmIChlbGVtZW50LnNwbGl0KCcgJylbMF0gPT09ICdFeHBvbmVudDE6Jylcblx0XHRcdHJzYVBhcmFtc1snZG1vZHAnXSA9IGVsZW1lbnRUb0J1ZihlbGVtZW50KTtcblx0XHRlbHNlIGlmIChlbGVtZW50LnNwbGl0KCcgJylbMF0gPT09ICdFeHBvbmVudDI6Jylcblx0XHRcdHJzYVBhcmFtc1snZG1vZHEnXSA9IGVsZW1lbnRUb0J1ZihlbGVtZW50KTtcblx0XHRlbHNlIGlmIChlbGVtZW50LnNwbGl0KCcgJylbMF0gPT09ICdDb2VmZmljaWVudDonKVxuXHRcdFx0cnNhUGFyYW1zWydpcW1wJ10gPSBlbGVtZW50VG9CdWYoZWxlbWVudCk7XG5cdH0pO1xuXHQvLyBub3csIG1ha2UgdGhlIGtleVxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdyc2EnLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICdlJywgZGF0YTogdXRpbHMubXBOb3JtYWxpemUocnNhUGFyYW1zWydlJ10pfSxcblx0XHRcdHsgbmFtZTogJ24nLCBkYXRhOiB1dGlscy5tcE5vcm1hbGl6ZShyc2FQYXJhbXNbJ24nXSl9LFxuXHRcdFx0eyBuYW1lOiAnZCcsIGRhdGE6IHV0aWxzLm1wTm9ybWFsaXplKHJzYVBhcmFtc1snZCddKX0sXG5cdFx0XHR7IG5hbWU6ICdwJywgZGF0YTogdXRpbHMubXBOb3JtYWxpemUocnNhUGFyYW1zWydwJ10pfSxcblx0XHRcdHsgbmFtZTogJ3EnLCBkYXRhOiB1dGlscy5tcE5vcm1hbGl6ZShyc2FQYXJhbXNbJ3EnXSl9LFxuXHRcdFx0eyBuYW1lOiAnZG1vZHAnLFxuXHRcdFx0ICAgIGRhdGE6IHV0aWxzLm1wTm9ybWFsaXplKHJzYVBhcmFtc1snZG1vZHAnXSl9LFxuXHRcdFx0eyBuYW1lOiAnZG1vZHEnLFxuXHRcdFx0ICAgIGRhdGE6IHV0aWxzLm1wTm9ybWFsaXplKHJzYVBhcmFtc1snZG1vZHEnXSl9LFxuXHRcdFx0eyBuYW1lOiAnaXFtcCcsXG5cdFx0XHQgICAgZGF0YTogdXRpbHMubXBOb3JtYWxpemUocnNhUGFyYW1zWydpcW1wJ10pfVxuXHRcdF1cblx0fTtcblx0cmV0dXJuIChuZXcgUHJpdmF0ZUtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZEROU1NFQ1ByaXZhdGVLZXkoYWxnLCBlbGVtZW50cykge1xuXHRpZiAoc3VwcG9ydGVkQWxnb3NCeUlkW2FsZ10ubWF0Y2goL15SU0EtLykpIHtcblx0XHRyZXR1cm4gKHJlYWRETlNTRUNSU0FQcml2YXRlS2V5KGVsZW1lbnRzKSk7XG5cdH1cblx0aWYgKHN1cHBvcnRlZEFsZ29zQnlJZFthbGddID09PSAnRUNEU0EtUDM4NC1TSEEzODQnIHx8XG5cdCAgICBzdXBwb3J0ZWRBbGdvc0J5SWRbYWxnXSA9PT0gJ0VDRFNBLVAyNTYtU0hBMjU2Jykge1xuXHRcdHZhciBkID0gQnVmZmVyLmZyb20oZWxlbWVudHNbMF0uc3BsaXQoJyAnKVsxXSwgJ2Jhc2U2NCcpO1xuXHRcdHZhciBjdXJ2ZSA9ICduaXN0cDM4NCc7XG5cdFx0dmFyIHNpemUgPSAzODQ7XG5cdFx0aWYgKHN1cHBvcnRlZEFsZ29zQnlJZFthbGddID09PSAnRUNEU0EtUDI1Ni1TSEEyNTYnKSB7XG5cdFx0XHRjdXJ2ZSA9ICduaXN0cDI1Nic7XG5cdFx0XHRzaXplID0gMjU2O1xuXHRcdH1cblx0XHQvLyBETlNTRUMgZ2VuZXJhdGVzIHRoZSBwdWJsaWMta2V5IG9uIHRoZSBmbHkgKGdvIGNhbGN1bGF0ZSBpdClcblx0XHR2YXIgcHVibGljS2V5ID0gdXRpbHMucHVibGljRnJvbVByaXZhdGVFQ0RTQShjdXJ2ZSwgZCk7XG5cdFx0dmFyIFEgPSBwdWJsaWNLZXkucGFydFsnUSddLmRhdGE7XG5cdFx0dmFyIGVjZHNhS2V5ID0ge1xuXHRcdFx0dHlwZTogJ2VjZHNhJyxcblx0XHRcdGN1cnZlOiBjdXJ2ZSxcblx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRwYXJ0czogW1xuXHRcdFx0XHR7bmFtZTogJ2N1cnZlJywgZGF0YTogQnVmZmVyLmZyb20oY3VydmUpIH0sXG5cdFx0XHRcdHtuYW1lOiAnZCcsIGRhdGE6IGQgfSxcblx0XHRcdFx0e25hbWU6ICdRJywgZGF0YTogUSB9XG5cdFx0XHRdXG5cdFx0fTtcblx0XHRyZXR1cm4gKG5ldyBQcml2YXRlS2V5KGVjZHNhS2V5KSk7XG5cdH1cblx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiAnICsgc3VwcG9ydGVkQWxnb3NCeUlkW2FsZ10pKTtcbn1cblxuZnVuY3Rpb24gZG5zc2VjVGltZXN0YW1wKGRhdGUpIHtcblx0dmFyIHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCkgKyAnJzsgLy9zdHJpbmdpZnlcblx0dmFyIG1vbnRoID0gKGRhdGUuZ2V0TW9udGgoKSArIDEpO1xuXHR2YXIgdGltZXN0YW1wU3RyID0geWVhciArIG1vbnRoICsgZGF0ZS5nZXRVVENEYXRlKCk7XG5cdHRpbWVzdGFtcFN0ciArPSAnJyArIGRhdGUuZ2V0VVRDSG91cnMoKSArIGRhdGUuZ2V0VVRDTWludXRlcygpO1xuXHR0aW1lc3RhbXBTdHIgKz0gZGF0ZS5nZXRVVENTZWNvbmRzKCk7XG5cdHJldHVybiAodGltZXN0YW1wU3RyKTtcbn1cblxuZnVuY3Rpb24gcnNhQWxnRnJvbU9wdGlvbnMob3B0cykge1xuXHRpZiAoIW9wdHMgfHwgIW9wdHMuaGFzaEFsZ28gfHwgb3B0cy5oYXNoQWxnbyA9PT0gJ3NoYTEnKVxuXHRcdHJldHVybiAoJzUgKFJTQVNIQTEpJyk7XG5cdGVsc2UgaWYgKG9wdHMuaGFzaEFsZ28gPT09ICdzaGEyNTYnKVxuXHRcdHJldHVybiAoJzggKFJTQVNIQTI1NiknKTtcblx0ZWxzZSBpZiAob3B0cy5oYXNoQWxnbyA9PT0gJ3NoYTUxMicpXG5cdFx0cmV0dXJuICgnMTAgKFJTQVNIQTUxMiknKTtcblx0ZWxzZVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1Vua25vd24gb3IgdW5zdXBwb3J0ZWQgaGFzaDogJyArXG5cdFx0ICAgIG9wdHMuaGFzaEFsZ28pKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVSU0Eoa2V5LCBvcHRpb25zKSB7XG5cdC8vIGlmIHdlJ3JlIG1pc3NpbmcgcGFydHMsIGFkZCB0aGVtLlxuXHRpZiAoIWtleS5wYXJ0LmRtb2RwIHx8ICFrZXkucGFydC5kbW9kcSkge1xuXHRcdHV0aWxzLmFkZFJTQU1pc3Npbmcoa2V5KTtcblx0fVxuXG5cdHZhciBvdXQgPSAnJztcblx0b3V0ICs9ICdQcml2YXRlLWtleS1mb3JtYXQ6IHYxLjNcXG4nO1xuXHRvdXQgKz0gJ0FsZ29yaXRobTogJyArIHJzYUFsZ0Zyb21PcHRpb25zKG9wdGlvbnMpICsgJ1xcbic7XG5cdHZhciBuID0gdXRpbHMubXBEZW5vcm1hbGl6ZShrZXkucGFydFsnbiddLmRhdGEpO1xuXHRvdXQgKz0gJ01vZHVsdXM6ICcgKyBuLnRvU3RyaW5nKCdiYXNlNjQnKSArICdcXG4nO1xuXHR2YXIgZSA9IHV0aWxzLm1wRGVub3JtYWxpemUoa2V5LnBhcnRbJ2UnXS5kYXRhKTtcblx0b3V0ICs9ICdQdWJsaWNFeHBvbmVudDogJyArIGUudG9TdHJpbmcoJ2Jhc2U2NCcpICsgJ1xcbic7XG5cdHZhciBkID0gdXRpbHMubXBEZW5vcm1hbGl6ZShrZXkucGFydFsnZCddLmRhdGEpO1xuXHRvdXQgKz0gJ1ByaXZhdGVFeHBvbmVudDogJyArIGQudG9TdHJpbmcoJ2Jhc2U2NCcpICsgJ1xcbic7XG5cdHZhciBwID0gdXRpbHMubXBEZW5vcm1hbGl6ZShrZXkucGFydFsncCddLmRhdGEpO1xuXHRvdXQgKz0gJ1ByaW1lMTogJyArIHAudG9TdHJpbmcoJ2Jhc2U2NCcpICsgJ1xcbic7XG5cdHZhciBxID0gdXRpbHMubXBEZW5vcm1hbGl6ZShrZXkucGFydFsncSddLmRhdGEpO1xuXHRvdXQgKz0gJ1ByaW1lMjogJyArIHEudG9TdHJpbmcoJ2Jhc2U2NCcpICsgJ1xcbic7XG5cdHZhciBkbW9kcCA9IHV0aWxzLm1wRGVub3JtYWxpemUoa2V5LnBhcnRbJ2Rtb2RwJ10uZGF0YSk7XG5cdG91dCArPSAnRXhwb25lbnQxOiAnICsgZG1vZHAudG9TdHJpbmcoJ2Jhc2U2NCcpICsgJ1xcbic7XG5cdHZhciBkbW9kcSA9IHV0aWxzLm1wRGVub3JtYWxpemUoa2V5LnBhcnRbJ2Rtb2RxJ10uZGF0YSk7XG5cdG91dCArPSAnRXhwb25lbnQyOiAnICsgZG1vZHEudG9TdHJpbmcoJ2Jhc2U2NCcpICsgJ1xcbic7XG5cdHZhciBpcW1wID0gdXRpbHMubXBEZW5vcm1hbGl6ZShrZXkucGFydFsnaXFtcCddLmRhdGEpO1xuXHRvdXQgKz0gJ0NvZWZmaWNpZW50OiAnICsgaXFtcC50b1N0cmluZygnYmFzZTY0JykgKyAnXFxuJztcblx0Ly8gQXNzdW1lIHRoYXQgd2UncmUgdmFsaWQgYXMtb2Ygbm93XG5cdHZhciB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuXHRvdXQgKz0gJ0NyZWF0ZWQ6ICcgKyBkbnNzZWNUaW1lc3RhbXAodGltZXN0YW1wKSArICdcXG4nO1xuXHRvdXQgKz0gJ1B1Ymxpc2g6ICcgKyBkbnNzZWNUaW1lc3RhbXAodGltZXN0YW1wKSArICdcXG4nO1xuXHRvdXQgKz0gJ0FjdGl2YXRlOiAnICsgZG5zc2VjVGltZXN0YW1wKHRpbWVzdGFtcCkgKyAnXFxuJztcblx0cmV0dXJuIChCdWZmZXIuZnJvbShvdXQsICdhc2NpaScpKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVFQ0RTQShrZXksIG9wdGlvbnMpIHtcblx0dmFyIG91dCA9ICcnO1xuXHRvdXQgKz0gJ1ByaXZhdGUta2V5LWZvcm1hdDogdjEuM1xcbic7XG5cblx0aWYgKGtleS5jdXJ2ZSA9PT0gJ25pc3RwMjU2Jykge1xuXHRcdG91dCArPSAnQWxnb3JpdGhtOiAxMyAoRUNEU0FQMjU2U0hBMjU2KVxcbic7XG5cdH0gZWxzZSBpZiAoa2V5LmN1cnZlID09PSAnbmlzdHAzODQnKSB7XG5cdFx0b3V0ICs9ICdBbGdvcml0aG06IDE0IChFQ0RTQVAzODRTSEEzODQpXFxuJztcblx0fSBlbHNlIHtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBjdXJ2ZScpKTtcblx0fVxuXHR2YXIgYmFzZTY0S2V5ID0ga2V5LnBhcnRbJ2QnXS5kYXRhLnRvU3RyaW5nKCdiYXNlNjQnKTtcblx0b3V0ICs9ICdQcml2YXRlS2V5OiAnICsgYmFzZTY0S2V5ICsgJ1xcbic7XG5cblx0Ly8gQXNzdW1lIHRoYXQgd2UncmUgdmFsaWQgYXMtb2Ygbm93XG5cdHZhciB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuXHRvdXQgKz0gJ0NyZWF0ZWQ6ICcgKyBkbnNzZWNUaW1lc3RhbXAodGltZXN0YW1wKSArICdcXG4nO1xuXHRvdXQgKz0gJ1B1Ymxpc2g6ICcgKyBkbnNzZWNUaW1lc3RhbXAodGltZXN0YW1wKSArICdcXG4nO1xuXHRvdXQgKz0gJ0FjdGl2YXRlOiAnICsgZG5zc2VjVGltZXN0YW1wKHRpbWVzdGFtcCkgKyAnXFxuJztcblxuXHRyZXR1cm4gKEJ1ZmZlci5mcm9tKG91dCwgJ2FzY2lpJykpO1xufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIG9wdGlvbnMpIHtcblx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpIHtcblx0XHRpZiAoa2V5LnR5cGUgPT09ICdyc2EnKSB7XG5cdFx0XHRyZXR1cm4gKHdyaXRlUlNBKGtleSwgb3B0aW9ucykpO1xuXHRcdH0gZWxzZSBpZiAoa2V5LnR5cGUgPT09ICdlY2RzYScpIHtcblx0XHRcdHJldHVybiAod3JpdGVFQ0RTQShrZXksIG9wdGlvbnMpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiAnICsga2V5LnR5cGUpKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoS2V5LmlzS2V5KGtleSkpIHtcblx0XHQvKlxuXHRcdCAqIFJGQzMxMTAgcmVxdWlyZXMgYSBrZXluYW1lLCBhbmQgYSBrZXl0eXBlLCB3aGljaCB3ZVxuXHRcdCAqIGRvbid0IHJlYWxseSBoYXZlIGEgbWVjaGFuaXNtIGZvciBzcGVjaWZ5aW5nIHN1Y2hcblx0XHQgKiBhZGRpdGlvbmFsIG1ldGFkYXRhLlxuXHRcdCAqL1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ0Zvcm1hdCBcImRuc3NlY1wiIG9ubHkgc3VwcG9ydHMgJyArXG5cdFx0ICAgICd3cml0aW5nIHByaXZhdGUga2V5cycpKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdrZXkgaXMgbm90IGEgS2V5IG9yIFByaXZhdGVLZXknKSk7XG5cdH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/formats/dnssec.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/formats/openssh-cert.js":
/*!********************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/openssh-cert.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2017 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\tverify: verify,\n\tsign: sign,\n\tsignAsync: signAsync,\n\twrite: write,\n\n\t/* Internal private API */\n\tfromBuffer: fromBuffer,\n\ttoBuffer: toBuffer\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ \"(action-browser)/./node_modules/sshpk/lib/ssh-buffer.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\nvar Identity = __webpack_require__(/*! ../identity */ \"(action-browser)/./node_modules/sshpk/lib/identity.js\");\nvar rfc4253 = __webpack_require__(/*! ./rfc4253 */ \"(action-browser)/./node_modules/sshpk/lib/formats/rfc4253.js\");\nvar Signature = __webpack_require__(/*! ../signature */ \"(action-browser)/./node_modules/sshpk/lib/signature.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar Certificate = __webpack_require__(/*! ../certificate */ \"(action-browser)/./node_modules/sshpk/lib/certificate.js\");\n\nfunction verify(cert, key) {\n\t/*\n\t * We always give an issuerKey, so if our verify() is being called then\n\t * there was no signature. Return false.\n\t */\n\treturn (false);\n}\n\nvar TYPES = {\n\t'user': 1,\n\t'host': 2\n};\nObject.keys(TYPES).forEach(function (k) { TYPES[TYPES[k]] = k; });\n\nvar ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;\n\nfunction read(buf, options) {\n\tif (Buffer.isBuffer(buf))\n\t\tbuf = buf.toString('ascii');\n\tvar parts = buf.trim().split(/[ \\t\\n]+/g);\n\tif (parts.length < 2 || parts.length > 3)\n\t\tthrow (new Error('Not a valid SSH certificate line'));\n\n\tvar algo = parts[0];\n\tvar data = parts[1];\n\n\tdata = Buffer.from(data, 'base64');\n\treturn (fromBuffer(data, algo));\n}\n\nfunction fromBuffer(data, algo, partial) {\n\tvar sshbuf = new SSHBuffer({ buffer: data });\n\tvar innerAlgo = sshbuf.readString();\n\tif (algo !== undefined && innerAlgo !== algo)\n\t\tthrow (new Error('SSH certificate algorithm mismatch'));\n\tif (algo === undefined)\n\t\talgo = innerAlgo;\n\n\tvar cert = {};\n\tcert.signatures = {};\n\tcert.signatures.openssh = {};\n\n\tcert.signatures.openssh.nonce = sshbuf.readBuffer();\n\n\tvar key = {};\n\tvar parts = (key.parts = []);\n\tkey.type = getAlg(algo);\n\n\tvar partCount = algs.info[key.type].parts.length;\n\twhile (parts.length < partCount)\n\t\tparts.push(sshbuf.readPart());\n\tassert.ok(parts.length >= 1, 'key must have at least one part');\n\n\tvar algInfo = algs.info[key.type];\n\tif (key.type === 'ecdsa') {\n\t\tvar res = ECDSA_ALGO.exec(algo);\n\t\tassert.ok(res !== null);\n\t\tassert.strictEqual(res[1], parts[0].data.toString());\n\t}\n\n\tfor (var i = 0; i < algInfo.parts.length; ++i) {\n\t\tparts[i].name = algInfo.parts[i];\n\t\tif (parts[i].name !== 'curve' &&\n\t\t    algInfo.normalize !== false) {\n\t\t\tvar p = parts[i];\n\t\t\tp.data = utils.mpNormalize(p.data);\n\t\t}\n\t}\n\n\tcert.subjectKey = new Key(key);\n\n\tcert.serial = sshbuf.readInt64();\n\n\tvar type = TYPES[sshbuf.readInt()];\n\tassert.string(type, 'valid cert type');\n\n\tcert.signatures.openssh.keyId = sshbuf.readString();\n\n\tvar principals = [];\n\tvar pbuf = sshbuf.readBuffer();\n\tvar psshbuf = new SSHBuffer({ buffer: pbuf });\n\twhile (!psshbuf.atEnd())\n\t\tprincipals.push(psshbuf.readString());\n\tif (principals.length === 0)\n\t\tprincipals = ['*'];\n\n\tcert.subjects = principals.map(function (pr) {\n\t\tif (type === 'user')\n\t\t\treturn (Identity.forUser(pr));\n\t\telse if (type === 'host')\n\t\t\treturn (Identity.forHost(pr));\n\t\tthrow (new Error('Unknown identity type ' + type));\n\t});\n\n\tcert.validFrom = int64ToDate(sshbuf.readInt64());\n\tcert.validUntil = int64ToDate(sshbuf.readInt64());\n\n\tvar exts = [];\n\tvar extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });\n\tvar ext;\n\twhile (!extbuf.atEnd()) {\n\t\text = { critical: true };\n\t\text.name = extbuf.readString();\n\t\text.data = extbuf.readBuffer();\n\t\texts.push(ext);\n\t}\n\textbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });\n\twhile (!extbuf.atEnd()) {\n\t\text = { critical: false };\n\t\text.name = extbuf.readString();\n\t\text.data = extbuf.readBuffer();\n\t\texts.push(ext);\n\t}\n\tcert.signatures.openssh.exts = exts;\n\n\t/* reserved */\n\tsshbuf.readBuffer();\n\n\tvar signingKeyBuf = sshbuf.readBuffer();\n\tcert.issuerKey = rfc4253.read(signingKeyBuf);\n\n\t/*\n\t * OpenSSH certs don't give the identity of the issuer, just their\n\t * public key. So, we use an Identity that matches anything. The\n\t * isSignedBy() function will later tell you if the key matches.\n\t */\n\tcert.issuer = Identity.forHost('**');\n\n\tvar sigBuf = sshbuf.readBuffer();\n\tcert.signatures.openssh.signature =\n\t    Signature.parse(sigBuf, cert.issuerKey.type, 'ssh');\n\n\tif (partial !== undefined) {\n\t\tpartial.remainder = sshbuf.remainder();\n\t\tpartial.consumed = sshbuf._offset;\n\t}\n\n\treturn (new Certificate(cert));\n}\n\nfunction int64ToDate(buf) {\n\tvar i = buf.readUInt32BE(0) * 4294967296;\n\ti += buf.readUInt32BE(4);\n\tvar d = new Date();\n\td.setTime(i * 1000);\n\td.sourceInt64 = buf;\n\treturn (d);\n}\n\nfunction dateToInt64(date) {\n\tif (date.sourceInt64 !== undefined)\n\t\treturn (date.sourceInt64);\n\tvar i = Math.round(date.getTime() / 1000);\n\tvar upper = Math.floor(i / 4294967296);\n\tvar lower = Math.floor(i % 4294967296);\n\tvar buf = Buffer.alloc(8);\n\tbuf.writeUInt32BE(upper, 0);\n\tbuf.writeUInt32BE(lower, 4);\n\treturn (buf);\n}\n\nfunction sign(cert, key) {\n\tif (cert.signatures.openssh === undefined)\n\t\tcert.signatures.openssh = {};\n\ttry {\n\t\tvar blob = toBuffer(cert, true);\n\t} catch (e) {\n\t\tdelete (cert.signatures.openssh);\n\t\treturn (false);\n\t}\n\tvar sig = cert.signatures.openssh;\n\tvar hashAlgo = undefined;\n\tif (key.type === 'rsa' || key.type === 'dsa')\n\t\thashAlgo = 'sha1';\n\tvar signer = key.createSign(hashAlgo);\n\tsigner.write(blob);\n\tsig.signature = signer.sign();\n\treturn (true);\n}\n\nfunction signAsync(cert, signer, done) {\n\tif (cert.signatures.openssh === undefined)\n\t\tcert.signatures.openssh = {};\n\ttry {\n\t\tvar blob = toBuffer(cert, true);\n\t} catch (e) {\n\t\tdelete (cert.signatures.openssh);\n\t\tdone(e);\n\t\treturn;\n\t}\n\tvar sig = cert.signatures.openssh;\n\n\tsigner(blob, function (err, signature) {\n\t\tif (err) {\n\t\t\tdone(err);\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\t/*\n\t\t\t * This will throw if the signature isn't of a\n\t\t\t * type/algo that can be used for SSH.\n\t\t\t */\n\t\t\tsignature.toBuffer('ssh');\n\t\t} catch (e) {\n\t\t\tdone(e);\n\t\t\treturn;\n\t\t}\n\t\tsig.signature = signature;\n\t\tdone();\n\t});\n}\n\nfunction write(cert, options) {\n\tif (options === undefined)\n\t\toptions = {};\n\n\tvar blob = toBuffer(cert);\n\tvar out = getCertType(cert.subjectKey) + ' ' + blob.toString('base64');\n\tif (options.comment)\n\t\tout = out + ' ' + options.comment;\n\treturn (out);\n}\n\n\nfunction toBuffer(cert, noSig) {\n\tassert.object(cert.signatures.openssh, 'signature for openssh format');\n\tvar sig = cert.signatures.openssh;\n\n\tif (sig.nonce === undefined)\n\t\tsig.nonce = crypto.randomBytes(16);\n\tvar buf = new SSHBuffer({});\n\tbuf.writeString(getCertType(cert.subjectKey));\n\tbuf.writeBuffer(sig.nonce);\n\n\tvar key = cert.subjectKey;\n\tvar algInfo = algs.info[key.type];\n\talgInfo.parts.forEach(function (part) {\n\t\tbuf.writePart(key.part[part]);\n\t});\n\n\tbuf.writeInt64(cert.serial);\n\n\tvar type = cert.subjects[0].type;\n\tassert.notStrictEqual(type, 'unknown');\n\tcert.subjects.forEach(function (id) {\n\t\tassert.strictEqual(id.type, type);\n\t});\n\ttype = TYPES[type];\n\tbuf.writeInt(type);\n\n\tif (sig.keyId === undefined) {\n\t\tsig.keyId = cert.subjects[0].type + '_' +\n\t\t    (cert.subjects[0].uid || cert.subjects[0].hostname);\n\t}\n\tbuf.writeString(sig.keyId);\n\n\tvar sub = new SSHBuffer({});\n\tcert.subjects.forEach(function (id) {\n\t\tif (type === TYPES.host)\n\t\t\tsub.writeString(id.hostname);\n\t\telse if (type === TYPES.user)\n\t\t\tsub.writeString(id.uid);\n\t});\n\tbuf.writeBuffer(sub.toBuffer());\n\n\tbuf.writeInt64(dateToInt64(cert.validFrom));\n\tbuf.writeInt64(dateToInt64(cert.validUntil));\n\n\tvar exts = sig.exts;\n\tif (exts === undefined)\n\t\texts = [];\n\n\tvar extbuf = new SSHBuffer({});\n\texts.forEach(function (ext) {\n\t\tif (ext.critical !== true)\n\t\t\treturn;\n\t\textbuf.writeString(ext.name);\n\t\textbuf.writeBuffer(ext.data);\n\t});\n\tbuf.writeBuffer(extbuf.toBuffer());\n\n\textbuf = new SSHBuffer({});\n\texts.forEach(function (ext) {\n\t\tif (ext.critical === true)\n\t\t\treturn;\n\t\textbuf.writeString(ext.name);\n\t\textbuf.writeBuffer(ext.data);\n\t});\n\tbuf.writeBuffer(extbuf.toBuffer());\n\n\t/* reserved */\n\tbuf.writeBuffer(Buffer.alloc(0));\n\n\tsub = rfc4253.write(cert.issuerKey);\n\tbuf.writeBuffer(sub);\n\n\tif (!noSig)\n\t\tbuf.writeBuffer(sig.signature.toBuffer('ssh'));\n\n\treturn (buf.toBuffer());\n}\n\nfunction getAlg(certType) {\n\tif (certType === 'ssh-rsa-cert-v01@openssh.com')\n\t\treturn ('rsa');\n\tif (certType === 'ssh-dss-cert-v01@openssh.com')\n\t\treturn ('dsa');\n\tif (certType.match(ECDSA_ALGO))\n\t\treturn ('ecdsa');\n\tif (certType === 'ssh-ed25519-cert-v01@openssh.com')\n\t\treturn ('ed25519');\n\tthrow (new Error('Unsupported cert type ' + certType));\n}\n\nfunction getCertType(key) {\n\tif (key.type === 'rsa')\n\t\treturn ('ssh-rsa-cert-v01@openssh.com');\n\tif (key.type === 'dsa')\n\t\treturn ('ssh-dss-cert-v01@openssh.com');\n\tif (key.type === 'ecdsa')\n\t\treturn ('ecdsa-sha2-' + key.curve + '-cert-v01@openssh.com');\n\tif (key.type === 'ed25519')\n\t\treturn ('ssh-ed25519-cert-v01@openssh.com');\n\tthrow (new Error('Unsupported key type ' + key.type));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9vcGVuc3NoLWNlcnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywwRUFBYTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBZTtBQUN2QyxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsYUFBYSx5R0FBOEI7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLGtFQUFTO0FBQzVCLFVBQVUsbUJBQU8sQ0FBQyxnRUFBUTtBQUMxQixpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBZ0I7QUFDekMsZUFBZSxtQkFBTyxDQUFDLDBFQUFhO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQywrRUFBVztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RUFBYztBQUN0QyxZQUFZLG1CQUFPLENBQUMsb0VBQVU7QUFDOUIsa0JBQWtCLG1CQUFPLENBQUMsZ0ZBQWdCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0I7O0FBRWhFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkJBQTZCO0FBQ3ZEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9mb3JtYXRzL29wZW5zc2gtY2VydC5qcz8yMDg2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE3IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmVhZDogcmVhZCxcblx0dmVyaWZ5OiB2ZXJpZnksXG5cdHNpZ246IHNpZ24sXG5cdHNpZ25Bc3luYzogc2lnbkFzeW5jLFxuXHR3cml0ZTogd3JpdGUsXG5cblx0LyogSW50ZXJuYWwgcHJpdmF0ZSBBUEkgKi9cblx0ZnJvbUJ1ZmZlcjogZnJvbUJ1ZmZlcixcblx0dG9CdWZmZXI6IHRvQnVmZmVyXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBTU0hCdWZmZXIgPSByZXF1aXJlKCcuLi9zc2gtYnVmZmVyJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuLi9hbGdzJyk7XG52YXIgS2V5ID0gcmVxdWlyZSgnLi4va2V5Jyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uL3ByaXZhdGUta2V5Jyk7XG52YXIgSWRlbnRpdHkgPSByZXF1aXJlKCcuLi9pZGVudGl0eScpO1xudmFyIHJmYzQyNTMgPSByZXF1aXJlKCcuL3JmYzQyNTMnKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuLi9zaWduYXR1cmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgQ2VydGlmaWNhdGUgPSByZXF1aXJlKCcuLi9jZXJ0aWZpY2F0ZScpO1xuXG5mdW5jdGlvbiB2ZXJpZnkoY2VydCwga2V5KSB7XG5cdC8qXG5cdCAqIFdlIGFsd2F5cyBnaXZlIGFuIGlzc3VlcktleSwgc28gaWYgb3VyIHZlcmlmeSgpIGlzIGJlaW5nIGNhbGxlZCB0aGVuXG5cdCAqIHRoZXJlIHdhcyBubyBzaWduYXR1cmUuIFJldHVybiBmYWxzZS5cblx0ICovXG5cdHJldHVybiAoZmFsc2UpO1xufVxuXG52YXIgVFlQRVMgPSB7XG5cdCd1c2VyJzogMSxcblx0J2hvc3QnOiAyXG59O1xuT2JqZWN0LmtleXMoVFlQRVMpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgVFlQRVNbVFlQRVNba11dID0gazsgfSk7XG5cbnZhciBFQ0RTQV9BTEdPID0gL15lY2RzYS1zaGEyLShbXkAtXSspLWNlcnQtdjAxQG9wZW5zc2guY29tJC87XG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvcHRpb25zKSB7XG5cdGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSlcblx0XHRidWYgPSBidWYudG9TdHJpbmcoJ2FzY2lpJyk7XG5cdHZhciBwYXJ0cyA9IGJ1Zi50cmltKCkuc3BsaXQoL1sgXFx0XFxuXSsvZyk7XG5cdGlmIChwYXJ0cy5sZW5ndGggPCAyIHx8IHBhcnRzLmxlbmd0aCA+IDMpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignTm90IGEgdmFsaWQgU1NIIGNlcnRpZmljYXRlIGxpbmUnKSk7XG5cblx0dmFyIGFsZ28gPSBwYXJ0c1swXTtcblx0dmFyIGRhdGEgPSBwYXJ0c1sxXTtcblxuXHRkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ2Jhc2U2NCcpO1xuXHRyZXR1cm4gKGZyb21CdWZmZXIoZGF0YSwgYWxnbykpO1xufVxuXG5mdW5jdGlvbiBmcm9tQnVmZmVyKGRhdGEsIGFsZ28sIHBhcnRpYWwpIHtcblx0dmFyIHNzaGJ1ZiA9IG5ldyBTU0hCdWZmZXIoeyBidWZmZXI6IGRhdGEgfSk7XG5cdHZhciBpbm5lckFsZ28gPSBzc2hidWYucmVhZFN0cmluZygpO1xuXHRpZiAoYWxnbyAhPT0gdW5kZWZpbmVkICYmIGlubmVyQWxnbyAhPT0gYWxnbylcblx0XHR0aHJvdyAobmV3IEVycm9yKCdTU0ggY2VydGlmaWNhdGUgYWxnb3JpdGhtIG1pc21hdGNoJykpO1xuXHRpZiAoYWxnbyA9PT0gdW5kZWZpbmVkKVxuXHRcdGFsZ28gPSBpbm5lckFsZ287XG5cblx0dmFyIGNlcnQgPSB7fTtcblx0Y2VydC5zaWduYXR1cmVzID0ge307XG5cdGNlcnQuc2lnbmF0dXJlcy5vcGVuc3NoID0ge307XG5cblx0Y2VydC5zaWduYXR1cmVzLm9wZW5zc2gubm9uY2UgPSBzc2hidWYucmVhZEJ1ZmZlcigpO1xuXG5cdHZhciBrZXkgPSB7fTtcblx0dmFyIHBhcnRzID0gKGtleS5wYXJ0cyA9IFtdKTtcblx0a2V5LnR5cGUgPSBnZXRBbGcoYWxnbyk7XG5cblx0dmFyIHBhcnRDb3VudCA9IGFsZ3MuaW5mb1trZXkudHlwZV0ucGFydHMubGVuZ3RoO1xuXHR3aGlsZSAocGFydHMubGVuZ3RoIDwgcGFydENvdW50KVxuXHRcdHBhcnRzLnB1c2goc3NoYnVmLnJlYWRQYXJ0KCkpO1xuXHRhc3NlcnQub2socGFydHMubGVuZ3RoID49IDEsICdrZXkgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBwYXJ0Jyk7XG5cblx0dmFyIGFsZ0luZm8gPSBhbGdzLmluZm9ba2V5LnR5cGVdO1xuXHRpZiAoa2V5LnR5cGUgPT09ICdlY2RzYScpIHtcblx0XHR2YXIgcmVzID0gRUNEU0FfQUxHTy5leGVjKGFsZ28pO1xuXHRcdGFzc2VydC5vayhyZXMgIT09IG51bGwpO1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChyZXNbMV0sIHBhcnRzWzBdLmRhdGEudG9TdHJpbmcoKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFsZ0luZm8ucGFydHMubGVuZ3RoOyArK2kpIHtcblx0XHRwYXJ0c1tpXS5uYW1lID0gYWxnSW5mby5wYXJ0c1tpXTtcblx0XHRpZiAocGFydHNbaV0ubmFtZSAhPT0gJ2N1cnZlJyAmJlxuXHRcdCAgICBhbGdJbmZvLm5vcm1hbGl6ZSAhPT0gZmFsc2UpIHtcblx0XHRcdHZhciBwID0gcGFydHNbaV07XG5cdFx0XHRwLmRhdGEgPSB1dGlscy5tcE5vcm1hbGl6ZShwLmRhdGEpO1xuXHRcdH1cblx0fVxuXG5cdGNlcnQuc3ViamVjdEtleSA9IG5ldyBLZXkoa2V5KTtcblxuXHRjZXJ0LnNlcmlhbCA9IHNzaGJ1Zi5yZWFkSW50NjQoKTtcblxuXHR2YXIgdHlwZSA9IFRZUEVTW3NzaGJ1Zi5yZWFkSW50KCldO1xuXHRhc3NlcnQuc3RyaW5nKHR5cGUsICd2YWxpZCBjZXJ0IHR5cGUnKTtcblxuXHRjZXJ0LnNpZ25hdHVyZXMub3BlbnNzaC5rZXlJZCA9IHNzaGJ1Zi5yZWFkU3RyaW5nKCk7XG5cblx0dmFyIHByaW5jaXBhbHMgPSBbXTtcblx0dmFyIHBidWYgPSBzc2hidWYucmVhZEJ1ZmZlcigpO1xuXHR2YXIgcHNzaGJ1ZiA9IG5ldyBTU0hCdWZmZXIoeyBidWZmZXI6IHBidWYgfSk7XG5cdHdoaWxlICghcHNzaGJ1Zi5hdEVuZCgpKVxuXHRcdHByaW5jaXBhbHMucHVzaChwc3NoYnVmLnJlYWRTdHJpbmcoKSk7XG5cdGlmIChwcmluY2lwYWxzLmxlbmd0aCA9PT0gMClcblx0XHRwcmluY2lwYWxzID0gWycqJ107XG5cblx0Y2VydC5zdWJqZWN0cyA9IHByaW5jaXBhbHMubWFwKGZ1bmN0aW9uIChwcikge1xuXHRcdGlmICh0eXBlID09PSAndXNlcicpXG5cdFx0XHRyZXR1cm4gKElkZW50aXR5LmZvclVzZXIocHIpKTtcblx0XHRlbHNlIGlmICh0eXBlID09PSAnaG9zdCcpXG5cdFx0XHRyZXR1cm4gKElkZW50aXR5LmZvckhvc3QocHIpKTtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdVbmtub3duIGlkZW50aXR5IHR5cGUgJyArIHR5cGUpKTtcblx0fSk7XG5cblx0Y2VydC52YWxpZEZyb20gPSBpbnQ2NFRvRGF0ZShzc2hidWYucmVhZEludDY0KCkpO1xuXHRjZXJ0LnZhbGlkVW50aWwgPSBpbnQ2NFRvRGF0ZShzc2hidWYucmVhZEludDY0KCkpO1xuXG5cdHZhciBleHRzID0gW107XG5cdHZhciBleHRidWYgPSBuZXcgU1NIQnVmZmVyKHsgYnVmZmVyOiBzc2hidWYucmVhZEJ1ZmZlcigpIH0pO1xuXHR2YXIgZXh0O1xuXHR3aGlsZSAoIWV4dGJ1Zi5hdEVuZCgpKSB7XG5cdFx0ZXh0ID0geyBjcml0aWNhbDogdHJ1ZSB9O1xuXHRcdGV4dC5uYW1lID0gZXh0YnVmLnJlYWRTdHJpbmcoKTtcblx0XHRleHQuZGF0YSA9IGV4dGJ1Zi5yZWFkQnVmZmVyKCk7XG5cdFx0ZXh0cy5wdXNoKGV4dCk7XG5cdH1cblx0ZXh0YnVmID0gbmV3IFNTSEJ1ZmZlcih7IGJ1ZmZlcjogc3NoYnVmLnJlYWRCdWZmZXIoKSB9KTtcblx0d2hpbGUgKCFleHRidWYuYXRFbmQoKSkge1xuXHRcdGV4dCA9IHsgY3JpdGljYWw6IGZhbHNlIH07XG5cdFx0ZXh0Lm5hbWUgPSBleHRidWYucmVhZFN0cmluZygpO1xuXHRcdGV4dC5kYXRhID0gZXh0YnVmLnJlYWRCdWZmZXIoKTtcblx0XHRleHRzLnB1c2goZXh0KTtcblx0fVxuXHRjZXJ0LnNpZ25hdHVyZXMub3BlbnNzaC5leHRzID0gZXh0cztcblxuXHQvKiByZXNlcnZlZCAqL1xuXHRzc2hidWYucmVhZEJ1ZmZlcigpO1xuXG5cdHZhciBzaWduaW5nS2V5QnVmID0gc3NoYnVmLnJlYWRCdWZmZXIoKTtcblx0Y2VydC5pc3N1ZXJLZXkgPSByZmM0MjUzLnJlYWQoc2lnbmluZ0tleUJ1Zik7XG5cblx0Lypcblx0ICogT3BlblNTSCBjZXJ0cyBkb24ndCBnaXZlIHRoZSBpZGVudGl0eSBvZiB0aGUgaXNzdWVyLCBqdXN0IHRoZWlyXG5cdCAqIHB1YmxpYyBrZXkuIFNvLCB3ZSB1c2UgYW4gSWRlbnRpdHkgdGhhdCBtYXRjaGVzIGFueXRoaW5nLiBUaGVcblx0ICogaXNTaWduZWRCeSgpIGZ1bmN0aW9uIHdpbGwgbGF0ZXIgdGVsbCB5b3UgaWYgdGhlIGtleSBtYXRjaGVzLlxuXHQgKi9cblx0Y2VydC5pc3N1ZXIgPSBJZGVudGl0eS5mb3JIb3N0KCcqKicpO1xuXG5cdHZhciBzaWdCdWYgPSBzc2hidWYucmVhZEJ1ZmZlcigpO1xuXHRjZXJ0LnNpZ25hdHVyZXMub3BlbnNzaC5zaWduYXR1cmUgPVxuXHQgICAgU2lnbmF0dXJlLnBhcnNlKHNpZ0J1ZiwgY2VydC5pc3N1ZXJLZXkudHlwZSwgJ3NzaCcpO1xuXG5cdGlmIChwYXJ0aWFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRwYXJ0aWFsLnJlbWFpbmRlciA9IHNzaGJ1Zi5yZW1haW5kZXIoKTtcblx0XHRwYXJ0aWFsLmNvbnN1bWVkID0gc3NoYnVmLl9vZmZzZXQ7XG5cdH1cblxuXHRyZXR1cm4gKG5ldyBDZXJ0aWZpY2F0ZShjZXJ0KSk7XG59XG5cbmZ1bmN0aW9uIGludDY0VG9EYXRlKGJ1Zikge1xuXHR2YXIgaSA9IGJ1Zi5yZWFkVUludDMyQkUoMCkgKiA0Mjk0OTY3Mjk2O1xuXHRpICs9IGJ1Zi5yZWFkVUludDMyQkUoNCk7XG5cdHZhciBkID0gbmV3IERhdGUoKTtcblx0ZC5zZXRUaW1lKGkgKiAxMDAwKTtcblx0ZC5zb3VyY2VJbnQ2NCA9IGJ1Zjtcblx0cmV0dXJuIChkKTtcbn1cblxuZnVuY3Rpb24gZGF0ZVRvSW50NjQoZGF0ZSkge1xuXHRpZiAoZGF0ZS5zb3VyY2VJbnQ2NCAhPT0gdW5kZWZpbmVkKVxuXHRcdHJldHVybiAoZGF0ZS5zb3VyY2VJbnQ2NCk7XG5cdHZhciBpID0gTWF0aC5yb3VuZChkYXRlLmdldFRpbWUoKSAvIDEwMDApO1xuXHR2YXIgdXBwZXIgPSBNYXRoLmZsb29yKGkgLyA0Mjk0OTY3Mjk2KTtcblx0dmFyIGxvd2VyID0gTWF0aC5mbG9vcihpICUgNDI5NDk2NzI5Nik7XG5cdHZhciBidWYgPSBCdWZmZXIuYWxsb2MoOCk7XG5cdGJ1Zi53cml0ZVVJbnQzMkJFKHVwcGVyLCAwKTtcblx0YnVmLndyaXRlVUludDMyQkUobG93ZXIsIDQpO1xuXHRyZXR1cm4gKGJ1Zik7XG59XG5cbmZ1bmN0aW9uIHNpZ24oY2VydCwga2V5KSB7XG5cdGlmIChjZXJ0LnNpZ25hdHVyZXMub3BlbnNzaCA9PT0gdW5kZWZpbmVkKVxuXHRcdGNlcnQuc2lnbmF0dXJlcy5vcGVuc3NoID0ge307XG5cdHRyeSB7XG5cdFx0dmFyIGJsb2IgPSB0b0J1ZmZlcihjZXJ0LCB0cnVlKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGRlbGV0ZSAoY2VydC5zaWduYXR1cmVzLm9wZW5zc2gpO1xuXHRcdHJldHVybiAoZmFsc2UpO1xuXHR9XG5cdHZhciBzaWcgPSBjZXJ0LnNpZ25hdHVyZXMub3BlbnNzaDtcblx0dmFyIGhhc2hBbGdvID0gdW5kZWZpbmVkO1xuXHRpZiAoa2V5LnR5cGUgPT09ICdyc2EnIHx8IGtleS50eXBlID09PSAnZHNhJylcblx0XHRoYXNoQWxnbyA9ICdzaGExJztcblx0dmFyIHNpZ25lciA9IGtleS5jcmVhdGVTaWduKGhhc2hBbGdvKTtcblx0c2lnbmVyLndyaXRlKGJsb2IpO1xuXHRzaWcuc2lnbmF0dXJlID0gc2lnbmVyLnNpZ24oKTtcblx0cmV0dXJuICh0cnVlKTtcbn1cblxuZnVuY3Rpb24gc2lnbkFzeW5jKGNlcnQsIHNpZ25lciwgZG9uZSkge1xuXHRpZiAoY2VydC5zaWduYXR1cmVzLm9wZW5zc2ggPT09IHVuZGVmaW5lZClcblx0XHRjZXJ0LnNpZ25hdHVyZXMub3BlbnNzaCA9IHt9O1xuXHR0cnkge1xuXHRcdHZhciBibG9iID0gdG9CdWZmZXIoY2VydCwgdHJ1ZSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRkZWxldGUgKGNlcnQuc2lnbmF0dXJlcy5vcGVuc3NoKTtcblx0XHRkb25lKGUpO1xuXHRcdHJldHVybjtcblx0fVxuXHR2YXIgc2lnID0gY2VydC5zaWduYXR1cmVzLm9wZW5zc2g7XG5cblx0c2lnbmVyKGJsb2IsIGZ1bmN0aW9uIChlcnIsIHNpZ25hdHVyZSkge1xuXHRcdGlmIChlcnIpIHtcblx0XHRcdGRvbmUoZXJyKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdC8qXG5cdFx0XHQgKiBUaGlzIHdpbGwgdGhyb3cgaWYgdGhlIHNpZ25hdHVyZSBpc24ndCBvZiBhXG5cdFx0XHQgKiB0eXBlL2FsZ28gdGhhdCBjYW4gYmUgdXNlZCBmb3IgU1NILlxuXHRcdFx0ICovXG5cdFx0XHRzaWduYXR1cmUudG9CdWZmZXIoJ3NzaCcpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGRvbmUoZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHNpZy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG5cdFx0ZG9uZSgpO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gd3JpdGUoY2VydCwgb3B0aW9ucykge1xuXHRpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxuXHRcdG9wdGlvbnMgPSB7fTtcblxuXHR2YXIgYmxvYiA9IHRvQnVmZmVyKGNlcnQpO1xuXHR2YXIgb3V0ID0gZ2V0Q2VydFR5cGUoY2VydC5zdWJqZWN0S2V5KSArICcgJyArIGJsb2IudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXHRpZiAob3B0aW9ucy5jb21tZW50KVxuXHRcdG91dCA9IG91dCArICcgJyArIG9wdGlvbnMuY29tbWVudDtcblx0cmV0dXJuIChvdXQpO1xufVxuXG5cbmZ1bmN0aW9uIHRvQnVmZmVyKGNlcnQsIG5vU2lnKSB7XG5cdGFzc2VydC5vYmplY3QoY2VydC5zaWduYXR1cmVzLm9wZW5zc2gsICdzaWduYXR1cmUgZm9yIG9wZW5zc2ggZm9ybWF0Jyk7XG5cdHZhciBzaWcgPSBjZXJ0LnNpZ25hdHVyZXMub3BlbnNzaDtcblxuXHRpZiAoc2lnLm5vbmNlID09PSB1bmRlZmluZWQpXG5cdFx0c2lnLm5vbmNlID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KTtcblx0dmFyIGJ1ZiA9IG5ldyBTU0hCdWZmZXIoe30pO1xuXHRidWYud3JpdGVTdHJpbmcoZ2V0Q2VydFR5cGUoY2VydC5zdWJqZWN0S2V5KSk7XG5cdGJ1Zi53cml0ZUJ1ZmZlcihzaWcubm9uY2UpO1xuXG5cdHZhciBrZXkgPSBjZXJ0LnN1YmplY3RLZXk7XG5cdHZhciBhbGdJbmZvID0gYWxncy5pbmZvW2tleS50eXBlXTtcblx0YWxnSW5mby5wYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG5cdFx0YnVmLndyaXRlUGFydChrZXkucGFydFtwYXJ0XSk7XG5cdH0pO1xuXG5cdGJ1Zi53cml0ZUludDY0KGNlcnQuc2VyaWFsKTtcblxuXHR2YXIgdHlwZSA9IGNlcnQuc3ViamVjdHNbMF0udHlwZTtcblx0YXNzZXJ0Lm5vdFN0cmljdEVxdWFsKHR5cGUsICd1bmtub3duJyk7XG5cdGNlcnQuc3ViamVjdHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwoaWQudHlwZSwgdHlwZSk7XG5cdH0pO1xuXHR0eXBlID0gVFlQRVNbdHlwZV07XG5cdGJ1Zi53cml0ZUludCh0eXBlKTtcblxuXHRpZiAoc2lnLmtleUlkID09PSB1bmRlZmluZWQpIHtcblx0XHRzaWcua2V5SWQgPSBjZXJ0LnN1YmplY3RzWzBdLnR5cGUgKyAnXycgK1xuXHRcdCAgICAoY2VydC5zdWJqZWN0c1swXS51aWQgfHwgY2VydC5zdWJqZWN0c1swXS5ob3N0bmFtZSk7XG5cdH1cblx0YnVmLndyaXRlU3RyaW5nKHNpZy5rZXlJZCk7XG5cblx0dmFyIHN1YiA9IG5ldyBTU0hCdWZmZXIoe30pO1xuXHRjZXJ0LnN1YmplY3RzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG5cdFx0aWYgKHR5cGUgPT09IFRZUEVTLmhvc3QpXG5cdFx0XHRzdWIud3JpdGVTdHJpbmcoaWQuaG9zdG5hbWUpO1xuXHRcdGVsc2UgaWYgKHR5cGUgPT09IFRZUEVTLnVzZXIpXG5cdFx0XHRzdWIud3JpdGVTdHJpbmcoaWQudWlkKTtcblx0fSk7XG5cdGJ1Zi53cml0ZUJ1ZmZlcihzdWIudG9CdWZmZXIoKSk7XG5cblx0YnVmLndyaXRlSW50NjQoZGF0ZVRvSW50NjQoY2VydC52YWxpZEZyb20pKTtcblx0YnVmLndyaXRlSW50NjQoZGF0ZVRvSW50NjQoY2VydC52YWxpZFVudGlsKSk7XG5cblx0dmFyIGV4dHMgPSBzaWcuZXh0cztcblx0aWYgKGV4dHMgPT09IHVuZGVmaW5lZClcblx0XHRleHRzID0gW107XG5cblx0dmFyIGV4dGJ1ZiA9IG5ldyBTU0hCdWZmZXIoe30pO1xuXHRleHRzLmZvckVhY2goZnVuY3Rpb24gKGV4dCkge1xuXHRcdGlmIChleHQuY3JpdGljYWwgIT09IHRydWUpXG5cdFx0XHRyZXR1cm47XG5cdFx0ZXh0YnVmLndyaXRlU3RyaW5nKGV4dC5uYW1lKTtcblx0XHRleHRidWYud3JpdGVCdWZmZXIoZXh0LmRhdGEpO1xuXHR9KTtcblx0YnVmLndyaXRlQnVmZmVyKGV4dGJ1Zi50b0J1ZmZlcigpKTtcblxuXHRleHRidWYgPSBuZXcgU1NIQnVmZmVyKHt9KTtcblx0ZXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChleHQpIHtcblx0XHRpZiAoZXh0LmNyaXRpY2FsID09PSB0cnVlKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGV4dGJ1Zi53cml0ZVN0cmluZyhleHQubmFtZSk7XG5cdFx0ZXh0YnVmLndyaXRlQnVmZmVyKGV4dC5kYXRhKTtcblx0fSk7XG5cdGJ1Zi53cml0ZUJ1ZmZlcihleHRidWYudG9CdWZmZXIoKSk7XG5cblx0LyogcmVzZXJ2ZWQgKi9cblx0YnVmLndyaXRlQnVmZmVyKEJ1ZmZlci5hbGxvYygwKSk7XG5cblx0c3ViID0gcmZjNDI1My53cml0ZShjZXJ0Lmlzc3VlcktleSk7XG5cdGJ1Zi53cml0ZUJ1ZmZlcihzdWIpO1xuXG5cdGlmICghbm9TaWcpXG5cdFx0YnVmLndyaXRlQnVmZmVyKHNpZy5zaWduYXR1cmUudG9CdWZmZXIoJ3NzaCcpKTtcblxuXHRyZXR1cm4gKGJ1Zi50b0J1ZmZlcigpKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxnKGNlcnRUeXBlKSB7XG5cdGlmIChjZXJ0VHlwZSA9PT0gJ3NzaC1yc2EtY2VydC12MDFAb3BlbnNzaC5jb20nKVxuXHRcdHJldHVybiAoJ3JzYScpO1xuXHRpZiAoY2VydFR5cGUgPT09ICdzc2gtZHNzLWNlcnQtdjAxQG9wZW5zc2guY29tJylcblx0XHRyZXR1cm4gKCdkc2EnKTtcblx0aWYgKGNlcnRUeXBlLm1hdGNoKEVDRFNBX0FMR08pKVxuXHRcdHJldHVybiAoJ2VjZHNhJyk7XG5cdGlmIChjZXJ0VHlwZSA9PT0gJ3NzaC1lZDI1NTE5LWNlcnQtdjAxQG9wZW5zc2guY29tJylcblx0XHRyZXR1cm4gKCdlZDI1NTE5Jyk7XG5cdHRocm93IChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNlcnQgdHlwZSAnICsgY2VydFR5cGUpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2VydFR5cGUoa2V5KSB7XG5cdGlmIChrZXkudHlwZSA9PT0gJ3JzYScpXG5cdFx0cmV0dXJuICgnc3NoLXJzYS1jZXJ0LXYwMUBvcGVuc3NoLmNvbScpO1xuXHRpZiAoa2V5LnR5cGUgPT09ICdkc2EnKVxuXHRcdHJldHVybiAoJ3NzaC1kc3MtY2VydC12MDFAb3BlbnNzaC5jb20nKTtcblx0aWYgKGtleS50eXBlID09PSAnZWNkc2EnKVxuXHRcdHJldHVybiAoJ2VjZHNhLXNoYTItJyArIGtleS5jdXJ2ZSArICctY2VydC12MDFAb3BlbnNzaC5jb20nKTtcblx0aWYgKGtleS50eXBlID09PSAnZWQyNTUxOScpXG5cdFx0cmV0dXJuICgnc3NoLWVkMjU1MTktY2VydC12MDFAb3BlbnNzaC5jb20nKTtcblx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQga2V5IHR5cGUgJyArIGtleS50eXBlKSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/formats/openssh-cert.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/formats/openssh-cert.js":
/*!********************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/openssh-cert.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2017 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\tverify: verify,\n\tsign: sign,\n\tsignAsync: signAsync,\n\twrite: write,\n\n\t/* Internal private API */\n\tfromBuffer: fromBuffer,\n\ttoBuffer: toBuffer\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ \"(rsc)/./node_modules/sshpk/lib/ssh-buffer.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\nvar Identity = __webpack_require__(/*! ../identity */ \"(rsc)/./node_modules/sshpk/lib/identity.js\");\nvar rfc4253 = __webpack_require__(/*! ./rfc4253 */ \"(rsc)/./node_modules/sshpk/lib/formats/rfc4253.js\");\nvar Signature = __webpack_require__(/*! ../signature */ \"(rsc)/./node_modules/sshpk/lib/signature.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar Certificate = __webpack_require__(/*! ../certificate */ \"(rsc)/./node_modules/sshpk/lib/certificate.js\");\n\nfunction verify(cert, key) {\n\t/*\n\t * We always give an issuerKey, so if our verify() is being called then\n\t * there was no signature. Return false.\n\t */\n\treturn (false);\n}\n\nvar TYPES = {\n\t'user': 1,\n\t'host': 2\n};\nObject.keys(TYPES).forEach(function (k) { TYPES[TYPES[k]] = k; });\n\nvar ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;\n\nfunction read(buf, options) {\n\tif (Buffer.isBuffer(buf))\n\t\tbuf = buf.toString('ascii');\n\tvar parts = buf.trim().split(/[ \\t\\n]+/g);\n\tif (parts.length < 2 || parts.length > 3)\n\t\tthrow (new Error('Not a valid SSH certificate line'));\n\n\tvar algo = parts[0];\n\tvar data = parts[1];\n\n\tdata = Buffer.from(data, 'base64');\n\treturn (fromBuffer(data, algo));\n}\n\nfunction fromBuffer(data, algo, partial) {\n\tvar sshbuf = new SSHBuffer({ buffer: data });\n\tvar innerAlgo = sshbuf.readString();\n\tif (algo !== undefined && innerAlgo !== algo)\n\t\tthrow (new Error('SSH certificate algorithm mismatch'));\n\tif (algo === undefined)\n\t\talgo = innerAlgo;\n\n\tvar cert = {};\n\tcert.signatures = {};\n\tcert.signatures.openssh = {};\n\n\tcert.signatures.openssh.nonce = sshbuf.readBuffer();\n\n\tvar key = {};\n\tvar parts = (key.parts = []);\n\tkey.type = getAlg(algo);\n\n\tvar partCount = algs.info[key.type].parts.length;\n\twhile (parts.length < partCount)\n\t\tparts.push(sshbuf.readPart());\n\tassert.ok(parts.length >= 1, 'key must have at least one part');\n\n\tvar algInfo = algs.info[key.type];\n\tif (key.type === 'ecdsa') {\n\t\tvar res = ECDSA_ALGO.exec(algo);\n\t\tassert.ok(res !== null);\n\t\tassert.strictEqual(res[1], parts[0].data.toString());\n\t}\n\n\tfor (var i = 0; i < algInfo.parts.length; ++i) {\n\t\tparts[i].name = algInfo.parts[i];\n\t\tif (parts[i].name !== 'curve' &&\n\t\t    algInfo.normalize !== false) {\n\t\t\tvar p = parts[i];\n\t\t\tp.data = utils.mpNormalize(p.data);\n\t\t}\n\t}\n\n\tcert.subjectKey = new Key(key);\n\n\tcert.serial = sshbuf.readInt64();\n\n\tvar type = TYPES[sshbuf.readInt()];\n\tassert.string(type, 'valid cert type');\n\n\tcert.signatures.openssh.keyId = sshbuf.readString();\n\n\tvar principals = [];\n\tvar pbuf = sshbuf.readBuffer();\n\tvar psshbuf = new SSHBuffer({ buffer: pbuf });\n\twhile (!psshbuf.atEnd())\n\t\tprincipals.push(psshbuf.readString());\n\tif (principals.length === 0)\n\t\tprincipals = ['*'];\n\n\tcert.subjects = principals.map(function (pr) {\n\t\tif (type === 'user')\n\t\t\treturn (Identity.forUser(pr));\n\t\telse if (type === 'host')\n\t\t\treturn (Identity.forHost(pr));\n\t\tthrow (new Error('Unknown identity type ' + type));\n\t});\n\n\tcert.validFrom = int64ToDate(sshbuf.readInt64());\n\tcert.validUntil = int64ToDate(sshbuf.readInt64());\n\n\tvar exts = [];\n\tvar extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });\n\tvar ext;\n\twhile (!extbuf.atEnd()) {\n\t\text = { critical: true };\n\t\text.name = extbuf.readString();\n\t\text.data = extbuf.readBuffer();\n\t\texts.push(ext);\n\t}\n\textbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });\n\twhile (!extbuf.atEnd()) {\n\t\text = { critical: false };\n\t\text.name = extbuf.readString();\n\t\text.data = extbuf.readBuffer();\n\t\texts.push(ext);\n\t}\n\tcert.signatures.openssh.exts = exts;\n\n\t/* reserved */\n\tsshbuf.readBuffer();\n\n\tvar signingKeyBuf = sshbuf.readBuffer();\n\tcert.issuerKey = rfc4253.read(signingKeyBuf);\n\n\t/*\n\t * OpenSSH certs don't give the identity of the issuer, just their\n\t * public key. So, we use an Identity that matches anything. The\n\t * isSignedBy() function will later tell you if the key matches.\n\t */\n\tcert.issuer = Identity.forHost('**');\n\n\tvar sigBuf = sshbuf.readBuffer();\n\tcert.signatures.openssh.signature =\n\t    Signature.parse(sigBuf, cert.issuerKey.type, 'ssh');\n\n\tif (partial !== undefined) {\n\t\tpartial.remainder = sshbuf.remainder();\n\t\tpartial.consumed = sshbuf._offset;\n\t}\n\n\treturn (new Certificate(cert));\n}\n\nfunction int64ToDate(buf) {\n\tvar i = buf.readUInt32BE(0) * 4294967296;\n\ti += buf.readUInt32BE(4);\n\tvar d = new Date();\n\td.setTime(i * 1000);\n\td.sourceInt64 = buf;\n\treturn (d);\n}\n\nfunction dateToInt64(date) {\n\tif (date.sourceInt64 !== undefined)\n\t\treturn (date.sourceInt64);\n\tvar i = Math.round(date.getTime() / 1000);\n\tvar upper = Math.floor(i / 4294967296);\n\tvar lower = Math.floor(i % 4294967296);\n\tvar buf = Buffer.alloc(8);\n\tbuf.writeUInt32BE(upper, 0);\n\tbuf.writeUInt32BE(lower, 4);\n\treturn (buf);\n}\n\nfunction sign(cert, key) {\n\tif (cert.signatures.openssh === undefined)\n\t\tcert.signatures.openssh = {};\n\ttry {\n\t\tvar blob = toBuffer(cert, true);\n\t} catch (e) {\n\t\tdelete (cert.signatures.openssh);\n\t\treturn (false);\n\t}\n\tvar sig = cert.signatures.openssh;\n\tvar hashAlgo = undefined;\n\tif (key.type === 'rsa' || key.type === 'dsa')\n\t\thashAlgo = 'sha1';\n\tvar signer = key.createSign(hashAlgo);\n\tsigner.write(blob);\n\tsig.signature = signer.sign();\n\treturn (true);\n}\n\nfunction signAsync(cert, signer, done) {\n\tif (cert.signatures.openssh === undefined)\n\t\tcert.signatures.openssh = {};\n\ttry {\n\t\tvar blob = toBuffer(cert, true);\n\t} catch (e) {\n\t\tdelete (cert.signatures.openssh);\n\t\tdone(e);\n\t\treturn;\n\t}\n\tvar sig = cert.signatures.openssh;\n\n\tsigner(blob, function (err, signature) {\n\t\tif (err) {\n\t\t\tdone(err);\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\t/*\n\t\t\t * This will throw if the signature isn't of a\n\t\t\t * type/algo that can be used for SSH.\n\t\t\t */\n\t\t\tsignature.toBuffer('ssh');\n\t\t} catch (e) {\n\t\t\tdone(e);\n\t\t\treturn;\n\t\t}\n\t\tsig.signature = signature;\n\t\tdone();\n\t});\n}\n\nfunction write(cert, options) {\n\tif (options === undefined)\n\t\toptions = {};\n\n\tvar blob = toBuffer(cert);\n\tvar out = getCertType(cert.subjectKey) + ' ' + blob.toString('base64');\n\tif (options.comment)\n\t\tout = out + ' ' + options.comment;\n\treturn (out);\n}\n\n\nfunction toBuffer(cert, noSig) {\n\tassert.object(cert.signatures.openssh, 'signature for openssh format');\n\tvar sig = cert.signatures.openssh;\n\n\tif (sig.nonce === undefined)\n\t\tsig.nonce = crypto.randomBytes(16);\n\tvar buf = new SSHBuffer({});\n\tbuf.writeString(getCertType(cert.subjectKey));\n\tbuf.writeBuffer(sig.nonce);\n\n\tvar key = cert.subjectKey;\n\tvar algInfo = algs.info[key.type];\n\talgInfo.parts.forEach(function (part) {\n\t\tbuf.writePart(key.part[part]);\n\t});\n\n\tbuf.writeInt64(cert.serial);\n\n\tvar type = cert.subjects[0].type;\n\tassert.notStrictEqual(type, 'unknown');\n\tcert.subjects.forEach(function (id) {\n\t\tassert.strictEqual(id.type, type);\n\t});\n\ttype = TYPES[type];\n\tbuf.writeInt(type);\n\n\tif (sig.keyId === undefined) {\n\t\tsig.keyId = cert.subjects[0].type + '_' +\n\t\t    (cert.subjects[0].uid || cert.subjects[0].hostname);\n\t}\n\tbuf.writeString(sig.keyId);\n\n\tvar sub = new SSHBuffer({});\n\tcert.subjects.forEach(function (id) {\n\t\tif (type === TYPES.host)\n\t\t\tsub.writeString(id.hostname);\n\t\telse if (type === TYPES.user)\n\t\t\tsub.writeString(id.uid);\n\t});\n\tbuf.writeBuffer(sub.toBuffer());\n\n\tbuf.writeInt64(dateToInt64(cert.validFrom));\n\tbuf.writeInt64(dateToInt64(cert.validUntil));\n\n\tvar exts = sig.exts;\n\tif (exts === undefined)\n\t\texts = [];\n\n\tvar extbuf = new SSHBuffer({});\n\texts.forEach(function (ext) {\n\t\tif (ext.critical !== true)\n\t\t\treturn;\n\t\textbuf.writeString(ext.name);\n\t\textbuf.writeBuffer(ext.data);\n\t});\n\tbuf.writeBuffer(extbuf.toBuffer());\n\n\textbuf = new SSHBuffer({});\n\texts.forEach(function (ext) {\n\t\tif (ext.critical === true)\n\t\t\treturn;\n\t\textbuf.writeString(ext.name);\n\t\textbuf.writeBuffer(ext.data);\n\t});\n\tbuf.writeBuffer(extbuf.toBuffer());\n\n\t/* reserved */\n\tbuf.writeBuffer(Buffer.alloc(0));\n\n\tsub = rfc4253.write(cert.issuerKey);\n\tbuf.writeBuffer(sub);\n\n\tif (!noSig)\n\t\tbuf.writeBuffer(sig.signature.toBuffer('ssh'));\n\n\treturn (buf.toBuffer());\n}\n\nfunction getAlg(certType) {\n\tif (certType === 'ssh-rsa-cert-v01@openssh.com')\n\t\treturn ('rsa');\n\tif (certType === 'ssh-dss-cert-v01@openssh.com')\n\t\treturn ('dsa');\n\tif (certType.match(ECDSA_ALGO))\n\t\treturn ('ecdsa');\n\tif (certType === 'ssh-ed25519-cert-v01@openssh.com')\n\t\treturn ('ed25519');\n\tthrow (new Error('Unsupported cert type ' + certType));\n}\n\nfunction getCertType(key) {\n\tif (key.type === 'rsa')\n\t\treturn ('ssh-rsa-cert-v01@openssh.com');\n\tif (key.type === 'dsa')\n\t\treturn ('ssh-dss-cert-v01@openssh.com');\n\tif (key.type === 'ecdsa')\n\t\treturn ('ecdsa-sha2-' + key.curve + '-cert-v01@openssh.com');\n\tif (key.type === 'ed25519')\n\t\treturn ('ssh-ed25519-cert-v01@openssh.com');\n\tthrow (new Error('Unsupported key type ' + key.type));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvb3BlbnNzaC1jZXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsK0RBQWE7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWU7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGFBQWEsOEZBQThCO0FBQzNDLFdBQVcsbUJBQU8sQ0FBQyx1REFBUztBQUM1QixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMscUVBQWdCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQywrREFBYTtBQUNwQyxjQUFjLG1CQUFPLENBQUMsb0VBQVc7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQWM7QUFDdEMsWUFBWSxtQkFBTyxDQUFDLHlEQUFVO0FBQzlCLGtCQUFrQixtQkFBTyxDQUFDLHFFQUFnQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCOztBQUVoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZCQUE2QjtBQUN2RDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9vcGVuc3NoLWNlcnQuanM/OTc1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNyBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHJlYWQ6IHJlYWQsXG5cdHZlcmlmeTogdmVyaWZ5LFxuXHRzaWduOiBzaWduLFxuXHRzaWduQXN5bmM6IHNpZ25Bc3luYyxcblx0d3JpdGU6IHdyaXRlLFxuXG5cdC8qIEludGVybmFsIHByaXZhdGUgQVBJICovXG5cdGZyb21CdWZmZXI6IGZyb21CdWZmZXIsXG5cdHRvQnVmZmVyOiB0b0J1ZmZlclxufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgU1NIQnVmZmVyID0gcmVxdWlyZSgnLi4vc3NoLWJ1ZmZlcicpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBhbGdzID0gcmVxdWlyZSgnLi4vYWxncycpO1xudmFyIEtleSA9IHJlcXVpcmUoJy4uL2tleScpO1xudmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuLi9wcml2YXRlLWtleScpO1xudmFyIElkZW50aXR5ID0gcmVxdWlyZSgnLi4vaWRlbnRpdHknKTtcbnZhciByZmM0MjUzID0gcmVxdWlyZSgnLi9yZmM0MjUzJyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vc2lnbmF0dXJlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIENlcnRpZmljYXRlID0gcmVxdWlyZSgnLi4vY2VydGlmaWNhdGUnKTtcblxuZnVuY3Rpb24gdmVyaWZ5KGNlcnQsIGtleSkge1xuXHQvKlxuXHQgKiBXZSBhbHdheXMgZ2l2ZSBhbiBpc3N1ZXJLZXksIHNvIGlmIG91ciB2ZXJpZnkoKSBpcyBiZWluZyBjYWxsZWQgdGhlblxuXHQgKiB0aGVyZSB3YXMgbm8gc2lnbmF0dXJlLiBSZXR1cm4gZmFsc2UuXG5cdCAqL1xuXHRyZXR1cm4gKGZhbHNlKTtcbn1cblxudmFyIFRZUEVTID0ge1xuXHQndXNlcic6IDEsXG5cdCdob3N0JzogMlxufTtcbk9iamVjdC5rZXlzKFRZUEVTKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IFRZUEVTW1RZUEVTW2tdXSA9IGs7IH0pO1xuXG52YXIgRUNEU0FfQUxHTyA9IC9eZWNkc2Etc2hhMi0oW15ALV0rKS1jZXJ0LXYwMUBvcGVuc3NoLmNvbSQvO1xuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb3B0aW9ucykge1xuXHRpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpXG5cdFx0YnVmID0gYnVmLnRvU3RyaW5nKCdhc2NpaScpO1xuXHR2YXIgcGFydHMgPSBidWYudHJpbSgpLnNwbGl0KC9bIFxcdFxcbl0rL2cpO1xuXHRpZiAocGFydHMubGVuZ3RoIDwgMiB8fCBwYXJ0cy5sZW5ndGggPiAzKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIFNTSCBjZXJ0aWZpY2F0ZSBsaW5lJykpO1xuXG5cdHZhciBhbGdvID0gcGFydHNbMF07XG5cdHZhciBkYXRhID0gcGFydHNbMV07XG5cblx0ZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiYXNlNjQnKTtcblx0cmV0dXJuIChmcm9tQnVmZmVyKGRhdGEsIGFsZ28pKTtcbn1cblxuZnVuY3Rpb24gZnJvbUJ1ZmZlcihkYXRhLCBhbGdvLCBwYXJ0aWFsKSB7XG5cdHZhciBzc2hidWYgPSBuZXcgU1NIQnVmZmVyKHsgYnVmZmVyOiBkYXRhIH0pO1xuXHR2YXIgaW5uZXJBbGdvID0gc3NoYnVmLnJlYWRTdHJpbmcoKTtcblx0aWYgKGFsZ28gIT09IHVuZGVmaW5lZCAmJiBpbm5lckFsZ28gIT09IGFsZ28pXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignU1NIIGNlcnRpZmljYXRlIGFsZ29yaXRobSBtaXNtYXRjaCcpKTtcblx0aWYgKGFsZ28gPT09IHVuZGVmaW5lZClcblx0XHRhbGdvID0gaW5uZXJBbGdvO1xuXG5cdHZhciBjZXJ0ID0ge307XG5cdGNlcnQuc2lnbmF0dXJlcyA9IHt9O1xuXHRjZXJ0LnNpZ25hdHVyZXMub3BlbnNzaCA9IHt9O1xuXG5cdGNlcnQuc2lnbmF0dXJlcy5vcGVuc3NoLm5vbmNlID0gc3NoYnVmLnJlYWRCdWZmZXIoKTtcblxuXHR2YXIga2V5ID0ge307XG5cdHZhciBwYXJ0cyA9IChrZXkucGFydHMgPSBbXSk7XG5cdGtleS50eXBlID0gZ2V0QWxnKGFsZ28pO1xuXG5cdHZhciBwYXJ0Q291bnQgPSBhbGdzLmluZm9ba2V5LnR5cGVdLnBhcnRzLmxlbmd0aDtcblx0d2hpbGUgKHBhcnRzLmxlbmd0aCA8IHBhcnRDb3VudClcblx0XHRwYXJ0cy5wdXNoKHNzaGJ1Zi5yZWFkUGFydCgpKTtcblx0YXNzZXJ0Lm9rKHBhcnRzLmxlbmd0aCA+PSAxLCAna2V5IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgcGFydCcpO1xuXG5cdHZhciBhbGdJbmZvID0gYWxncy5pbmZvW2tleS50eXBlXTtcblx0aWYgKGtleS50eXBlID09PSAnZWNkc2EnKSB7XG5cdFx0dmFyIHJlcyA9IEVDRFNBX0FMR08uZXhlYyhhbGdvKTtcblx0XHRhc3NlcnQub2socmVzICE9PSBudWxsKTtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwocmVzWzFdLCBwYXJ0c1swXS5kYXRhLnRvU3RyaW5nKCkpO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbGdJbmZvLnBhcnRzLmxlbmd0aDsgKytpKSB7XG5cdFx0cGFydHNbaV0ubmFtZSA9IGFsZ0luZm8ucGFydHNbaV07XG5cdFx0aWYgKHBhcnRzW2ldLm5hbWUgIT09ICdjdXJ2ZScgJiZcblx0XHQgICAgYWxnSW5mby5ub3JtYWxpemUgIT09IGZhbHNlKSB7XG5cdFx0XHR2YXIgcCA9IHBhcnRzW2ldO1xuXHRcdFx0cC5kYXRhID0gdXRpbHMubXBOb3JtYWxpemUocC5kYXRhKTtcblx0XHR9XG5cdH1cblxuXHRjZXJ0LnN1YmplY3RLZXkgPSBuZXcgS2V5KGtleSk7XG5cblx0Y2VydC5zZXJpYWwgPSBzc2hidWYucmVhZEludDY0KCk7XG5cblx0dmFyIHR5cGUgPSBUWVBFU1tzc2hidWYucmVhZEludCgpXTtcblx0YXNzZXJ0LnN0cmluZyh0eXBlLCAndmFsaWQgY2VydCB0eXBlJyk7XG5cblx0Y2VydC5zaWduYXR1cmVzLm9wZW5zc2gua2V5SWQgPSBzc2hidWYucmVhZFN0cmluZygpO1xuXG5cdHZhciBwcmluY2lwYWxzID0gW107XG5cdHZhciBwYnVmID0gc3NoYnVmLnJlYWRCdWZmZXIoKTtcblx0dmFyIHBzc2hidWYgPSBuZXcgU1NIQnVmZmVyKHsgYnVmZmVyOiBwYnVmIH0pO1xuXHR3aGlsZSAoIXBzc2hidWYuYXRFbmQoKSlcblx0XHRwcmluY2lwYWxzLnB1c2gocHNzaGJ1Zi5yZWFkU3RyaW5nKCkpO1xuXHRpZiAocHJpbmNpcGFscy5sZW5ndGggPT09IDApXG5cdFx0cHJpbmNpcGFscyA9IFsnKiddO1xuXG5cdGNlcnQuc3ViamVjdHMgPSBwcmluY2lwYWxzLm1hcChmdW5jdGlvbiAocHIpIHtcblx0XHRpZiAodHlwZSA9PT0gJ3VzZXInKVxuXHRcdFx0cmV0dXJuIChJZGVudGl0eS5mb3JVc2VyKHByKSk7XG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gJ2hvc3QnKVxuXHRcdFx0cmV0dXJuIChJZGVudGl0eS5mb3JIb3N0KHByKSk7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biBpZGVudGl0eSB0eXBlICcgKyB0eXBlKSk7XG5cdH0pO1xuXG5cdGNlcnQudmFsaWRGcm9tID0gaW50NjRUb0RhdGUoc3NoYnVmLnJlYWRJbnQ2NCgpKTtcblx0Y2VydC52YWxpZFVudGlsID0gaW50NjRUb0RhdGUoc3NoYnVmLnJlYWRJbnQ2NCgpKTtcblxuXHR2YXIgZXh0cyA9IFtdO1xuXHR2YXIgZXh0YnVmID0gbmV3IFNTSEJ1ZmZlcih7IGJ1ZmZlcjogc3NoYnVmLnJlYWRCdWZmZXIoKSB9KTtcblx0dmFyIGV4dDtcblx0d2hpbGUgKCFleHRidWYuYXRFbmQoKSkge1xuXHRcdGV4dCA9IHsgY3JpdGljYWw6IHRydWUgfTtcblx0XHRleHQubmFtZSA9IGV4dGJ1Zi5yZWFkU3RyaW5nKCk7XG5cdFx0ZXh0LmRhdGEgPSBleHRidWYucmVhZEJ1ZmZlcigpO1xuXHRcdGV4dHMucHVzaChleHQpO1xuXHR9XG5cdGV4dGJ1ZiA9IG5ldyBTU0hCdWZmZXIoeyBidWZmZXI6IHNzaGJ1Zi5yZWFkQnVmZmVyKCkgfSk7XG5cdHdoaWxlICghZXh0YnVmLmF0RW5kKCkpIHtcblx0XHRleHQgPSB7IGNyaXRpY2FsOiBmYWxzZSB9O1xuXHRcdGV4dC5uYW1lID0gZXh0YnVmLnJlYWRTdHJpbmcoKTtcblx0XHRleHQuZGF0YSA9IGV4dGJ1Zi5yZWFkQnVmZmVyKCk7XG5cdFx0ZXh0cy5wdXNoKGV4dCk7XG5cdH1cblx0Y2VydC5zaWduYXR1cmVzLm9wZW5zc2guZXh0cyA9IGV4dHM7XG5cblx0LyogcmVzZXJ2ZWQgKi9cblx0c3NoYnVmLnJlYWRCdWZmZXIoKTtcblxuXHR2YXIgc2lnbmluZ0tleUJ1ZiA9IHNzaGJ1Zi5yZWFkQnVmZmVyKCk7XG5cdGNlcnQuaXNzdWVyS2V5ID0gcmZjNDI1My5yZWFkKHNpZ25pbmdLZXlCdWYpO1xuXG5cdC8qXG5cdCAqIE9wZW5TU0ggY2VydHMgZG9uJ3QgZ2l2ZSB0aGUgaWRlbnRpdHkgb2YgdGhlIGlzc3VlciwganVzdCB0aGVpclxuXHQgKiBwdWJsaWMga2V5LiBTbywgd2UgdXNlIGFuIElkZW50aXR5IHRoYXQgbWF0Y2hlcyBhbnl0aGluZy4gVGhlXG5cdCAqIGlzU2lnbmVkQnkoKSBmdW5jdGlvbiB3aWxsIGxhdGVyIHRlbGwgeW91IGlmIHRoZSBrZXkgbWF0Y2hlcy5cblx0ICovXG5cdGNlcnQuaXNzdWVyID0gSWRlbnRpdHkuZm9ySG9zdCgnKionKTtcblxuXHR2YXIgc2lnQnVmID0gc3NoYnVmLnJlYWRCdWZmZXIoKTtcblx0Y2VydC5zaWduYXR1cmVzLm9wZW5zc2guc2lnbmF0dXJlID1cblx0ICAgIFNpZ25hdHVyZS5wYXJzZShzaWdCdWYsIGNlcnQuaXNzdWVyS2V5LnR5cGUsICdzc2gnKTtcblxuXHRpZiAocGFydGlhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cGFydGlhbC5yZW1haW5kZXIgPSBzc2hidWYucmVtYWluZGVyKCk7XG5cdFx0cGFydGlhbC5jb25zdW1lZCA9IHNzaGJ1Zi5fb2Zmc2V0O1xuXHR9XG5cblx0cmV0dXJuIChuZXcgQ2VydGlmaWNhdGUoY2VydCkpO1xufVxuXG5mdW5jdGlvbiBpbnQ2NFRvRGF0ZShidWYpIHtcblx0dmFyIGkgPSBidWYucmVhZFVJbnQzMkJFKDApICogNDI5NDk2NzI5Njtcblx0aSArPSBidWYucmVhZFVJbnQzMkJFKDQpO1xuXHR2YXIgZCA9IG5ldyBEYXRlKCk7XG5cdGQuc2V0VGltZShpICogMTAwMCk7XG5cdGQuc291cmNlSW50NjQgPSBidWY7XG5cdHJldHVybiAoZCk7XG59XG5cbmZ1bmN0aW9uIGRhdGVUb0ludDY0KGRhdGUpIHtcblx0aWYgKGRhdGUuc291cmNlSW50NjQgIT09IHVuZGVmaW5lZClcblx0XHRyZXR1cm4gKGRhdGUuc291cmNlSW50NjQpO1xuXHR2YXIgaSA9IE1hdGgucm91bmQoZGF0ZS5nZXRUaW1lKCkgLyAxMDAwKTtcblx0dmFyIHVwcGVyID0gTWF0aC5mbG9vcihpIC8gNDI5NDk2NzI5Nik7XG5cdHZhciBsb3dlciA9IE1hdGguZmxvb3IoaSAlIDQyOTQ5NjcyOTYpO1xuXHR2YXIgYnVmID0gQnVmZmVyLmFsbG9jKDgpO1xuXHRidWYud3JpdGVVSW50MzJCRSh1cHBlciwgMCk7XG5cdGJ1Zi53cml0ZVVJbnQzMkJFKGxvd2VyLCA0KTtcblx0cmV0dXJuIChidWYpO1xufVxuXG5mdW5jdGlvbiBzaWduKGNlcnQsIGtleSkge1xuXHRpZiAoY2VydC5zaWduYXR1cmVzLm9wZW5zc2ggPT09IHVuZGVmaW5lZClcblx0XHRjZXJ0LnNpZ25hdHVyZXMub3BlbnNzaCA9IHt9O1xuXHR0cnkge1xuXHRcdHZhciBibG9iID0gdG9CdWZmZXIoY2VydCwgdHJ1ZSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRkZWxldGUgKGNlcnQuc2lnbmF0dXJlcy5vcGVuc3NoKTtcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0fVxuXHR2YXIgc2lnID0gY2VydC5zaWduYXR1cmVzLm9wZW5zc2g7XG5cdHZhciBoYXNoQWxnbyA9IHVuZGVmaW5lZDtcblx0aWYgKGtleS50eXBlID09PSAncnNhJyB8fCBrZXkudHlwZSA9PT0gJ2RzYScpXG5cdFx0aGFzaEFsZ28gPSAnc2hhMSc7XG5cdHZhciBzaWduZXIgPSBrZXkuY3JlYXRlU2lnbihoYXNoQWxnbyk7XG5cdHNpZ25lci53cml0ZShibG9iKTtcblx0c2lnLnNpZ25hdHVyZSA9IHNpZ25lci5zaWduKCk7XG5cdHJldHVybiAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHNpZ25Bc3luYyhjZXJ0LCBzaWduZXIsIGRvbmUpIHtcblx0aWYgKGNlcnQuc2lnbmF0dXJlcy5vcGVuc3NoID09PSB1bmRlZmluZWQpXG5cdFx0Y2VydC5zaWduYXR1cmVzLm9wZW5zc2ggPSB7fTtcblx0dHJ5IHtcblx0XHR2YXIgYmxvYiA9IHRvQnVmZmVyKGNlcnQsIHRydWUpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0ZGVsZXRlIChjZXJ0LnNpZ25hdHVyZXMub3BlbnNzaCk7XG5cdFx0ZG9uZShlKTtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyIHNpZyA9IGNlcnQuc2lnbmF0dXJlcy5vcGVuc3NoO1xuXG5cdHNpZ25lcihibG9iLCBmdW5jdGlvbiAoZXJyLCBzaWduYXR1cmUpIHtcblx0XHRpZiAoZXJyKSB7XG5cdFx0XHRkb25lKGVycik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHQvKlxuXHRcdFx0ICogVGhpcyB3aWxsIHRocm93IGlmIHRoZSBzaWduYXR1cmUgaXNuJ3Qgb2YgYVxuXHRcdFx0ICogdHlwZS9hbGdvIHRoYXQgY2FuIGJlIHVzZWQgZm9yIFNTSC5cblx0XHRcdCAqL1xuXHRcdFx0c2lnbmF0dXJlLnRvQnVmZmVyKCdzc2gnKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRkb25lKGUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRzaWcuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuXHRcdGRvbmUoKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlKGNlcnQsIG9wdGlvbnMpIHtcblx0aWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZClcblx0XHRvcHRpb25zID0ge307XG5cblx0dmFyIGJsb2IgPSB0b0J1ZmZlcihjZXJ0KTtcblx0dmFyIG91dCA9IGdldENlcnRUeXBlKGNlcnQuc3ViamVjdEtleSkgKyAnICcgKyBibG9iLnRvU3RyaW5nKCdiYXNlNjQnKTtcblx0aWYgKG9wdGlvbnMuY29tbWVudClcblx0XHRvdXQgPSBvdXQgKyAnICcgKyBvcHRpb25zLmNvbW1lbnQ7XG5cdHJldHVybiAob3V0KTtcbn1cblxuXG5mdW5jdGlvbiB0b0J1ZmZlcihjZXJ0LCBub1NpZykge1xuXHRhc3NlcnQub2JqZWN0KGNlcnQuc2lnbmF0dXJlcy5vcGVuc3NoLCAnc2lnbmF0dXJlIGZvciBvcGVuc3NoIGZvcm1hdCcpO1xuXHR2YXIgc2lnID0gY2VydC5zaWduYXR1cmVzLm9wZW5zc2g7XG5cblx0aWYgKHNpZy5ub25jZSA9PT0gdW5kZWZpbmVkKVxuXHRcdHNpZy5ub25jZSA9IGNyeXB0by5yYW5kb21CeXRlcygxNik7XG5cdHZhciBidWYgPSBuZXcgU1NIQnVmZmVyKHt9KTtcblx0YnVmLndyaXRlU3RyaW5nKGdldENlcnRUeXBlKGNlcnQuc3ViamVjdEtleSkpO1xuXHRidWYud3JpdGVCdWZmZXIoc2lnLm5vbmNlKTtcblxuXHR2YXIga2V5ID0gY2VydC5zdWJqZWN0S2V5O1xuXHR2YXIgYWxnSW5mbyA9IGFsZ3MuaW5mb1trZXkudHlwZV07XG5cdGFsZ0luZm8ucGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuXHRcdGJ1Zi53cml0ZVBhcnQoa2V5LnBhcnRbcGFydF0pO1xuXHR9KTtcblxuXHRidWYud3JpdGVJbnQ2NChjZXJ0LnNlcmlhbCk7XG5cblx0dmFyIHR5cGUgPSBjZXJ0LnN1YmplY3RzWzBdLnR5cGU7XG5cdGFzc2VydC5ub3RTdHJpY3RFcXVhbCh0eXBlLCAndW5rbm93bicpO1xuXHRjZXJ0LnN1YmplY3RzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG5cdFx0YXNzZXJ0LnN0cmljdEVxdWFsKGlkLnR5cGUsIHR5cGUpO1xuXHR9KTtcblx0dHlwZSA9IFRZUEVTW3R5cGVdO1xuXHRidWYud3JpdGVJbnQodHlwZSk7XG5cblx0aWYgKHNpZy5rZXlJZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0c2lnLmtleUlkID0gY2VydC5zdWJqZWN0c1swXS50eXBlICsgJ18nICtcblx0XHQgICAgKGNlcnQuc3ViamVjdHNbMF0udWlkIHx8IGNlcnQuc3ViamVjdHNbMF0uaG9zdG5hbWUpO1xuXHR9XG5cdGJ1Zi53cml0ZVN0cmluZyhzaWcua2V5SWQpO1xuXG5cdHZhciBzdWIgPSBuZXcgU1NIQnVmZmVyKHt9KTtcblx0Y2VydC5zdWJqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuXHRcdGlmICh0eXBlID09PSBUWVBFUy5ob3N0KVxuXHRcdFx0c3ViLndyaXRlU3RyaW5nKGlkLmhvc3RuYW1lKTtcblx0XHRlbHNlIGlmICh0eXBlID09PSBUWVBFUy51c2VyKVxuXHRcdFx0c3ViLndyaXRlU3RyaW5nKGlkLnVpZCk7XG5cdH0pO1xuXHRidWYud3JpdGVCdWZmZXIoc3ViLnRvQnVmZmVyKCkpO1xuXG5cdGJ1Zi53cml0ZUludDY0KGRhdGVUb0ludDY0KGNlcnQudmFsaWRGcm9tKSk7XG5cdGJ1Zi53cml0ZUludDY0KGRhdGVUb0ludDY0KGNlcnQudmFsaWRVbnRpbCkpO1xuXG5cdHZhciBleHRzID0gc2lnLmV4dHM7XG5cdGlmIChleHRzID09PSB1bmRlZmluZWQpXG5cdFx0ZXh0cyA9IFtdO1xuXG5cdHZhciBleHRidWYgPSBuZXcgU1NIQnVmZmVyKHt9KTtcblx0ZXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChleHQpIHtcblx0XHRpZiAoZXh0LmNyaXRpY2FsICE9PSB0cnVlKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGV4dGJ1Zi53cml0ZVN0cmluZyhleHQubmFtZSk7XG5cdFx0ZXh0YnVmLndyaXRlQnVmZmVyKGV4dC5kYXRhKTtcblx0fSk7XG5cdGJ1Zi53cml0ZUJ1ZmZlcihleHRidWYudG9CdWZmZXIoKSk7XG5cblx0ZXh0YnVmID0gbmV3IFNTSEJ1ZmZlcih7fSk7XG5cdGV4dHMuZm9yRWFjaChmdW5jdGlvbiAoZXh0KSB7XG5cdFx0aWYgKGV4dC5jcml0aWNhbCA9PT0gdHJ1ZSlcblx0XHRcdHJldHVybjtcblx0XHRleHRidWYud3JpdGVTdHJpbmcoZXh0Lm5hbWUpO1xuXHRcdGV4dGJ1Zi53cml0ZUJ1ZmZlcihleHQuZGF0YSk7XG5cdH0pO1xuXHRidWYud3JpdGVCdWZmZXIoZXh0YnVmLnRvQnVmZmVyKCkpO1xuXG5cdC8qIHJlc2VydmVkICovXG5cdGJ1Zi53cml0ZUJ1ZmZlcihCdWZmZXIuYWxsb2MoMCkpO1xuXG5cdHN1YiA9IHJmYzQyNTMud3JpdGUoY2VydC5pc3N1ZXJLZXkpO1xuXHRidWYud3JpdGVCdWZmZXIoc3ViKTtcblxuXHRpZiAoIW5vU2lnKVxuXHRcdGJ1Zi53cml0ZUJ1ZmZlcihzaWcuc2lnbmF0dXJlLnRvQnVmZmVyKCdzc2gnKSk7XG5cblx0cmV0dXJuIChidWYudG9CdWZmZXIoKSk7XG59XG5cbmZ1bmN0aW9uIGdldEFsZyhjZXJ0VHlwZSkge1xuXHRpZiAoY2VydFR5cGUgPT09ICdzc2gtcnNhLWNlcnQtdjAxQG9wZW5zc2guY29tJylcblx0XHRyZXR1cm4gKCdyc2EnKTtcblx0aWYgKGNlcnRUeXBlID09PSAnc3NoLWRzcy1jZXJ0LXYwMUBvcGVuc3NoLmNvbScpXG5cdFx0cmV0dXJuICgnZHNhJyk7XG5cdGlmIChjZXJ0VHlwZS5tYXRjaChFQ0RTQV9BTEdPKSlcblx0XHRyZXR1cm4gKCdlY2RzYScpO1xuXHRpZiAoY2VydFR5cGUgPT09ICdzc2gtZWQyNTUxOS1jZXJ0LXYwMUBvcGVuc3NoLmNvbScpXG5cdFx0cmV0dXJuICgnZWQyNTUxOScpO1xuXHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBjZXJ0IHR5cGUgJyArIGNlcnRUeXBlKSk7XG59XG5cbmZ1bmN0aW9uIGdldENlcnRUeXBlKGtleSkge1xuXHRpZiAoa2V5LnR5cGUgPT09ICdyc2EnKVxuXHRcdHJldHVybiAoJ3NzaC1yc2EtY2VydC12MDFAb3BlbnNzaC5jb20nKTtcblx0aWYgKGtleS50eXBlID09PSAnZHNhJylcblx0XHRyZXR1cm4gKCdzc2gtZHNzLWNlcnQtdjAxQG9wZW5zc2guY29tJyk7XG5cdGlmIChrZXkudHlwZSA9PT0gJ2VjZHNhJylcblx0XHRyZXR1cm4gKCdlY2RzYS1zaGEyLScgKyBrZXkuY3VydmUgKyAnLWNlcnQtdjAxQG9wZW5zc2guY29tJyk7XG5cdGlmIChrZXkudHlwZSA9PT0gJ2VkMjU1MTknKVxuXHRcdHJldHVybiAoJ3NzaC1lZDI1NTE5LWNlcnQtdjAxQG9wZW5zc2guY29tJyk7XG5cdHRocm93IChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtleSB0eXBlICcgKyBrZXkudHlwZSkpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/formats/openssh-cert.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/formats/pem.js":
/*!***********************************************!*\
  !*** ./node_modules/sshpk/lib/formats/pem.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2018 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(action-browser)/./node_modules/asn1/lib/index.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\n\nvar pkcs1 = __webpack_require__(/*! ./pkcs1 */ \"(action-browser)/./node_modules/sshpk/lib/formats/pkcs1.js\");\nvar pkcs8 = __webpack_require__(/*! ./pkcs8 */ \"(action-browser)/./node_modules/sshpk/lib/formats/pkcs8.js\");\nvar sshpriv = __webpack_require__(/*! ./ssh-private */ \"(action-browser)/./node_modules/sshpk/lib/formats/ssh-private.js\");\nvar rfc4253 = __webpack_require__(/*! ./rfc4253 */ \"(action-browser)/./node_modules/sshpk/lib/formats/rfc4253.js\");\n\nvar errors = __webpack_require__(/*! ../errors */ \"(action-browser)/./node_modules/sshpk/lib/errors.js\");\n\nvar OID_PBES2 = '1.2.840.113549.1.5.13';\nvar OID_PBKDF2 = '1.2.840.113549.1.5.12';\n\nvar OID_TO_CIPHER = {\n\t'1.2.840.113549.3.7': '3des-cbc',\n\t'2.16.840.1.101.3.4.1.2': 'aes128-cbc',\n\t'2.16.840.1.101.3.4.1.42': 'aes256-cbc'\n};\nvar CIPHER_TO_OID = {};\nObject.keys(OID_TO_CIPHER).forEach(function (k) {\n\tCIPHER_TO_OID[OID_TO_CIPHER[k]] = k;\n});\n\nvar OID_TO_HASH = {\n\t'1.2.840.113549.2.7': 'sha1',\n\t'1.2.840.113549.2.9': 'sha256',\n\t'1.2.840.113549.2.11': 'sha512'\n};\nvar HASH_TO_OID = {};\nObject.keys(OID_TO_HASH).forEach(function (k) {\n\tHASH_TO_OID[OID_TO_HASH[k]] = k;\n});\n\n/*\n * For reading we support both PKCS#1 and PKCS#8. If we find a private key,\n * we just take the public component of it and use that.\n */\nfunction read(buf, options, forceType) {\n\tvar input = buf;\n\tif (typeof (buf) !== 'string') {\n\t\tassert.buffer(buf, 'buf');\n\t\tbuf = buf.toString('ascii');\n\t}\n\n\tvar lines = buf.trim().split(/[\\r\\n]+/g);\n\n\tvar m;\n\tvar si = -1;\n\twhile (!m && si < lines.length) {\n\t\tm = lines[++si].match(/*JSSTYLED*/\n\t\t    /[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);\n\t}\n\tassert.ok(m, 'invalid PEM header');\n\n\tvar m2;\n\tvar ei = lines.length;\n\twhile (!m2 && ei > 0) {\n\t\tm2 = lines[--ei].match(/*JSSTYLED*/\n\t\t    /[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);\n\t}\n\tassert.ok(m2, 'invalid PEM footer');\n\n\t/* Begin and end banners must match key type */\n\tassert.equal(m[2], m2[2]);\n\tvar type = m[2].toLowerCase();\n\n\tvar alg;\n\tif (m[1]) {\n\t\t/* They also must match algorithms, if given */\n\t\tassert.equal(m[1], m2[1], 'PEM header and footer mismatch');\n\t\talg = m[1].trim();\n\t}\n\n\tlines = lines.slice(si, ei + 1);\n\n\tvar headers = {};\n\twhile (true) {\n\t\tlines = lines.slice(1);\n\t\tm = lines[0].match(/*JSSTYLED*/\n\t\t    /^([A-Za-z0-9-]+): (.+)$/);\n\t\tif (!m)\n\t\t\tbreak;\n\t\theaders[m[1].toLowerCase()] = m[2];\n\t}\n\n\t/* Chop off the first and last lines */\n\tlines = lines.slice(0, -1).join('');\n\tbuf = Buffer.from(lines, 'base64');\n\n\tvar cipher, key, iv;\n\tif (headers['proc-type']) {\n\t\tvar parts = headers['proc-type'].split(',');\n\t\tif (parts[0] === '4' && parts[1] === 'ENCRYPTED') {\n\t\t\tif (typeof (options.passphrase) === 'string') {\n\t\t\t\toptions.passphrase = Buffer.from(\n\t\t\t\t    options.passphrase, 'utf-8');\n\t\t\t}\n\t\t\tif (!Buffer.isBuffer(options.passphrase)) {\n\t\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t\t    options.filename, 'PEM'));\n\t\t\t} else {\n\t\t\t\tparts = headers['dek-info'].split(',');\n\t\t\t\tassert.ok(parts.length === 2);\n\t\t\t\tcipher = parts[0].toLowerCase();\n\t\t\t\tiv = Buffer.from(parts[1], 'hex');\n\t\t\t\tkey = utils.opensslKeyDeriv(cipher, iv,\n\t\t\t\t    options.passphrase, 1).key;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (alg && alg.toLowerCase() === 'encrypted') {\n\t\tvar eder = new asn1.BerReader(buf);\n\t\tvar pbesEnd;\n\t\teder.readSequence();\n\n\t\teder.readSequence();\n\t\tpbesEnd = eder.offset + eder.length;\n\n\t\tvar method = eder.readOID();\n\t\tif (method !== OID_PBES2) {\n\t\t\tthrow (new Error('Unsupported PEM/PKCS8 encryption ' +\n\t\t\t    'scheme: ' + method));\n\t\t}\n\n\t\teder.readSequence();\t/* PBES2-params */\n\n\t\teder.readSequence();\t/* keyDerivationFunc */\n\t\tvar kdfEnd = eder.offset + eder.length;\n\t\tvar kdfOid = eder.readOID();\n\t\tif (kdfOid !== OID_PBKDF2)\n\t\t\tthrow (new Error('Unsupported PBES2 KDF: ' + kdfOid));\n\t\teder.readSequence();\n\t\tvar salt = eder.readString(asn1.Ber.OctetString, true);\n\t\tvar iterations = eder.readInt();\n\t\tvar hashAlg = 'sha1';\n\t\tif (eder.offset < kdfEnd) {\n\t\t\teder.readSequence();\n\t\t\tvar hashAlgOid = eder.readOID();\n\t\t\thashAlg = OID_TO_HASH[hashAlgOid];\n\t\t\tif (hashAlg === undefined) {\n\t\t\t\tthrow (new Error('Unsupported PBKDF2 hash: ' +\n\t\t\t\t    hashAlgOid));\n\t\t\t}\n\t\t}\n\t\teder._offset = kdfEnd;\n\n\t\teder.readSequence();\t/* encryptionScheme */\n\t\tvar cipherOid = eder.readOID();\n\t\tcipher = OID_TO_CIPHER[cipherOid];\n\t\tif (cipher === undefined) {\n\t\t\tthrow (new Error('Unsupported PBES2 cipher: ' +\n\t\t\t    cipherOid));\n\t\t}\n\t\tiv = eder.readString(asn1.Ber.OctetString, true);\n\n\t\teder._offset = pbesEnd;\n\t\tbuf = eder.readString(asn1.Ber.OctetString, true);\n\n\t\tif (typeof (options.passphrase) === 'string') {\n\t\t\toptions.passphrase = Buffer.from(\n\t\t\t    options.passphrase, 'utf-8');\n\t\t}\n\t\tif (!Buffer.isBuffer(options.passphrase)) {\n\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t    options.filename, 'PEM'));\n\t\t}\n\n\t\tvar cinfo = utils.opensshCipherInfo(cipher);\n\n\t\tcipher = cinfo.opensslName;\n\t\tkey = utils.pbkdf2(hashAlg, salt, iterations, cinfo.keySize,\n\t\t    options.passphrase);\n\t\talg = undefined;\n\t}\n\n\tif (cipher && key && iv) {\n\t\tvar cipherStream = crypto.createDecipheriv(cipher, key, iv);\n\t\tvar chunk, chunks = [];\n\t\tcipherStream.once('error', function (e) {\n\t\t\tif (e.toString().indexOf('bad decrypt') !== -1) {\n\t\t\t\tthrow (new Error('Incorrect passphrase ' +\n\t\t\t\t    'supplied, could not decrypt key'));\n\t\t\t}\n\t\t\tthrow (e);\n\t\t});\n\t\tcipherStream.write(buf);\n\t\tcipherStream.end();\n\t\twhile ((chunk = cipherStream.read()) !== null)\n\t\t\tchunks.push(chunk);\n\t\tbuf = Buffer.concat(chunks);\n\t}\n\n\t/* The new OpenSSH internal format abuses PEM headers */\n\tif (alg && alg.toLowerCase() === 'openssh')\n\t\treturn (sshpriv.readSSHPrivate(type, buf, options));\n\tif (alg && alg.toLowerCase() === 'ssh2')\n\t\treturn (rfc4253.readType(type, buf, options));\n\n\tvar der = new asn1.BerReader(buf);\n\tder.originalInput = input;\n\n\t/*\n\t * All of the PEM file types start with a sequence tag, so chop it\n\t * off here\n\t */\n\tder.readSequence();\n\n\t/* PKCS#1 type keys name an algorithm in the banner explicitly */\n\tif (alg) {\n\t\tif (forceType)\n\t\t\tassert.strictEqual(forceType, 'pkcs1');\n\t\treturn (pkcs1.readPkcs1(alg, type, der));\n\t} else {\n\t\tif (forceType)\n\t\t\tassert.strictEqual(forceType, 'pkcs8');\n\t\treturn (pkcs8.readPkcs8(alg, type, der));\n\t}\n}\n\nfunction write(key, options, type) {\n\tassert.object(key);\n\n\tvar alg = {\n\t    'ecdsa': 'EC',\n\t    'rsa': 'RSA',\n\t    'dsa': 'DSA',\n\t    'ed25519': 'EdDSA'\n\t}[key.type];\n\tvar header;\n\n\tvar der = new asn1.BerWriter();\n\n\tif (PrivateKey.isPrivateKey(key)) {\n\t\tif (type && type === 'pkcs8') {\n\t\t\theader = 'PRIVATE KEY';\n\t\t\tpkcs8.writePkcs8(der, key);\n\t\t} else {\n\t\t\tif (type)\n\t\t\t\tassert.strictEqual(type, 'pkcs1');\n\t\t\theader = alg + ' PRIVATE KEY';\n\t\t\tpkcs1.writePkcs1(der, key);\n\t\t}\n\n\t} else if (Key.isKey(key)) {\n\t\tif (type && type === 'pkcs1') {\n\t\t\theader = alg + ' PUBLIC KEY';\n\t\t\tpkcs1.writePkcs1(der, key);\n\t\t} else {\n\t\t\tif (type)\n\t\t\t\tassert.strictEqual(type, 'pkcs8');\n\t\t\theader = 'PUBLIC KEY';\n\t\t\tpkcs8.writePkcs8(der, key);\n\t\t}\n\n\t} else {\n\t\tthrow (new Error('key is not a Key or PrivateKey'));\n\t}\n\n\tvar tmp = der.buffer.toString('base64');\n\tvar len = tmp.length + (tmp.length / 64) +\n\t    18 + 16 + header.length*2 + 10;\n\tvar buf = Buffer.alloc(len);\n\tvar o = 0;\n\to += buf.write('-----BEGIN ' + header + '-----\\n', o);\n\tfor (var i = 0; i < tmp.length; ) {\n\t\tvar limit = i + 64;\n\t\tif (limit > tmp.length)\n\t\t\tlimit = tmp.length;\n\t\to += buf.write(tmp.slice(i, limit), o);\n\t\tbuf[o++] = 10;\n\t\ti = limit;\n\t}\n\to += buf.write('-----END ' + header + '-----\\n', o);\n\n\treturn (buf.slice(0, o));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9wZW0uanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDBFQUFhO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQywrREFBTTtBQUN6QixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsYUFBYSx5R0FBOEI7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLGtFQUFTO0FBQzVCLFlBQVksbUJBQU8sQ0FBQyxvRUFBVTtBQUM5QixVQUFVLG1CQUFPLENBQUMsZ0VBQVE7QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQWdCOztBQUV6QyxZQUFZLG1CQUFPLENBQUMsMkVBQVM7QUFDN0IsWUFBWSxtQkFBTyxDQUFDLDJFQUFTO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyx1RkFBZTtBQUNyQyxjQUFjLG1CQUFPLENBQUMsK0VBQVc7O0FBRWpDLGFBQWEsbUJBQU8sQ0FBQyxzRUFBVzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9wZW0uanM/NTU3MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOCBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHJlYWQ6IHJlYWQsXG5cdHdyaXRlOiB3cml0ZVxufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgYXNuMSA9IHJlcXVpcmUoJ2FzbjEnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4uL2FsZ3MnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgS2V5ID0gcmVxdWlyZSgnLi4va2V5Jyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uL3ByaXZhdGUta2V5Jyk7XG5cbnZhciBwa2NzMSA9IHJlcXVpcmUoJy4vcGtjczEnKTtcbnZhciBwa2NzOCA9IHJlcXVpcmUoJy4vcGtjczgnKTtcbnZhciBzc2hwcml2ID0gcmVxdWlyZSgnLi9zc2gtcHJpdmF0ZScpO1xudmFyIHJmYzQyNTMgPSByZXF1aXJlKCcuL3JmYzQyNTMnKTtcblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuXG52YXIgT0lEX1BCRVMyID0gJzEuMi44NDAuMTEzNTQ5LjEuNS4xMyc7XG52YXIgT0lEX1BCS0RGMiA9ICcxLjIuODQwLjExMzU0OS4xLjUuMTInO1xuXG52YXIgT0lEX1RPX0NJUEhFUiA9IHtcblx0JzEuMi44NDAuMTEzNTQ5LjMuNyc6ICczZGVzLWNiYycsXG5cdCcyLjE2Ljg0MC4xLjEwMS4zLjQuMS4yJzogJ2FlczEyOC1jYmMnLFxuXHQnMi4xNi44NDAuMS4xMDEuMy40LjEuNDInOiAnYWVzMjU2LWNiYydcbn07XG52YXIgQ0lQSEVSX1RPX09JRCA9IHt9O1xuT2JqZWN0LmtleXMoT0lEX1RPX0NJUEhFUikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRDSVBIRVJfVE9fT0lEW09JRF9UT19DSVBIRVJba11dID0gaztcbn0pO1xuXG52YXIgT0lEX1RPX0hBU0ggPSB7XG5cdCcxLjIuODQwLjExMzU0OS4yLjcnOiAnc2hhMScsXG5cdCcxLjIuODQwLjExMzU0OS4yLjknOiAnc2hhMjU2Jyxcblx0JzEuMi44NDAuMTEzNTQ5LjIuMTEnOiAnc2hhNTEyJ1xufTtcbnZhciBIQVNIX1RPX09JRCA9IHt9O1xuT2JqZWN0LmtleXMoT0lEX1RPX0hBU0gpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0SEFTSF9UT19PSURbT0lEX1RPX0hBU0hba11dID0gaztcbn0pO1xuXG4vKlxuICogRm9yIHJlYWRpbmcgd2Ugc3VwcG9ydCBib3RoIFBLQ1MjMSBhbmQgUEtDUyM4LiBJZiB3ZSBmaW5kIGEgcHJpdmF0ZSBrZXksXG4gKiB3ZSBqdXN0IHRha2UgdGhlIHB1YmxpYyBjb21wb25lbnQgb2YgaXQgYW5kIHVzZSB0aGF0LlxuICovXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb3B0aW9ucywgZm9yY2VUeXBlKSB7XG5cdHZhciBpbnB1dCA9IGJ1Zjtcblx0aWYgKHR5cGVvZiAoYnVmKSAhPT0gJ3N0cmluZycpIHtcblx0XHRhc3NlcnQuYnVmZmVyKGJ1ZiwgJ2J1ZicpO1xuXHRcdGJ1ZiA9IGJ1Zi50b1N0cmluZygnYXNjaWknKTtcblx0fVxuXG5cdHZhciBsaW5lcyA9IGJ1Zi50cmltKCkuc3BsaXQoL1tcXHJcXG5dKy9nKTtcblxuXHR2YXIgbTtcblx0dmFyIHNpID0gLTE7XG5cdHdoaWxlICghbSAmJiBzaSA8IGxpbmVzLmxlbmd0aCkge1xuXHRcdG0gPSBsaW5lc1srK3NpXS5tYXRjaCgvKkpTU1RZTEVEKi9cblx0XHQgICAgL1stXStbIF0qQkVHSU4gKFtBLVowLTldW0EtWmEtejAtOV0rICk/KFBVQkxJQ3xQUklWQVRFKSBLRVlbIF0qWy1dKy8pO1xuXHR9XG5cdGFzc2VydC5vayhtLCAnaW52YWxpZCBQRU0gaGVhZGVyJyk7XG5cblx0dmFyIG0yO1xuXHR2YXIgZWkgPSBsaW5lcy5sZW5ndGg7XG5cdHdoaWxlICghbTIgJiYgZWkgPiAwKSB7XG5cdFx0bTIgPSBsaW5lc1stLWVpXS5tYXRjaCgvKkpTU1RZTEVEKi9cblx0XHQgICAgL1stXStbIF0qRU5EIChbQS1aMC05XVtBLVphLXowLTldKyApPyhQVUJMSUN8UFJJVkFURSkgS0VZWyBdKlstXSsvKTtcblx0fVxuXHRhc3NlcnQub2sobTIsICdpbnZhbGlkIFBFTSBmb290ZXInKTtcblxuXHQvKiBCZWdpbiBhbmQgZW5kIGJhbm5lcnMgbXVzdCBtYXRjaCBrZXkgdHlwZSAqL1xuXHRhc3NlcnQuZXF1YWwobVsyXSwgbTJbMl0pO1xuXHR2YXIgdHlwZSA9IG1bMl0udG9Mb3dlckNhc2UoKTtcblxuXHR2YXIgYWxnO1xuXHRpZiAobVsxXSkge1xuXHRcdC8qIFRoZXkgYWxzbyBtdXN0IG1hdGNoIGFsZ29yaXRobXMsIGlmIGdpdmVuICovXG5cdFx0YXNzZXJ0LmVxdWFsKG1bMV0sIG0yWzFdLCAnUEVNIGhlYWRlciBhbmQgZm9vdGVyIG1pc21hdGNoJyk7XG5cdFx0YWxnID0gbVsxXS50cmltKCk7XG5cdH1cblxuXHRsaW5lcyA9IGxpbmVzLnNsaWNlKHNpLCBlaSArIDEpO1xuXG5cdHZhciBoZWFkZXJzID0ge307XG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0bGluZXMgPSBsaW5lcy5zbGljZSgxKTtcblx0XHRtID0gbGluZXNbMF0ubWF0Y2goLypKU1NUWUxFRCovXG5cdFx0ICAgIC9eKFtBLVphLXowLTktXSspOiAoLispJC8pO1xuXHRcdGlmICghbSlcblx0XHRcdGJyZWFrO1xuXHRcdGhlYWRlcnNbbVsxXS50b0xvd2VyQ2FzZSgpXSA9IG1bMl07XG5cdH1cblxuXHQvKiBDaG9wIG9mZiB0aGUgZmlyc3QgYW5kIGxhc3QgbGluZXMgKi9cblx0bGluZXMgPSBsaW5lcy5zbGljZSgwLCAtMSkuam9pbignJyk7XG5cdGJ1ZiA9IEJ1ZmZlci5mcm9tKGxpbmVzLCAnYmFzZTY0Jyk7XG5cblx0dmFyIGNpcGhlciwga2V5LCBpdjtcblx0aWYgKGhlYWRlcnNbJ3Byb2MtdHlwZSddKSB7XG5cdFx0dmFyIHBhcnRzID0gaGVhZGVyc1sncHJvYy10eXBlJ10uc3BsaXQoJywnKTtcblx0XHRpZiAocGFydHNbMF0gPT09ICc0JyAmJiBwYXJ0c1sxXSA9PT0gJ0VOQ1JZUFRFRCcpIHtcblx0XHRcdGlmICh0eXBlb2YgKG9wdGlvbnMucGFzc3BocmFzZSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdG9wdGlvbnMucGFzc3BocmFzZSA9IEJ1ZmZlci5mcm9tKFxuXHRcdFx0XHQgICAgb3B0aW9ucy5wYXNzcGhyYXNlLCAndXRmLTgnKTtcblx0XHRcdH1cblx0XHRcdGlmICghQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMucGFzc3BocmFzZSkpIHtcblx0XHRcdFx0dGhyb3cgKG5ldyBlcnJvcnMuS2V5RW5jcnlwdGVkRXJyb3IoXG5cdFx0XHRcdCAgICBvcHRpb25zLmZpbGVuYW1lLCAnUEVNJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGFydHMgPSBoZWFkZXJzWydkZWstaW5mbyddLnNwbGl0KCcsJyk7XG5cdFx0XHRcdGFzc2VydC5vayhwYXJ0cy5sZW5ndGggPT09IDIpO1xuXHRcdFx0XHRjaXBoZXIgPSBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRpdiA9IEJ1ZmZlci5mcm9tKHBhcnRzWzFdLCAnaGV4Jyk7XG5cdFx0XHRcdGtleSA9IHV0aWxzLm9wZW5zc2xLZXlEZXJpdihjaXBoZXIsIGl2LFxuXHRcdFx0XHQgICAgb3B0aW9ucy5wYXNzcGhyYXNlLCAxKS5rZXk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGFsZyAmJiBhbGcudG9Mb3dlckNhc2UoKSA9PT0gJ2VuY3J5cHRlZCcpIHtcblx0XHR2YXIgZWRlciA9IG5ldyBhc24xLkJlclJlYWRlcihidWYpO1xuXHRcdHZhciBwYmVzRW5kO1xuXHRcdGVkZXIucmVhZFNlcXVlbmNlKCk7XG5cblx0XHRlZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRcdHBiZXNFbmQgPSBlZGVyLm9mZnNldCArIGVkZXIubGVuZ3RoO1xuXG5cdFx0dmFyIG1ldGhvZCA9IGVkZXIucmVhZE9JRCgpO1xuXHRcdGlmIChtZXRob2QgIT09IE9JRF9QQkVTMikge1xuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUEVNL1BLQ1M4IGVuY3J5cHRpb24gJyArXG5cdFx0XHQgICAgJ3NjaGVtZTogJyArIG1ldGhvZCkpO1xuXHRcdH1cblxuXHRcdGVkZXIucmVhZFNlcXVlbmNlKCk7XHQvKiBQQkVTMi1wYXJhbXMgKi9cblxuXHRcdGVkZXIucmVhZFNlcXVlbmNlKCk7XHQvKiBrZXlEZXJpdmF0aW9uRnVuYyAqL1xuXHRcdHZhciBrZGZFbmQgPSBlZGVyLm9mZnNldCArIGVkZXIubGVuZ3RoO1xuXHRcdHZhciBrZGZPaWQgPSBlZGVyLnJlYWRPSUQoKTtcblx0XHRpZiAoa2RmT2lkICE9PSBPSURfUEJLREYyKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUEJFUzIgS0RGOiAnICsga2RmT2lkKSk7XG5cdFx0ZWRlci5yZWFkU2VxdWVuY2UoKTtcblx0XHR2YXIgc2FsdCA9IGVkZXIucmVhZFN0cmluZyhhc24xLkJlci5PY3RldFN0cmluZywgdHJ1ZSk7XG5cdFx0dmFyIGl0ZXJhdGlvbnMgPSBlZGVyLnJlYWRJbnQoKTtcblx0XHR2YXIgaGFzaEFsZyA9ICdzaGExJztcblx0XHRpZiAoZWRlci5vZmZzZXQgPCBrZGZFbmQpIHtcblx0XHRcdGVkZXIucmVhZFNlcXVlbmNlKCk7XG5cdFx0XHR2YXIgaGFzaEFsZ09pZCA9IGVkZXIucmVhZE9JRCgpO1xuXHRcdFx0aGFzaEFsZyA9IE9JRF9UT19IQVNIW2hhc2hBbGdPaWRdO1xuXHRcdFx0aWYgKGhhc2hBbGcgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQQktERjIgaGFzaDogJyArXG5cdFx0XHRcdCAgICBoYXNoQWxnT2lkKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVkZXIuX29mZnNldCA9IGtkZkVuZDtcblxuXHRcdGVkZXIucmVhZFNlcXVlbmNlKCk7XHQvKiBlbmNyeXB0aW9uU2NoZW1lICovXG5cdFx0dmFyIGNpcGhlck9pZCA9IGVkZXIucmVhZE9JRCgpO1xuXHRcdGNpcGhlciA9IE9JRF9UT19DSVBIRVJbY2lwaGVyT2lkXTtcblx0XHRpZiAoY2lwaGVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFBCRVMyIGNpcGhlcjogJyArXG5cdFx0XHQgICAgY2lwaGVyT2lkKSk7XG5cdFx0fVxuXHRcdGl2ID0gZWRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLk9jdGV0U3RyaW5nLCB0cnVlKTtcblxuXHRcdGVkZXIuX29mZnNldCA9IHBiZXNFbmQ7XG5cdFx0YnVmID0gZWRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLk9jdGV0U3RyaW5nLCB0cnVlKTtcblxuXHRcdGlmICh0eXBlb2YgKG9wdGlvbnMucGFzc3BocmFzZSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRvcHRpb25zLnBhc3NwaHJhc2UgPSBCdWZmZXIuZnJvbShcblx0XHRcdCAgICBvcHRpb25zLnBhc3NwaHJhc2UsICd1dGYtOCcpO1xuXHRcdH1cblx0XHRpZiAoIUJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLnBhc3NwaHJhc2UpKSB7XG5cdFx0XHR0aHJvdyAobmV3IGVycm9ycy5LZXlFbmNyeXB0ZWRFcnJvcihcblx0XHRcdCAgICBvcHRpb25zLmZpbGVuYW1lLCAnUEVNJykpO1xuXHRcdH1cblxuXHRcdHZhciBjaW5mbyA9IHV0aWxzLm9wZW5zc2hDaXBoZXJJbmZvKGNpcGhlcik7XG5cblx0XHRjaXBoZXIgPSBjaW5mby5vcGVuc3NsTmFtZTtcblx0XHRrZXkgPSB1dGlscy5wYmtkZjIoaGFzaEFsZywgc2FsdCwgaXRlcmF0aW9ucywgY2luZm8ua2V5U2l6ZSxcblx0XHQgICAgb3B0aW9ucy5wYXNzcGhyYXNlKTtcblx0XHRhbGcgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoY2lwaGVyICYmIGtleSAmJiBpdikge1xuXHRcdHZhciBjaXBoZXJTdHJlYW0gPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihjaXBoZXIsIGtleSwgaXYpO1xuXHRcdHZhciBjaHVuaywgY2h1bmtzID0gW107XG5cdFx0Y2lwaGVyU3RyZWFtLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChlLnRvU3RyaW5nKCkuaW5kZXhPZignYmFkIGRlY3J5cHQnKSAhPT0gLTEpIHtcblx0XHRcdFx0dGhyb3cgKG5ldyBFcnJvcignSW5jb3JyZWN0IHBhc3NwaHJhc2UgJyArXG5cdFx0XHRcdCAgICAnc3VwcGxpZWQsIGNvdWxkIG5vdCBkZWNyeXB0IGtleScpKTtcblx0XHRcdH1cblx0XHRcdHRocm93IChlKTtcblx0XHR9KTtcblx0XHRjaXBoZXJTdHJlYW0ud3JpdGUoYnVmKTtcblx0XHRjaXBoZXJTdHJlYW0uZW5kKCk7XG5cdFx0d2hpbGUgKChjaHVuayA9IGNpcGhlclN0cmVhbS5yZWFkKCkpICE9PSBudWxsKVxuXHRcdFx0Y2h1bmtzLnB1c2goY2h1bmspO1xuXHRcdGJ1ZiA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzKTtcblx0fVxuXG5cdC8qIFRoZSBuZXcgT3BlblNTSCBpbnRlcm5hbCBmb3JtYXQgYWJ1c2VzIFBFTSBoZWFkZXJzICovXG5cdGlmIChhbGcgJiYgYWxnLnRvTG93ZXJDYXNlKCkgPT09ICdvcGVuc3NoJylcblx0XHRyZXR1cm4gKHNzaHByaXYucmVhZFNTSFByaXZhdGUodHlwZSwgYnVmLCBvcHRpb25zKSk7XG5cdGlmIChhbGcgJiYgYWxnLnRvTG93ZXJDYXNlKCkgPT09ICdzc2gyJylcblx0XHRyZXR1cm4gKHJmYzQyNTMucmVhZFR5cGUodHlwZSwgYnVmLCBvcHRpb25zKSk7XG5cblx0dmFyIGRlciA9IG5ldyBhc24xLkJlclJlYWRlcihidWYpO1xuXHRkZXIub3JpZ2luYWxJbnB1dCA9IGlucHV0O1xuXG5cdC8qXG5cdCAqIEFsbCBvZiB0aGUgUEVNIGZpbGUgdHlwZXMgc3RhcnQgd2l0aCBhIHNlcXVlbmNlIHRhZywgc28gY2hvcCBpdFxuXHQgKiBvZmYgaGVyZVxuXHQgKi9cblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXG5cdC8qIFBLQ1MjMSB0eXBlIGtleXMgbmFtZSBhbiBhbGdvcml0aG0gaW4gdGhlIGJhbm5lciBleHBsaWNpdGx5ICovXG5cdGlmIChhbGcpIHtcblx0XHRpZiAoZm9yY2VUeXBlKVxuXHRcdFx0YXNzZXJ0LnN0cmljdEVxdWFsKGZvcmNlVHlwZSwgJ3BrY3MxJyk7XG5cdFx0cmV0dXJuIChwa2NzMS5yZWFkUGtjczEoYWxnLCB0eXBlLCBkZXIpKTtcblx0fSBlbHNlIHtcblx0XHRpZiAoZm9yY2VUeXBlKVxuXHRcdFx0YXNzZXJ0LnN0cmljdEVxdWFsKGZvcmNlVHlwZSwgJ3BrY3M4Jyk7XG5cdFx0cmV0dXJuIChwa2NzOC5yZWFkUGtjczgoYWxnLCB0eXBlLCBkZXIpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIG9wdGlvbnMsIHR5cGUpIHtcblx0YXNzZXJ0Lm9iamVjdChrZXkpO1xuXG5cdHZhciBhbGcgPSB7XG5cdCAgICAnZWNkc2EnOiAnRUMnLFxuXHQgICAgJ3JzYSc6ICdSU0EnLFxuXHQgICAgJ2RzYSc6ICdEU0EnLFxuXHQgICAgJ2VkMjU1MTknOiAnRWREU0EnXG5cdH1ba2V5LnR5cGVdO1xuXHR2YXIgaGVhZGVyO1xuXG5cdHZhciBkZXIgPSBuZXcgYXNuMS5CZXJXcml0ZXIoKTtcblxuXHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSkge1xuXHRcdGlmICh0eXBlICYmIHR5cGUgPT09ICdwa2NzOCcpIHtcblx0XHRcdGhlYWRlciA9ICdQUklWQVRFIEtFWSc7XG5cdFx0XHRwa2NzOC53cml0ZVBrY3M4KGRlciwga2V5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHR5cGUpXG5cdFx0XHRcdGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlLCAncGtjczEnKTtcblx0XHRcdGhlYWRlciA9IGFsZyArICcgUFJJVkFURSBLRVknO1xuXHRcdFx0cGtjczEud3JpdGVQa2NzMShkZXIsIGtleSk7XG5cdFx0fVxuXG5cdH0gZWxzZSBpZiAoS2V5LmlzS2V5KGtleSkpIHtcblx0XHRpZiAodHlwZSAmJiB0eXBlID09PSAncGtjczEnKSB7XG5cdFx0XHRoZWFkZXIgPSBhbGcgKyAnIFBVQkxJQyBLRVknO1xuXHRcdFx0cGtjczEud3JpdGVQa2NzMShkZXIsIGtleSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0eXBlKVxuXHRcdFx0XHRhc3NlcnQuc3RyaWN0RXF1YWwodHlwZSwgJ3BrY3M4Jyk7XG5cdFx0XHRoZWFkZXIgPSAnUFVCTElDIEtFWSc7XG5cdFx0XHRwa2NzOC53cml0ZVBrY3M4KGRlciwga2V5KTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdrZXkgaXMgbm90IGEgS2V5IG9yIFByaXZhdGVLZXknKSk7XG5cdH1cblxuXHR2YXIgdG1wID0gZGVyLmJ1ZmZlci50b1N0cmluZygnYmFzZTY0Jyk7XG5cdHZhciBsZW4gPSB0bXAubGVuZ3RoICsgKHRtcC5sZW5ndGggLyA2NCkgK1xuXHQgICAgMTggKyAxNiArIGhlYWRlci5sZW5ndGgqMiArIDEwO1xuXHR2YXIgYnVmID0gQnVmZmVyLmFsbG9jKGxlbik7XG5cdHZhciBvID0gMDtcblx0byArPSBidWYud3JpdGUoJy0tLS0tQkVHSU4gJyArIGhlYWRlciArICctLS0tLVxcbicsIG8pO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7ICkge1xuXHRcdHZhciBsaW1pdCA9IGkgKyA2NDtcblx0XHRpZiAobGltaXQgPiB0bXAubGVuZ3RoKVxuXHRcdFx0bGltaXQgPSB0bXAubGVuZ3RoO1xuXHRcdG8gKz0gYnVmLndyaXRlKHRtcC5zbGljZShpLCBsaW1pdCksIG8pO1xuXHRcdGJ1ZltvKytdID0gMTA7XG5cdFx0aSA9IGxpbWl0O1xuXHR9XG5cdG8gKz0gYnVmLndyaXRlKCctLS0tLUVORCAnICsgaGVhZGVyICsgJy0tLS0tXFxuJywgbyk7XG5cblx0cmV0dXJuIChidWYuc2xpY2UoMCwgbykpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/formats/pem.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/formats/pem.js":
/*!***********************************************!*\
  !*** ./node_modules/sshpk/lib/formats/pem.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2018 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(rsc)/./node_modules/asn1/lib/index.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\n\nvar pkcs1 = __webpack_require__(/*! ./pkcs1 */ \"(rsc)/./node_modules/sshpk/lib/formats/pkcs1.js\");\nvar pkcs8 = __webpack_require__(/*! ./pkcs8 */ \"(rsc)/./node_modules/sshpk/lib/formats/pkcs8.js\");\nvar sshpriv = __webpack_require__(/*! ./ssh-private */ \"(rsc)/./node_modules/sshpk/lib/formats/ssh-private.js\");\nvar rfc4253 = __webpack_require__(/*! ./rfc4253 */ \"(rsc)/./node_modules/sshpk/lib/formats/rfc4253.js\");\n\nvar errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/sshpk/lib/errors.js\");\n\nvar OID_PBES2 = '1.2.840.113549.1.5.13';\nvar OID_PBKDF2 = '1.2.840.113549.1.5.12';\n\nvar OID_TO_CIPHER = {\n\t'1.2.840.113549.3.7': '3des-cbc',\n\t'2.16.840.1.101.3.4.1.2': 'aes128-cbc',\n\t'2.16.840.1.101.3.4.1.42': 'aes256-cbc'\n};\nvar CIPHER_TO_OID = {};\nObject.keys(OID_TO_CIPHER).forEach(function (k) {\n\tCIPHER_TO_OID[OID_TO_CIPHER[k]] = k;\n});\n\nvar OID_TO_HASH = {\n\t'1.2.840.113549.2.7': 'sha1',\n\t'1.2.840.113549.2.9': 'sha256',\n\t'1.2.840.113549.2.11': 'sha512'\n};\nvar HASH_TO_OID = {};\nObject.keys(OID_TO_HASH).forEach(function (k) {\n\tHASH_TO_OID[OID_TO_HASH[k]] = k;\n});\n\n/*\n * For reading we support both PKCS#1 and PKCS#8. If we find a private key,\n * we just take the public component of it and use that.\n */\nfunction read(buf, options, forceType) {\n\tvar input = buf;\n\tif (typeof (buf) !== 'string') {\n\t\tassert.buffer(buf, 'buf');\n\t\tbuf = buf.toString('ascii');\n\t}\n\n\tvar lines = buf.trim().split(/[\\r\\n]+/g);\n\n\tvar m;\n\tvar si = -1;\n\twhile (!m && si < lines.length) {\n\t\tm = lines[++si].match(/*JSSTYLED*/\n\t\t    /[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);\n\t}\n\tassert.ok(m, 'invalid PEM header');\n\n\tvar m2;\n\tvar ei = lines.length;\n\twhile (!m2 && ei > 0) {\n\t\tm2 = lines[--ei].match(/*JSSTYLED*/\n\t\t    /[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);\n\t}\n\tassert.ok(m2, 'invalid PEM footer');\n\n\t/* Begin and end banners must match key type */\n\tassert.equal(m[2], m2[2]);\n\tvar type = m[2].toLowerCase();\n\n\tvar alg;\n\tif (m[1]) {\n\t\t/* They also must match algorithms, if given */\n\t\tassert.equal(m[1], m2[1], 'PEM header and footer mismatch');\n\t\talg = m[1].trim();\n\t}\n\n\tlines = lines.slice(si, ei + 1);\n\n\tvar headers = {};\n\twhile (true) {\n\t\tlines = lines.slice(1);\n\t\tm = lines[0].match(/*JSSTYLED*/\n\t\t    /^([A-Za-z0-9-]+): (.+)$/);\n\t\tif (!m)\n\t\t\tbreak;\n\t\theaders[m[1].toLowerCase()] = m[2];\n\t}\n\n\t/* Chop off the first and last lines */\n\tlines = lines.slice(0, -1).join('');\n\tbuf = Buffer.from(lines, 'base64');\n\n\tvar cipher, key, iv;\n\tif (headers['proc-type']) {\n\t\tvar parts = headers['proc-type'].split(',');\n\t\tif (parts[0] === '4' && parts[1] === 'ENCRYPTED') {\n\t\t\tif (typeof (options.passphrase) === 'string') {\n\t\t\t\toptions.passphrase = Buffer.from(\n\t\t\t\t    options.passphrase, 'utf-8');\n\t\t\t}\n\t\t\tif (!Buffer.isBuffer(options.passphrase)) {\n\t\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t\t    options.filename, 'PEM'));\n\t\t\t} else {\n\t\t\t\tparts = headers['dek-info'].split(',');\n\t\t\t\tassert.ok(parts.length === 2);\n\t\t\t\tcipher = parts[0].toLowerCase();\n\t\t\t\tiv = Buffer.from(parts[1], 'hex');\n\t\t\t\tkey = utils.opensslKeyDeriv(cipher, iv,\n\t\t\t\t    options.passphrase, 1).key;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (alg && alg.toLowerCase() === 'encrypted') {\n\t\tvar eder = new asn1.BerReader(buf);\n\t\tvar pbesEnd;\n\t\teder.readSequence();\n\n\t\teder.readSequence();\n\t\tpbesEnd = eder.offset + eder.length;\n\n\t\tvar method = eder.readOID();\n\t\tif (method !== OID_PBES2) {\n\t\t\tthrow (new Error('Unsupported PEM/PKCS8 encryption ' +\n\t\t\t    'scheme: ' + method));\n\t\t}\n\n\t\teder.readSequence();\t/* PBES2-params */\n\n\t\teder.readSequence();\t/* keyDerivationFunc */\n\t\tvar kdfEnd = eder.offset + eder.length;\n\t\tvar kdfOid = eder.readOID();\n\t\tif (kdfOid !== OID_PBKDF2)\n\t\t\tthrow (new Error('Unsupported PBES2 KDF: ' + kdfOid));\n\t\teder.readSequence();\n\t\tvar salt = eder.readString(asn1.Ber.OctetString, true);\n\t\tvar iterations = eder.readInt();\n\t\tvar hashAlg = 'sha1';\n\t\tif (eder.offset < kdfEnd) {\n\t\t\teder.readSequence();\n\t\t\tvar hashAlgOid = eder.readOID();\n\t\t\thashAlg = OID_TO_HASH[hashAlgOid];\n\t\t\tif (hashAlg === undefined) {\n\t\t\t\tthrow (new Error('Unsupported PBKDF2 hash: ' +\n\t\t\t\t    hashAlgOid));\n\t\t\t}\n\t\t}\n\t\teder._offset = kdfEnd;\n\n\t\teder.readSequence();\t/* encryptionScheme */\n\t\tvar cipherOid = eder.readOID();\n\t\tcipher = OID_TO_CIPHER[cipherOid];\n\t\tif (cipher === undefined) {\n\t\t\tthrow (new Error('Unsupported PBES2 cipher: ' +\n\t\t\t    cipherOid));\n\t\t}\n\t\tiv = eder.readString(asn1.Ber.OctetString, true);\n\n\t\teder._offset = pbesEnd;\n\t\tbuf = eder.readString(asn1.Ber.OctetString, true);\n\n\t\tif (typeof (options.passphrase) === 'string') {\n\t\t\toptions.passphrase = Buffer.from(\n\t\t\t    options.passphrase, 'utf-8');\n\t\t}\n\t\tif (!Buffer.isBuffer(options.passphrase)) {\n\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t    options.filename, 'PEM'));\n\t\t}\n\n\t\tvar cinfo = utils.opensshCipherInfo(cipher);\n\n\t\tcipher = cinfo.opensslName;\n\t\tkey = utils.pbkdf2(hashAlg, salt, iterations, cinfo.keySize,\n\t\t    options.passphrase);\n\t\talg = undefined;\n\t}\n\n\tif (cipher && key && iv) {\n\t\tvar cipherStream = crypto.createDecipheriv(cipher, key, iv);\n\t\tvar chunk, chunks = [];\n\t\tcipherStream.once('error', function (e) {\n\t\t\tif (e.toString().indexOf('bad decrypt') !== -1) {\n\t\t\t\tthrow (new Error('Incorrect passphrase ' +\n\t\t\t\t    'supplied, could not decrypt key'));\n\t\t\t}\n\t\t\tthrow (e);\n\t\t});\n\t\tcipherStream.write(buf);\n\t\tcipherStream.end();\n\t\twhile ((chunk = cipherStream.read()) !== null)\n\t\t\tchunks.push(chunk);\n\t\tbuf = Buffer.concat(chunks);\n\t}\n\n\t/* The new OpenSSH internal format abuses PEM headers */\n\tif (alg && alg.toLowerCase() === 'openssh')\n\t\treturn (sshpriv.readSSHPrivate(type, buf, options));\n\tif (alg && alg.toLowerCase() === 'ssh2')\n\t\treturn (rfc4253.readType(type, buf, options));\n\n\tvar der = new asn1.BerReader(buf);\n\tder.originalInput = input;\n\n\t/*\n\t * All of the PEM file types start with a sequence tag, so chop it\n\t * off here\n\t */\n\tder.readSequence();\n\n\t/* PKCS#1 type keys name an algorithm in the banner explicitly */\n\tif (alg) {\n\t\tif (forceType)\n\t\t\tassert.strictEqual(forceType, 'pkcs1');\n\t\treturn (pkcs1.readPkcs1(alg, type, der));\n\t} else {\n\t\tif (forceType)\n\t\t\tassert.strictEqual(forceType, 'pkcs8');\n\t\treturn (pkcs8.readPkcs8(alg, type, der));\n\t}\n}\n\nfunction write(key, options, type) {\n\tassert.object(key);\n\n\tvar alg = {\n\t    'ecdsa': 'EC',\n\t    'rsa': 'RSA',\n\t    'dsa': 'DSA',\n\t    'ed25519': 'EdDSA'\n\t}[key.type];\n\tvar header;\n\n\tvar der = new asn1.BerWriter();\n\n\tif (PrivateKey.isPrivateKey(key)) {\n\t\tif (type && type === 'pkcs8') {\n\t\t\theader = 'PRIVATE KEY';\n\t\t\tpkcs8.writePkcs8(der, key);\n\t\t} else {\n\t\t\tif (type)\n\t\t\t\tassert.strictEqual(type, 'pkcs1');\n\t\t\theader = alg + ' PRIVATE KEY';\n\t\t\tpkcs1.writePkcs1(der, key);\n\t\t}\n\n\t} else if (Key.isKey(key)) {\n\t\tif (type && type === 'pkcs1') {\n\t\t\theader = alg + ' PUBLIC KEY';\n\t\t\tpkcs1.writePkcs1(der, key);\n\t\t} else {\n\t\t\tif (type)\n\t\t\t\tassert.strictEqual(type, 'pkcs8');\n\t\t\theader = 'PUBLIC KEY';\n\t\t\tpkcs8.writePkcs8(der, key);\n\t\t}\n\n\t} else {\n\t\tthrow (new Error('key is not a Key or PrivateKey'));\n\t}\n\n\tvar tmp = der.buffer.toString('base64');\n\tvar len = tmp.length + (tmp.length / 64) +\n\t    18 + 16 + header.length*2 + 10;\n\tvar buf = Buffer.alloc(len);\n\tvar o = 0;\n\to += buf.write('-----BEGIN ' + header + '-----\\n', o);\n\tfor (var i = 0; i < tmp.length; ) {\n\t\tvar limit = i + 64;\n\t\tif (limit > tmp.length)\n\t\t\tlimit = tmp.length;\n\t\to += buf.write(tmp.slice(i, limit), o);\n\t\tbuf[o++] = 10;\n\t\ti = limit;\n\t}\n\to += buf.write('-----END ' + header + '-----\\n', o);\n\n\treturn (buf.slice(0, o));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvcGVtLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrREFBYTtBQUNsQyxXQUFXLG1CQUFPLENBQUMsb0RBQU07QUFDekIsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGFBQWEsOEZBQThCO0FBQzNDLFdBQVcsbUJBQU8sQ0FBQyx1REFBUztBQUM1QixZQUFZLG1CQUFPLENBQUMseURBQVU7QUFDOUIsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFnQjs7QUFFekMsWUFBWSxtQkFBTyxDQUFDLGdFQUFTO0FBQzdCLFlBQVksbUJBQU8sQ0FBQyxnRUFBUztBQUM3QixjQUFjLG1CQUFPLENBQUMsNEVBQWU7QUFDckMsY0FBYyxtQkFBTyxDQUFDLG9FQUFXOztBQUVqQyxhQUFhLG1CQUFPLENBQUMsMkRBQVc7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvcGVtLmpzPzY4NzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTggSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRyZWFkOiByZWFkLFxuXHR3cml0ZTogd3JpdGVcbn07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGFzbjEgPSByZXF1aXJlKCdhc24xJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuLi9hbGdzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEtleSA9IHJlcXVpcmUoJy4uL2tleScpO1xudmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuLi9wcml2YXRlLWtleScpO1xuXG52YXIgcGtjczEgPSByZXF1aXJlKCcuL3BrY3MxJyk7XG52YXIgcGtjczggPSByZXF1aXJlKCcuL3BrY3M4Jyk7XG52YXIgc3NocHJpdiA9IHJlcXVpcmUoJy4vc3NoLXByaXZhdGUnKTtcbnZhciByZmM0MjUzID0gcmVxdWlyZSgnLi9yZmM0MjUzJyk7XG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcblxudmFyIE9JRF9QQkVTMiA9ICcxLjIuODQwLjExMzU0OS4xLjUuMTMnO1xudmFyIE9JRF9QQktERjIgPSAnMS4yLjg0MC4xMTM1NDkuMS41LjEyJztcblxudmFyIE9JRF9UT19DSVBIRVIgPSB7XG5cdCcxLjIuODQwLjExMzU0OS4zLjcnOiAnM2Rlcy1jYmMnLFxuXHQnMi4xNi44NDAuMS4xMDEuMy40LjEuMic6ICdhZXMxMjgtY2JjJyxcblx0JzIuMTYuODQwLjEuMTAxLjMuNC4xLjQyJzogJ2FlczI1Ni1jYmMnXG59O1xudmFyIENJUEhFUl9UT19PSUQgPSB7fTtcbk9iamVjdC5rZXlzKE9JRF9UT19DSVBIRVIpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0Q0lQSEVSX1RPX09JRFtPSURfVE9fQ0lQSEVSW2tdXSA9IGs7XG59KTtcblxudmFyIE9JRF9UT19IQVNIID0ge1xuXHQnMS4yLjg0MC4xMTM1NDkuMi43JzogJ3NoYTEnLFxuXHQnMS4yLjg0MC4xMTM1NDkuMi45JzogJ3NoYTI1NicsXG5cdCcxLjIuODQwLjExMzU0OS4yLjExJzogJ3NoYTUxMidcbn07XG52YXIgSEFTSF9UT19PSUQgPSB7fTtcbk9iamVjdC5rZXlzKE9JRF9UT19IQVNIKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdEhBU0hfVE9fT0lEW09JRF9UT19IQVNIW2tdXSA9IGs7XG59KTtcblxuLypcbiAqIEZvciByZWFkaW5nIHdlIHN1cHBvcnQgYm90aCBQS0NTIzEgYW5kIFBLQ1MjOC4gSWYgd2UgZmluZCBhIHByaXZhdGUga2V5LFxuICogd2UganVzdCB0YWtlIHRoZSBwdWJsaWMgY29tcG9uZW50IG9mIGl0IGFuZCB1c2UgdGhhdC5cbiAqL1xuZnVuY3Rpb24gcmVhZChidWYsIG9wdGlvbnMsIGZvcmNlVHlwZSkge1xuXHR2YXIgaW5wdXQgPSBidWY7XG5cdGlmICh0eXBlb2YgKGJ1ZikgIT09ICdzdHJpbmcnKSB7XG5cdFx0YXNzZXJ0LmJ1ZmZlcihidWYsICdidWYnKTtcblx0XHRidWYgPSBidWYudG9TdHJpbmcoJ2FzY2lpJyk7XG5cdH1cblxuXHR2YXIgbGluZXMgPSBidWYudHJpbSgpLnNwbGl0KC9bXFxyXFxuXSsvZyk7XG5cblx0dmFyIG07XG5cdHZhciBzaSA9IC0xO1xuXHR3aGlsZSAoIW0gJiYgc2kgPCBsaW5lcy5sZW5ndGgpIHtcblx0XHRtID0gbGluZXNbKytzaV0ubWF0Y2goLypKU1NUWUxFRCovXG5cdFx0ICAgIC9bLV0rWyBdKkJFR0lOIChbQS1aMC05XVtBLVphLXowLTldKyApPyhQVUJMSUN8UFJJVkFURSkgS0VZWyBdKlstXSsvKTtcblx0fVxuXHRhc3NlcnQub2sobSwgJ2ludmFsaWQgUEVNIGhlYWRlcicpO1xuXG5cdHZhciBtMjtcblx0dmFyIGVpID0gbGluZXMubGVuZ3RoO1xuXHR3aGlsZSAoIW0yICYmIGVpID4gMCkge1xuXHRcdG0yID0gbGluZXNbLS1laV0ubWF0Y2goLypKU1NUWUxFRCovXG5cdFx0ICAgIC9bLV0rWyBdKkVORCAoW0EtWjAtOV1bQS1aYS16MC05XSsgKT8oUFVCTElDfFBSSVZBVEUpIEtFWVsgXSpbLV0rLyk7XG5cdH1cblx0YXNzZXJ0Lm9rKG0yLCAnaW52YWxpZCBQRU0gZm9vdGVyJyk7XG5cblx0LyogQmVnaW4gYW5kIGVuZCBiYW5uZXJzIG11c3QgbWF0Y2gga2V5IHR5cGUgKi9cblx0YXNzZXJ0LmVxdWFsKG1bMl0sIG0yWzJdKTtcblx0dmFyIHR5cGUgPSBtWzJdLnRvTG93ZXJDYXNlKCk7XG5cblx0dmFyIGFsZztcblx0aWYgKG1bMV0pIHtcblx0XHQvKiBUaGV5IGFsc28gbXVzdCBtYXRjaCBhbGdvcml0aG1zLCBpZiBnaXZlbiAqL1xuXHRcdGFzc2VydC5lcXVhbChtWzFdLCBtMlsxXSwgJ1BFTSBoZWFkZXIgYW5kIGZvb3RlciBtaXNtYXRjaCcpO1xuXHRcdGFsZyA9IG1bMV0udHJpbSgpO1xuXHR9XG5cblx0bGluZXMgPSBsaW5lcy5zbGljZShzaSwgZWkgKyAxKTtcblxuXHR2YXIgaGVhZGVycyA9IHt9O1xuXHR3aGlsZSAodHJ1ZSkge1xuXHRcdGxpbmVzID0gbGluZXMuc2xpY2UoMSk7XG5cdFx0bSA9IGxpbmVzWzBdLm1hdGNoKC8qSlNTVFlMRUQqL1xuXHRcdCAgICAvXihbQS1aYS16MC05LV0rKTogKC4rKSQvKTtcblx0XHRpZiAoIW0pXG5cdFx0XHRicmVhaztcblx0XHRoZWFkZXJzW21bMV0udG9Mb3dlckNhc2UoKV0gPSBtWzJdO1xuXHR9XG5cblx0LyogQ2hvcCBvZmYgdGhlIGZpcnN0IGFuZCBsYXN0IGxpbmVzICovXG5cdGxpbmVzID0gbGluZXMuc2xpY2UoMCwgLTEpLmpvaW4oJycpO1xuXHRidWYgPSBCdWZmZXIuZnJvbShsaW5lcywgJ2Jhc2U2NCcpO1xuXG5cdHZhciBjaXBoZXIsIGtleSwgaXY7XG5cdGlmIChoZWFkZXJzWydwcm9jLXR5cGUnXSkge1xuXHRcdHZhciBwYXJ0cyA9IGhlYWRlcnNbJ3Byb2MtdHlwZSddLnNwbGl0KCcsJyk7XG5cdFx0aWYgKHBhcnRzWzBdID09PSAnNCcgJiYgcGFydHNbMV0gPT09ICdFTkNSWVBURUQnKSB7XG5cdFx0XHRpZiAodHlwZW9mIChvcHRpb25zLnBhc3NwaHJhc2UpID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRvcHRpb25zLnBhc3NwaHJhc2UgPSBCdWZmZXIuZnJvbShcblx0XHRcdFx0ICAgIG9wdGlvbnMucGFzc3BocmFzZSwgJ3V0Zi04Jyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIUJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLnBhc3NwaHJhc2UpKSB7XG5cdFx0XHRcdHRocm93IChuZXcgZXJyb3JzLktleUVuY3J5cHRlZEVycm9yKFxuXHRcdFx0XHQgICAgb3B0aW9ucy5maWxlbmFtZSwgJ1BFTScpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhcnRzID0gaGVhZGVyc1snZGVrLWluZm8nXS5zcGxpdCgnLCcpO1xuXHRcdFx0XHRhc3NlcnQub2socGFydHMubGVuZ3RoID09PSAyKTtcblx0XHRcdFx0Y2lwaGVyID0gcGFydHNbMF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0aXYgPSBCdWZmZXIuZnJvbShwYXJ0c1sxXSwgJ2hleCcpO1xuXHRcdFx0XHRrZXkgPSB1dGlscy5vcGVuc3NsS2V5RGVyaXYoY2lwaGVyLCBpdixcblx0XHRcdFx0ICAgIG9wdGlvbnMucGFzc3BocmFzZSwgMSkua2V5O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChhbGcgJiYgYWxnLnRvTG93ZXJDYXNlKCkgPT09ICdlbmNyeXB0ZWQnKSB7XG5cdFx0dmFyIGVkZXIgPSBuZXcgYXNuMS5CZXJSZWFkZXIoYnVmKTtcblx0XHR2YXIgcGJlc0VuZDtcblx0XHRlZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXG5cdFx0ZWRlci5yZWFkU2VxdWVuY2UoKTtcblx0XHRwYmVzRW5kID0gZWRlci5vZmZzZXQgKyBlZGVyLmxlbmd0aDtcblxuXHRcdHZhciBtZXRob2QgPSBlZGVyLnJlYWRPSUQoKTtcblx0XHRpZiAobWV0aG9kICE9PSBPSURfUEJFUzIpIHtcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFBFTS9QS0NTOCBlbmNyeXB0aW9uICcgK1xuXHRcdFx0ICAgICdzY2hlbWU6ICcgKyBtZXRob2QpKTtcblx0XHR9XG5cblx0XHRlZGVyLnJlYWRTZXF1ZW5jZSgpO1x0LyogUEJFUzItcGFyYW1zICovXG5cblx0XHRlZGVyLnJlYWRTZXF1ZW5jZSgpO1x0Lyoga2V5RGVyaXZhdGlvbkZ1bmMgKi9cblx0XHR2YXIga2RmRW5kID0gZWRlci5vZmZzZXQgKyBlZGVyLmxlbmd0aDtcblx0XHR2YXIga2RmT2lkID0gZWRlci5yZWFkT0lEKCk7XG5cdFx0aWYgKGtkZk9pZCAhPT0gT0lEX1BCS0RGMilcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFBCRVMyIEtERjogJyArIGtkZk9pZCkpO1xuXHRcdGVkZXIucmVhZFNlcXVlbmNlKCk7XG5cdFx0dmFyIHNhbHQgPSBlZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuT2N0ZXRTdHJpbmcsIHRydWUpO1xuXHRcdHZhciBpdGVyYXRpb25zID0gZWRlci5yZWFkSW50KCk7XG5cdFx0dmFyIGhhc2hBbGcgPSAnc2hhMSc7XG5cdFx0aWYgKGVkZXIub2Zmc2V0IDwga2RmRW5kKSB7XG5cdFx0XHRlZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRcdFx0dmFyIGhhc2hBbGdPaWQgPSBlZGVyLnJlYWRPSUQoKTtcblx0XHRcdGhhc2hBbGcgPSBPSURfVE9fSEFTSFtoYXNoQWxnT2lkXTtcblx0XHRcdGlmIChoYXNoQWxnID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUEJLREYyIGhhc2g6ICcgK1xuXHRcdFx0XHQgICAgaGFzaEFsZ09pZCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlZGVyLl9vZmZzZXQgPSBrZGZFbmQ7XG5cblx0XHRlZGVyLnJlYWRTZXF1ZW5jZSgpO1x0LyogZW5jcnlwdGlvblNjaGVtZSAqL1xuXHRcdHZhciBjaXBoZXJPaWQgPSBlZGVyLnJlYWRPSUQoKTtcblx0XHRjaXBoZXIgPSBPSURfVE9fQ0lQSEVSW2NpcGhlck9pZF07XG5cdFx0aWYgKGNpcGhlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQQkVTMiBjaXBoZXI6ICcgK1xuXHRcdFx0ICAgIGNpcGhlck9pZCkpO1xuXHRcdH1cblx0XHRpdiA9IGVkZXIucmVhZFN0cmluZyhhc24xLkJlci5PY3RldFN0cmluZywgdHJ1ZSk7XG5cblx0XHRlZGVyLl9vZmZzZXQgPSBwYmVzRW5kO1xuXHRcdGJ1ZiA9IGVkZXIucmVhZFN0cmluZyhhc24xLkJlci5PY3RldFN0cmluZywgdHJ1ZSk7XG5cblx0XHRpZiAodHlwZW9mIChvcHRpb25zLnBhc3NwaHJhc2UpID09PSAnc3RyaW5nJykge1xuXHRcdFx0b3B0aW9ucy5wYXNzcGhyYXNlID0gQnVmZmVyLmZyb20oXG5cdFx0XHQgICAgb3B0aW9ucy5wYXNzcGhyYXNlLCAndXRmLTgnKTtcblx0XHR9XG5cdFx0aWYgKCFCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5wYXNzcGhyYXNlKSkge1xuXHRcdFx0dGhyb3cgKG5ldyBlcnJvcnMuS2V5RW5jcnlwdGVkRXJyb3IoXG5cdFx0XHQgICAgb3B0aW9ucy5maWxlbmFtZSwgJ1BFTScpKTtcblx0XHR9XG5cblx0XHR2YXIgY2luZm8gPSB1dGlscy5vcGVuc3NoQ2lwaGVySW5mbyhjaXBoZXIpO1xuXG5cdFx0Y2lwaGVyID0gY2luZm8ub3BlbnNzbE5hbWU7XG5cdFx0a2V5ID0gdXRpbHMucGJrZGYyKGhhc2hBbGcsIHNhbHQsIGl0ZXJhdGlvbnMsIGNpbmZvLmtleVNpemUsXG5cdFx0ICAgIG9wdGlvbnMucGFzc3BocmFzZSk7XG5cdFx0YWxnID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKGNpcGhlciAmJiBrZXkgJiYgaXYpIHtcblx0XHR2YXIgY2lwaGVyU3RyZWFtID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoY2lwaGVyLCBrZXksIGl2KTtcblx0XHR2YXIgY2h1bmssIGNodW5rcyA9IFtdO1xuXHRcdGNpcGhlclN0cmVhbS5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoZS50b1N0cmluZygpLmluZGV4T2YoJ2JhZCBkZWNyeXB0JykgIT09IC0xKSB7XG5cdFx0XHRcdHRocm93IChuZXcgRXJyb3IoJ0luY29ycmVjdCBwYXNzcGhyYXNlICcgK1xuXHRcdFx0XHQgICAgJ3N1cHBsaWVkLCBjb3VsZCBub3QgZGVjcnlwdCBrZXknKSk7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyAoZSk7XG5cdFx0fSk7XG5cdFx0Y2lwaGVyU3RyZWFtLndyaXRlKGJ1Zik7XG5cdFx0Y2lwaGVyU3RyZWFtLmVuZCgpO1xuXHRcdHdoaWxlICgoY2h1bmsgPSBjaXBoZXJTdHJlYW0ucmVhZCgpKSAhPT0gbnVsbClcblx0XHRcdGNodW5rcy5wdXNoKGNodW5rKTtcblx0XHRidWYgPSBCdWZmZXIuY29uY2F0KGNodW5rcyk7XG5cdH1cblxuXHQvKiBUaGUgbmV3IE9wZW5TU0ggaW50ZXJuYWwgZm9ybWF0IGFidXNlcyBQRU0gaGVhZGVycyAqL1xuXHRpZiAoYWxnICYmIGFsZy50b0xvd2VyQ2FzZSgpID09PSAnb3BlbnNzaCcpXG5cdFx0cmV0dXJuIChzc2hwcml2LnJlYWRTU0hQcml2YXRlKHR5cGUsIGJ1Ziwgb3B0aW9ucykpO1xuXHRpZiAoYWxnICYmIGFsZy50b0xvd2VyQ2FzZSgpID09PSAnc3NoMicpXG5cdFx0cmV0dXJuIChyZmM0MjUzLnJlYWRUeXBlKHR5cGUsIGJ1Ziwgb3B0aW9ucykpO1xuXG5cdHZhciBkZXIgPSBuZXcgYXNuMS5CZXJSZWFkZXIoYnVmKTtcblx0ZGVyLm9yaWdpbmFsSW5wdXQgPSBpbnB1dDtcblxuXHQvKlxuXHQgKiBBbGwgb2YgdGhlIFBFTSBmaWxlIHR5cGVzIHN0YXJ0IHdpdGggYSBzZXF1ZW5jZSB0YWcsIHNvIGNob3AgaXRcblx0ICogb2ZmIGhlcmVcblx0ICovXG5cdGRlci5yZWFkU2VxdWVuY2UoKTtcblxuXHQvKiBQS0NTIzEgdHlwZSBrZXlzIG5hbWUgYW4gYWxnb3JpdGhtIGluIHRoZSBiYW5uZXIgZXhwbGljaXRseSAqL1xuXHRpZiAoYWxnKSB7XG5cdFx0aWYgKGZvcmNlVHlwZSlcblx0XHRcdGFzc2VydC5zdHJpY3RFcXVhbChmb3JjZVR5cGUsICdwa2NzMScpO1xuXHRcdHJldHVybiAocGtjczEucmVhZFBrY3MxKGFsZywgdHlwZSwgZGVyKSk7XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGZvcmNlVHlwZSlcblx0XHRcdGFzc2VydC5zdHJpY3RFcXVhbChmb3JjZVR5cGUsICdwa2NzOCcpO1xuXHRcdHJldHVybiAocGtjczgucmVhZFBrY3M4KGFsZywgdHlwZSwgZGVyKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBvcHRpb25zLCB0eXBlKSB7XG5cdGFzc2VydC5vYmplY3Qoa2V5KTtcblxuXHR2YXIgYWxnID0ge1xuXHQgICAgJ2VjZHNhJzogJ0VDJyxcblx0ICAgICdyc2EnOiAnUlNBJyxcblx0ICAgICdkc2EnOiAnRFNBJyxcblx0ICAgICdlZDI1NTE5JzogJ0VkRFNBJ1xuXHR9W2tleS50eXBlXTtcblx0dmFyIGhlYWRlcjtcblxuXHR2YXIgZGVyID0gbmV3IGFzbjEuQmVyV3JpdGVyKCk7XG5cblx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpIHtcblx0XHRpZiAodHlwZSAmJiB0eXBlID09PSAncGtjczgnKSB7XG5cdFx0XHRoZWFkZXIgPSAnUFJJVkFURSBLRVknO1xuXHRcdFx0cGtjczgud3JpdGVQa2NzOChkZXIsIGtleSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0eXBlKVxuXHRcdFx0XHRhc3NlcnQuc3RyaWN0RXF1YWwodHlwZSwgJ3BrY3MxJyk7XG5cdFx0XHRoZWFkZXIgPSBhbGcgKyAnIFBSSVZBVEUgS0VZJztcblx0XHRcdHBrY3MxLndyaXRlUGtjczEoZGVyLCBrZXkpO1xuXHRcdH1cblxuXHR9IGVsc2UgaWYgKEtleS5pc0tleShrZXkpKSB7XG5cdFx0aWYgKHR5cGUgJiYgdHlwZSA9PT0gJ3BrY3MxJykge1xuXHRcdFx0aGVhZGVyID0gYWxnICsgJyBQVUJMSUMgS0VZJztcblx0XHRcdHBrY3MxLndyaXRlUGtjczEoZGVyLCBrZXkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodHlwZSlcblx0XHRcdFx0YXNzZXJ0LnN0cmljdEVxdWFsKHR5cGUsICdwa2NzOCcpO1xuXHRcdFx0aGVhZGVyID0gJ1BVQkxJQyBLRVknO1xuXHRcdFx0cGtjczgud3JpdGVQa2NzOChkZXIsIGtleSk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcigna2V5IGlzIG5vdCBhIEtleSBvciBQcml2YXRlS2V5JykpO1xuXHR9XG5cblx0dmFyIHRtcCA9IGRlci5idWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXHR2YXIgbGVuID0gdG1wLmxlbmd0aCArICh0bXAubGVuZ3RoIC8gNjQpICtcblx0ICAgIDE4ICsgMTYgKyBoZWFkZXIubGVuZ3RoKjIgKyAxMDtcblx0dmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyhsZW4pO1xuXHR2YXIgbyA9IDA7XG5cdG8gKz0gYnVmLndyaXRlKCctLS0tLUJFR0lOICcgKyBoZWFkZXIgKyAnLS0tLS1cXG4nLCBvKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyApIHtcblx0XHR2YXIgbGltaXQgPSBpICsgNjQ7XG5cdFx0aWYgKGxpbWl0ID4gdG1wLmxlbmd0aClcblx0XHRcdGxpbWl0ID0gdG1wLmxlbmd0aDtcblx0XHRvICs9IGJ1Zi53cml0ZSh0bXAuc2xpY2UoaSwgbGltaXQpLCBvKTtcblx0XHRidWZbbysrXSA9IDEwO1xuXHRcdGkgPSBsaW1pdDtcblx0fVxuXHRvICs9IGJ1Zi53cml0ZSgnLS0tLS1FTkQgJyArIGhlYWRlciArICctLS0tLVxcbicsIG8pO1xuXG5cdHJldHVybiAoYnVmLnNsaWNlKDAsIG8pKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/formats/pem.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/formats/pkcs1.js":
/*!*************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/pkcs1.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\treadPkcs1: readPkcs1,\n\twrite: write,\n\twritePkcs1: writePkcs1\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(action-browser)/./node_modules/asn1/lib/index.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\n\nvar Key = __webpack_require__(/*! ../key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\nvar pem = __webpack_require__(/*! ./pem */ \"(action-browser)/./node_modules/sshpk/lib/formats/pem.js\");\n\nvar pkcs8 = __webpack_require__(/*! ./pkcs8 */ \"(action-browser)/./node_modules/sshpk/lib/formats/pkcs8.js\");\nvar readECDSACurve = pkcs8.readECDSACurve;\n\nfunction read(buf, options) {\n\treturn (pem.read(buf, options, 'pkcs1'));\n}\n\nfunction write(key, options) {\n\treturn (pem.write(key, options, 'pkcs1'));\n}\n\n/* Helper to read in a single mpint */\nfunction readMPInt(der, nm) {\n\tassert.strictEqual(der.peek(), asn1.Ber.Integer,\n\t    nm + ' is not an Integer');\n\treturn (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));\n}\n\nfunction readPkcs1(alg, type, der) {\n\tswitch (alg) {\n\tcase 'RSA':\n\t\tif (type === 'public')\n\t\t\treturn (readPkcs1RSAPublic(der));\n\t\telse if (type === 'private')\n\t\t\treturn (readPkcs1RSAPrivate(der));\n\t\tthrow (new Error('Unknown key type: ' + type));\n\tcase 'DSA':\n\t\tif (type === 'public')\n\t\t\treturn (readPkcs1DSAPublic(der));\n\t\telse if (type === 'private')\n\t\t\treturn (readPkcs1DSAPrivate(der));\n\t\tthrow (new Error('Unknown key type: ' + type));\n\tcase 'EC':\n\tcase 'ECDSA':\n\t\tif (type === 'private')\n\t\t\treturn (readPkcs1ECDSAPrivate(der));\n\t\telse if (type === 'public')\n\t\t\treturn (readPkcs1ECDSAPublic(der));\n\t\tthrow (new Error('Unknown key type: ' + type));\n\tcase 'EDDSA':\n\tcase 'EdDSA':\n\t\tif (type === 'private')\n\t\t\treturn (readPkcs1EdDSAPrivate(der));\n\t\tthrow (new Error(type + ' keys not supported with EdDSA'));\n\tdefault:\n\t\tthrow (new Error('Unknown key algo: ' + alg));\n\t}\n}\n\nfunction readPkcs1RSAPublic(der) {\n\t// modulus and exponent\n\tvar n = readMPInt(der, 'modulus');\n\tvar e = readMPInt(der, 'exponent');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'rsa',\n\t\tparts: [\n\t\t\t{ name: 'e', data: e },\n\t\t\t{ name: 'n', data: n }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs1RSAPrivate(der) {\n\tvar version = readMPInt(der, 'version');\n\tassert.strictEqual(version[0], 0);\n\n\t// modulus then public exponent\n\tvar n = readMPInt(der, 'modulus');\n\tvar e = readMPInt(der, 'public exponent');\n\tvar d = readMPInt(der, 'private exponent');\n\tvar p = readMPInt(der, 'prime1');\n\tvar q = readMPInt(der, 'prime2');\n\tvar dmodp = readMPInt(der, 'exponent1');\n\tvar dmodq = readMPInt(der, 'exponent2');\n\tvar iqmp = readMPInt(der, 'iqmp');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'rsa',\n\t\tparts: [\n\t\t\t{ name: 'n', data: n },\n\t\t\t{ name: 'e', data: e },\n\t\t\t{ name: 'd', data: d },\n\t\t\t{ name: 'iqmp', data: iqmp },\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'dmodp', data: dmodp },\n\t\t\t{ name: 'dmodq', data: dmodq }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs1DSAPrivate(der) {\n\tvar version = readMPInt(der, 'version');\n\tassert.strictEqual(version.readUInt8(0), 0);\n\n\tvar p = readMPInt(der, 'p');\n\tvar q = readMPInt(der, 'q');\n\tvar g = readMPInt(der, 'g');\n\tvar y = readMPInt(der, 'y');\n\tvar x = readMPInt(der, 'x');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'dsa',\n\t\tparts: [\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'g', data: g },\n\t\t\t{ name: 'y', data: y },\n\t\t\t{ name: 'x', data: x }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs1EdDSAPrivate(der) {\n\tvar version = readMPInt(der, 'version');\n\tassert.strictEqual(version.readUInt8(0), 1);\n\n\t// private key\n\tvar k = der.readString(asn1.Ber.OctetString, true);\n\n\tder.readSequence(0xa0);\n\tvar oid = der.readOID();\n\tassert.strictEqual(oid, '1.3.101.112', 'the ed25519 curve identifier');\n\n\tder.readSequence(0xa1);\n\tvar A = utils.readBitString(der);\n\n\tvar key = {\n\t\ttype: 'ed25519',\n\t\tparts: [\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\n\t\t\t{ name: 'k', data: k }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs1DSAPublic(der) {\n\tvar y = readMPInt(der, 'y');\n\tvar p = readMPInt(der, 'p');\n\tvar q = readMPInt(der, 'q');\n\tvar g = readMPInt(der, 'g');\n\n\tvar key = {\n\t\ttype: 'dsa',\n\t\tparts: [\n\t\t\t{ name: 'y', data: y },\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'g', data: g }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs1ECDSAPublic(der) {\n\tder.readSequence();\n\n\tvar oid = der.readOID();\n\tassert.strictEqual(oid, '1.2.840.10045.2.1', 'must be ecPublicKey');\n\n\tvar curveOid = der.readOID();\n\n\tvar curve;\n\tvar curves = Object.keys(algs.curves);\n\tfor (var j = 0; j < curves.length; ++j) {\n\t\tvar c = curves[j];\n\t\tvar cd = algs.curves[c];\n\t\tif (cd.pkcs8oid === curveOid) {\n\t\t\tcurve = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\tassert.string(curve, 'a known ECDSA named curve');\n\n\tvar Q = der.readString(asn1.Ber.BitString, true);\n\tQ = utils.ecNormalize(Q);\n\n\tvar key = {\n\t\ttype: 'ecdsa',\n\t\tparts: [\n\t\t\t{ name: 'curve', data: Buffer.from(curve) },\n\t\t\t{ name: 'Q', data: Q }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs1ECDSAPrivate(der) {\n\tvar version = readMPInt(der, 'version');\n\tassert.strictEqual(version.readUInt8(0), 1);\n\n\t// private key\n\tvar d = der.readString(asn1.Ber.OctetString, true);\n\n\tder.readSequence(0xa0);\n\tvar curve = readECDSACurve(der);\n\tassert.string(curve, 'a known elliptic curve');\n\n\tder.readSequence(0xa1);\n\tvar Q = der.readString(asn1.Ber.BitString, true);\n\tQ = utils.ecNormalize(Q);\n\n\tvar key = {\n\t\ttype: 'ecdsa',\n\t\tparts: [\n\t\t\t{ name: 'curve', data: Buffer.from(curve) },\n\t\t\t{ name: 'Q', data: Q },\n\t\t\t{ name: 'd', data: d }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction writePkcs1(der, key) {\n\tder.startSequence();\n\n\tswitch (key.type) {\n\tcase 'rsa':\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs1RSAPrivate(der, key);\n\t\telse\n\t\t\twritePkcs1RSAPublic(der, key);\n\t\tbreak;\n\tcase 'dsa':\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs1DSAPrivate(der, key);\n\t\telse\n\t\t\twritePkcs1DSAPublic(der, key);\n\t\tbreak;\n\tcase 'ecdsa':\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs1ECDSAPrivate(der, key);\n\t\telse\n\t\t\twritePkcs1ECDSAPublic(der, key);\n\t\tbreak;\n\tcase 'ed25519':\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs1EdDSAPrivate(der, key);\n\t\telse\n\t\t\twritePkcs1EdDSAPublic(der, key);\n\t\tbreak;\n\tdefault:\n\t\tthrow (new Error('Unknown key algo: ' + key.type));\n\t}\n\n\tder.endSequence();\n}\n\nfunction writePkcs1RSAPublic(der, key) {\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1RSAPrivate(der, key) {\n\tvar ver = Buffer.from([0]);\n\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.d.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tif (!key.part.dmodp || !key.part.dmodq)\n\t\tutils.addRSAMissing(key);\n\tder.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1DSAPrivate(der, key) {\n\tvar ver = Buffer.from([0]);\n\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.x.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1DSAPublic(der, key) {\n\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1ECDSAPublic(der, key) {\n\tder.startSequence();\n\n\tder.writeOID('1.2.840.10045.2.1'); /* ecPublicKey */\n\tvar curve = key.part.curve.data.toString();\n\tvar curveOid = algs.curves[curve].pkcs8oid;\n\tassert.string(curveOid, 'a known ECDSA named curve');\n\tder.writeOID(curveOid);\n\n\tder.endSequence();\n\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\tder.writeBuffer(Q, asn1.Ber.BitString);\n}\n\nfunction writePkcs1ECDSAPrivate(der, key) {\n\tvar ver = Buffer.from([1]);\n\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.d.data, asn1.Ber.OctetString);\n\n\tder.startSequence(0xa0);\n\tvar curve = key.part.curve.data.toString();\n\tvar curveOid = algs.curves[curve].pkcs8oid;\n\tassert.string(curveOid, 'a known ECDSA named curve');\n\tder.writeOID(curveOid);\n\tder.endSequence();\n\n\tder.startSequence(0xa1);\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\tder.writeBuffer(Q, asn1.Ber.BitString);\n\tder.endSequence();\n}\n\nfunction writePkcs1EdDSAPrivate(der, key) {\n\tvar ver = Buffer.from([1]);\n\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.k.data, asn1.Ber.OctetString);\n\n\tder.startSequence(0xa0);\n\tder.writeOID('1.3.101.112');\n\tder.endSequence();\n\n\tder.startSequence(0xa1);\n\tutils.writeBitString(der, key.part.A.data);\n\tder.endSequence();\n}\n\nfunction writePkcs1EdDSAPublic(der, key) {\n\tthrow (new Error('Public keys are not supported for EdDSA PKCS#1'));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9wa2NzMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDBFQUFhO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQywrREFBTTtBQUN6QixhQUFhLHlHQUE4QjtBQUMzQyxXQUFXLG1CQUFPLENBQUMsa0VBQVM7QUFDNUIsWUFBWSxtQkFBTyxDQUFDLG9FQUFVOztBQUU5QixVQUFVLG1CQUFPLENBQUMsZ0VBQVE7QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQWdCO0FBQ3pDLFVBQVUsbUJBQU8sQ0FBQyx1RUFBTzs7QUFFekIsWUFBWSxtQkFBTyxDQUFDLDJFQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0JBQW9CO0FBQ3pCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0JBQW9CO0FBQ3pCLEtBQUssb0JBQW9CO0FBQ3pCLEtBQUssb0JBQW9CO0FBQ3pCLEtBQUssMEJBQTBCO0FBQy9CLEtBQUssb0JBQW9CO0FBQ3pCLEtBQUssb0JBQW9CO0FBQ3pCLEtBQUssNEJBQTRCO0FBQ2pDLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQjtBQUN6QixLQUFLLG9CQUFvQjtBQUN6QixLQUFLLG9CQUFvQjtBQUN6QixLQUFLLG9CQUFvQjtBQUN6QixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUssK0NBQStDO0FBQ3BELEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQjtBQUN6QixLQUFLLG9CQUFvQjtBQUN6QixLQUFLLG9CQUFvQjtBQUN6QixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyx5Q0FBeUM7QUFDOUMsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUsseUNBQXlDO0FBQzlDLEtBQUssb0JBQW9CO0FBQ3pCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9mb3JtYXRzL3BrY3MxLmpzPzZhNmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRyZWFkOiByZWFkLFxuXHRyZWFkUGtjczE6IHJlYWRQa2NzMSxcblx0d3JpdGU6IHdyaXRlLFxuXHR3cml0ZVBrY3MxOiB3cml0ZVBrY3MxXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMScpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBhbGdzID0gcmVxdWlyZSgnLi4vYWxncycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIEtleSA9IHJlcXVpcmUoJy4uL2tleScpO1xudmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuLi9wcml2YXRlLWtleScpO1xudmFyIHBlbSA9IHJlcXVpcmUoJy4vcGVtJyk7XG5cbnZhciBwa2NzOCA9IHJlcXVpcmUoJy4vcGtjczgnKTtcbnZhciByZWFkRUNEU0FDdXJ2ZSA9IHBrY3M4LnJlYWRFQ0RTQUN1cnZlO1xuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb3B0aW9ucykge1xuXHRyZXR1cm4gKHBlbS5yZWFkKGJ1Ziwgb3B0aW9ucywgJ3BrY3MxJykpO1xufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIG9wdGlvbnMpIHtcblx0cmV0dXJuIChwZW0ud3JpdGUoa2V5LCBvcHRpb25zLCAncGtjczEnKSk7XG59XG5cbi8qIEhlbHBlciB0byByZWFkIGluIGEgc2luZ2xlIG1waW50ICovXG5mdW5jdGlvbiByZWFkTVBJbnQoZGVyLCBubSkge1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwoZGVyLnBlZWsoKSwgYXNuMS5CZXIuSW50ZWdlcixcblx0ICAgIG5tICsgJyBpcyBub3QgYW4gSW50ZWdlcicpO1xuXHRyZXR1cm4gKHV0aWxzLm1wTm9ybWFsaXplKGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkludGVnZXIsIHRydWUpKSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzMShhbGcsIHR5cGUsIGRlcikge1xuXHRzd2l0Y2ggKGFsZykge1xuXHRjYXNlICdSU0EnOlxuXHRcdGlmICh0eXBlID09PSAncHVibGljJylcblx0XHRcdHJldHVybiAocmVhZFBrY3MxUlNBUHVibGljKGRlcikpO1xuXHRcdGVsc2UgaWYgKHR5cGUgPT09ICdwcml2YXRlJylcblx0XHRcdHJldHVybiAocmVhZFBrY3MxUlNBUHJpdmF0ZShkZXIpKTtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdVbmtub3duIGtleSB0eXBlOiAnICsgdHlwZSkpO1xuXHRjYXNlICdEU0EnOlxuXHRcdGlmICh0eXBlID09PSAncHVibGljJylcblx0XHRcdHJldHVybiAocmVhZFBrY3MxRFNBUHVibGljKGRlcikpO1xuXHRcdGVsc2UgaWYgKHR5cGUgPT09ICdwcml2YXRlJylcblx0XHRcdHJldHVybiAocmVhZFBrY3MxRFNBUHJpdmF0ZShkZXIpKTtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdVbmtub3duIGtleSB0eXBlOiAnICsgdHlwZSkpO1xuXHRjYXNlICdFQyc6XG5cdGNhc2UgJ0VDRFNBJzpcblx0XHRpZiAodHlwZSA9PT0gJ3ByaXZhdGUnKVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczFFQ0RTQVByaXZhdGUoZGVyKSk7XG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gJ3B1YmxpYycpXG5cdFx0XHRyZXR1cm4gKHJlYWRQa2NzMUVDRFNBUHVibGljKGRlcikpO1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ1Vua25vd24ga2V5IHR5cGU6ICcgKyB0eXBlKSk7XG5cdGNhc2UgJ0VERFNBJzpcblx0Y2FzZSAnRWREU0EnOlxuXHRcdGlmICh0eXBlID09PSAncHJpdmF0ZScpXG5cdFx0XHRyZXR1cm4gKHJlYWRQa2NzMUVkRFNBUHJpdmF0ZShkZXIpKTtcblx0XHR0aHJvdyAobmV3IEVycm9yKHR5cGUgKyAnIGtleXMgbm90IHN1cHBvcnRlZCB3aXRoIEVkRFNBJykpO1xuXHRkZWZhdWx0OlxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1Vua25vd24ga2V5IGFsZ286ICcgKyBhbGcpKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZWFkUGtjczFSU0FQdWJsaWMoZGVyKSB7XG5cdC8vIG1vZHVsdXMgYW5kIGV4cG9uZW50XG5cdHZhciBuID0gcmVhZE1QSW50KGRlciwgJ21vZHVsdXMnKTtcblx0dmFyIGUgPSByZWFkTVBJbnQoZGVyLCAnZXhwb25lbnQnKTtcblxuXHQvLyBub3csIG1ha2UgdGhlIGtleVxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdyc2EnLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICdlJywgZGF0YTogZSB9LFxuXHRcdFx0eyBuYW1lOiAnbicsIGRhdGE6IG4gfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzMVJTQVByaXZhdGUoZGVyKSB7XG5cdHZhciB2ZXJzaW9uID0gcmVhZE1QSW50KGRlciwgJ3ZlcnNpb24nKTtcblx0YXNzZXJ0LnN0cmljdEVxdWFsKHZlcnNpb25bMF0sIDApO1xuXG5cdC8vIG1vZHVsdXMgdGhlbiBwdWJsaWMgZXhwb25lbnRcblx0dmFyIG4gPSByZWFkTVBJbnQoZGVyLCAnbW9kdWx1cycpO1xuXHR2YXIgZSA9IHJlYWRNUEludChkZXIsICdwdWJsaWMgZXhwb25lbnQnKTtcblx0dmFyIGQgPSByZWFkTVBJbnQoZGVyLCAncHJpdmF0ZSBleHBvbmVudCcpO1xuXHR2YXIgcCA9IHJlYWRNUEludChkZXIsICdwcmltZTEnKTtcblx0dmFyIHEgPSByZWFkTVBJbnQoZGVyLCAncHJpbWUyJyk7XG5cdHZhciBkbW9kcCA9IHJlYWRNUEludChkZXIsICdleHBvbmVudDEnKTtcblx0dmFyIGRtb2RxID0gcmVhZE1QSW50KGRlciwgJ2V4cG9uZW50MicpO1xuXHR2YXIgaXFtcCA9IHJlYWRNUEludChkZXIsICdpcW1wJyk7XG5cblx0Ly8gbm93LCBtYWtlIHRoZSBrZXlcblx0dmFyIGtleSA9IHtcblx0XHR0eXBlOiAncnNhJyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnbicsIGRhdGE6IG4gfSxcblx0XHRcdHsgbmFtZTogJ2UnLCBkYXRhOiBlIH0sXG5cdFx0XHR7IG5hbWU6ICdkJywgZGF0YTogZCB9LFxuXHRcdFx0eyBuYW1lOiAnaXFtcCcsIGRhdGE6IGlxbXAgfSxcblx0XHRcdHsgbmFtZTogJ3AnLCBkYXRhOiBwIH0sXG5cdFx0XHR7IG5hbWU6ICdxJywgZGF0YTogcSB9LFxuXHRcdFx0eyBuYW1lOiAnZG1vZHAnLCBkYXRhOiBkbW9kcCB9LFxuXHRcdFx0eyBuYW1lOiAnZG1vZHEnLCBkYXRhOiBkbW9kcSB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IFByaXZhdGVLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzMURTQVByaXZhdGUoZGVyKSB7XG5cdHZhciB2ZXJzaW9uID0gcmVhZE1QSW50KGRlciwgJ3ZlcnNpb24nKTtcblx0YXNzZXJ0LnN0cmljdEVxdWFsKHZlcnNpb24ucmVhZFVJbnQ4KDApLCAwKTtcblxuXHR2YXIgcCA9IHJlYWRNUEludChkZXIsICdwJyk7XG5cdHZhciBxID0gcmVhZE1QSW50KGRlciwgJ3EnKTtcblx0dmFyIGcgPSByZWFkTVBJbnQoZGVyLCAnZycpO1xuXHR2YXIgeSA9IHJlYWRNUEludChkZXIsICd5Jyk7XG5cdHZhciB4ID0gcmVhZE1QSW50KGRlciwgJ3gnKTtcblxuXHQvLyBub3csIG1ha2UgdGhlIGtleVxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdkc2EnLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICdwJywgZGF0YTogcCB9LFxuXHRcdFx0eyBuYW1lOiAncScsIGRhdGE6IHEgfSxcblx0XHRcdHsgbmFtZTogJ2cnLCBkYXRhOiBnIH0sXG5cdFx0XHR7IG5hbWU6ICd5JywgZGF0YTogeSB9LFxuXHRcdFx0eyBuYW1lOiAneCcsIGRhdGE6IHggfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBQcml2YXRlS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiByZWFkUGtjczFFZERTQVByaXZhdGUoZGVyKSB7XG5cdHZhciB2ZXJzaW9uID0gcmVhZE1QSW50KGRlciwgJ3ZlcnNpb24nKTtcblx0YXNzZXJ0LnN0cmljdEVxdWFsKHZlcnNpb24ucmVhZFVJbnQ4KDApLCAxKTtcblxuXHQvLyBwcml2YXRlIGtleVxuXHR2YXIgayA9IGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLk9jdGV0U3RyaW5nLCB0cnVlKTtcblxuXHRkZXIucmVhZFNlcXVlbmNlKDB4YTApO1xuXHR2YXIgb2lkID0gZGVyLnJlYWRPSUQoKTtcblx0YXNzZXJ0LnN0cmljdEVxdWFsKG9pZCwgJzEuMy4xMDEuMTEyJywgJ3RoZSBlZDI1NTE5IGN1cnZlIGlkZW50aWZpZXInKTtcblxuXHRkZXIucmVhZFNlcXVlbmNlKDB4YTEpO1xuXHR2YXIgQSA9IHV0aWxzLnJlYWRCaXRTdHJpbmcoZGVyKTtcblxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdlZDI1NTE5Jyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnQScsIGRhdGE6IHV0aWxzLnplcm9QYWRUb0xlbmd0aChBLCAzMikgfSxcblx0XHRcdHsgbmFtZTogJ2snLCBkYXRhOiBrIH1cblx0XHRdXG5cdH07XG5cblx0cmV0dXJuIChuZXcgUHJpdmF0ZUtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3MxRFNBUHVibGljKGRlcikge1xuXHR2YXIgeSA9IHJlYWRNUEludChkZXIsICd5Jyk7XG5cdHZhciBwID0gcmVhZE1QSW50KGRlciwgJ3AnKTtcblx0dmFyIHEgPSByZWFkTVBJbnQoZGVyLCAncScpO1xuXHR2YXIgZyA9IHJlYWRNUEludChkZXIsICdnJyk7XG5cblx0dmFyIGtleSA9IHtcblx0XHR0eXBlOiAnZHNhJyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAneScsIGRhdGE6IHkgfSxcblx0XHRcdHsgbmFtZTogJ3AnLCBkYXRhOiBwIH0sXG5cdFx0XHR7IG5hbWU6ICdxJywgZGF0YTogcSB9LFxuXHRcdFx0eyBuYW1lOiAnZycsIGRhdGE6IGcgfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzMUVDRFNBUHVibGljKGRlcikge1xuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cblx0dmFyIG9pZCA9IGRlci5yZWFkT0lEKCk7XG5cdGFzc2VydC5zdHJpY3RFcXVhbChvaWQsICcxLjIuODQwLjEwMDQ1LjIuMScsICdtdXN0IGJlIGVjUHVibGljS2V5Jyk7XG5cblx0dmFyIGN1cnZlT2lkID0gZGVyLnJlYWRPSUQoKTtcblxuXHR2YXIgY3VydmU7XG5cdHZhciBjdXJ2ZXMgPSBPYmplY3Qua2V5cyhhbGdzLmN1cnZlcyk7XG5cdGZvciAodmFyIGogPSAwOyBqIDwgY3VydmVzLmxlbmd0aDsgKytqKSB7XG5cdFx0dmFyIGMgPSBjdXJ2ZXNbal07XG5cdFx0dmFyIGNkID0gYWxncy5jdXJ2ZXNbY107XG5cdFx0aWYgKGNkLnBrY3M4b2lkID09PSBjdXJ2ZU9pZCkge1xuXHRcdFx0Y3VydmUgPSBjO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cdGFzc2VydC5zdHJpbmcoY3VydmUsICdhIGtub3duIEVDRFNBIG5hbWVkIGN1cnZlJyk7XG5cblx0dmFyIFEgPSBkZXIucmVhZFN0cmluZyhhc24xLkJlci5CaXRTdHJpbmcsIHRydWUpO1xuXHRRID0gdXRpbHMuZWNOb3JtYWxpemUoUSk7XG5cblx0dmFyIGtleSA9IHtcblx0XHR0eXBlOiAnZWNkc2EnLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICdjdXJ2ZScsIGRhdGE6IEJ1ZmZlci5mcm9tKGN1cnZlKSB9LFxuXHRcdFx0eyBuYW1lOiAnUScsIGRhdGE6IFEgfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzMUVDRFNBUHJpdmF0ZShkZXIpIHtcblx0dmFyIHZlcnNpb24gPSByZWFkTVBJbnQoZGVyLCAndmVyc2lvbicpO1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwodmVyc2lvbi5yZWFkVUludDgoMCksIDEpO1xuXG5cdC8vIHByaXZhdGUga2V5XG5cdHZhciBkID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuT2N0ZXRTdHJpbmcsIHRydWUpO1xuXG5cdGRlci5yZWFkU2VxdWVuY2UoMHhhMCk7XG5cdHZhciBjdXJ2ZSA9IHJlYWRFQ0RTQUN1cnZlKGRlcik7XG5cdGFzc2VydC5zdHJpbmcoY3VydmUsICdhIGtub3duIGVsbGlwdGljIGN1cnZlJyk7XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZSgweGExKTtcblx0dmFyIFEgPSBkZXIucmVhZFN0cmluZyhhc24xLkJlci5CaXRTdHJpbmcsIHRydWUpO1xuXHRRID0gdXRpbHMuZWNOb3JtYWxpemUoUSk7XG5cblx0dmFyIGtleSA9IHtcblx0XHR0eXBlOiAnZWNkc2EnLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICdjdXJ2ZScsIGRhdGE6IEJ1ZmZlci5mcm9tKGN1cnZlKSB9LFxuXHRcdFx0eyBuYW1lOiAnUScsIGRhdGE6IFEgfSxcblx0XHRcdHsgbmFtZTogJ2QnLCBkYXRhOiBkIH1cblx0XHRdXG5cdH07XG5cblx0cmV0dXJuIChuZXcgUHJpdmF0ZUtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzMShkZXIsIGtleSkge1xuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXG5cdHN3aXRjaCAoa2V5LnR5cGUpIHtcblx0Y2FzZSAncnNhJzpcblx0XHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSlcblx0XHRcdHdyaXRlUGtjczFSU0FQcml2YXRlKGRlciwga2V5KTtcblx0XHRlbHNlXG5cdFx0XHR3cml0ZVBrY3MxUlNBUHVibGljKGRlciwga2V5KTtcblx0XHRicmVhaztcblx0Y2FzZSAnZHNhJzpcblx0XHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSlcblx0XHRcdHdyaXRlUGtjczFEU0FQcml2YXRlKGRlciwga2V5KTtcblx0XHRlbHNlXG5cdFx0XHR3cml0ZVBrY3MxRFNBUHVibGljKGRlciwga2V5KTtcblx0XHRicmVhaztcblx0Y2FzZSAnZWNkc2EnOlxuXHRcdGlmIChQcml2YXRlS2V5LmlzUHJpdmF0ZUtleShrZXkpKVxuXHRcdFx0d3JpdGVQa2NzMUVDRFNBUHJpdmF0ZShkZXIsIGtleSk7XG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVQa2NzMUVDRFNBUHVibGljKGRlciwga2V5KTtcblx0XHRicmVhaztcblx0Y2FzZSAnZWQyNTUxOSc6XG5cdFx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpXG5cdFx0XHR3cml0ZVBrY3MxRWREU0FQcml2YXRlKGRlciwga2V5KTtcblx0XHRlbHNlXG5cdFx0XHR3cml0ZVBrY3MxRWREU0FQdWJsaWMoZGVyLCBrZXkpO1xuXHRcdGJyZWFrO1xuXHRkZWZhdWx0OlxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1Vua25vd24ga2V5IGFsZ286ICcgKyBrZXkudHlwZSkpO1xuXHR9XG5cblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczFSU0FQdWJsaWMoZGVyLCBrZXkpIHtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0Lm4uZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5lLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3MxUlNBUHJpdmF0ZShkZXIsIGtleSkge1xuXHR2YXIgdmVyID0gQnVmZmVyLmZyb20oWzBdKTtcblx0ZGVyLndyaXRlQnVmZmVyKHZlciwgYXNuMS5CZXIuSW50ZWdlcik7XG5cblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0Lm4uZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5lLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZC5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnAuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5xLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRpZiAoIWtleS5wYXJ0LmRtb2RwIHx8ICFrZXkucGFydC5kbW9kcSlcblx0XHR1dGlscy5hZGRSU0FNaXNzaW5nKGtleSk7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5kbW9kcC5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmRtb2RxLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuaXFtcC5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzMURTQVByaXZhdGUoZGVyLCBrZXkpIHtcblx0dmFyIHZlciA9IEJ1ZmZlci5mcm9tKFswXSk7XG5cdGRlci53cml0ZUJ1ZmZlcih2ZXIsIGFzbjEuQmVyLkludGVnZXIpO1xuXG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5wLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQucS5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmcuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC55LmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQueC5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzMURTQVB1YmxpYyhkZXIsIGtleSkge1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQueS5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnAuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5xLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZy5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzMUVDRFNBUHVibGljKGRlciwga2V5KSB7XG5cdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cblx0ZGVyLndyaXRlT0lEKCcxLjIuODQwLjEwMDQ1LjIuMScpOyAvKiBlY1B1YmxpY0tleSAqL1xuXHR2YXIgY3VydmUgPSBrZXkucGFydC5jdXJ2ZS5kYXRhLnRvU3RyaW5nKCk7XG5cdHZhciBjdXJ2ZU9pZCA9IGFsZ3MuY3VydmVzW2N1cnZlXS5wa2NzOG9pZDtcblx0YXNzZXJ0LnN0cmluZyhjdXJ2ZU9pZCwgJ2Ega25vd24gRUNEU0EgbmFtZWQgY3VydmUnKTtcblx0ZGVyLndyaXRlT0lEKGN1cnZlT2lkKTtcblxuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHR2YXIgUSA9IHV0aWxzLmVjTm9ybWFsaXplKGtleS5wYXJ0LlEuZGF0YSwgdHJ1ZSk7XG5cdGRlci53cml0ZUJ1ZmZlcihRLCBhc24xLkJlci5CaXRTdHJpbmcpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3MxRUNEU0FQcml2YXRlKGRlciwga2V5KSB7XG5cdHZhciB2ZXIgPSBCdWZmZXIuZnJvbShbMV0pO1xuXHRkZXIud3JpdGVCdWZmZXIodmVyLCBhc24xLkJlci5JbnRlZ2VyKTtcblxuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZC5kYXRhLCBhc24xLkJlci5PY3RldFN0cmluZyk7XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoMHhhMCk7XG5cdHZhciBjdXJ2ZSA9IGtleS5wYXJ0LmN1cnZlLmRhdGEudG9TdHJpbmcoKTtcblx0dmFyIGN1cnZlT2lkID0gYWxncy5jdXJ2ZXNbY3VydmVdLnBrY3M4b2lkO1xuXHRhc3NlcnQuc3RyaW5nKGN1cnZlT2lkLCAnYSBrbm93biBFQ0RTQSBuYW1lZCBjdXJ2ZScpO1xuXHRkZXIud3JpdGVPSUQoY3VydmVPaWQpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZSgweGExKTtcblx0dmFyIFEgPSB1dGlscy5lY05vcm1hbGl6ZShrZXkucGFydC5RLmRhdGEsIHRydWUpO1xuXHRkZXIud3JpdGVCdWZmZXIoUSwgYXNuMS5CZXIuQml0U3RyaW5nKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczFFZERTQVByaXZhdGUoZGVyLCBrZXkpIHtcblx0dmFyIHZlciA9IEJ1ZmZlci5mcm9tKFsxXSk7XG5cdGRlci53cml0ZUJ1ZmZlcih2ZXIsIGFzbjEuQmVyLkludGVnZXIpO1xuXG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5rLmRhdGEsIGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZSgweGEwKTtcblx0ZGVyLndyaXRlT0lEKCcxLjMuMTAxLjExMicpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZSgweGExKTtcblx0dXRpbHMud3JpdGVCaXRTdHJpbmcoZGVyLCBrZXkucGFydC5BLmRhdGEpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzMUVkRFNBUHVibGljKGRlciwga2V5KSB7XG5cdHRocm93IChuZXcgRXJyb3IoJ1B1YmxpYyBrZXlzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBFZERTQSBQS0NTIzEnKSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/formats/pkcs1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/formats/pkcs1.js":
/*!*************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/pkcs1.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\treadPkcs1: readPkcs1,\n\twrite: write,\n\twritePkcs1: writePkcs1\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(rsc)/./node_modules/asn1/lib/index.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\n\nvar Key = __webpack_require__(/*! ../key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\nvar pem = __webpack_require__(/*! ./pem */ \"(rsc)/./node_modules/sshpk/lib/formats/pem.js\");\n\nvar pkcs8 = __webpack_require__(/*! ./pkcs8 */ \"(rsc)/./node_modules/sshpk/lib/formats/pkcs8.js\");\nvar readECDSACurve = pkcs8.readECDSACurve;\n\nfunction read(buf, options) {\n\treturn (pem.read(buf, options, 'pkcs1'));\n}\n\nfunction write(key, options) {\n\treturn (pem.write(key, options, 'pkcs1'));\n}\n\n/* Helper to read in a single mpint */\nfunction readMPInt(der, nm) {\n\tassert.strictEqual(der.peek(), asn1.Ber.Integer,\n\t    nm + ' is not an Integer');\n\treturn (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));\n}\n\nfunction readPkcs1(alg, type, der) {\n\tswitch (alg) {\n\tcase 'RSA':\n\t\tif (type === 'public')\n\t\t\treturn (readPkcs1RSAPublic(der));\n\t\telse if (type === 'private')\n\t\t\treturn (readPkcs1RSAPrivate(der));\n\t\tthrow (new Error('Unknown key type: ' + type));\n\tcase 'DSA':\n\t\tif (type === 'public')\n\t\t\treturn (readPkcs1DSAPublic(der));\n\t\telse if (type === 'private')\n\t\t\treturn (readPkcs1DSAPrivate(der));\n\t\tthrow (new Error('Unknown key type: ' + type));\n\tcase 'EC':\n\tcase 'ECDSA':\n\t\tif (type === 'private')\n\t\t\treturn (readPkcs1ECDSAPrivate(der));\n\t\telse if (type === 'public')\n\t\t\treturn (readPkcs1ECDSAPublic(der));\n\t\tthrow (new Error('Unknown key type: ' + type));\n\tcase 'EDDSA':\n\tcase 'EdDSA':\n\t\tif (type === 'private')\n\t\t\treturn (readPkcs1EdDSAPrivate(der));\n\t\tthrow (new Error(type + ' keys not supported with EdDSA'));\n\tdefault:\n\t\tthrow (new Error('Unknown key algo: ' + alg));\n\t}\n}\n\nfunction readPkcs1RSAPublic(der) {\n\t// modulus and exponent\n\tvar n = readMPInt(der, 'modulus');\n\tvar e = readMPInt(der, 'exponent');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'rsa',\n\t\tparts: [\n\t\t\t{ name: 'e', data: e },\n\t\t\t{ name: 'n', data: n }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs1RSAPrivate(der) {\n\tvar version = readMPInt(der, 'version');\n\tassert.strictEqual(version[0], 0);\n\n\t// modulus then public exponent\n\tvar n = readMPInt(der, 'modulus');\n\tvar e = readMPInt(der, 'public exponent');\n\tvar d = readMPInt(der, 'private exponent');\n\tvar p = readMPInt(der, 'prime1');\n\tvar q = readMPInt(der, 'prime2');\n\tvar dmodp = readMPInt(der, 'exponent1');\n\tvar dmodq = readMPInt(der, 'exponent2');\n\tvar iqmp = readMPInt(der, 'iqmp');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'rsa',\n\t\tparts: [\n\t\t\t{ name: 'n', data: n },\n\t\t\t{ name: 'e', data: e },\n\t\t\t{ name: 'd', data: d },\n\t\t\t{ name: 'iqmp', data: iqmp },\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'dmodp', data: dmodp },\n\t\t\t{ name: 'dmodq', data: dmodq }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs1DSAPrivate(der) {\n\tvar version = readMPInt(der, 'version');\n\tassert.strictEqual(version.readUInt8(0), 0);\n\n\tvar p = readMPInt(der, 'p');\n\tvar q = readMPInt(der, 'q');\n\tvar g = readMPInt(der, 'g');\n\tvar y = readMPInt(der, 'y');\n\tvar x = readMPInt(der, 'x');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'dsa',\n\t\tparts: [\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'g', data: g },\n\t\t\t{ name: 'y', data: y },\n\t\t\t{ name: 'x', data: x }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs1EdDSAPrivate(der) {\n\tvar version = readMPInt(der, 'version');\n\tassert.strictEqual(version.readUInt8(0), 1);\n\n\t// private key\n\tvar k = der.readString(asn1.Ber.OctetString, true);\n\n\tder.readSequence(0xa0);\n\tvar oid = der.readOID();\n\tassert.strictEqual(oid, '1.3.101.112', 'the ed25519 curve identifier');\n\n\tder.readSequence(0xa1);\n\tvar A = utils.readBitString(der);\n\n\tvar key = {\n\t\ttype: 'ed25519',\n\t\tparts: [\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\n\t\t\t{ name: 'k', data: k }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs1DSAPublic(der) {\n\tvar y = readMPInt(der, 'y');\n\tvar p = readMPInt(der, 'p');\n\tvar q = readMPInt(der, 'q');\n\tvar g = readMPInt(der, 'g');\n\n\tvar key = {\n\t\ttype: 'dsa',\n\t\tparts: [\n\t\t\t{ name: 'y', data: y },\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'g', data: g }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs1ECDSAPublic(der) {\n\tder.readSequence();\n\n\tvar oid = der.readOID();\n\tassert.strictEqual(oid, '1.2.840.10045.2.1', 'must be ecPublicKey');\n\n\tvar curveOid = der.readOID();\n\n\tvar curve;\n\tvar curves = Object.keys(algs.curves);\n\tfor (var j = 0; j < curves.length; ++j) {\n\t\tvar c = curves[j];\n\t\tvar cd = algs.curves[c];\n\t\tif (cd.pkcs8oid === curveOid) {\n\t\t\tcurve = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\tassert.string(curve, 'a known ECDSA named curve');\n\n\tvar Q = der.readString(asn1.Ber.BitString, true);\n\tQ = utils.ecNormalize(Q);\n\n\tvar key = {\n\t\ttype: 'ecdsa',\n\t\tparts: [\n\t\t\t{ name: 'curve', data: Buffer.from(curve) },\n\t\t\t{ name: 'Q', data: Q }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs1ECDSAPrivate(der) {\n\tvar version = readMPInt(der, 'version');\n\tassert.strictEqual(version.readUInt8(0), 1);\n\n\t// private key\n\tvar d = der.readString(asn1.Ber.OctetString, true);\n\n\tder.readSequence(0xa0);\n\tvar curve = readECDSACurve(der);\n\tassert.string(curve, 'a known elliptic curve');\n\n\tder.readSequence(0xa1);\n\tvar Q = der.readString(asn1.Ber.BitString, true);\n\tQ = utils.ecNormalize(Q);\n\n\tvar key = {\n\t\ttype: 'ecdsa',\n\t\tparts: [\n\t\t\t{ name: 'curve', data: Buffer.from(curve) },\n\t\t\t{ name: 'Q', data: Q },\n\t\t\t{ name: 'd', data: d }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction writePkcs1(der, key) {\n\tder.startSequence();\n\n\tswitch (key.type) {\n\tcase 'rsa':\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs1RSAPrivate(der, key);\n\t\telse\n\t\t\twritePkcs1RSAPublic(der, key);\n\t\tbreak;\n\tcase 'dsa':\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs1DSAPrivate(der, key);\n\t\telse\n\t\t\twritePkcs1DSAPublic(der, key);\n\t\tbreak;\n\tcase 'ecdsa':\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs1ECDSAPrivate(der, key);\n\t\telse\n\t\t\twritePkcs1ECDSAPublic(der, key);\n\t\tbreak;\n\tcase 'ed25519':\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs1EdDSAPrivate(der, key);\n\t\telse\n\t\t\twritePkcs1EdDSAPublic(der, key);\n\t\tbreak;\n\tdefault:\n\t\tthrow (new Error('Unknown key algo: ' + key.type));\n\t}\n\n\tder.endSequence();\n}\n\nfunction writePkcs1RSAPublic(der, key) {\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1RSAPrivate(der, key) {\n\tvar ver = Buffer.from([0]);\n\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.d.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tif (!key.part.dmodp || !key.part.dmodq)\n\t\tutils.addRSAMissing(key);\n\tder.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1DSAPrivate(der, key) {\n\tvar ver = Buffer.from([0]);\n\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.x.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1DSAPublic(der, key) {\n\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1ECDSAPublic(der, key) {\n\tder.startSequence();\n\n\tder.writeOID('1.2.840.10045.2.1'); /* ecPublicKey */\n\tvar curve = key.part.curve.data.toString();\n\tvar curveOid = algs.curves[curve].pkcs8oid;\n\tassert.string(curveOid, 'a known ECDSA named curve');\n\tder.writeOID(curveOid);\n\n\tder.endSequence();\n\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\tder.writeBuffer(Q, asn1.Ber.BitString);\n}\n\nfunction writePkcs1ECDSAPrivate(der, key) {\n\tvar ver = Buffer.from([1]);\n\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.d.data, asn1.Ber.OctetString);\n\n\tder.startSequence(0xa0);\n\tvar curve = key.part.curve.data.toString();\n\tvar curveOid = algs.curves[curve].pkcs8oid;\n\tassert.string(curveOid, 'a known ECDSA named curve');\n\tder.writeOID(curveOid);\n\tder.endSequence();\n\n\tder.startSequence(0xa1);\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\tder.writeBuffer(Q, asn1.Ber.BitString);\n\tder.endSequence();\n}\n\nfunction writePkcs1EdDSAPrivate(der, key) {\n\tvar ver = Buffer.from([1]);\n\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.k.data, asn1.Ber.OctetString);\n\n\tder.startSequence(0xa0);\n\tder.writeOID('1.3.101.112');\n\tder.endSequence();\n\n\tder.startSequence(0xa1);\n\tutils.writeBitString(der, key.part.A.data);\n\tder.endSequence();\n}\n\nfunction writePkcs1EdDSAPublic(der, key) {\n\tthrow (new Error('Public keys are not supported for EdDSA PKCS#1'));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvcGtjczEuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrREFBYTtBQUNsQyxXQUFXLG1CQUFPLENBQUMsb0RBQU07QUFDekIsYUFBYSw4RkFBOEI7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLHVEQUFTO0FBQzVCLFlBQVksbUJBQU8sQ0FBQyx5REFBVTs7QUFFOUIsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFnQjtBQUN6QyxVQUFVLG1CQUFPLENBQUMsNERBQU87O0FBRXpCLFlBQVksbUJBQU8sQ0FBQyxnRUFBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQjtBQUN6QixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQjtBQUN6QixLQUFLLG9CQUFvQjtBQUN6QixLQUFLLG9CQUFvQjtBQUN6QixLQUFLLDBCQUEwQjtBQUMvQixLQUFLLG9CQUFvQjtBQUN6QixLQUFLLG9CQUFvQjtBQUN6QixLQUFLLDRCQUE0QjtBQUNqQyxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0I7QUFDekIsS0FBSyxvQkFBb0I7QUFDekIsS0FBSyxvQkFBb0I7QUFDekIsS0FBSyxvQkFBb0I7QUFDekIsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtDQUErQztBQUNwRCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0I7QUFDekIsS0FBSyxvQkFBb0I7QUFDekIsS0FBSyxvQkFBb0I7QUFDekIsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUsseUNBQXlDO0FBQzlDLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHlDQUF5QztBQUM5QyxLQUFLLG9CQUFvQjtBQUN6QixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9wa2NzMS5qcz9hMmMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmVhZDogcmVhZCxcblx0cmVhZFBrY3MxOiByZWFkUGtjczEsXG5cdHdyaXRlOiB3cml0ZSxcblx0d3JpdGVQa2NzMTogd3JpdGVQa2NzMVxufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgYXNuMSA9IHJlcXVpcmUoJ2FzbjEnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4uL2FsZ3MnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciBLZXkgPSByZXF1aXJlKCcuLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZS1rZXknKTtcbnZhciBwZW0gPSByZXF1aXJlKCcuL3BlbScpO1xuXG52YXIgcGtjczggPSByZXF1aXJlKCcuL3BrY3M4Jyk7XG52YXIgcmVhZEVDRFNBQ3VydmUgPSBwa2NzOC5yZWFkRUNEU0FDdXJ2ZTtcblxuZnVuY3Rpb24gcmVhZChidWYsIG9wdGlvbnMpIHtcblx0cmV0dXJuIChwZW0ucmVhZChidWYsIG9wdGlvbnMsICdwa2NzMScpKTtcbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBvcHRpb25zKSB7XG5cdHJldHVybiAocGVtLndyaXRlKGtleSwgb3B0aW9ucywgJ3BrY3MxJykpO1xufVxuXG4vKiBIZWxwZXIgdG8gcmVhZCBpbiBhIHNpbmdsZSBtcGludCAqL1xuZnVuY3Rpb24gcmVhZE1QSW50KGRlciwgbm0pIHtcblx0YXNzZXJ0LnN0cmljdEVxdWFsKGRlci5wZWVrKCksIGFzbjEuQmVyLkludGVnZXIsXG5cdCAgICBubSArICcgaXMgbm90IGFuIEludGVnZXInKTtcblx0cmV0dXJuICh1dGlscy5tcE5vcm1hbGl6ZShkZXIucmVhZFN0cmluZyhhc24xLkJlci5JbnRlZ2VyLCB0cnVlKSkpO1xufVxuXG5mdW5jdGlvbiByZWFkUGtjczEoYWxnLCB0eXBlLCBkZXIpIHtcblx0c3dpdGNoIChhbGcpIHtcblx0Y2FzZSAnUlNBJzpcblx0XHRpZiAodHlwZSA9PT0gJ3B1YmxpYycpXG5cdFx0XHRyZXR1cm4gKHJlYWRQa2NzMVJTQVB1YmxpYyhkZXIpKTtcblx0XHRlbHNlIGlmICh0eXBlID09PSAncHJpdmF0ZScpXG5cdFx0XHRyZXR1cm4gKHJlYWRQa2NzMVJTQVByaXZhdGUoZGVyKSk7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biBrZXkgdHlwZTogJyArIHR5cGUpKTtcblx0Y2FzZSAnRFNBJzpcblx0XHRpZiAodHlwZSA9PT0gJ3B1YmxpYycpXG5cdFx0XHRyZXR1cm4gKHJlYWRQa2NzMURTQVB1YmxpYyhkZXIpKTtcblx0XHRlbHNlIGlmICh0eXBlID09PSAncHJpdmF0ZScpXG5cdFx0XHRyZXR1cm4gKHJlYWRQa2NzMURTQVByaXZhdGUoZGVyKSk7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biBrZXkgdHlwZTogJyArIHR5cGUpKTtcblx0Y2FzZSAnRUMnOlxuXHRjYXNlICdFQ0RTQSc6XG5cdFx0aWYgKHR5cGUgPT09ICdwcml2YXRlJylcblx0XHRcdHJldHVybiAocmVhZFBrY3MxRUNEU0FQcml2YXRlKGRlcikpO1xuXHRcdGVsc2UgaWYgKHR5cGUgPT09ICdwdWJsaWMnKVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczFFQ0RTQVB1YmxpYyhkZXIpKTtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdVbmtub3duIGtleSB0eXBlOiAnICsgdHlwZSkpO1xuXHRjYXNlICdFRERTQSc6XG5cdGNhc2UgJ0VkRFNBJzpcblx0XHRpZiAodHlwZSA9PT0gJ3ByaXZhdGUnKVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczFFZERTQVByaXZhdGUoZGVyKSk7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcih0eXBlICsgJyBrZXlzIG5vdCBzdXBwb3J0ZWQgd2l0aCBFZERTQScpKTtcblx0ZGVmYXVsdDpcblx0XHR0aHJvdyAobmV3IEVycm9yKCdVbmtub3duIGtleSBhbGdvOiAnICsgYWxnKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVhZFBrY3MxUlNBUHVibGljKGRlcikge1xuXHQvLyBtb2R1bHVzIGFuZCBleHBvbmVudFxuXHR2YXIgbiA9IHJlYWRNUEludChkZXIsICdtb2R1bHVzJyk7XG5cdHZhciBlID0gcmVhZE1QSW50KGRlciwgJ2V4cG9uZW50Jyk7XG5cblx0Ly8gbm93LCBtYWtlIHRoZSBrZXlcblx0dmFyIGtleSA9IHtcblx0XHR0eXBlOiAncnNhJyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnZScsIGRhdGE6IGUgfSxcblx0XHRcdHsgbmFtZTogJ24nLCBkYXRhOiBuIH1cblx0XHRdXG5cdH07XG5cblx0cmV0dXJuIChuZXcgS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiByZWFkUGtjczFSU0FQcml2YXRlKGRlcikge1xuXHR2YXIgdmVyc2lvbiA9IHJlYWRNUEludChkZXIsICd2ZXJzaW9uJyk7XG5cdGFzc2VydC5zdHJpY3RFcXVhbCh2ZXJzaW9uWzBdLCAwKTtcblxuXHQvLyBtb2R1bHVzIHRoZW4gcHVibGljIGV4cG9uZW50XG5cdHZhciBuID0gcmVhZE1QSW50KGRlciwgJ21vZHVsdXMnKTtcblx0dmFyIGUgPSByZWFkTVBJbnQoZGVyLCAncHVibGljIGV4cG9uZW50Jyk7XG5cdHZhciBkID0gcmVhZE1QSW50KGRlciwgJ3ByaXZhdGUgZXhwb25lbnQnKTtcblx0dmFyIHAgPSByZWFkTVBJbnQoZGVyLCAncHJpbWUxJyk7XG5cdHZhciBxID0gcmVhZE1QSW50KGRlciwgJ3ByaW1lMicpO1xuXHR2YXIgZG1vZHAgPSByZWFkTVBJbnQoZGVyLCAnZXhwb25lbnQxJyk7XG5cdHZhciBkbW9kcSA9IHJlYWRNUEludChkZXIsICdleHBvbmVudDInKTtcblx0dmFyIGlxbXAgPSByZWFkTVBJbnQoZGVyLCAnaXFtcCcpO1xuXG5cdC8vIG5vdywgbWFrZSB0aGUga2V5XG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ3JzYScsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ24nLCBkYXRhOiBuIH0sXG5cdFx0XHR7IG5hbWU6ICdlJywgZGF0YTogZSB9LFxuXHRcdFx0eyBuYW1lOiAnZCcsIGRhdGE6IGQgfSxcblx0XHRcdHsgbmFtZTogJ2lxbXAnLCBkYXRhOiBpcW1wIH0sXG5cdFx0XHR7IG5hbWU6ICdwJywgZGF0YTogcCB9LFxuXHRcdFx0eyBuYW1lOiAncScsIGRhdGE6IHEgfSxcblx0XHRcdHsgbmFtZTogJ2Rtb2RwJywgZGF0YTogZG1vZHAgfSxcblx0XHRcdHsgbmFtZTogJ2Rtb2RxJywgZGF0YTogZG1vZHEgfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBQcml2YXRlS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiByZWFkUGtjczFEU0FQcml2YXRlKGRlcikge1xuXHR2YXIgdmVyc2lvbiA9IHJlYWRNUEludChkZXIsICd2ZXJzaW9uJyk7XG5cdGFzc2VydC5zdHJpY3RFcXVhbCh2ZXJzaW9uLnJlYWRVSW50OCgwKSwgMCk7XG5cblx0dmFyIHAgPSByZWFkTVBJbnQoZGVyLCAncCcpO1xuXHR2YXIgcSA9IHJlYWRNUEludChkZXIsICdxJyk7XG5cdHZhciBnID0gcmVhZE1QSW50KGRlciwgJ2cnKTtcblx0dmFyIHkgPSByZWFkTVBJbnQoZGVyLCAneScpO1xuXHR2YXIgeCA9IHJlYWRNUEludChkZXIsICd4Jyk7XG5cblx0Ly8gbm93LCBtYWtlIHRoZSBrZXlcblx0dmFyIGtleSA9IHtcblx0XHR0eXBlOiAnZHNhJyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAncCcsIGRhdGE6IHAgfSxcblx0XHRcdHsgbmFtZTogJ3EnLCBkYXRhOiBxIH0sXG5cdFx0XHR7IG5hbWU6ICdnJywgZGF0YTogZyB9LFxuXHRcdFx0eyBuYW1lOiAneScsIGRhdGE6IHkgfSxcblx0XHRcdHsgbmFtZTogJ3gnLCBkYXRhOiB4IH1cblx0XHRdXG5cdH07XG5cblx0cmV0dXJuIChuZXcgUHJpdmF0ZUtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3MxRWREU0FQcml2YXRlKGRlcikge1xuXHR2YXIgdmVyc2lvbiA9IHJlYWRNUEludChkZXIsICd2ZXJzaW9uJyk7XG5cdGFzc2VydC5zdHJpY3RFcXVhbCh2ZXJzaW9uLnJlYWRVSW50OCgwKSwgMSk7XG5cblx0Ly8gcHJpdmF0ZSBrZXlcblx0dmFyIGsgPSBkZXIucmVhZFN0cmluZyhhc24xLkJlci5PY3RldFN0cmluZywgdHJ1ZSk7XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZSgweGEwKTtcblx0dmFyIG9pZCA9IGRlci5yZWFkT0lEKCk7XG5cdGFzc2VydC5zdHJpY3RFcXVhbChvaWQsICcxLjMuMTAxLjExMicsICd0aGUgZWQyNTUxOSBjdXJ2ZSBpZGVudGlmaWVyJyk7XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZSgweGExKTtcblx0dmFyIEEgPSB1dGlscy5yZWFkQml0U3RyaW5nKGRlcik7XG5cblx0dmFyIGtleSA9IHtcblx0XHR0eXBlOiAnZWQyNTUxOScsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ0EnLCBkYXRhOiB1dGlscy56ZXJvUGFkVG9MZW5ndGgoQSwgMzIpIH0sXG5cdFx0XHR7IG5hbWU6ICdrJywgZGF0YTogayB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IFByaXZhdGVLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzMURTQVB1YmxpYyhkZXIpIHtcblx0dmFyIHkgPSByZWFkTVBJbnQoZGVyLCAneScpO1xuXHR2YXIgcCA9IHJlYWRNUEludChkZXIsICdwJyk7XG5cdHZhciBxID0gcmVhZE1QSW50KGRlciwgJ3EnKTtcblx0dmFyIGcgPSByZWFkTVBJbnQoZGVyLCAnZycpO1xuXG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ2RzYScsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ3knLCBkYXRhOiB5IH0sXG5cdFx0XHR7IG5hbWU6ICdwJywgZGF0YTogcCB9LFxuXHRcdFx0eyBuYW1lOiAncScsIGRhdGE6IHEgfSxcblx0XHRcdHsgbmFtZTogJ2cnLCBkYXRhOiBnIH1cblx0XHRdXG5cdH07XG5cblx0cmV0dXJuIChuZXcgS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiByZWFkUGtjczFFQ0RTQVB1YmxpYyhkZXIpIHtcblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXG5cdHZhciBvaWQgPSBkZXIucmVhZE9JRCgpO1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwob2lkLCAnMS4yLjg0MC4xMDA0NS4yLjEnLCAnbXVzdCBiZSBlY1B1YmxpY0tleScpO1xuXG5cdHZhciBjdXJ2ZU9pZCA9IGRlci5yZWFkT0lEKCk7XG5cblx0dmFyIGN1cnZlO1xuXHR2YXIgY3VydmVzID0gT2JqZWN0LmtleXMoYWxncy5jdXJ2ZXMpO1xuXHRmb3IgKHZhciBqID0gMDsgaiA8IGN1cnZlcy5sZW5ndGg7ICsraikge1xuXHRcdHZhciBjID0gY3VydmVzW2pdO1xuXHRcdHZhciBjZCA9IGFsZ3MuY3VydmVzW2NdO1xuXHRcdGlmIChjZC5wa2NzOG9pZCA9PT0gY3VydmVPaWQpIHtcblx0XHRcdGN1cnZlID0gYztcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXHRhc3NlcnQuc3RyaW5nKGN1cnZlLCAnYSBrbm93biBFQ0RTQSBuYW1lZCBjdXJ2ZScpO1xuXG5cdHZhciBRID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuQml0U3RyaW5nLCB0cnVlKTtcblx0USA9IHV0aWxzLmVjTm9ybWFsaXplKFEpO1xuXG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ2VjZHNhJyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnY3VydmUnLCBkYXRhOiBCdWZmZXIuZnJvbShjdXJ2ZSkgfSxcblx0XHRcdHsgbmFtZTogJ1EnLCBkYXRhOiBRIH1cblx0XHRdXG5cdH07XG5cblx0cmV0dXJuIChuZXcgS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiByZWFkUGtjczFFQ0RTQVByaXZhdGUoZGVyKSB7XG5cdHZhciB2ZXJzaW9uID0gcmVhZE1QSW50KGRlciwgJ3ZlcnNpb24nKTtcblx0YXNzZXJ0LnN0cmljdEVxdWFsKHZlcnNpb24ucmVhZFVJbnQ4KDApLCAxKTtcblxuXHQvLyBwcml2YXRlIGtleVxuXHR2YXIgZCA9IGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLk9jdGV0U3RyaW5nLCB0cnVlKTtcblxuXHRkZXIucmVhZFNlcXVlbmNlKDB4YTApO1xuXHR2YXIgY3VydmUgPSByZWFkRUNEU0FDdXJ2ZShkZXIpO1xuXHRhc3NlcnQuc3RyaW5nKGN1cnZlLCAnYSBrbm93biBlbGxpcHRpYyBjdXJ2ZScpO1xuXG5cdGRlci5yZWFkU2VxdWVuY2UoMHhhMSk7XG5cdHZhciBRID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuQml0U3RyaW5nLCB0cnVlKTtcblx0USA9IHV0aWxzLmVjTm9ybWFsaXplKFEpO1xuXG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ2VjZHNhJyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnY3VydmUnLCBkYXRhOiBCdWZmZXIuZnJvbShjdXJ2ZSkgfSxcblx0XHRcdHsgbmFtZTogJ1EnLCBkYXRhOiBRIH0sXG5cdFx0XHR7IG5hbWU6ICdkJywgZGF0YTogZCB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IFByaXZhdGVLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczEoZGVyLCBrZXkpIHtcblx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblxuXHRzd2l0Y2ggKGtleS50eXBlKSB7XG5cdGNhc2UgJ3JzYSc6XG5cdFx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpXG5cdFx0XHR3cml0ZVBrY3MxUlNBUHJpdmF0ZShkZXIsIGtleSk7XG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVQa2NzMVJTQVB1YmxpYyhkZXIsIGtleSk7XG5cdFx0YnJlYWs7XG5cdGNhc2UgJ2RzYSc6XG5cdFx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpXG5cdFx0XHR3cml0ZVBrY3MxRFNBUHJpdmF0ZShkZXIsIGtleSk7XG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVQa2NzMURTQVB1YmxpYyhkZXIsIGtleSk7XG5cdFx0YnJlYWs7XG5cdGNhc2UgJ2VjZHNhJzpcblx0XHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSlcblx0XHRcdHdyaXRlUGtjczFFQ0RTQVByaXZhdGUoZGVyLCBrZXkpO1xuXHRcdGVsc2Vcblx0XHRcdHdyaXRlUGtjczFFQ0RTQVB1YmxpYyhkZXIsIGtleSk7XG5cdFx0YnJlYWs7XG5cdGNhc2UgJ2VkMjU1MTknOlxuXHRcdGlmIChQcml2YXRlS2V5LmlzUHJpdmF0ZUtleShrZXkpKVxuXHRcdFx0d3JpdGVQa2NzMUVkRFNBUHJpdmF0ZShkZXIsIGtleSk7XG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVQa2NzMUVkRFNBUHVibGljKGRlciwga2V5KTtcblx0XHRicmVhaztcblx0ZGVmYXVsdDpcblx0XHR0aHJvdyAobmV3IEVycm9yKCdVbmtub3duIGtleSBhbGdvOiAnICsga2V5LnR5cGUpKTtcblx0fVxuXG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3MxUlNBUHVibGljKGRlciwga2V5KSB7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5uLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZS5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzMVJTQVByaXZhdGUoZGVyLCBrZXkpIHtcblx0dmFyIHZlciA9IEJ1ZmZlci5mcm9tKFswXSk7XG5cdGRlci53cml0ZUJ1ZmZlcih2ZXIsIGFzbjEuQmVyLkludGVnZXIpO1xuXG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5uLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZS5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmQuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5wLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQucS5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0aWYgKCFrZXkucGFydC5kbW9kcCB8fCAha2V5LnBhcnQuZG1vZHEpXG5cdFx0dXRpbHMuYWRkUlNBTWlzc2luZyhrZXkpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZG1vZHAuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5kbW9kcS5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmlxbXAuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczFEU0FQcml2YXRlKGRlciwga2V5KSB7XG5cdHZhciB2ZXIgPSBCdWZmZXIuZnJvbShbMF0pO1xuXHRkZXIud3JpdGVCdWZmZXIodmVyLCBhc24xLkJlci5JbnRlZ2VyKTtcblxuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQucC5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnEuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5nLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQueS5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnguZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczFEU0FQdWJsaWMoZGVyLCBrZXkpIHtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnkuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5wLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQucS5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmcuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczFFQ0RTQVB1YmxpYyhkZXIsIGtleSkge1xuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXG5cdGRlci53cml0ZU9JRCgnMS4yLjg0MC4xMDA0NS4yLjEnKTsgLyogZWNQdWJsaWNLZXkgKi9cblx0dmFyIGN1cnZlID0ga2V5LnBhcnQuY3VydmUuZGF0YS50b1N0cmluZygpO1xuXHR2YXIgY3VydmVPaWQgPSBhbGdzLmN1cnZlc1tjdXJ2ZV0ucGtjczhvaWQ7XG5cdGFzc2VydC5zdHJpbmcoY3VydmVPaWQsICdhIGtub3duIEVDRFNBIG5hbWVkIGN1cnZlJyk7XG5cdGRlci53cml0ZU9JRChjdXJ2ZU9pZCk7XG5cblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0dmFyIFEgPSB1dGlscy5lY05vcm1hbGl6ZShrZXkucGFydC5RLmRhdGEsIHRydWUpO1xuXHRkZXIud3JpdGVCdWZmZXIoUSwgYXNuMS5CZXIuQml0U3RyaW5nKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzMUVDRFNBUHJpdmF0ZShkZXIsIGtleSkge1xuXHR2YXIgdmVyID0gQnVmZmVyLmZyb20oWzFdKTtcblx0ZGVyLndyaXRlQnVmZmVyKHZlciwgYXNuMS5CZXIuSW50ZWdlcik7XG5cblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmQuZGF0YSwgYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXG5cdGRlci5zdGFydFNlcXVlbmNlKDB4YTApO1xuXHR2YXIgY3VydmUgPSBrZXkucGFydC5jdXJ2ZS5kYXRhLnRvU3RyaW5nKCk7XG5cdHZhciBjdXJ2ZU9pZCA9IGFsZ3MuY3VydmVzW2N1cnZlXS5wa2NzOG9pZDtcblx0YXNzZXJ0LnN0cmluZyhjdXJ2ZU9pZCwgJ2Ega25vd24gRUNEU0EgbmFtZWQgY3VydmUnKTtcblx0ZGVyLndyaXRlT0lEKGN1cnZlT2lkKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoMHhhMSk7XG5cdHZhciBRID0gdXRpbHMuZWNOb3JtYWxpemUoa2V5LnBhcnQuUS5kYXRhLCB0cnVlKTtcblx0ZGVyLndyaXRlQnVmZmVyKFEsIGFzbjEuQmVyLkJpdFN0cmluZyk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3MxRWREU0FQcml2YXRlKGRlciwga2V5KSB7XG5cdHZhciB2ZXIgPSBCdWZmZXIuZnJvbShbMV0pO1xuXHRkZXIud3JpdGVCdWZmZXIodmVyLCBhc24xLkJlci5JbnRlZ2VyKTtcblxuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuay5kYXRhLCBhc24xLkJlci5PY3RldFN0cmluZyk7XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoMHhhMCk7XG5cdGRlci53cml0ZU9JRCgnMS4zLjEwMS4xMTInKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoMHhhMSk7XG5cdHV0aWxzLndyaXRlQml0U3RyaW5nKGRlciwga2V5LnBhcnQuQS5kYXRhKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczFFZERTQVB1YmxpYyhkZXIsIGtleSkge1xuXHR0aHJvdyAobmV3IEVycm9yKCdQdWJsaWMga2V5cyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgRWREU0EgUEtDUyMxJykpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/formats/pkcs1.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/formats/pkcs8.js":
/*!*************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/pkcs8.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2018 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\treadPkcs8: readPkcs8,\n\twrite: write,\n\twritePkcs8: writePkcs8,\n\tpkcs8ToBuffer: pkcs8ToBuffer,\n\n\treadECDSACurve: readECDSACurve,\n\twriteECDSACurve: writeECDSACurve\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(action-browser)/./node_modules/asn1/lib/index.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\nvar pem = __webpack_require__(/*! ./pem */ \"(action-browser)/./node_modules/sshpk/lib/formats/pem.js\");\n\nfunction read(buf, options) {\n\treturn (pem.read(buf, options, 'pkcs8'));\n}\n\nfunction write(key, options) {\n\treturn (pem.write(key, options, 'pkcs8'));\n}\n\n/* Helper to read in a single mpint */\nfunction readMPInt(der, nm) {\n\tassert.strictEqual(der.peek(), asn1.Ber.Integer,\n\t    nm + ' is not an Integer');\n\treturn (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));\n}\n\nfunction readPkcs8(alg, type, der) {\n\t/* Private keys in pkcs#8 format have a weird extra int */\n\tif (der.peek() === asn1.Ber.Integer) {\n\t\tassert.strictEqual(type, 'private',\n\t\t    'unexpected Integer at start of public key');\n\t\tder.readString(asn1.Ber.Integer, true);\n\t}\n\n\tder.readSequence();\n\tvar next = der.offset + der.length;\n\n\tvar oid = der.readOID();\n\tswitch (oid) {\n\tcase '1.2.840.113549.1.1.1':\n\t\tder._offset = next;\n\t\tif (type === 'public')\n\t\t\treturn (readPkcs8RSAPublic(der));\n\t\telse\n\t\t\treturn (readPkcs8RSAPrivate(der));\n\tcase '1.2.840.10040.4.1':\n\t\tif (type === 'public')\n\t\t\treturn (readPkcs8DSAPublic(der));\n\t\telse\n\t\t\treturn (readPkcs8DSAPrivate(der));\n\tcase '1.2.840.10045.2.1':\n\t\tif (type === 'public')\n\t\t\treturn (readPkcs8ECDSAPublic(der));\n\t\telse\n\t\t\treturn (readPkcs8ECDSAPrivate(der));\n\tcase '1.3.101.112':\n\t\tif (type === 'public') {\n\t\t\treturn (readPkcs8EdDSAPublic(der));\n\t\t} else {\n\t\t\treturn (readPkcs8EdDSAPrivate(der));\n\t\t}\n\tcase '1.3.101.110':\n\t\tif (type === 'public') {\n\t\t\treturn (readPkcs8X25519Public(der));\n\t\t} else {\n\t\t\treturn (readPkcs8X25519Private(der));\n\t\t}\n\tdefault:\n\t\tthrow (new Error('Unknown key type OID ' + oid));\n\t}\n}\n\nfunction readPkcs8RSAPublic(der) {\n\t// bit string sequence\n\tder.readSequence(asn1.Ber.BitString);\n\tder.readByte();\n\tder.readSequence();\n\n\t// modulus\n\tvar n = readMPInt(der, 'modulus');\n\tvar e = readMPInt(der, 'exponent');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'rsa',\n\t\tsource: der.originalInput,\n\t\tparts: [\n\t\t\t{ name: 'e', data: e },\n\t\t\t{ name: 'n', data: n }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs8RSAPrivate(der) {\n\tder.readSequence(asn1.Ber.OctetString);\n\tder.readSequence();\n\n\tvar ver = readMPInt(der, 'version');\n\tassert.equal(ver[0], 0x0, 'unknown RSA private key version');\n\n\t// modulus then public exponent\n\tvar n = readMPInt(der, 'modulus');\n\tvar e = readMPInt(der, 'public exponent');\n\tvar d = readMPInt(der, 'private exponent');\n\tvar p = readMPInt(der, 'prime1');\n\tvar q = readMPInt(der, 'prime2');\n\tvar dmodp = readMPInt(der, 'exponent1');\n\tvar dmodq = readMPInt(der, 'exponent2');\n\tvar iqmp = readMPInt(der, 'iqmp');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'rsa',\n\t\tparts: [\n\t\t\t{ name: 'n', data: n },\n\t\t\t{ name: 'e', data: e },\n\t\t\t{ name: 'd', data: d },\n\t\t\t{ name: 'iqmp', data: iqmp },\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'dmodp', data: dmodp },\n\t\t\t{ name: 'dmodq', data: dmodq }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs8DSAPublic(der) {\n\tder.readSequence();\n\n\tvar p = readMPInt(der, 'p');\n\tvar q = readMPInt(der, 'q');\n\tvar g = readMPInt(der, 'g');\n\n\t// bit string sequence\n\tder.readSequence(asn1.Ber.BitString);\n\tder.readByte();\n\n\tvar y = readMPInt(der, 'y');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'dsa',\n\t\tparts: [\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'g', data: g },\n\t\t\t{ name: 'y', data: y }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs8DSAPrivate(der) {\n\tder.readSequence();\n\n\tvar p = readMPInt(der, 'p');\n\tvar q = readMPInt(der, 'q');\n\tvar g = readMPInt(der, 'g');\n\n\tder.readSequence(asn1.Ber.OctetString);\n\tvar x = readMPInt(der, 'x');\n\n\t/* The pkcs#8 format does not include the public key */\n\tvar y = utils.calculateDSAPublic(g, p, x);\n\n\tvar key = {\n\t\ttype: 'dsa',\n\t\tparts: [\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'g', data: g },\n\t\t\t{ name: 'y', data: y },\n\t\t\t{ name: 'x', data: x }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readECDSACurve(der) {\n\tvar curveName, curveNames;\n\tvar j, c, cd;\n\n\tif (der.peek() === asn1.Ber.OID) {\n\t\tvar oid = der.readOID();\n\n\t\tcurveNames = Object.keys(algs.curves);\n\t\tfor (j = 0; j < curveNames.length; ++j) {\n\t\t\tc = curveNames[j];\n\t\t\tcd = algs.curves[c];\n\t\t\tif (cd.pkcs8oid === oid) {\n\t\t\t\tcurveName = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t// ECParameters sequence\n\t\tder.readSequence();\n\t\tvar version = der.readString(asn1.Ber.Integer, true);\n\t\tassert.strictEqual(version[0], 1, 'ECDSA key not version 1');\n\n\t\tvar curve = {};\n\n\t\t// FieldID sequence\n\t\tder.readSequence();\n\t\tvar fieldTypeOid = der.readOID();\n\t\tassert.strictEqual(fieldTypeOid, '1.2.840.10045.1.1',\n\t\t    'ECDSA key is not from a prime-field');\n\t\tvar p = curve.p = utils.mpNormalize(\n\t\t    der.readString(asn1.Ber.Integer, true));\n\t\t/*\n\t\t * p always starts with a 1 bit, so count the zeros to get its\n\t\t * real size.\n\t\t */\n\t\tcurve.size = p.length * 8 - utils.countZeros(p);\n\n\t\t// Curve sequence\n\t\tder.readSequence();\n\t\tcurve.a = utils.mpNormalize(\n\t\t    der.readString(asn1.Ber.OctetString, true));\n\t\tcurve.b = utils.mpNormalize(\n\t\t    der.readString(asn1.Ber.OctetString, true));\n\t\tif (der.peek() === asn1.Ber.BitString)\n\t\t\tcurve.s = der.readString(asn1.Ber.BitString, true);\n\n\t\t// Combined Gx and Gy\n\t\tcurve.G = der.readString(asn1.Ber.OctetString, true);\n\t\tassert.strictEqual(curve.G[0], 0x4,\n\t\t    'uncompressed G is required');\n\n\t\tcurve.n = utils.mpNormalize(\n\t\t    der.readString(asn1.Ber.Integer, true));\n\t\tcurve.h = utils.mpNormalize(\n\t\t    der.readString(asn1.Ber.Integer, true));\n\t\tassert.strictEqual(curve.h[0], 0x1, 'a cofactor=1 curve is ' +\n\t\t    'required');\n\n\t\tcurveNames = Object.keys(algs.curves);\n\t\tvar ks = Object.keys(curve);\n\t\tfor (j = 0; j < curveNames.length; ++j) {\n\t\t\tc = curveNames[j];\n\t\t\tcd = algs.curves[c];\n\t\t\tvar equal = true;\n\t\t\tfor (var i = 0; i < ks.length; ++i) {\n\t\t\t\tvar k = ks[i];\n\t\t\t\tif (cd[k] === undefined)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (typeof (cd[k]) === 'object' &&\n\t\t\t\t    cd[k].equals !== undefined) {\n\t\t\t\t\tif (!cd[k].equals(curve[k])) {\n\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (Buffer.isBuffer(cd[k])) {\n\t\t\t\t\tif (cd[k].toString('binary')\n\t\t\t\t\t    !== curve[k].toString('binary')) {\n\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (cd[k] !== curve[k]) {\n\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (equal) {\n\t\t\t\tcurveName = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn (curveName);\n}\n\nfunction readPkcs8ECDSAPrivate(der) {\n\tvar curveName = readECDSACurve(der);\n\tassert.string(curveName, 'a known elliptic curve');\n\n\tder.readSequence(asn1.Ber.OctetString);\n\tder.readSequence();\n\n\tvar version = readMPInt(der, 'version');\n\tassert.equal(version[0], 1, 'unknown version of ECDSA key');\n\n\tvar d = der.readString(asn1.Ber.OctetString, true);\n\tvar Q;\n\n\tif (der.peek() == 0xa0) {\n\t\tder.readSequence(0xa0);\n\t\tder._offset += der.length;\n\t}\n\tif (der.peek() == 0xa1) {\n\t\tder.readSequence(0xa1);\n\t\tQ = der.readString(asn1.Ber.BitString, true);\n\t\tQ = utils.ecNormalize(Q);\n\t}\n\n\tif (Q === undefined) {\n\t\tvar pub = utils.publicFromPrivateECDSA(curveName, d);\n\t\tQ = pub.part.Q.data;\n\t}\n\n\tvar key = {\n\t\ttype: 'ecdsa',\n\t\tparts: [\n\t\t\t{ name: 'curve', data: Buffer.from(curveName) },\n\t\t\t{ name: 'Q', data: Q },\n\t\t\t{ name: 'd', data: d }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs8ECDSAPublic(der) {\n\tvar curveName = readECDSACurve(der);\n\tassert.string(curveName, 'a known elliptic curve');\n\n\tvar Q = der.readString(asn1.Ber.BitString, true);\n\tQ = utils.ecNormalize(Q);\n\n\tvar key = {\n\t\ttype: 'ecdsa',\n\t\tparts: [\n\t\t\t{ name: 'curve', data: Buffer.from(curveName) },\n\t\t\t{ name: 'Q', data: Q }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs8EdDSAPublic(der) {\n\tif (der.peek() === 0x00)\n\t\tder.readByte();\n\n\tvar A = utils.readBitString(der);\n\n\tvar key = {\n\t\ttype: 'ed25519',\n\t\tparts: [\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs8X25519Public(der) {\n\tvar A = utils.readBitString(der);\n\n\tvar key = {\n\t\ttype: 'curve25519',\n\t\tparts: [\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs8EdDSAPrivate(der) {\n\tif (der.peek() === 0x00)\n\t\tder.readByte();\n\n\tder.readSequence(asn1.Ber.OctetString);\n\tvar k = der.readString(asn1.Ber.OctetString, true);\n\tk = utils.zeroPadToLength(k, 32);\n\n\tvar A, tag;\n\twhile ((tag = der.peek()) !== null) {\n\t\tif (tag === (asn1.Ber.Context | 1)) {\n\t\t\tA = utils.readBitString(der, tag);\n\t\t} else {\n\t\t\tder.readSequence(tag);\n\t\t\tder._offset += der.length;\n\t\t}\n\t}\n\tif (A === undefined)\n\t\tA = utils.calculateED25519Public(k);\n\n\tvar key = {\n\t\ttype: 'ed25519',\n\t\tparts: [\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\n\t\t\t{ name: 'k', data: utils.zeroPadToLength(k, 32) }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs8X25519Private(der) {\n\tif (der.peek() === 0x00)\n\t\tder.readByte();\n\n\tder.readSequence(asn1.Ber.OctetString);\n\tvar k = der.readString(asn1.Ber.OctetString, true);\n\tk = utils.zeroPadToLength(k, 32);\n\n\tvar A = utils.calculateX25519Public(k);\n\n\tvar key = {\n\t\ttype: 'curve25519',\n\t\tparts: [\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\n\t\t\t{ name: 'k', data: utils.zeroPadToLength(k, 32) }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction pkcs8ToBuffer(key) {\n\tvar der = new asn1.BerWriter();\n\twritePkcs8(der, key);\n\treturn (der.buffer);\n}\n\nfunction writePkcs8(der, key) {\n\tder.startSequence();\n\n\tif (PrivateKey.isPrivateKey(key)) {\n\t\tvar version = 0;\n\t\tif (key.type === 'ed25519')\n\t\t\tversion = 1;\n\t\tvar vbuf = Buffer.from([version]);\n\t\tder.writeBuffer(vbuf, asn1.Ber.Integer);\n\t}\n\n\tder.startSequence();\n\tswitch (key.type) {\n\tcase 'rsa':\n\t\tder.writeOID('1.2.840.113549.1.1.1');\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs8RSAPrivate(key, der);\n\t\telse\n\t\t\twritePkcs8RSAPublic(key, der);\n\t\tbreak;\n\tcase 'dsa':\n\t\tder.writeOID('1.2.840.10040.4.1');\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs8DSAPrivate(key, der);\n\t\telse\n\t\t\twritePkcs8DSAPublic(key, der);\n\t\tbreak;\n\tcase 'ecdsa':\n\t\tder.writeOID('1.2.840.10045.2.1');\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs8ECDSAPrivate(key, der);\n\t\telse\n\t\t\twritePkcs8ECDSAPublic(key, der);\n\t\tbreak;\n\tcase 'ed25519':\n\t\tder.writeOID('1.3.101.112');\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs8EdDSAPrivate(key, der);\n\t\telse\n\t\t\twritePkcs8EdDSAPublic(key, der);\n\t\tbreak;\n\tdefault:\n\t\tthrow (new Error('Unsupported key type: ' + key.type));\n\t}\n\n\tder.endSequence();\n}\n\nfunction writePkcs8RSAPrivate(key, der) {\n\tder.writeNull();\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.OctetString);\n\tder.startSequence();\n\n\tvar version = Buffer.from([0]);\n\tder.writeBuffer(version, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.d.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tif (!key.part.dmodp || !key.part.dmodq)\n\t\tutils.addRSAMissing(key);\n\tder.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);\n\n\tder.endSequence();\n\tder.endSequence();\n}\n\nfunction writePkcs8RSAPublic(key, der) {\n\tder.writeNull();\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.BitString);\n\tder.writeByte(0x00);\n\n\tder.startSequence();\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n\tder.endSequence();\n\n\tder.endSequence();\n}\n\nfunction writePkcs8DSAPrivate(key, der) {\n\tder.startSequence();\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n\tder.endSequence();\n\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.OctetString);\n\tder.writeBuffer(key.part.x.data, asn1.Ber.Integer);\n\tder.endSequence();\n}\n\nfunction writePkcs8DSAPublic(key, der) {\n\tder.startSequence();\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n\tder.endSequence();\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.BitString);\n\tder.writeByte(0x00);\n\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n\tder.endSequence();\n}\n\nfunction writeECDSACurve(key, der) {\n\tvar curve = algs.curves[key.curve];\n\tif (curve.pkcs8oid) {\n\t\t/* This one has a name in pkcs#8, so just write the oid */\n\t\tder.writeOID(curve.pkcs8oid);\n\n\t} else {\n\t\t// ECParameters sequence\n\t\tder.startSequence();\n\n\t\tvar version = Buffer.from([1]);\n\t\tder.writeBuffer(version, asn1.Ber.Integer);\n\n\t\t// FieldID sequence\n\t\tder.startSequence();\n\t\tder.writeOID('1.2.840.10045.1.1'); // prime-field\n\t\tder.writeBuffer(curve.p, asn1.Ber.Integer);\n\t\tder.endSequence();\n\n\t\t// Curve sequence\n\t\tder.startSequence();\n\t\tvar a = curve.p;\n\t\tif (a[0] === 0x0)\n\t\t\ta = a.slice(1);\n\t\tder.writeBuffer(a, asn1.Ber.OctetString);\n\t\tder.writeBuffer(curve.b, asn1.Ber.OctetString);\n\t\tder.writeBuffer(curve.s, asn1.Ber.BitString);\n\t\tder.endSequence();\n\n\t\tder.writeBuffer(curve.G, asn1.Ber.OctetString);\n\t\tder.writeBuffer(curve.n, asn1.Ber.Integer);\n\t\tvar h = curve.h;\n\t\tif (!h) {\n\t\t\th = Buffer.from([1]);\n\t\t}\n\t\tder.writeBuffer(h, asn1.Ber.Integer);\n\n\t\t// ECParameters\n\t\tder.endSequence();\n\t}\n}\n\nfunction writePkcs8ECDSAPublic(key, der) {\n\twriteECDSACurve(key, der);\n\tder.endSequence();\n\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\tder.writeBuffer(Q, asn1.Ber.BitString);\n}\n\nfunction writePkcs8ECDSAPrivate(key, der) {\n\twriteECDSACurve(key, der);\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.OctetString);\n\tder.startSequence();\n\n\tvar version = Buffer.from([1]);\n\tder.writeBuffer(version, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.d.data, asn1.Ber.OctetString);\n\n\tder.startSequence(0xa1);\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\tder.writeBuffer(Q, asn1.Ber.BitString);\n\tder.endSequence();\n\n\tder.endSequence();\n\tder.endSequence();\n}\n\nfunction writePkcs8EdDSAPublic(key, der) {\n\tder.endSequence();\n\n\tutils.writeBitString(der, key.part.A.data);\n}\n\nfunction writePkcs8EdDSAPrivate(key, der) {\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.OctetString);\n\tvar k = utils.mpNormalize(key.part.k.data);\n\t/* RFCs call for storing exactly 32 bytes, so strip any leading zeros */\n\twhile (k.length > 32 && k[0] === 0x00)\n\t\tk = k.slice(1);\n\tder.writeBuffer(k, asn1.Ber.OctetString);\n\tder.endSequence();\n\n\tutils.writeBitString(der, key.part.A.data, asn1.Ber.Context | 1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9wa2NzOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywwRUFBYTtBQUNsQyxXQUFXLG1CQUFPLENBQUMsK0RBQU07QUFDekIsYUFBYSx5R0FBOEI7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLGtFQUFTO0FBQzVCLFlBQVksbUJBQU8sQ0FBQyxvRUFBVTtBQUM5QixVQUFVLG1CQUFPLENBQUMsZ0VBQVE7QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQWdCO0FBQ3pDLFVBQVUsbUJBQU8sQ0FBQyx1RUFBTzs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0JBQW9CO0FBQ3pCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0I7QUFDekIsS0FBSyxvQkFBb0I7QUFDekIsS0FBSyxvQkFBb0I7QUFDekIsS0FBSywwQkFBMEI7QUFDL0IsS0FBSyxvQkFBb0I7QUFDekIsS0FBSyxvQkFBb0I7QUFDekIsS0FBSyw0QkFBNEI7QUFDakMsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQjtBQUN6QixLQUFLLG9CQUFvQjtBQUN6QixLQUFLLG9CQUFvQjtBQUN6QixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQjtBQUN6QixLQUFLLG9CQUFvQjtBQUN6QixLQUFLLG9CQUFvQjtBQUN6QixLQUFLLG9CQUFvQjtBQUN6QixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNkNBQTZDO0FBQ2xELEtBQUssb0JBQW9CO0FBQ3pCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyw2Q0FBNkM7QUFDbEQsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQ0FBK0M7QUFDcEQsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUssK0NBQStDO0FBQ3BELEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9wa2NzOC5qcz9kNTliIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE4IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmVhZDogcmVhZCxcblx0cmVhZFBrY3M4OiByZWFkUGtjczgsXG5cdHdyaXRlOiB3cml0ZSxcblx0d3JpdGVQa2NzODogd3JpdGVQa2NzOCxcblx0cGtjczhUb0J1ZmZlcjogcGtjczhUb0J1ZmZlcixcblxuXHRyZWFkRUNEU0FDdXJ2ZTogcmVhZEVDRFNBQ3VydmUsXG5cdHdyaXRlRUNEU0FDdXJ2ZTogd3JpdGVFQ0RTQUN1cnZlXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMScpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBhbGdzID0gcmVxdWlyZSgnLi4vYWxncycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBLZXkgPSByZXF1aXJlKCcuLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZS1rZXknKTtcbnZhciBwZW0gPSByZXF1aXJlKCcuL3BlbScpO1xuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb3B0aW9ucykge1xuXHRyZXR1cm4gKHBlbS5yZWFkKGJ1Ziwgb3B0aW9ucywgJ3BrY3M4JykpO1xufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIG9wdGlvbnMpIHtcblx0cmV0dXJuIChwZW0ud3JpdGUoa2V5LCBvcHRpb25zLCAncGtjczgnKSk7XG59XG5cbi8qIEhlbHBlciB0byByZWFkIGluIGEgc2luZ2xlIG1waW50ICovXG5mdW5jdGlvbiByZWFkTVBJbnQoZGVyLCBubSkge1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwoZGVyLnBlZWsoKSwgYXNuMS5CZXIuSW50ZWdlcixcblx0ICAgIG5tICsgJyBpcyBub3QgYW4gSW50ZWdlcicpO1xuXHRyZXR1cm4gKHV0aWxzLm1wTm9ybWFsaXplKGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkludGVnZXIsIHRydWUpKSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzOChhbGcsIHR5cGUsIGRlcikge1xuXHQvKiBQcml2YXRlIGtleXMgaW4gcGtjcyM4IGZvcm1hdCBoYXZlIGEgd2VpcmQgZXh0cmEgaW50ICovXG5cdGlmIChkZXIucGVlaygpID09PSBhc24xLkJlci5JbnRlZ2VyKSB7XG5cdFx0YXNzZXJ0LnN0cmljdEVxdWFsKHR5cGUsICdwcml2YXRlJyxcblx0XHQgICAgJ3VuZXhwZWN0ZWQgSW50ZWdlciBhdCBzdGFydCBvZiBwdWJsaWMga2V5Jyk7XG5cdFx0ZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuSW50ZWdlciwgdHJ1ZSk7XG5cdH1cblxuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdHZhciBuZXh0ID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cblx0dmFyIG9pZCA9IGRlci5yZWFkT0lEKCk7XG5cdHN3aXRjaCAob2lkKSB7XG5cdGNhc2UgJzEuMi44NDAuMTEzNTQ5LjEuMS4xJzpcblx0XHRkZXIuX29mZnNldCA9IG5leHQ7XG5cdFx0aWYgKHR5cGUgPT09ICdwdWJsaWMnKVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhSU0FQdWJsaWMoZGVyKSk7XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhSU0FQcml2YXRlKGRlcikpO1xuXHRjYXNlICcxLjIuODQwLjEwMDQwLjQuMSc6XG5cdFx0aWYgKHR5cGUgPT09ICdwdWJsaWMnKVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhEU0FQdWJsaWMoZGVyKSk7XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhEU0FQcml2YXRlKGRlcikpO1xuXHRjYXNlICcxLjIuODQwLjEwMDQ1LjIuMSc6XG5cdFx0aWYgKHR5cGUgPT09ICdwdWJsaWMnKVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhFQ0RTQVB1YmxpYyhkZXIpKTtcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gKHJlYWRQa2NzOEVDRFNBUHJpdmF0ZShkZXIpKTtcblx0Y2FzZSAnMS4zLjEwMS4xMTInOlxuXHRcdGlmICh0eXBlID09PSAncHVibGljJykge1xuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhFZERTQVB1YmxpYyhkZXIpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhFZERTQVByaXZhdGUoZGVyKSk7XG5cdFx0fVxuXHRjYXNlICcxLjMuMTAxLjExMCc6XG5cdFx0aWYgKHR5cGUgPT09ICdwdWJsaWMnKSB7XG5cdFx0XHRyZXR1cm4gKHJlYWRQa2NzOFgyNTUxOVB1YmxpYyhkZXIpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhYMjU1MTlQcml2YXRlKGRlcikpO1xuXHRcdH1cblx0ZGVmYXVsdDpcblx0XHR0aHJvdyAobmV3IEVycm9yKCdVbmtub3duIGtleSB0eXBlIE9JRCAnICsgb2lkKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVhZFBrY3M4UlNBUHVibGljKGRlcikge1xuXHQvLyBiaXQgc3RyaW5nIHNlcXVlbmNlXG5cdGRlci5yZWFkU2VxdWVuY2UoYXNuMS5CZXIuQml0U3RyaW5nKTtcblx0ZGVyLnJlYWRCeXRlKCk7XG5cdGRlci5yZWFkU2VxdWVuY2UoKTtcblxuXHQvLyBtb2R1bHVzXG5cdHZhciBuID0gcmVhZE1QSW50KGRlciwgJ21vZHVsdXMnKTtcblx0dmFyIGUgPSByZWFkTVBJbnQoZGVyLCAnZXhwb25lbnQnKTtcblxuXHQvLyBub3csIG1ha2UgdGhlIGtleVxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdyc2EnLFxuXHRcdHNvdXJjZTogZGVyLm9yaWdpbmFsSW5wdXQsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ2UnLCBkYXRhOiBlIH0sXG5cdFx0XHR7IG5hbWU6ICduJywgZGF0YTogbiB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IEtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3M4UlNBUHJpdmF0ZShkZXIpIHtcblx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdGRlci5yZWFkU2VxdWVuY2UoKTtcblxuXHR2YXIgdmVyID0gcmVhZE1QSW50KGRlciwgJ3ZlcnNpb24nKTtcblx0YXNzZXJ0LmVxdWFsKHZlclswXSwgMHgwLCAndW5rbm93biBSU0EgcHJpdmF0ZSBrZXkgdmVyc2lvbicpO1xuXG5cdC8vIG1vZHVsdXMgdGhlbiBwdWJsaWMgZXhwb25lbnRcblx0dmFyIG4gPSByZWFkTVBJbnQoZGVyLCAnbW9kdWx1cycpO1xuXHR2YXIgZSA9IHJlYWRNUEludChkZXIsICdwdWJsaWMgZXhwb25lbnQnKTtcblx0dmFyIGQgPSByZWFkTVBJbnQoZGVyLCAncHJpdmF0ZSBleHBvbmVudCcpO1xuXHR2YXIgcCA9IHJlYWRNUEludChkZXIsICdwcmltZTEnKTtcblx0dmFyIHEgPSByZWFkTVBJbnQoZGVyLCAncHJpbWUyJyk7XG5cdHZhciBkbW9kcCA9IHJlYWRNUEludChkZXIsICdleHBvbmVudDEnKTtcblx0dmFyIGRtb2RxID0gcmVhZE1QSW50KGRlciwgJ2V4cG9uZW50MicpO1xuXHR2YXIgaXFtcCA9IHJlYWRNUEludChkZXIsICdpcW1wJyk7XG5cblx0Ly8gbm93LCBtYWtlIHRoZSBrZXlcblx0dmFyIGtleSA9IHtcblx0XHR0eXBlOiAncnNhJyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnbicsIGRhdGE6IG4gfSxcblx0XHRcdHsgbmFtZTogJ2UnLCBkYXRhOiBlIH0sXG5cdFx0XHR7IG5hbWU6ICdkJywgZGF0YTogZCB9LFxuXHRcdFx0eyBuYW1lOiAnaXFtcCcsIGRhdGE6IGlxbXAgfSxcblx0XHRcdHsgbmFtZTogJ3AnLCBkYXRhOiBwIH0sXG5cdFx0XHR7IG5hbWU6ICdxJywgZGF0YTogcSB9LFxuXHRcdFx0eyBuYW1lOiAnZG1vZHAnLCBkYXRhOiBkbW9kcCB9LFxuXHRcdFx0eyBuYW1lOiAnZG1vZHEnLCBkYXRhOiBkbW9kcSB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IFByaXZhdGVLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzOERTQVB1YmxpYyhkZXIpIHtcblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXG5cdHZhciBwID0gcmVhZE1QSW50KGRlciwgJ3AnKTtcblx0dmFyIHEgPSByZWFkTVBJbnQoZGVyLCAncScpO1xuXHR2YXIgZyA9IHJlYWRNUEludChkZXIsICdnJyk7XG5cblx0Ly8gYml0IHN0cmluZyBzZXF1ZW5jZVxuXHRkZXIucmVhZFNlcXVlbmNlKGFzbjEuQmVyLkJpdFN0cmluZyk7XG5cdGRlci5yZWFkQnl0ZSgpO1xuXG5cdHZhciB5ID0gcmVhZE1QSW50KGRlciwgJ3knKTtcblxuXHQvLyBub3csIG1ha2UgdGhlIGtleVxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdkc2EnLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICdwJywgZGF0YTogcCB9LFxuXHRcdFx0eyBuYW1lOiAncScsIGRhdGE6IHEgfSxcblx0XHRcdHsgbmFtZTogJ2cnLCBkYXRhOiBnIH0sXG5cdFx0XHR7IG5hbWU6ICd5JywgZGF0YTogeSB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IEtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3M4RFNBUHJpdmF0ZShkZXIpIHtcblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXG5cdHZhciBwID0gcmVhZE1QSW50KGRlciwgJ3AnKTtcblx0dmFyIHEgPSByZWFkTVBJbnQoZGVyLCAncScpO1xuXHR2YXIgZyA9IHJlYWRNUEludChkZXIsICdnJyk7XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdHZhciB4ID0gcmVhZE1QSW50KGRlciwgJ3gnKTtcblxuXHQvKiBUaGUgcGtjcyM4IGZvcm1hdCBkb2VzIG5vdCBpbmNsdWRlIHRoZSBwdWJsaWMga2V5ICovXG5cdHZhciB5ID0gdXRpbHMuY2FsY3VsYXRlRFNBUHVibGljKGcsIHAsIHgpO1xuXG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ2RzYScsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ3AnLCBkYXRhOiBwIH0sXG5cdFx0XHR7IG5hbWU6ICdxJywgZGF0YTogcSB9LFxuXHRcdFx0eyBuYW1lOiAnZycsIGRhdGE6IGcgfSxcblx0XHRcdHsgbmFtZTogJ3knLCBkYXRhOiB5IH0sXG5cdFx0XHR7IG5hbWU6ICd4JywgZGF0YTogeCB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IFByaXZhdGVLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRFQ0RTQUN1cnZlKGRlcikge1xuXHR2YXIgY3VydmVOYW1lLCBjdXJ2ZU5hbWVzO1xuXHR2YXIgaiwgYywgY2Q7XG5cblx0aWYgKGRlci5wZWVrKCkgPT09IGFzbjEuQmVyLk9JRCkge1xuXHRcdHZhciBvaWQgPSBkZXIucmVhZE9JRCgpO1xuXG5cdFx0Y3VydmVOYW1lcyA9IE9iamVjdC5rZXlzKGFsZ3MuY3VydmVzKTtcblx0XHRmb3IgKGogPSAwOyBqIDwgY3VydmVOYW1lcy5sZW5ndGg7ICsraikge1xuXHRcdFx0YyA9IGN1cnZlTmFtZXNbal07XG5cdFx0XHRjZCA9IGFsZ3MuY3VydmVzW2NdO1xuXHRcdFx0aWYgKGNkLnBrY3M4b2lkID09PSBvaWQpIHtcblx0XHRcdFx0Y3VydmVOYW1lID0gYztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gRUNQYXJhbWV0ZXJzIHNlcXVlbmNlXG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRcdHZhciB2ZXJzaW9uID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuSW50ZWdlciwgdHJ1ZSk7XG5cdFx0YXNzZXJ0LnN0cmljdEVxdWFsKHZlcnNpb25bMF0sIDEsICdFQ0RTQSBrZXkgbm90IHZlcnNpb24gMScpO1xuXG5cdFx0dmFyIGN1cnZlID0ge307XG5cblx0XHQvLyBGaWVsZElEIHNlcXVlbmNlXG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRcdHZhciBmaWVsZFR5cGVPaWQgPSBkZXIucmVhZE9JRCgpO1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChmaWVsZFR5cGVPaWQsICcxLjIuODQwLjEwMDQ1LjEuMScsXG5cdFx0ICAgICdFQ0RTQSBrZXkgaXMgbm90IGZyb20gYSBwcmltZS1maWVsZCcpO1xuXHRcdHZhciBwID0gY3VydmUucCA9IHV0aWxzLm1wTm9ybWFsaXplKFxuXHRcdCAgICBkZXIucmVhZFN0cmluZyhhc24xLkJlci5JbnRlZ2VyLCB0cnVlKSk7XG5cdFx0Lypcblx0XHQgKiBwIGFsd2F5cyBzdGFydHMgd2l0aCBhIDEgYml0LCBzbyBjb3VudCB0aGUgemVyb3MgdG8gZ2V0IGl0c1xuXHRcdCAqIHJlYWwgc2l6ZS5cblx0XHQgKi9cblx0XHRjdXJ2ZS5zaXplID0gcC5sZW5ndGggKiA4IC0gdXRpbHMuY291bnRaZXJvcyhwKTtcblxuXHRcdC8vIEN1cnZlIHNlcXVlbmNlXG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRcdGN1cnZlLmEgPSB1dGlscy5tcE5vcm1hbGl6ZShcblx0XHQgICAgZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuT2N0ZXRTdHJpbmcsIHRydWUpKTtcblx0XHRjdXJ2ZS5iID0gdXRpbHMubXBOb3JtYWxpemUoXG5cdFx0ICAgIGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLk9jdGV0U3RyaW5nLCB0cnVlKSk7XG5cdFx0aWYgKGRlci5wZWVrKCkgPT09IGFzbjEuQmVyLkJpdFN0cmluZylcblx0XHRcdGN1cnZlLnMgPSBkZXIucmVhZFN0cmluZyhhc24xLkJlci5CaXRTdHJpbmcsIHRydWUpO1xuXG5cdFx0Ly8gQ29tYmluZWQgR3ggYW5kIEd5XG5cdFx0Y3VydmUuRyA9IGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLk9jdGV0U3RyaW5nLCB0cnVlKTtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwoY3VydmUuR1swXSwgMHg0LFxuXHRcdCAgICAndW5jb21wcmVzc2VkIEcgaXMgcmVxdWlyZWQnKTtcblxuXHRcdGN1cnZlLm4gPSB1dGlscy5tcE5vcm1hbGl6ZShcblx0XHQgICAgZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuSW50ZWdlciwgdHJ1ZSkpO1xuXHRcdGN1cnZlLmggPSB1dGlscy5tcE5vcm1hbGl6ZShcblx0XHQgICAgZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuSW50ZWdlciwgdHJ1ZSkpO1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChjdXJ2ZS5oWzBdLCAweDEsICdhIGNvZmFjdG9yPTEgY3VydmUgaXMgJyArXG5cdFx0ICAgICdyZXF1aXJlZCcpO1xuXG5cdFx0Y3VydmVOYW1lcyA9IE9iamVjdC5rZXlzKGFsZ3MuY3VydmVzKTtcblx0XHR2YXIga3MgPSBPYmplY3Qua2V5cyhjdXJ2ZSk7XG5cdFx0Zm9yIChqID0gMDsgaiA8IGN1cnZlTmFtZXMubGVuZ3RoOyArK2opIHtcblx0XHRcdGMgPSBjdXJ2ZU5hbWVzW2pdO1xuXHRcdFx0Y2QgPSBhbGdzLmN1cnZlc1tjXTtcblx0XHRcdHZhciBlcXVhbCA9IHRydWU7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHZhciBrID0ga3NbaV07XG5cdFx0XHRcdGlmIChjZFtrXSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRpZiAodHlwZW9mIChjZFtrXSkgPT09ICdvYmplY3QnICYmXG5cdFx0XHRcdCAgICBjZFtrXS5lcXVhbHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGlmICghY2Rba10uZXF1YWxzKGN1cnZlW2tdKSkge1xuXHRcdFx0XHRcdFx0ZXF1YWwgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoY2Rba10pKSB7XG5cdFx0XHRcdFx0aWYgKGNkW2tdLnRvU3RyaW5nKCdiaW5hcnknKVxuXHRcdFx0XHRcdCAgICAhPT0gY3VydmVba10udG9TdHJpbmcoJ2JpbmFyeScpKSB7XG5cdFx0XHRcdFx0XHRlcXVhbCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChjZFtrXSAhPT0gY3VydmVba10pIHtcblx0XHRcdFx0XHRcdGVxdWFsID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChlcXVhbCkge1xuXHRcdFx0XHRjdXJ2ZU5hbWUgPSBjO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIChjdXJ2ZU5hbWUpO1xufVxuXG5mdW5jdGlvbiByZWFkUGtjczhFQ0RTQVByaXZhdGUoZGVyKSB7XG5cdHZhciBjdXJ2ZU5hbWUgPSByZWFkRUNEU0FDdXJ2ZShkZXIpO1xuXHRhc3NlcnQuc3RyaW5nKGN1cnZlTmFtZSwgJ2Ega25vd24gZWxsaXB0aWMgY3VydmUnKTtcblxuXHRkZXIucmVhZFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXG5cdHZhciB2ZXJzaW9uID0gcmVhZE1QSW50KGRlciwgJ3ZlcnNpb24nKTtcblx0YXNzZXJ0LmVxdWFsKHZlcnNpb25bMF0sIDEsICd1bmtub3duIHZlcnNpb24gb2YgRUNEU0Ega2V5Jyk7XG5cblx0dmFyIGQgPSBkZXIucmVhZFN0cmluZyhhc24xLkJlci5PY3RldFN0cmluZywgdHJ1ZSk7XG5cdHZhciBRO1xuXG5cdGlmIChkZXIucGVlaygpID09IDB4YTApIHtcblx0XHRkZXIucmVhZFNlcXVlbmNlKDB4YTApO1xuXHRcdGRlci5fb2Zmc2V0ICs9IGRlci5sZW5ndGg7XG5cdH1cblx0aWYgKGRlci5wZWVrKCkgPT0gMHhhMSkge1xuXHRcdGRlci5yZWFkU2VxdWVuY2UoMHhhMSk7XG5cdFx0USA9IGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkJpdFN0cmluZywgdHJ1ZSk7XG5cdFx0USA9IHV0aWxzLmVjTm9ybWFsaXplKFEpO1xuXHR9XG5cblx0aWYgKFEgPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBwdWIgPSB1dGlscy5wdWJsaWNGcm9tUHJpdmF0ZUVDRFNBKGN1cnZlTmFtZSwgZCk7XG5cdFx0USA9IHB1Yi5wYXJ0LlEuZGF0YTtcblx0fVxuXG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ2VjZHNhJyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnY3VydmUnLCBkYXRhOiBCdWZmZXIuZnJvbShjdXJ2ZU5hbWUpIH0sXG5cdFx0XHR7IG5hbWU6ICdRJywgZGF0YTogUSB9LFxuXHRcdFx0eyBuYW1lOiAnZCcsIGRhdGE6IGQgfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBQcml2YXRlS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiByZWFkUGtjczhFQ0RTQVB1YmxpYyhkZXIpIHtcblx0dmFyIGN1cnZlTmFtZSA9IHJlYWRFQ0RTQUN1cnZlKGRlcik7XG5cdGFzc2VydC5zdHJpbmcoY3VydmVOYW1lLCAnYSBrbm93biBlbGxpcHRpYyBjdXJ2ZScpO1xuXG5cdHZhciBRID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuQml0U3RyaW5nLCB0cnVlKTtcblx0USA9IHV0aWxzLmVjTm9ybWFsaXplKFEpO1xuXG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ2VjZHNhJyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnY3VydmUnLCBkYXRhOiBCdWZmZXIuZnJvbShjdXJ2ZU5hbWUpIH0sXG5cdFx0XHR7IG5hbWU6ICdRJywgZGF0YTogUSB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IEtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3M4RWREU0FQdWJsaWMoZGVyKSB7XG5cdGlmIChkZXIucGVlaygpID09PSAweDAwKVxuXHRcdGRlci5yZWFkQnl0ZSgpO1xuXG5cdHZhciBBID0gdXRpbHMucmVhZEJpdFN0cmluZyhkZXIpO1xuXG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ2VkMjU1MTknLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICdBJywgZGF0YTogdXRpbHMuemVyb1BhZFRvTGVuZ3RoKEEsIDMyKSB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IEtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3M4WDI1NTE5UHVibGljKGRlcikge1xuXHR2YXIgQSA9IHV0aWxzLnJlYWRCaXRTdHJpbmcoZGVyKTtcblxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdjdXJ2ZTI1NTE5Jyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnQScsIGRhdGE6IHV0aWxzLnplcm9QYWRUb0xlbmd0aChBLCAzMikgfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzOEVkRFNBUHJpdmF0ZShkZXIpIHtcblx0aWYgKGRlci5wZWVrKCkgPT09IDB4MDApXG5cdFx0ZGVyLnJlYWRCeXRlKCk7XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdHZhciBrID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuT2N0ZXRTdHJpbmcsIHRydWUpO1xuXHRrID0gdXRpbHMuemVyb1BhZFRvTGVuZ3RoKGssIDMyKTtcblxuXHR2YXIgQSwgdGFnO1xuXHR3aGlsZSAoKHRhZyA9IGRlci5wZWVrKCkpICE9PSBudWxsKSB7XG5cdFx0aWYgKHRhZyA9PT0gKGFzbjEuQmVyLkNvbnRleHQgfCAxKSkge1xuXHRcdFx0QSA9IHV0aWxzLnJlYWRCaXRTdHJpbmcoZGVyLCB0YWcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXIucmVhZFNlcXVlbmNlKHRhZyk7XG5cdFx0XHRkZXIuX29mZnNldCArPSBkZXIubGVuZ3RoO1xuXHRcdH1cblx0fVxuXHRpZiAoQSA9PT0gdW5kZWZpbmVkKVxuXHRcdEEgPSB1dGlscy5jYWxjdWxhdGVFRDI1NTE5UHVibGljKGspO1xuXG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ2VkMjU1MTknLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICdBJywgZGF0YTogdXRpbHMuemVyb1BhZFRvTGVuZ3RoKEEsIDMyKSB9LFxuXHRcdFx0eyBuYW1lOiAnaycsIGRhdGE6IHV0aWxzLnplcm9QYWRUb0xlbmd0aChrLCAzMikgfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBQcml2YXRlS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiByZWFkUGtjczhYMjU1MTlQcml2YXRlKGRlcikge1xuXHRpZiAoZGVyLnBlZWsoKSA9PT0gMHgwMClcblx0XHRkZXIucmVhZEJ5dGUoKTtcblxuXHRkZXIucmVhZFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0dmFyIGsgPSBkZXIucmVhZFN0cmluZyhhc24xLkJlci5PY3RldFN0cmluZywgdHJ1ZSk7XG5cdGsgPSB1dGlscy56ZXJvUGFkVG9MZW5ndGgoaywgMzIpO1xuXG5cdHZhciBBID0gdXRpbHMuY2FsY3VsYXRlWDI1NTE5UHVibGljKGspO1xuXG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ2N1cnZlMjU1MTknLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICdBJywgZGF0YTogdXRpbHMuemVyb1BhZFRvTGVuZ3RoKEEsIDMyKSB9LFxuXHRcdFx0eyBuYW1lOiAnaycsIGRhdGE6IHV0aWxzLnplcm9QYWRUb0xlbmd0aChrLCAzMikgfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBQcml2YXRlS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiBwa2NzOFRvQnVmZmVyKGtleSkge1xuXHR2YXIgZGVyID0gbmV3IGFzbjEuQmVyV3JpdGVyKCk7XG5cdHdyaXRlUGtjczgoZGVyLCBrZXkpO1xuXHRyZXR1cm4gKGRlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3M4KGRlciwga2V5KSB7XG5cdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cblx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpIHtcblx0XHR2YXIgdmVyc2lvbiA9IDA7XG5cdFx0aWYgKGtleS50eXBlID09PSAnZWQyNTUxOScpXG5cdFx0XHR2ZXJzaW9uID0gMTtcblx0XHR2YXIgdmJ1ZiA9IEJ1ZmZlci5mcm9tKFt2ZXJzaW9uXSk7XG5cdFx0ZGVyLndyaXRlQnVmZmVyKHZidWYsIGFzbjEuQmVyLkludGVnZXIpO1xuXHR9XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblx0c3dpdGNoIChrZXkudHlwZSkge1xuXHRjYXNlICdyc2EnOlxuXHRcdGRlci53cml0ZU9JRCgnMS4yLjg0MC4xMTM1NDkuMS4xLjEnKTtcblx0XHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSlcblx0XHRcdHdyaXRlUGtjczhSU0FQcml2YXRlKGtleSwgZGVyKTtcblx0XHRlbHNlXG5cdFx0XHR3cml0ZVBrY3M4UlNBUHVibGljKGtleSwgZGVyKTtcblx0XHRicmVhaztcblx0Y2FzZSAnZHNhJzpcblx0XHRkZXIud3JpdGVPSUQoJzEuMi44NDAuMTAwNDAuNC4xJyk7XG5cdFx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpXG5cdFx0XHR3cml0ZVBrY3M4RFNBUHJpdmF0ZShrZXksIGRlcik7XG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVQa2NzOERTQVB1YmxpYyhrZXksIGRlcik7XG5cdFx0YnJlYWs7XG5cdGNhc2UgJ2VjZHNhJzpcblx0XHRkZXIud3JpdGVPSUQoJzEuMi44NDAuMTAwNDUuMi4xJyk7XG5cdFx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpXG5cdFx0XHR3cml0ZVBrY3M4RUNEU0FQcml2YXRlKGtleSwgZGVyKTtcblx0XHRlbHNlXG5cdFx0XHR3cml0ZVBrY3M4RUNEU0FQdWJsaWMoa2V5LCBkZXIpO1xuXHRcdGJyZWFrO1xuXHRjYXNlICdlZDI1NTE5Jzpcblx0XHRkZXIud3JpdGVPSUQoJzEuMy4xMDEuMTEyJyk7XG5cdFx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpXG5cdFx0XHR3cml0ZVBrY3M4RWREU0FQcml2YXRlKGtleSwgZGVyKTtcblx0XHRlbHNlXG5cdFx0XHR3cml0ZVBrY3M4RWREU0FQdWJsaWMoa2V5LCBkZXIpO1xuXHRcdGJyZWFrO1xuXHRkZWZhdWx0OlxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtleSB0eXBlOiAnICsga2V5LnR5cGUpKTtcblx0fVxuXG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3M4UlNBUHJpdmF0ZShrZXksIGRlcikge1xuXHRkZXIud3JpdGVOdWxsKCk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdGRlci5zdGFydFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblxuXHR2YXIgdmVyc2lvbiA9IEJ1ZmZlci5mcm9tKFswXSk7XG5cdGRlci53cml0ZUJ1ZmZlcih2ZXJzaW9uLCBhc24xLkJlci5JbnRlZ2VyKTtcblxuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQubi5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmUuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5kLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQucC5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnEuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGlmICgha2V5LnBhcnQuZG1vZHAgfHwgIWtleS5wYXJ0LmRtb2RxKVxuXHRcdHV0aWxzLmFkZFJTQU1pc3Npbmcoa2V5KTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmRtb2RwLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZG1vZHEuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5pcW1wLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzOFJTQVB1YmxpYyhrZXksIGRlcikge1xuXHRkZXIud3JpdGVOdWxsKCk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdGRlci5zdGFydFNlcXVlbmNlKGFzbjEuQmVyLkJpdFN0cmluZyk7XG5cdGRlci53cml0ZUJ5dGUoMHgwMCk7XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0Lm4uZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5lLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRkZXIuZW5kU2VxdWVuY2UoKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzOERTQVByaXZhdGUoa2V5LCBkZXIpIHtcblx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnAuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5xLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZy5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQueC5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczhEU0FQdWJsaWMoa2V5LCBkZXIpIHtcblx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnAuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5xLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZy5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdGRlci5zdGFydFNlcXVlbmNlKGFzbjEuQmVyLkJpdFN0cmluZyk7XG5cdGRlci53cml0ZUJ5dGUoMHgwMCk7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC55LmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVFQ0RTQUN1cnZlKGtleSwgZGVyKSB7XG5cdHZhciBjdXJ2ZSA9IGFsZ3MuY3VydmVzW2tleS5jdXJ2ZV07XG5cdGlmIChjdXJ2ZS5wa2NzOG9pZCkge1xuXHRcdC8qIFRoaXMgb25lIGhhcyBhIG5hbWUgaW4gcGtjcyM4LCBzbyBqdXN0IHdyaXRlIHRoZSBvaWQgKi9cblx0XHRkZXIud3JpdGVPSUQoY3VydmUucGtjczhvaWQpO1xuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gRUNQYXJhbWV0ZXJzIHNlcXVlbmNlXG5cdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblxuXHRcdHZhciB2ZXJzaW9uID0gQnVmZmVyLmZyb20oWzFdKTtcblx0XHRkZXIud3JpdGVCdWZmZXIodmVyc2lvbiwgYXNuMS5CZXIuSW50ZWdlcik7XG5cblx0XHQvLyBGaWVsZElEIHNlcXVlbmNlXG5cdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblx0XHRkZXIud3JpdGVPSUQoJzEuMi44NDAuMTAwNDUuMS4xJyk7IC8vIHByaW1lLWZpZWxkXG5cdFx0ZGVyLndyaXRlQnVmZmVyKGN1cnZlLnAsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdFx0Ly8gQ3VydmUgc2VxdWVuY2Vcblx0XHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRcdHZhciBhID0gY3VydmUucDtcblx0XHRpZiAoYVswXSA9PT0gMHgwKVxuXHRcdFx0YSA9IGEuc2xpY2UoMSk7XG5cdFx0ZGVyLndyaXRlQnVmZmVyKGEsIGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0XHRkZXIud3JpdGVCdWZmZXIoY3VydmUuYiwgYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRcdGRlci53cml0ZUJ1ZmZlcihjdXJ2ZS5zLCBhc24xLkJlci5CaXRTdHJpbmcpO1xuXHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdFx0ZGVyLndyaXRlQnVmZmVyKGN1cnZlLkcsIGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0XHRkZXIud3JpdGVCdWZmZXIoY3VydmUubiwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdFx0dmFyIGggPSBjdXJ2ZS5oO1xuXHRcdGlmICghaCkge1xuXHRcdFx0aCA9IEJ1ZmZlci5mcm9tKFsxXSk7XG5cdFx0fVxuXHRcdGRlci53cml0ZUJ1ZmZlcihoLCBhc24xLkJlci5JbnRlZ2VyKTtcblxuXHRcdC8vIEVDUGFyYW1ldGVyc1xuXHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczhFQ0RTQVB1YmxpYyhrZXksIGRlcikge1xuXHR3cml0ZUVDRFNBQ3VydmUoa2V5LCBkZXIpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHR2YXIgUSA9IHV0aWxzLmVjTm9ybWFsaXplKGtleS5wYXJ0LlEuZGF0YSwgdHJ1ZSk7XG5cdGRlci53cml0ZUJ1ZmZlcihRLCBhc24xLkJlci5CaXRTdHJpbmcpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3M4RUNEU0FQcml2YXRlKGtleSwgZGVyKSB7XG5cdHdyaXRlRUNEU0FDdXJ2ZShrZXksIGRlcik7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdGRlci5zdGFydFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblxuXHR2YXIgdmVyc2lvbiA9IEJ1ZmZlci5mcm9tKFsxXSk7XG5cdGRlci53cml0ZUJ1ZmZlcih2ZXJzaW9uLCBhc24xLkJlci5JbnRlZ2VyKTtcblxuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZC5kYXRhLCBhc24xLkJlci5PY3RldFN0cmluZyk7XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoMHhhMSk7XG5cdHZhciBRID0gdXRpbHMuZWNOb3JtYWxpemUoa2V5LnBhcnQuUS5kYXRhLCB0cnVlKTtcblx0ZGVyLndyaXRlQnVmZmVyKFEsIGFzbjEuQmVyLkJpdFN0cmluZyk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzOEVkRFNBUHVibGljKGtleSwgZGVyKSB7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdHV0aWxzLndyaXRlQml0U3RyaW5nKGRlciwga2V5LnBhcnQuQS5kYXRhKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzOEVkRFNBUHJpdmF0ZShrZXksIGRlcikge1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdHZhciBrID0gdXRpbHMubXBOb3JtYWxpemUoa2V5LnBhcnQuay5kYXRhKTtcblx0LyogUkZDcyBjYWxsIGZvciBzdG9yaW5nIGV4YWN0bHkgMzIgYnl0ZXMsIHNvIHN0cmlwIGFueSBsZWFkaW5nIHplcm9zICovXG5cdHdoaWxlIChrLmxlbmd0aCA+IDMyICYmIGtbMF0gPT09IDB4MDApXG5cdFx0ayA9IGsuc2xpY2UoMSk7XG5cdGRlci53cml0ZUJ1ZmZlcihrLCBhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdHV0aWxzLndyaXRlQml0U3RyaW5nKGRlciwga2V5LnBhcnQuQS5kYXRhLCBhc24xLkJlci5Db250ZXh0IHwgMSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/formats/pkcs8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/formats/pkcs8.js":
/*!*************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/pkcs8.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2018 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\treadPkcs8: readPkcs8,\n\twrite: write,\n\twritePkcs8: writePkcs8,\n\tpkcs8ToBuffer: pkcs8ToBuffer,\n\n\treadECDSACurve: readECDSACurve,\n\twriteECDSACurve: writeECDSACurve\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(rsc)/./node_modules/asn1/lib/index.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\nvar pem = __webpack_require__(/*! ./pem */ \"(rsc)/./node_modules/sshpk/lib/formats/pem.js\");\n\nfunction read(buf, options) {\n\treturn (pem.read(buf, options, 'pkcs8'));\n}\n\nfunction write(key, options) {\n\treturn (pem.write(key, options, 'pkcs8'));\n}\n\n/* Helper to read in a single mpint */\nfunction readMPInt(der, nm) {\n\tassert.strictEqual(der.peek(), asn1.Ber.Integer,\n\t    nm + ' is not an Integer');\n\treturn (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));\n}\n\nfunction readPkcs8(alg, type, der) {\n\t/* Private keys in pkcs#8 format have a weird extra int */\n\tif (der.peek() === asn1.Ber.Integer) {\n\t\tassert.strictEqual(type, 'private',\n\t\t    'unexpected Integer at start of public key');\n\t\tder.readString(asn1.Ber.Integer, true);\n\t}\n\n\tder.readSequence();\n\tvar next = der.offset + der.length;\n\n\tvar oid = der.readOID();\n\tswitch (oid) {\n\tcase '1.2.840.113549.1.1.1':\n\t\tder._offset = next;\n\t\tif (type === 'public')\n\t\t\treturn (readPkcs8RSAPublic(der));\n\t\telse\n\t\t\treturn (readPkcs8RSAPrivate(der));\n\tcase '1.2.840.10040.4.1':\n\t\tif (type === 'public')\n\t\t\treturn (readPkcs8DSAPublic(der));\n\t\telse\n\t\t\treturn (readPkcs8DSAPrivate(der));\n\tcase '1.2.840.10045.2.1':\n\t\tif (type === 'public')\n\t\t\treturn (readPkcs8ECDSAPublic(der));\n\t\telse\n\t\t\treturn (readPkcs8ECDSAPrivate(der));\n\tcase '1.3.101.112':\n\t\tif (type === 'public') {\n\t\t\treturn (readPkcs8EdDSAPublic(der));\n\t\t} else {\n\t\t\treturn (readPkcs8EdDSAPrivate(der));\n\t\t}\n\tcase '1.3.101.110':\n\t\tif (type === 'public') {\n\t\t\treturn (readPkcs8X25519Public(der));\n\t\t} else {\n\t\t\treturn (readPkcs8X25519Private(der));\n\t\t}\n\tdefault:\n\t\tthrow (new Error('Unknown key type OID ' + oid));\n\t}\n}\n\nfunction readPkcs8RSAPublic(der) {\n\t// bit string sequence\n\tder.readSequence(asn1.Ber.BitString);\n\tder.readByte();\n\tder.readSequence();\n\n\t// modulus\n\tvar n = readMPInt(der, 'modulus');\n\tvar e = readMPInt(der, 'exponent');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'rsa',\n\t\tsource: der.originalInput,\n\t\tparts: [\n\t\t\t{ name: 'e', data: e },\n\t\t\t{ name: 'n', data: n }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs8RSAPrivate(der) {\n\tder.readSequence(asn1.Ber.OctetString);\n\tder.readSequence();\n\n\tvar ver = readMPInt(der, 'version');\n\tassert.equal(ver[0], 0x0, 'unknown RSA private key version');\n\n\t// modulus then public exponent\n\tvar n = readMPInt(der, 'modulus');\n\tvar e = readMPInt(der, 'public exponent');\n\tvar d = readMPInt(der, 'private exponent');\n\tvar p = readMPInt(der, 'prime1');\n\tvar q = readMPInt(der, 'prime2');\n\tvar dmodp = readMPInt(der, 'exponent1');\n\tvar dmodq = readMPInt(der, 'exponent2');\n\tvar iqmp = readMPInt(der, 'iqmp');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'rsa',\n\t\tparts: [\n\t\t\t{ name: 'n', data: n },\n\t\t\t{ name: 'e', data: e },\n\t\t\t{ name: 'd', data: d },\n\t\t\t{ name: 'iqmp', data: iqmp },\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'dmodp', data: dmodp },\n\t\t\t{ name: 'dmodq', data: dmodq }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs8DSAPublic(der) {\n\tder.readSequence();\n\n\tvar p = readMPInt(der, 'p');\n\tvar q = readMPInt(der, 'q');\n\tvar g = readMPInt(der, 'g');\n\n\t// bit string sequence\n\tder.readSequence(asn1.Ber.BitString);\n\tder.readByte();\n\n\tvar y = readMPInt(der, 'y');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'dsa',\n\t\tparts: [\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'g', data: g },\n\t\t\t{ name: 'y', data: y }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs8DSAPrivate(der) {\n\tder.readSequence();\n\n\tvar p = readMPInt(der, 'p');\n\tvar q = readMPInt(der, 'q');\n\tvar g = readMPInt(der, 'g');\n\n\tder.readSequence(asn1.Ber.OctetString);\n\tvar x = readMPInt(der, 'x');\n\n\t/* The pkcs#8 format does not include the public key */\n\tvar y = utils.calculateDSAPublic(g, p, x);\n\n\tvar key = {\n\t\ttype: 'dsa',\n\t\tparts: [\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'g', data: g },\n\t\t\t{ name: 'y', data: y },\n\t\t\t{ name: 'x', data: x }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readECDSACurve(der) {\n\tvar curveName, curveNames;\n\tvar j, c, cd;\n\n\tif (der.peek() === asn1.Ber.OID) {\n\t\tvar oid = der.readOID();\n\n\t\tcurveNames = Object.keys(algs.curves);\n\t\tfor (j = 0; j < curveNames.length; ++j) {\n\t\t\tc = curveNames[j];\n\t\t\tcd = algs.curves[c];\n\t\t\tif (cd.pkcs8oid === oid) {\n\t\t\t\tcurveName = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t// ECParameters sequence\n\t\tder.readSequence();\n\t\tvar version = der.readString(asn1.Ber.Integer, true);\n\t\tassert.strictEqual(version[0], 1, 'ECDSA key not version 1');\n\n\t\tvar curve = {};\n\n\t\t// FieldID sequence\n\t\tder.readSequence();\n\t\tvar fieldTypeOid = der.readOID();\n\t\tassert.strictEqual(fieldTypeOid, '1.2.840.10045.1.1',\n\t\t    'ECDSA key is not from a prime-field');\n\t\tvar p = curve.p = utils.mpNormalize(\n\t\t    der.readString(asn1.Ber.Integer, true));\n\t\t/*\n\t\t * p always starts with a 1 bit, so count the zeros to get its\n\t\t * real size.\n\t\t */\n\t\tcurve.size = p.length * 8 - utils.countZeros(p);\n\n\t\t// Curve sequence\n\t\tder.readSequence();\n\t\tcurve.a = utils.mpNormalize(\n\t\t    der.readString(asn1.Ber.OctetString, true));\n\t\tcurve.b = utils.mpNormalize(\n\t\t    der.readString(asn1.Ber.OctetString, true));\n\t\tif (der.peek() === asn1.Ber.BitString)\n\t\t\tcurve.s = der.readString(asn1.Ber.BitString, true);\n\n\t\t// Combined Gx and Gy\n\t\tcurve.G = der.readString(asn1.Ber.OctetString, true);\n\t\tassert.strictEqual(curve.G[0], 0x4,\n\t\t    'uncompressed G is required');\n\n\t\tcurve.n = utils.mpNormalize(\n\t\t    der.readString(asn1.Ber.Integer, true));\n\t\tcurve.h = utils.mpNormalize(\n\t\t    der.readString(asn1.Ber.Integer, true));\n\t\tassert.strictEqual(curve.h[0], 0x1, 'a cofactor=1 curve is ' +\n\t\t    'required');\n\n\t\tcurveNames = Object.keys(algs.curves);\n\t\tvar ks = Object.keys(curve);\n\t\tfor (j = 0; j < curveNames.length; ++j) {\n\t\t\tc = curveNames[j];\n\t\t\tcd = algs.curves[c];\n\t\t\tvar equal = true;\n\t\t\tfor (var i = 0; i < ks.length; ++i) {\n\t\t\t\tvar k = ks[i];\n\t\t\t\tif (cd[k] === undefined)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (typeof (cd[k]) === 'object' &&\n\t\t\t\t    cd[k].equals !== undefined) {\n\t\t\t\t\tif (!cd[k].equals(curve[k])) {\n\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (Buffer.isBuffer(cd[k])) {\n\t\t\t\t\tif (cd[k].toString('binary')\n\t\t\t\t\t    !== curve[k].toString('binary')) {\n\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (cd[k] !== curve[k]) {\n\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (equal) {\n\t\t\t\tcurveName = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn (curveName);\n}\n\nfunction readPkcs8ECDSAPrivate(der) {\n\tvar curveName = readECDSACurve(der);\n\tassert.string(curveName, 'a known elliptic curve');\n\n\tder.readSequence(asn1.Ber.OctetString);\n\tder.readSequence();\n\n\tvar version = readMPInt(der, 'version');\n\tassert.equal(version[0], 1, 'unknown version of ECDSA key');\n\n\tvar d = der.readString(asn1.Ber.OctetString, true);\n\tvar Q;\n\n\tif (der.peek() == 0xa0) {\n\t\tder.readSequence(0xa0);\n\t\tder._offset += der.length;\n\t}\n\tif (der.peek() == 0xa1) {\n\t\tder.readSequence(0xa1);\n\t\tQ = der.readString(asn1.Ber.BitString, true);\n\t\tQ = utils.ecNormalize(Q);\n\t}\n\n\tif (Q === undefined) {\n\t\tvar pub = utils.publicFromPrivateECDSA(curveName, d);\n\t\tQ = pub.part.Q.data;\n\t}\n\n\tvar key = {\n\t\ttype: 'ecdsa',\n\t\tparts: [\n\t\t\t{ name: 'curve', data: Buffer.from(curveName) },\n\t\t\t{ name: 'Q', data: Q },\n\t\t\t{ name: 'd', data: d }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs8ECDSAPublic(der) {\n\tvar curveName = readECDSACurve(der);\n\tassert.string(curveName, 'a known elliptic curve');\n\n\tvar Q = der.readString(asn1.Ber.BitString, true);\n\tQ = utils.ecNormalize(Q);\n\n\tvar key = {\n\t\ttype: 'ecdsa',\n\t\tparts: [\n\t\t\t{ name: 'curve', data: Buffer.from(curveName) },\n\t\t\t{ name: 'Q', data: Q }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs8EdDSAPublic(der) {\n\tif (der.peek() === 0x00)\n\t\tder.readByte();\n\n\tvar A = utils.readBitString(der);\n\n\tvar key = {\n\t\ttype: 'ed25519',\n\t\tparts: [\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs8X25519Public(der) {\n\tvar A = utils.readBitString(der);\n\n\tvar key = {\n\t\ttype: 'curve25519',\n\t\tparts: [\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs8EdDSAPrivate(der) {\n\tif (der.peek() === 0x00)\n\t\tder.readByte();\n\n\tder.readSequence(asn1.Ber.OctetString);\n\tvar k = der.readString(asn1.Ber.OctetString, true);\n\tk = utils.zeroPadToLength(k, 32);\n\n\tvar A, tag;\n\twhile ((tag = der.peek()) !== null) {\n\t\tif (tag === (asn1.Ber.Context | 1)) {\n\t\t\tA = utils.readBitString(der, tag);\n\t\t} else {\n\t\t\tder.readSequence(tag);\n\t\t\tder._offset += der.length;\n\t\t}\n\t}\n\tif (A === undefined)\n\t\tA = utils.calculateED25519Public(k);\n\n\tvar key = {\n\t\ttype: 'ed25519',\n\t\tparts: [\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\n\t\t\t{ name: 'k', data: utils.zeroPadToLength(k, 32) }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs8X25519Private(der) {\n\tif (der.peek() === 0x00)\n\t\tder.readByte();\n\n\tder.readSequence(asn1.Ber.OctetString);\n\tvar k = der.readString(asn1.Ber.OctetString, true);\n\tk = utils.zeroPadToLength(k, 32);\n\n\tvar A = utils.calculateX25519Public(k);\n\n\tvar key = {\n\t\ttype: 'curve25519',\n\t\tparts: [\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\n\t\t\t{ name: 'k', data: utils.zeroPadToLength(k, 32) }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction pkcs8ToBuffer(key) {\n\tvar der = new asn1.BerWriter();\n\twritePkcs8(der, key);\n\treturn (der.buffer);\n}\n\nfunction writePkcs8(der, key) {\n\tder.startSequence();\n\n\tif (PrivateKey.isPrivateKey(key)) {\n\t\tvar version = 0;\n\t\tif (key.type === 'ed25519')\n\t\t\tversion = 1;\n\t\tvar vbuf = Buffer.from([version]);\n\t\tder.writeBuffer(vbuf, asn1.Ber.Integer);\n\t}\n\n\tder.startSequence();\n\tswitch (key.type) {\n\tcase 'rsa':\n\t\tder.writeOID('1.2.840.113549.1.1.1');\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs8RSAPrivate(key, der);\n\t\telse\n\t\t\twritePkcs8RSAPublic(key, der);\n\t\tbreak;\n\tcase 'dsa':\n\t\tder.writeOID('1.2.840.10040.4.1');\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs8DSAPrivate(key, der);\n\t\telse\n\t\t\twritePkcs8DSAPublic(key, der);\n\t\tbreak;\n\tcase 'ecdsa':\n\t\tder.writeOID('1.2.840.10045.2.1');\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs8ECDSAPrivate(key, der);\n\t\telse\n\t\t\twritePkcs8ECDSAPublic(key, der);\n\t\tbreak;\n\tcase 'ed25519':\n\t\tder.writeOID('1.3.101.112');\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs8EdDSAPrivate(key, der);\n\t\telse\n\t\t\twritePkcs8EdDSAPublic(key, der);\n\t\tbreak;\n\tdefault:\n\t\tthrow (new Error('Unsupported key type: ' + key.type));\n\t}\n\n\tder.endSequence();\n}\n\nfunction writePkcs8RSAPrivate(key, der) {\n\tder.writeNull();\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.OctetString);\n\tder.startSequence();\n\n\tvar version = Buffer.from([0]);\n\tder.writeBuffer(version, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.d.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tif (!key.part.dmodp || !key.part.dmodq)\n\t\tutils.addRSAMissing(key);\n\tder.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);\n\n\tder.endSequence();\n\tder.endSequence();\n}\n\nfunction writePkcs8RSAPublic(key, der) {\n\tder.writeNull();\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.BitString);\n\tder.writeByte(0x00);\n\n\tder.startSequence();\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n\tder.endSequence();\n\n\tder.endSequence();\n}\n\nfunction writePkcs8DSAPrivate(key, der) {\n\tder.startSequence();\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n\tder.endSequence();\n\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.OctetString);\n\tder.writeBuffer(key.part.x.data, asn1.Ber.Integer);\n\tder.endSequence();\n}\n\nfunction writePkcs8DSAPublic(key, der) {\n\tder.startSequence();\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n\tder.endSequence();\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.BitString);\n\tder.writeByte(0x00);\n\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n\tder.endSequence();\n}\n\nfunction writeECDSACurve(key, der) {\n\tvar curve = algs.curves[key.curve];\n\tif (curve.pkcs8oid) {\n\t\t/* This one has a name in pkcs#8, so just write the oid */\n\t\tder.writeOID(curve.pkcs8oid);\n\n\t} else {\n\t\t// ECParameters sequence\n\t\tder.startSequence();\n\n\t\tvar version = Buffer.from([1]);\n\t\tder.writeBuffer(version, asn1.Ber.Integer);\n\n\t\t// FieldID sequence\n\t\tder.startSequence();\n\t\tder.writeOID('1.2.840.10045.1.1'); // prime-field\n\t\tder.writeBuffer(curve.p, asn1.Ber.Integer);\n\t\tder.endSequence();\n\n\t\t// Curve sequence\n\t\tder.startSequence();\n\t\tvar a = curve.p;\n\t\tif (a[0] === 0x0)\n\t\t\ta = a.slice(1);\n\t\tder.writeBuffer(a, asn1.Ber.OctetString);\n\t\tder.writeBuffer(curve.b, asn1.Ber.OctetString);\n\t\tder.writeBuffer(curve.s, asn1.Ber.BitString);\n\t\tder.endSequence();\n\n\t\tder.writeBuffer(curve.G, asn1.Ber.OctetString);\n\t\tder.writeBuffer(curve.n, asn1.Ber.Integer);\n\t\tvar h = curve.h;\n\t\tif (!h) {\n\t\t\th = Buffer.from([1]);\n\t\t}\n\t\tder.writeBuffer(h, asn1.Ber.Integer);\n\n\t\t// ECParameters\n\t\tder.endSequence();\n\t}\n}\n\nfunction writePkcs8ECDSAPublic(key, der) {\n\twriteECDSACurve(key, der);\n\tder.endSequence();\n\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\tder.writeBuffer(Q, asn1.Ber.BitString);\n}\n\nfunction writePkcs8ECDSAPrivate(key, der) {\n\twriteECDSACurve(key, der);\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.OctetString);\n\tder.startSequence();\n\n\tvar version = Buffer.from([1]);\n\tder.writeBuffer(version, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.d.data, asn1.Ber.OctetString);\n\n\tder.startSequence(0xa1);\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\tder.writeBuffer(Q, asn1.Ber.BitString);\n\tder.endSequence();\n\n\tder.endSequence();\n\tder.endSequence();\n}\n\nfunction writePkcs8EdDSAPublic(key, der) {\n\tder.endSequence();\n\n\tutils.writeBitString(der, key.part.A.data);\n}\n\nfunction writePkcs8EdDSAPrivate(key, der) {\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.OctetString);\n\tvar k = utils.mpNormalize(key.part.k.data);\n\t/* RFCs call for storing exactly 32 bytes, so strip any leading zeros */\n\twhile (k.length > 32 && k[0] === 0x00)\n\t\tk = k.slice(1);\n\tder.writeBuffer(k, asn1.Ber.OctetString);\n\tder.endSequence();\n\n\tutils.writeBitString(der, key.part.A.data, asn1.Ber.Context | 1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvcGtjczguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsK0RBQWE7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLG9EQUFNO0FBQ3pCLGFBQWEsOEZBQThCO0FBQzNDLFdBQVcsbUJBQU8sQ0FBQyx1REFBUztBQUM1QixZQUFZLG1CQUFPLENBQUMseURBQVU7QUFDOUIsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFnQjtBQUN6QyxVQUFVLG1CQUFPLENBQUMsNERBQU87O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQjtBQUN6QixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0JBQW9CO0FBQ3pCLEtBQUssb0JBQW9CO0FBQ3pCLEtBQUssb0JBQW9CO0FBQ3pCLEtBQUssMEJBQTBCO0FBQy9CLEtBQUssb0JBQW9CO0FBQ3pCLEtBQUssb0JBQW9CO0FBQ3pCLEtBQUssNEJBQTRCO0FBQ2pDLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0I7QUFDekIsS0FBSyxvQkFBb0I7QUFDekIsS0FBSyxvQkFBb0I7QUFDekIsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0I7QUFDekIsS0FBSyxvQkFBb0I7QUFDekIsS0FBSyxvQkFBb0I7QUFDekIsS0FBSyxvQkFBb0I7QUFDekIsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZDQUE2QztBQUNsRCxLQUFLLG9CQUFvQjtBQUN6QixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNkNBQTZDO0FBQ2xELEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUssK0NBQStDO0FBQ3BELEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtDQUErQztBQUNwRCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvcGtjczguanM/NzBlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOCBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHJlYWQ6IHJlYWQsXG5cdHJlYWRQa2NzODogcmVhZFBrY3M4LFxuXHR3cml0ZTogd3JpdGUsXG5cdHdyaXRlUGtjczg6IHdyaXRlUGtjczgsXG5cdHBrY3M4VG9CdWZmZXI6IHBrY3M4VG9CdWZmZXIsXG5cblx0cmVhZEVDRFNBQ3VydmU6IHJlYWRFQ0RTQUN1cnZlLFxuXHR3cml0ZUVDRFNBQ3VydmU6IHdyaXRlRUNEU0FDdXJ2ZVxufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgYXNuMSA9IHJlcXVpcmUoJ2FzbjEnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4uL2FsZ3MnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgS2V5ID0gcmVxdWlyZSgnLi4va2V5Jyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uL3ByaXZhdGUta2V5Jyk7XG52YXIgcGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcblxuZnVuY3Rpb24gcmVhZChidWYsIG9wdGlvbnMpIHtcblx0cmV0dXJuIChwZW0ucmVhZChidWYsIG9wdGlvbnMsICdwa2NzOCcpKTtcbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBvcHRpb25zKSB7XG5cdHJldHVybiAocGVtLndyaXRlKGtleSwgb3B0aW9ucywgJ3BrY3M4JykpO1xufVxuXG4vKiBIZWxwZXIgdG8gcmVhZCBpbiBhIHNpbmdsZSBtcGludCAqL1xuZnVuY3Rpb24gcmVhZE1QSW50KGRlciwgbm0pIHtcblx0YXNzZXJ0LnN0cmljdEVxdWFsKGRlci5wZWVrKCksIGFzbjEuQmVyLkludGVnZXIsXG5cdCAgICBubSArICcgaXMgbm90IGFuIEludGVnZXInKTtcblx0cmV0dXJuICh1dGlscy5tcE5vcm1hbGl6ZShkZXIucmVhZFN0cmluZyhhc24xLkJlci5JbnRlZ2VyLCB0cnVlKSkpO1xufVxuXG5mdW5jdGlvbiByZWFkUGtjczgoYWxnLCB0eXBlLCBkZXIpIHtcblx0LyogUHJpdmF0ZSBrZXlzIGluIHBrY3MjOCBmb3JtYXQgaGF2ZSBhIHdlaXJkIGV4dHJhIGludCAqL1xuXHRpZiAoZGVyLnBlZWsoKSA9PT0gYXNuMS5CZXIuSW50ZWdlcikge1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlLCAncHJpdmF0ZScsXG5cdFx0ICAgICd1bmV4cGVjdGVkIEludGVnZXIgYXQgc3RhcnQgb2YgcHVibGljIGtleScpO1xuXHRcdGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkludGVnZXIsIHRydWUpO1xuXHR9XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHR2YXIgbmV4dCA9IGRlci5vZmZzZXQgKyBkZXIubGVuZ3RoO1xuXG5cdHZhciBvaWQgPSBkZXIucmVhZE9JRCgpO1xuXHRzd2l0Y2ggKG9pZCkge1xuXHRjYXNlICcxLjIuODQwLjExMzU0OS4xLjEuMSc6XG5cdFx0ZGVyLl9vZmZzZXQgPSBuZXh0O1xuXHRcdGlmICh0eXBlID09PSAncHVibGljJylcblx0XHRcdHJldHVybiAocmVhZFBrY3M4UlNBUHVibGljKGRlcikpO1xuXHRcdGVsc2Vcblx0XHRcdHJldHVybiAocmVhZFBrY3M4UlNBUHJpdmF0ZShkZXIpKTtcblx0Y2FzZSAnMS4yLjg0MC4xMDA0MC40LjEnOlxuXHRcdGlmICh0eXBlID09PSAncHVibGljJylcblx0XHRcdHJldHVybiAocmVhZFBrY3M4RFNBUHVibGljKGRlcikpO1xuXHRcdGVsc2Vcblx0XHRcdHJldHVybiAocmVhZFBrY3M4RFNBUHJpdmF0ZShkZXIpKTtcblx0Y2FzZSAnMS4yLjg0MC4xMDA0NS4yLjEnOlxuXHRcdGlmICh0eXBlID09PSAncHVibGljJylcblx0XHRcdHJldHVybiAocmVhZFBrY3M4RUNEU0FQdWJsaWMoZGVyKSk7XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhFQ0RTQVByaXZhdGUoZGVyKSk7XG5cdGNhc2UgJzEuMy4xMDEuMTEyJzpcblx0XHRpZiAodHlwZSA9PT0gJ3B1YmxpYycpIHtcblx0XHRcdHJldHVybiAocmVhZFBrY3M4RWREU0FQdWJsaWMoZGVyKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAocmVhZFBrY3M4RWREU0FQcml2YXRlKGRlcikpO1xuXHRcdH1cblx0Y2FzZSAnMS4zLjEwMS4xMTAnOlxuXHRcdGlmICh0eXBlID09PSAncHVibGljJykge1xuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhYMjU1MTlQdWJsaWMoZGVyKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAocmVhZFBrY3M4WDI1NTE5UHJpdmF0ZShkZXIpKTtcblx0XHR9XG5cdGRlZmF1bHQ6XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biBrZXkgdHlwZSBPSUQgJyArIG9pZCkpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzOFJTQVB1YmxpYyhkZXIpIHtcblx0Ly8gYml0IHN0cmluZyBzZXF1ZW5jZVxuXHRkZXIucmVhZFNlcXVlbmNlKGFzbjEuQmVyLkJpdFN0cmluZyk7XG5cdGRlci5yZWFkQnl0ZSgpO1xuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cblx0Ly8gbW9kdWx1c1xuXHR2YXIgbiA9IHJlYWRNUEludChkZXIsICdtb2R1bHVzJyk7XG5cdHZhciBlID0gcmVhZE1QSW50KGRlciwgJ2V4cG9uZW50Jyk7XG5cblx0Ly8gbm93LCBtYWtlIHRoZSBrZXlcblx0dmFyIGtleSA9IHtcblx0XHR0eXBlOiAncnNhJyxcblx0XHRzb3VyY2U6IGRlci5vcmlnaW5hbElucHV0LFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICdlJywgZGF0YTogZSB9LFxuXHRcdFx0eyBuYW1lOiAnbicsIGRhdGE6IG4gfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzOFJTQVByaXZhdGUoZGVyKSB7XG5cdGRlci5yZWFkU2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cblx0dmFyIHZlciA9IHJlYWRNUEludChkZXIsICd2ZXJzaW9uJyk7XG5cdGFzc2VydC5lcXVhbCh2ZXJbMF0sIDB4MCwgJ3Vua25vd24gUlNBIHByaXZhdGUga2V5IHZlcnNpb24nKTtcblxuXHQvLyBtb2R1bHVzIHRoZW4gcHVibGljIGV4cG9uZW50XG5cdHZhciBuID0gcmVhZE1QSW50KGRlciwgJ21vZHVsdXMnKTtcblx0dmFyIGUgPSByZWFkTVBJbnQoZGVyLCAncHVibGljIGV4cG9uZW50Jyk7XG5cdHZhciBkID0gcmVhZE1QSW50KGRlciwgJ3ByaXZhdGUgZXhwb25lbnQnKTtcblx0dmFyIHAgPSByZWFkTVBJbnQoZGVyLCAncHJpbWUxJyk7XG5cdHZhciBxID0gcmVhZE1QSW50KGRlciwgJ3ByaW1lMicpO1xuXHR2YXIgZG1vZHAgPSByZWFkTVBJbnQoZGVyLCAnZXhwb25lbnQxJyk7XG5cdHZhciBkbW9kcSA9IHJlYWRNUEludChkZXIsICdleHBvbmVudDInKTtcblx0dmFyIGlxbXAgPSByZWFkTVBJbnQoZGVyLCAnaXFtcCcpO1xuXG5cdC8vIG5vdywgbWFrZSB0aGUga2V5XG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ3JzYScsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ24nLCBkYXRhOiBuIH0sXG5cdFx0XHR7IG5hbWU6ICdlJywgZGF0YTogZSB9LFxuXHRcdFx0eyBuYW1lOiAnZCcsIGRhdGE6IGQgfSxcblx0XHRcdHsgbmFtZTogJ2lxbXAnLCBkYXRhOiBpcW1wIH0sXG5cdFx0XHR7IG5hbWU6ICdwJywgZGF0YTogcCB9LFxuXHRcdFx0eyBuYW1lOiAncScsIGRhdGE6IHEgfSxcblx0XHRcdHsgbmFtZTogJ2Rtb2RwJywgZGF0YTogZG1vZHAgfSxcblx0XHRcdHsgbmFtZTogJ2Rtb2RxJywgZGF0YTogZG1vZHEgfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBQcml2YXRlS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiByZWFkUGtjczhEU0FQdWJsaWMoZGVyKSB7XG5cdGRlci5yZWFkU2VxdWVuY2UoKTtcblxuXHR2YXIgcCA9IHJlYWRNUEludChkZXIsICdwJyk7XG5cdHZhciBxID0gcmVhZE1QSW50KGRlciwgJ3EnKTtcblx0dmFyIGcgPSByZWFkTVBJbnQoZGVyLCAnZycpO1xuXG5cdC8vIGJpdCBzdHJpbmcgc2VxdWVuY2Vcblx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5CaXRTdHJpbmcpO1xuXHRkZXIucmVhZEJ5dGUoKTtcblxuXHR2YXIgeSA9IHJlYWRNUEludChkZXIsICd5Jyk7XG5cblx0Ly8gbm93LCBtYWtlIHRoZSBrZXlcblx0dmFyIGtleSA9IHtcblx0XHR0eXBlOiAnZHNhJyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAncCcsIGRhdGE6IHAgfSxcblx0XHRcdHsgbmFtZTogJ3EnLCBkYXRhOiBxIH0sXG5cdFx0XHR7IG5hbWU6ICdnJywgZGF0YTogZyB9LFxuXHRcdFx0eyBuYW1lOiAneScsIGRhdGE6IHkgfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzOERTQVByaXZhdGUoZGVyKSB7XG5cdGRlci5yZWFkU2VxdWVuY2UoKTtcblxuXHR2YXIgcCA9IHJlYWRNUEludChkZXIsICdwJyk7XG5cdHZhciBxID0gcmVhZE1QSW50KGRlciwgJ3EnKTtcblx0dmFyIGcgPSByZWFkTVBJbnQoZGVyLCAnZycpO1xuXG5cdGRlci5yZWFkU2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHR2YXIgeCA9IHJlYWRNUEludChkZXIsICd4Jyk7XG5cblx0LyogVGhlIHBrY3MjOCBmb3JtYXQgZG9lcyBub3QgaW5jbHVkZSB0aGUgcHVibGljIGtleSAqL1xuXHR2YXIgeSA9IHV0aWxzLmNhbGN1bGF0ZURTQVB1YmxpYyhnLCBwLCB4KTtcblxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdkc2EnLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICdwJywgZGF0YTogcCB9LFxuXHRcdFx0eyBuYW1lOiAncScsIGRhdGE6IHEgfSxcblx0XHRcdHsgbmFtZTogJ2cnLCBkYXRhOiBnIH0sXG5cdFx0XHR7IG5hbWU6ICd5JywgZGF0YTogeSB9LFxuXHRcdFx0eyBuYW1lOiAneCcsIGRhdGE6IHggfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBQcml2YXRlS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiByZWFkRUNEU0FDdXJ2ZShkZXIpIHtcblx0dmFyIGN1cnZlTmFtZSwgY3VydmVOYW1lcztcblx0dmFyIGosIGMsIGNkO1xuXG5cdGlmIChkZXIucGVlaygpID09PSBhc24xLkJlci5PSUQpIHtcblx0XHR2YXIgb2lkID0gZGVyLnJlYWRPSUQoKTtcblxuXHRcdGN1cnZlTmFtZXMgPSBPYmplY3Qua2V5cyhhbGdzLmN1cnZlcyk7XG5cdFx0Zm9yIChqID0gMDsgaiA8IGN1cnZlTmFtZXMubGVuZ3RoOyArK2opIHtcblx0XHRcdGMgPSBjdXJ2ZU5hbWVzW2pdO1xuXHRcdFx0Y2QgPSBhbGdzLmN1cnZlc1tjXTtcblx0XHRcdGlmIChjZC5wa2NzOG9pZCA9PT0gb2lkKSB7XG5cdFx0XHRcdGN1cnZlTmFtZSA9IGM7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXHRcdC8vIEVDUGFyYW1ldGVycyBzZXF1ZW5jZVxuXHRcdGRlci5yZWFkU2VxdWVuY2UoKTtcblx0XHR2YXIgdmVyc2lvbiA9IGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkludGVnZXIsIHRydWUpO1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbCh2ZXJzaW9uWzBdLCAxLCAnRUNEU0Ega2V5IG5vdCB2ZXJzaW9uIDEnKTtcblxuXHRcdHZhciBjdXJ2ZSA9IHt9O1xuXG5cdFx0Ly8gRmllbGRJRCBzZXF1ZW5jZVxuXHRcdGRlci5yZWFkU2VxdWVuY2UoKTtcblx0XHR2YXIgZmllbGRUeXBlT2lkID0gZGVyLnJlYWRPSUQoKTtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwoZmllbGRUeXBlT2lkLCAnMS4yLjg0MC4xMDA0NS4xLjEnLFxuXHRcdCAgICAnRUNEU0Ega2V5IGlzIG5vdCBmcm9tIGEgcHJpbWUtZmllbGQnKTtcblx0XHR2YXIgcCA9IGN1cnZlLnAgPSB1dGlscy5tcE5vcm1hbGl6ZShcblx0XHQgICAgZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuSW50ZWdlciwgdHJ1ZSkpO1xuXHRcdC8qXG5cdFx0ICogcCBhbHdheXMgc3RhcnRzIHdpdGggYSAxIGJpdCwgc28gY291bnQgdGhlIHplcm9zIHRvIGdldCBpdHNcblx0XHQgKiByZWFsIHNpemUuXG5cdFx0ICovXG5cdFx0Y3VydmUuc2l6ZSA9IHAubGVuZ3RoICogOCAtIHV0aWxzLmNvdW50WmVyb3MocCk7XG5cblx0XHQvLyBDdXJ2ZSBzZXF1ZW5jZVxuXHRcdGRlci5yZWFkU2VxdWVuY2UoKTtcblx0XHRjdXJ2ZS5hID0gdXRpbHMubXBOb3JtYWxpemUoXG5cdFx0ICAgIGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLk9jdGV0U3RyaW5nLCB0cnVlKSk7XG5cdFx0Y3VydmUuYiA9IHV0aWxzLm1wTm9ybWFsaXplKFxuXHRcdCAgICBkZXIucmVhZFN0cmluZyhhc24xLkJlci5PY3RldFN0cmluZywgdHJ1ZSkpO1xuXHRcdGlmIChkZXIucGVlaygpID09PSBhc24xLkJlci5CaXRTdHJpbmcpXG5cdFx0XHRjdXJ2ZS5zID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuQml0U3RyaW5nLCB0cnVlKTtcblxuXHRcdC8vIENvbWJpbmVkIEd4IGFuZCBHeVxuXHRcdGN1cnZlLkcgPSBkZXIucmVhZFN0cmluZyhhc24xLkJlci5PY3RldFN0cmluZywgdHJ1ZSk7XG5cdFx0YXNzZXJ0LnN0cmljdEVxdWFsKGN1cnZlLkdbMF0sIDB4NCxcblx0XHQgICAgJ3VuY29tcHJlc3NlZCBHIGlzIHJlcXVpcmVkJyk7XG5cblx0XHRjdXJ2ZS5uID0gdXRpbHMubXBOb3JtYWxpemUoXG5cdFx0ICAgIGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkludGVnZXIsIHRydWUpKTtcblx0XHRjdXJ2ZS5oID0gdXRpbHMubXBOb3JtYWxpemUoXG5cdFx0ICAgIGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkludGVnZXIsIHRydWUpKTtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwoY3VydmUuaFswXSwgMHgxLCAnYSBjb2ZhY3Rvcj0xIGN1cnZlIGlzICcgK1xuXHRcdCAgICAncmVxdWlyZWQnKTtcblxuXHRcdGN1cnZlTmFtZXMgPSBPYmplY3Qua2V5cyhhbGdzLmN1cnZlcyk7XG5cdFx0dmFyIGtzID0gT2JqZWN0LmtleXMoY3VydmUpO1xuXHRcdGZvciAoaiA9IDA7IGogPCBjdXJ2ZU5hbWVzLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRjID0gY3VydmVOYW1lc1tqXTtcblx0XHRcdGNkID0gYWxncy5jdXJ2ZXNbY107XG5cdFx0XHR2YXIgZXF1YWwgPSB0cnVlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR2YXIgayA9IGtzW2ldO1xuXHRcdFx0XHRpZiAoY2Rba10gPT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0aWYgKHR5cGVvZiAoY2Rba10pID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0XHQgICAgY2Rba10uZXF1YWxzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRpZiAoIWNkW2tdLmVxdWFscyhjdXJ2ZVtrXSkpIHtcblx0XHRcdFx0XHRcdGVxdWFsID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGNkW2tdKSkge1xuXHRcdFx0XHRcdGlmIChjZFtrXS50b1N0cmluZygnYmluYXJ5Jylcblx0XHRcdFx0XHQgICAgIT09IGN1cnZlW2tdLnRvU3RyaW5nKCdiaW5hcnknKSkge1xuXHRcdFx0XHRcdFx0ZXF1YWwgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoY2Rba10gIT09IGN1cnZlW2tdKSB7XG5cdFx0XHRcdFx0XHRlcXVhbCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZXF1YWwpIHtcblx0XHRcdFx0Y3VydmVOYW1lID0gYztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiAoY3VydmVOYW1lKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3M4RUNEU0FQcml2YXRlKGRlcikge1xuXHR2YXIgY3VydmVOYW1lID0gcmVhZEVDRFNBQ3VydmUoZGVyKTtcblx0YXNzZXJ0LnN0cmluZyhjdXJ2ZU5hbWUsICdhIGtub3duIGVsbGlwdGljIGN1cnZlJyk7XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdGRlci5yZWFkU2VxdWVuY2UoKTtcblxuXHR2YXIgdmVyc2lvbiA9IHJlYWRNUEludChkZXIsICd2ZXJzaW9uJyk7XG5cdGFzc2VydC5lcXVhbCh2ZXJzaW9uWzBdLCAxLCAndW5rbm93biB2ZXJzaW9uIG9mIEVDRFNBIGtleScpO1xuXG5cdHZhciBkID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuT2N0ZXRTdHJpbmcsIHRydWUpO1xuXHR2YXIgUTtcblxuXHRpZiAoZGVyLnBlZWsoKSA9PSAweGEwKSB7XG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZSgweGEwKTtcblx0XHRkZXIuX29mZnNldCArPSBkZXIubGVuZ3RoO1xuXHR9XG5cdGlmIChkZXIucGVlaygpID09IDB4YTEpIHtcblx0XHRkZXIucmVhZFNlcXVlbmNlKDB4YTEpO1xuXHRcdFEgPSBkZXIucmVhZFN0cmluZyhhc24xLkJlci5CaXRTdHJpbmcsIHRydWUpO1xuXHRcdFEgPSB1dGlscy5lY05vcm1hbGl6ZShRKTtcblx0fVxuXG5cdGlmIChRID09PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgcHViID0gdXRpbHMucHVibGljRnJvbVByaXZhdGVFQ0RTQShjdXJ2ZU5hbWUsIGQpO1xuXHRcdFEgPSBwdWIucGFydC5RLmRhdGE7XG5cdH1cblxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdlY2RzYScsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ2N1cnZlJywgZGF0YTogQnVmZmVyLmZyb20oY3VydmVOYW1lKSB9LFxuXHRcdFx0eyBuYW1lOiAnUScsIGRhdGE6IFEgfSxcblx0XHRcdHsgbmFtZTogJ2QnLCBkYXRhOiBkIH1cblx0XHRdXG5cdH07XG5cblx0cmV0dXJuIChuZXcgUHJpdmF0ZUtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3M4RUNEU0FQdWJsaWMoZGVyKSB7XG5cdHZhciBjdXJ2ZU5hbWUgPSByZWFkRUNEU0FDdXJ2ZShkZXIpO1xuXHRhc3NlcnQuc3RyaW5nKGN1cnZlTmFtZSwgJ2Ega25vd24gZWxsaXB0aWMgY3VydmUnKTtcblxuXHR2YXIgUSA9IGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkJpdFN0cmluZywgdHJ1ZSk7XG5cdFEgPSB1dGlscy5lY05vcm1hbGl6ZShRKTtcblxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdlY2RzYScsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ2N1cnZlJywgZGF0YTogQnVmZmVyLmZyb20oY3VydmVOYW1lKSB9LFxuXHRcdFx0eyBuYW1lOiAnUScsIGRhdGE6IFEgfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzOEVkRFNBUHVibGljKGRlcikge1xuXHRpZiAoZGVyLnBlZWsoKSA9PT0gMHgwMClcblx0XHRkZXIucmVhZEJ5dGUoKTtcblxuXHR2YXIgQSA9IHV0aWxzLnJlYWRCaXRTdHJpbmcoZGVyKTtcblxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdlZDI1NTE5Jyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnQScsIGRhdGE6IHV0aWxzLnplcm9QYWRUb0xlbmd0aChBLCAzMikgfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzOFgyNTUxOVB1YmxpYyhkZXIpIHtcblx0dmFyIEEgPSB1dGlscy5yZWFkQml0U3RyaW5nKGRlcik7XG5cblx0dmFyIGtleSA9IHtcblx0XHR0eXBlOiAnY3VydmUyNTUxOScsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ0EnLCBkYXRhOiB1dGlscy56ZXJvUGFkVG9MZW5ndGgoQSwgMzIpIH1cblx0XHRdXG5cdH07XG5cblx0cmV0dXJuIChuZXcgS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiByZWFkUGtjczhFZERTQVByaXZhdGUoZGVyKSB7XG5cdGlmIChkZXIucGVlaygpID09PSAweDAwKVxuXHRcdGRlci5yZWFkQnl0ZSgpO1xuXG5cdGRlci5yZWFkU2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHR2YXIgayA9IGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLk9jdGV0U3RyaW5nLCB0cnVlKTtcblx0ayA9IHV0aWxzLnplcm9QYWRUb0xlbmd0aChrLCAzMik7XG5cblx0dmFyIEEsIHRhZztcblx0d2hpbGUgKCh0YWcgPSBkZXIucGVlaygpKSAhPT0gbnVsbCkge1xuXHRcdGlmICh0YWcgPT09IChhc24xLkJlci5Db250ZXh0IHwgMSkpIHtcblx0XHRcdEEgPSB1dGlscy5yZWFkQml0U3RyaW5nKGRlciwgdGFnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVyLnJlYWRTZXF1ZW5jZSh0YWcpO1xuXHRcdFx0ZGVyLl9vZmZzZXQgKz0gZGVyLmxlbmd0aDtcblx0XHR9XG5cdH1cblx0aWYgKEEgPT09IHVuZGVmaW5lZClcblx0XHRBID0gdXRpbHMuY2FsY3VsYXRlRUQyNTUxOVB1YmxpYyhrKTtcblxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdlZDI1NTE5Jyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnQScsIGRhdGE6IHV0aWxzLnplcm9QYWRUb0xlbmd0aChBLCAzMikgfSxcblx0XHRcdHsgbmFtZTogJ2snLCBkYXRhOiB1dGlscy56ZXJvUGFkVG9MZW5ndGgoaywgMzIpIH1cblx0XHRdXG5cdH07XG5cblx0cmV0dXJuIChuZXcgUHJpdmF0ZUtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3M4WDI1NTE5UHJpdmF0ZShkZXIpIHtcblx0aWYgKGRlci5wZWVrKCkgPT09IDB4MDApXG5cdFx0ZGVyLnJlYWRCeXRlKCk7XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdHZhciBrID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuT2N0ZXRTdHJpbmcsIHRydWUpO1xuXHRrID0gdXRpbHMuemVyb1BhZFRvTGVuZ3RoKGssIDMyKTtcblxuXHR2YXIgQSA9IHV0aWxzLmNhbGN1bGF0ZVgyNTUxOVB1YmxpYyhrKTtcblxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdjdXJ2ZTI1NTE5Jyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnQScsIGRhdGE6IHV0aWxzLnplcm9QYWRUb0xlbmd0aChBLCAzMikgfSxcblx0XHRcdHsgbmFtZTogJ2snLCBkYXRhOiB1dGlscy56ZXJvUGFkVG9MZW5ndGgoaywgMzIpIH1cblx0XHRdXG5cdH07XG5cblx0cmV0dXJuIChuZXcgUHJpdmF0ZUtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcGtjczhUb0J1ZmZlcihrZXkpIHtcblx0dmFyIGRlciA9IG5ldyBhc24xLkJlcldyaXRlcigpO1xuXHR3cml0ZVBrY3M4KGRlciwga2V5KTtcblx0cmV0dXJuIChkZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzOChkZXIsIGtleSkge1xuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXG5cdGlmIChQcml2YXRlS2V5LmlzUHJpdmF0ZUtleShrZXkpKSB7XG5cdFx0dmFyIHZlcnNpb24gPSAwO1xuXHRcdGlmIChrZXkudHlwZSA9PT0gJ2VkMjU1MTknKVxuXHRcdFx0dmVyc2lvbiA9IDE7XG5cdFx0dmFyIHZidWYgPSBCdWZmZXIuZnJvbShbdmVyc2lvbl0pO1xuXHRcdGRlci53cml0ZUJ1ZmZlcih2YnVmLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0fVxuXG5cdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cdHN3aXRjaCAoa2V5LnR5cGUpIHtcblx0Y2FzZSAncnNhJzpcblx0XHRkZXIud3JpdGVPSUQoJzEuMi44NDAuMTEzNTQ5LjEuMS4xJyk7XG5cdFx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpXG5cdFx0XHR3cml0ZVBrY3M4UlNBUHJpdmF0ZShrZXksIGRlcik7XG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVQa2NzOFJTQVB1YmxpYyhrZXksIGRlcik7XG5cdFx0YnJlYWs7XG5cdGNhc2UgJ2RzYSc6XG5cdFx0ZGVyLndyaXRlT0lEKCcxLjIuODQwLjEwMDQwLjQuMScpO1xuXHRcdGlmIChQcml2YXRlS2V5LmlzUHJpdmF0ZUtleShrZXkpKVxuXHRcdFx0d3JpdGVQa2NzOERTQVByaXZhdGUoa2V5LCBkZXIpO1xuXHRcdGVsc2Vcblx0XHRcdHdyaXRlUGtjczhEU0FQdWJsaWMoa2V5LCBkZXIpO1xuXHRcdGJyZWFrO1xuXHRjYXNlICdlY2RzYSc6XG5cdFx0ZGVyLndyaXRlT0lEKCcxLjIuODQwLjEwMDQ1LjIuMScpO1xuXHRcdGlmIChQcml2YXRlS2V5LmlzUHJpdmF0ZUtleShrZXkpKVxuXHRcdFx0d3JpdGVQa2NzOEVDRFNBUHJpdmF0ZShrZXksIGRlcik7XG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVQa2NzOEVDRFNBUHVibGljKGtleSwgZGVyKTtcblx0XHRicmVhaztcblx0Y2FzZSAnZWQyNTUxOSc6XG5cdFx0ZGVyLndyaXRlT0lEKCcxLjMuMTAxLjExMicpO1xuXHRcdGlmIChQcml2YXRlS2V5LmlzUHJpdmF0ZUtleShrZXkpKVxuXHRcdFx0d3JpdGVQa2NzOEVkRFNBUHJpdmF0ZShrZXksIGRlcik7XG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVQa2NzOEVkRFNBUHVibGljKGtleSwgZGVyKTtcblx0XHRicmVhaztcblx0ZGVmYXVsdDpcblx0XHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZXkgdHlwZTogJyArIGtleS50eXBlKSk7XG5cdH1cblxuXHRkZXIuZW5kU2VxdWVuY2UoKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzOFJTQVByaXZhdGUoa2V5LCBkZXIpIHtcblx0ZGVyLndyaXRlTnVsbCgpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cblx0dmFyIHZlcnNpb24gPSBCdWZmZXIuZnJvbShbMF0pO1xuXHRkZXIud3JpdGVCdWZmZXIodmVyc2lvbiwgYXNuMS5CZXIuSW50ZWdlcik7XG5cblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0Lm4uZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5lLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZC5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnAuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5xLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRpZiAoIWtleS5wYXJ0LmRtb2RwIHx8ICFrZXkucGFydC5kbW9kcSlcblx0XHR1dGlscy5hZGRSU0FNaXNzaW5nKGtleSk7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5kbW9kcC5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmRtb2RxLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuaXFtcC5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblxuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczhSU0FQdWJsaWMoa2V5LCBkZXIpIHtcblx0ZGVyLndyaXRlTnVsbCgpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZShhc24xLkJlci5CaXRTdHJpbmcpO1xuXHRkZXIud3JpdGVCeXRlKDB4MDApO1xuXG5cdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5uLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZS5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczhEU0FQcml2YXRlKGtleSwgZGVyKSB7XG5cdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5wLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQucS5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmcuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdGRlci5zdGFydFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnguZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3M4RFNBUHVibGljKGtleSwgZGVyKSB7XG5cdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5wLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQucS5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmcuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZShhc24xLkJlci5CaXRTdHJpbmcpO1xuXHRkZXIud3JpdGVCeXRlKDB4MDApO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQueS5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRUNEU0FDdXJ2ZShrZXksIGRlcikge1xuXHR2YXIgY3VydmUgPSBhbGdzLmN1cnZlc1trZXkuY3VydmVdO1xuXHRpZiAoY3VydmUucGtjczhvaWQpIHtcblx0XHQvKiBUaGlzIG9uZSBoYXMgYSBuYW1lIGluIHBrY3MjOCwgc28ganVzdCB3cml0ZSB0aGUgb2lkICovXG5cdFx0ZGVyLndyaXRlT0lEKGN1cnZlLnBrY3M4b2lkKTtcblxuXHR9IGVsc2Uge1xuXHRcdC8vIEVDUGFyYW1ldGVycyBzZXF1ZW5jZVxuXHRcdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cblx0XHR2YXIgdmVyc2lvbiA9IEJ1ZmZlci5mcm9tKFsxXSk7XG5cdFx0ZGVyLndyaXRlQnVmZmVyKHZlcnNpb24sIGFzbjEuQmVyLkludGVnZXIpO1xuXG5cdFx0Ly8gRmllbGRJRCBzZXF1ZW5jZVxuXHRcdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cdFx0ZGVyLndyaXRlT0lEKCcxLjIuODQwLjEwMDQ1LjEuMScpOyAvLyBwcmltZS1maWVsZFxuXHRcdGRlci53cml0ZUJ1ZmZlcihjdXJ2ZS5wLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRcdC8vIEN1cnZlIHNlcXVlbmNlXG5cdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblx0XHR2YXIgYSA9IGN1cnZlLnA7XG5cdFx0aWYgKGFbMF0gPT09IDB4MClcblx0XHRcdGEgPSBhLnNsaWNlKDEpO1xuXHRcdGRlci53cml0ZUJ1ZmZlcihhLCBhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdFx0ZGVyLndyaXRlQnVmZmVyKGN1cnZlLmIsIGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0XHRkZXIud3JpdGVCdWZmZXIoY3VydmUucywgYXNuMS5CZXIuQml0U3RyaW5nKTtcblx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRcdGRlci53cml0ZUJ1ZmZlcihjdXJ2ZS5HLCBhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdFx0ZGVyLndyaXRlQnVmZmVyKGN1cnZlLm4sIGFzbjEuQmVyLkludGVnZXIpO1xuXHRcdHZhciBoID0gY3VydmUuaDtcblx0XHRpZiAoIWgpIHtcblx0XHRcdGggPSBCdWZmZXIuZnJvbShbMV0pO1xuXHRcdH1cblx0XHRkZXIud3JpdGVCdWZmZXIoaCwgYXNuMS5CZXIuSW50ZWdlcik7XG5cblx0XHQvLyBFQ1BhcmFtZXRlcnNcblx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0fVxufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3M4RUNEU0FQdWJsaWMoa2V5LCBkZXIpIHtcblx0d3JpdGVFQ0RTQUN1cnZlKGtleSwgZGVyKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0dmFyIFEgPSB1dGlscy5lY05vcm1hbGl6ZShrZXkucGFydC5RLmRhdGEsIHRydWUpO1xuXHRkZXIud3JpdGVCdWZmZXIoUSwgYXNuMS5CZXIuQml0U3RyaW5nKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzOEVDRFNBUHJpdmF0ZShrZXksIGRlcikge1xuXHR3cml0ZUVDRFNBQ3VydmUoa2V5LCBkZXIpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cblx0dmFyIHZlcnNpb24gPSBCdWZmZXIuZnJvbShbMV0pO1xuXHRkZXIud3JpdGVCdWZmZXIodmVyc2lvbiwgYXNuMS5CZXIuSW50ZWdlcik7XG5cblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmQuZGF0YSwgYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXG5cdGRlci5zdGFydFNlcXVlbmNlKDB4YTEpO1xuXHR2YXIgUSA9IHV0aWxzLmVjTm9ybWFsaXplKGtleS5wYXJ0LlEuZGF0YSwgdHJ1ZSk7XG5cdGRlci53cml0ZUJ1ZmZlcihRLCBhc24xLkJlci5CaXRTdHJpbmcpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczhFZERTQVB1YmxpYyhrZXksIGRlcikge1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHR1dGlscy53cml0ZUJpdFN0cmluZyhkZXIsIGtleS5wYXJ0LkEuZGF0YSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczhFZERTQVByaXZhdGUoa2V5LCBkZXIpIHtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHR2YXIgayA9IHV0aWxzLm1wTm9ybWFsaXplKGtleS5wYXJ0LmsuZGF0YSk7XG5cdC8qIFJGQ3MgY2FsbCBmb3Igc3RvcmluZyBleGFjdGx5IDMyIGJ5dGVzLCBzbyBzdHJpcCBhbnkgbGVhZGluZyB6ZXJvcyAqL1xuXHR3aGlsZSAoay5sZW5ndGggPiAzMiAmJiBrWzBdID09PSAweDAwKVxuXHRcdGsgPSBrLnNsaWNlKDEpO1xuXHRkZXIud3JpdGVCdWZmZXIoaywgYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHR1dGlscy53cml0ZUJpdFN0cmluZyhkZXIsIGtleS5wYXJ0LkEuZGF0YSwgYXNuMS5CZXIuQ29udGV4dCB8IDEpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/formats/pkcs8.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/formats/putty.js":
/*!*************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/putty.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2018 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar rfc4253 = __webpack_require__(/*! ./rfc4253 */ \"(action-browser)/./node_modules/sshpk/lib/formats/rfc4253.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ \"(action-browser)/./node_modules/sshpk/lib/ssh-buffer.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\n\nvar errors = __webpack_require__(/*! ../errors */ \"(action-browser)/./node_modules/sshpk/lib/errors.js\");\n\n// https://tartarus.org/~simon/putty-prerel-snapshots/htmldoc/AppendixC.html\nfunction read(buf, options) {\n\tvar lines = buf.toString('ascii').split(/[\\r\\n]+/);\n\tvar found = false;\n\tvar parts;\n\tvar si = 0;\n\tvar formatVersion;\n\twhile (si < lines.length) {\n\t\tparts = splitHeader(lines[si++]);\n\t\tif (parts) {\n\t\t\tformatVersion = {\n\t\t\t\t'putty-user-key-file-2': 2,\n\t\t\t\t'putty-user-key-file-3': 3\n\t\t\t}[parts[0].toLowerCase()];\n\t\t\tif (formatVersion) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!found) {\n\t\tthrow (new Error('No PuTTY format first line found'));\n\t}\n\tvar alg = parts[1];\n\n\tparts = splitHeader(lines[si++]);\n\tassert.equal(parts[0].toLowerCase(), 'encryption');\n\tvar encryption = parts[1];\n\n\tparts = splitHeader(lines[si++]);\n\tassert.equal(parts[0].toLowerCase(), 'comment');\n\tvar comment = parts[1];\n\n\tparts = splitHeader(lines[si++]);\n\tassert.equal(parts[0].toLowerCase(), 'public-lines');\n\tvar publicLines = parseInt(parts[1], 10);\n\tif (!isFinite(publicLines) || publicLines < 0 ||\n\t    publicLines > lines.length) {\n\t\tthrow (new Error('Invalid public-lines count'));\n\t}\n\n\tvar publicBuf = Buffer.from(\n\t    lines.slice(si, si + publicLines).join(''), 'base64');\n\tvar keyType = rfc4253.algToKeyType(alg);\n\tvar key = rfc4253.read(publicBuf);\n\tif (key.type !== keyType) {\n\t\tthrow (new Error('Outer key algorithm mismatch'));\n\t}\n\n\tsi += publicLines;\n\tif (lines[si]) {\n\t\tparts = splitHeader(lines[si++]);\n\t\tassert.equal(parts[0].toLowerCase(), 'private-lines');\n\t\tvar privateLines = parseInt(parts[1], 10);\n\t\tif (!isFinite(privateLines) || privateLines < 0 ||\n\t\t    privateLines > lines.length) {\n\t\t\tthrow (new Error('Invalid private-lines count'));\n\t\t}\n\n\t\tvar privateBuf = Buffer.from(\n\t\t\tlines.slice(si, si + privateLines).join(''), 'base64');\n\n\t\tif (encryption !== 'none' && formatVersion === 3) {\n\t\t\tthrow new Error('Encrypted keys arenot supported for' +\n\t\t\t' PuTTY format version 3');\n\t\t}\n\n\t\tif (encryption === 'aes256-cbc') {\n\t\t\tif (!options.passphrase) {\n\t\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t\t\toptions.filename, 'PEM'));\n\t\t\t}\n\n\t\t\tvar iv = Buffer.alloc(16, 0);\n\t\t\tvar decipher = crypto.createDecipheriv(\n\t\t\t\t'aes-256-cbc',\n\t\t\t\tderivePPK2EncryptionKey(options.passphrase),\n\t\t\t\tiv);\n\t\t\tdecipher.setAutoPadding(false);\n\t\t\tprivateBuf = Buffer.concat([\n\t\t\t\tdecipher.update(privateBuf), decipher.final()]);\n\t\t}\n\n\t\tkey = new PrivateKey(key);\n\t\tif (key.type !== keyType) {\n\t\t\tthrow (new Error('Outer key algorithm mismatch'));\n\t\t}\n\n\t\tvar sshbuf = new SSHBuffer({buffer: privateBuf});\n\t\tvar privateKeyParts;\n\t\tif (alg === 'ssh-dss') {\n\t\t\tprivateKeyParts = [ {\n\t\t\t\tname: 'x',\n\t\t\t\tdata: sshbuf.readBuffer()\n\t\t\t}];\n\t\t} else if (alg === 'ssh-rsa') {\n\t\t\tprivateKeyParts = [\n\t\t\t\t{ name: 'd', data: sshbuf.readBuffer() },\n\t\t\t\t{ name: 'p', data: sshbuf.readBuffer() },\n\t\t\t\t{ name: 'q', data: sshbuf.readBuffer() },\n\t\t\t\t{ name: 'iqmp', data: sshbuf.readBuffer() }\n\t\t\t];\n\t\t} else if (alg.match(/^ecdsa-sha2-nistp/)) {\n\t\t\tprivateKeyParts = [ {\n\t\t\t\tname: 'd', data: sshbuf.readBuffer()\n\t\t\t} ];\n\t\t} else if (alg === 'ssh-ed25519') {\n\t\t\tprivateKeyParts = [ {\n\t\t\t\tname: 'k', data: sshbuf.readBuffer()\n\t\t\t} ];\n\t\t} else {\n\t\t\tthrow new Error('Unsupported PPK key type: ' + alg);\n\t\t}\n\n\t\tkey = new PrivateKey({\n\t\t\ttype: key.type,\n\t\t\tparts: key.parts.concat(privateKeyParts)\n\t\t});\n\t}\n\n\tkey.comment = comment;\n\treturn (key);\n}\n\nfunction derivePPK2EncryptionKey(passphrase) {\n\tvar hash1 = crypto.createHash('sha1').update(Buffer.concat([\n\t\tBuffer.from([0, 0, 0, 0]),\n\t\tBuffer.from(passphrase)\n\t])).digest();\n\tvar hash2 = crypto.createHash('sha1').update(Buffer.concat([\n\t\tBuffer.from([0, 0, 0, 1]),\n\t\tBuffer.from(passphrase)\n\t])).digest();\n\treturn (Buffer.concat([hash1, hash2]).slice(0, 32));\n}\n\nfunction splitHeader(line) {\n\tvar idx = line.indexOf(':');\n\tif (idx === -1)\n\t\treturn (null);\n\tvar header = line.slice(0, idx);\n\t++idx;\n\twhile (line[idx] === ' ')\n\t\t++idx;\n\tvar rest = line.slice(idx);\n\treturn ([header, rest]);\n}\n\nfunction write(key, options) {\n\tassert.object(key);\n\tif (!Key.isKey(key))\n\t\tthrow (new Error('Must be a public key'));\n\n\tvar alg = rfc4253.keyTypeToAlg(key);\n\tvar buf = rfc4253.write(key);\n\tvar comment = key.comment || '';\n\n\tvar b64 = buf.toString('base64');\n\tvar lines = wrap(b64, 64);\n\n\tlines.unshift('Public-Lines: ' + lines.length);\n\tlines.unshift('Comment: ' + comment);\n\tlines.unshift('Encryption: none');\n\tlines.unshift('PuTTY-User-Key-File-2: ' + alg);\n\n\treturn (Buffer.from(lines.join('\\n') + '\\n'));\n}\n\nfunction wrap(txt, len) {\n\tvar lines = [];\n\tvar pos = 0;\n\twhile (pos < txt.length) {\n\t\tlines.push(txt.slice(pos, pos + 64));\n\t\tpos += 64;\n\t}\n\treturn (lines);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9wdXR0eS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsMEVBQWE7QUFDbEMsYUFBYSx5R0FBOEI7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLCtFQUFXO0FBQ2pDLFVBQVUsbUJBQU8sQ0FBQyxnRUFBUTtBQUMxQixnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBZTtBQUN2QyxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQWdCOztBQUV6QyxhQUFhLG1CQUFPLENBQUMsc0VBQVc7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSjtBQUNBLE1BQU0sc0NBQXNDO0FBQzVDLE1BQU0sc0NBQXNDO0FBQzVDLE1BQU0sc0NBQXNDO0FBQzVDLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9wdXR0eS5qcz9mMDQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE4IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgcmZjNDI1MyA9IHJlcXVpcmUoJy4vcmZjNDI1MycpO1xudmFyIEtleSA9IHJlcXVpcmUoJy4uL2tleScpO1xudmFyIFNTSEJ1ZmZlciA9IHJlcXVpcmUoJy4uL3NzaC1idWZmZXInKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZS1rZXknKTtcblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuXG4vLyBodHRwczovL3RhcnRhcnVzLm9yZy9+c2ltb24vcHV0dHktcHJlcmVsLXNuYXBzaG90cy9odG1sZG9jL0FwcGVuZGl4Qy5odG1sXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb3B0aW9ucykge1xuXHR2YXIgbGluZXMgPSBidWYudG9TdHJpbmcoJ2FzY2lpJykuc3BsaXQoL1tcXHJcXG5dKy8pO1xuXHR2YXIgZm91bmQgPSBmYWxzZTtcblx0dmFyIHBhcnRzO1xuXHR2YXIgc2kgPSAwO1xuXHR2YXIgZm9ybWF0VmVyc2lvbjtcblx0d2hpbGUgKHNpIDwgbGluZXMubGVuZ3RoKSB7XG5cdFx0cGFydHMgPSBzcGxpdEhlYWRlcihsaW5lc1tzaSsrXSk7XG5cdFx0aWYgKHBhcnRzKSB7XG5cdFx0XHRmb3JtYXRWZXJzaW9uID0ge1xuXHRcdFx0XHQncHV0dHktdXNlci1rZXktZmlsZS0yJzogMixcblx0XHRcdFx0J3B1dHR5LXVzZXIta2V5LWZpbGUtMyc6IDNcblx0XHRcdH1bcGFydHNbMF0udG9Mb3dlckNhc2UoKV07XG5cdFx0XHRpZiAoZm9ybWF0VmVyc2lvbikge1xuXHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZiAoIWZvdW5kKSB7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignTm8gUHVUVFkgZm9ybWF0IGZpcnN0IGxpbmUgZm91bmQnKSk7XG5cdH1cblx0dmFyIGFsZyA9IHBhcnRzWzFdO1xuXG5cdHBhcnRzID0gc3BsaXRIZWFkZXIobGluZXNbc2krK10pO1xuXHRhc3NlcnQuZXF1YWwocGFydHNbMF0udG9Mb3dlckNhc2UoKSwgJ2VuY3J5cHRpb24nKTtcblx0dmFyIGVuY3J5cHRpb24gPSBwYXJ0c1sxXTtcblxuXHRwYXJ0cyA9IHNwbGl0SGVhZGVyKGxpbmVzW3NpKytdKTtcblx0YXNzZXJ0LmVxdWFsKHBhcnRzWzBdLnRvTG93ZXJDYXNlKCksICdjb21tZW50Jyk7XG5cdHZhciBjb21tZW50ID0gcGFydHNbMV07XG5cblx0cGFydHMgPSBzcGxpdEhlYWRlcihsaW5lc1tzaSsrXSk7XG5cdGFzc2VydC5lcXVhbChwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLCAncHVibGljLWxpbmVzJyk7XG5cdHZhciBwdWJsaWNMaW5lcyA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7XG5cdGlmICghaXNGaW5pdGUocHVibGljTGluZXMpIHx8IHB1YmxpY0xpbmVzIDwgMCB8fFxuXHQgICAgcHVibGljTGluZXMgPiBsaW5lcy5sZW5ndGgpIHtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdJbnZhbGlkIHB1YmxpYy1saW5lcyBjb3VudCcpKTtcblx0fVxuXG5cdHZhciBwdWJsaWNCdWYgPSBCdWZmZXIuZnJvbShcblx0ICAgIGxpbmVzLnNsaWNlKHNpLCBzaSArIHB1YmxpY0xpbmVzKS5qb2luKCcnKSwgJ2Jhc2U2NCcpO1xuXHR2YXIga2V5VHlwZSA9IHJmYzQyNTMuYWxnVG9LZXlUeXBlKGFsZyk7XG5cdHZhciBrZXkgPSByZmM0MjUzLnJlYWQocHVibGljQnVmKTtcblx0aWYgKGtleS50eXBlICE9PSBrZXlUeXBlKSB7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignT3V0ZXIga2V5IGFsZ29yaXRobSBtaXNtYXRjaCcpKTtcblx0fVxuXG5cdHNpICs9IHB1YmxpY0xpbmVzO1xuXHRpZiAobGluZXNbc2ldKSB7XG5cdFx0cGFydHMgPSBzcGxpdEhlYWRlcihsaW5lc1tzaSsrXSk7XG5cdFx0YXNzZXJ0LmVxdWFsKHBhcnRzWzBdLnRvTG93ZXJDYXNlKCksICdwcml2YXRlLWxpbmVzJyk7XG5cdFx0dmFyIHByaXZhdGVMaW5lcyA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7XG5cdFx0aWYgKCFpc0Zpbml0ZShwcml2YXRlTGluZXMpIHx8IHByaXZhdGVMaW5lcyA8IDAgfHxcblx0XHQgICAgcHJpdmF0ZUxpbmVzID4gbGluZXMubGVuZ3RoKSB7XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdJbnZhbGlkIHByaXZhdGUtbGluZXMgY291bnQnKSk7XG5cdFx0fVxuXG5cdFx0dmFyIHByaXZhdGVCdWYgPSBCdWZmZXIuZnJvbShcblx0XHRcdGxpbmVzLnNsaWNlKHNpLCBzaSArIHByaXZhdGVMaW5lcykuam9pbignJyksICdiYXNlNjQnKTtcblxuXHRcdGlmIChlbmNyeXB0aW9uICE9PSAnbm9uZScgJiYgZm9ybWF0VmVyc2lvbiA9PT0gMykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0ZWQga2V5cyBhcmVub3Qgc3VwcG9ydGVkIGZvcicgK1xuXHRcdFx0JyBQdVRUWSBmb3JtYXQgdmVyc2lvbiAzJyk7XG5cdFx0fVxuXG5cdFx0aWYgKGVuY3J5cHRpb24gPT09ICdhZXMyNTYtY2JjJykge1xuXHRcdFx0aWYgKCFvcHRpb25zLnBhc3NwaHJhc2UpIHtcblx0XHRcdFx0dGhyb3cgKG5ldyBlcnJvcnMuS2V5RW5jcnlwdGVkRXJyb3IoXG5cdFx0XHRcdFx0b3B0aW9ucy5maWxlbmFtZSwgJ1BFTScpKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGl2ID0gQnVmZmVyLmFsbG9jKDE2LCAwKTtcblx0XHRcdHZhciBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KFxuXHRcdFx0XHQnYWVzLTI1Ni1jYmMnLFxuXHRcdFx0XHRkZXJpdmVQUEsyRW5jcnlwdGlvbktleShvcHRpb25zLnBhc3NwaHJhc2UpLFxuXHRcdFx0XHRpdik7XG5cdFx0XHRkZWNpcGhlci5zZXRBdXRvUGFkZGluZyhmYWxzZSk7XG5cdFx0XHRwcml2YXRlQnVmID0gQnVmZmVyLmNvbmNhdChbXG5cdFx0XHRcdGRlY2lwaGVyLnVwZGF0ZShwcml2YXRlQnVmKSwgZGVjaXBoZXIuZmluYWwoKV0pO1xuXHRcdH1cblxuXHRcdGtleSA9IG5ldyBQcml2YXRlS2V5KGtleSk7XG5cdFx0aWYgKGtleS50eXBlICE9PSBrZXlUeXBlKSB7XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdPdXRlciBrZXkgYWxnb3JpdGhtIG1pc21hdGNoJykpO1xuXHRcdH1cblxuXHRcdHZhciBzc2hidWYgPSBuZXcgU1NIQnVmZmVyKHtidWZmZXI6IHByaXZhdGVCdWZ9KTtcblx0XHR2YXIgcHJpdmF0ZUtleVBhcnRzO1xuXHRcdGlmIChhbGcgPT09ICdzc2gtZHNzJykge1xuXHRcdFx0cHJpdmF0ZUtleVBhcnRzID0gWyB7XG5cdFx0XHRcdG5hbWU6ICd4Jyxcblx0XHRcdFx0ZGF0YTogc3NoYnVmLnJlYWRCdWZmZXIoKVxuXHRcdFx0fV07XG5cdFx0fSBlbHNlIGlmIChhbGcgPT09ICdzc2gtcnNhJykge1xuXHRcdFx0cHJpdmF0ZUtleVBhcnRzID0gW1xuXHRcdFx0XHR7IG5hbWU6ICdkJywgZGF0YTogc3NoYnVmLnJlYWRCdWZmZXIoKSB9LFxuXHRcdFx0XHR7IG5hbWU6ICdwJywgZGF0YTogc3NoYnVmLnJlYWRCdWZmZXIoKSB9LFxuXHRcdFx0XHR7IG5hbWU6ICdxJywgZGF0YTogc3NoYnVmLnJlYWRCdWZmZXIoKSB9LFxuXHRcdFx0XHR7IG5hbWU6ICdpcW1wJywgZGF0YTogc3NoYnVmLnJlYWRCdWZmZXIoKSB9XG5cdFx0XHRdO1xuXHRcdH0gZWxzZSBpZiAoYWxnLm1hdGNoKC9eZWNkc2Etc2hhMi1uaXN0cC8pKSB7XG5cdFx0XHRwcml2YXRlS2V5UGFydHMgPSBbIHtcblx0XHRcdFx0bmFtZTogJ2QnLCBkYXRhOiBzc2hidWYucmVhZEJ1ZmZlcigpXG5cdFx0XHR9IF07XG5cdFx0fSBlbHNlIGlmIChhbGcgPT09ICdzc2gtZWQyNTUxOScpIHtcblx0XHRcdHByaXZhdGVLZXlQYXJ0cyA9IFsge1xuXHRcdFx0XHRuYW1lOiAnaycsIGRhdGE6IHNzaGJ1Zi5yZWFkQnVmZmVyKClcblx0XHRcdH0gXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQUEsga2V5IHR5cGU6ICcgKyBhbGcpO1xuXHRcdH1cblxuXHRcdGtleSA9IG5ldyBQcml2YXRlS2V5KHtcblx0XHRcdHR5cGU6IGtleS50eXBlLFxuXHRcdFx0cGFydHM6IGtleS5wYXJ0cy5jb25jYXQocHJpdmF0ZUtleVBhcnRzKVxuXHRcdH0pO1xuXHR9XG5cblx0a2V5LmNvbW1lbnQgPSBjb21tZW50O1xuXHRyZXR1cm4gKGtleSk7XG59XG5cbmZ1bmN0aW9uIGRlcml2ZVBQSzJFbmNyeXB0aW9uS2V5KHBhc3NwaHJhc2UpIHtcblx0dmFyIGhhc2gxID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoQnVmZmVyLmNvbmNhdChbXG5cdFx0QnVmZmVyLmZyb20oWzAsIDAsIDAsIDBdKSxcblx0XHRCdWZmZXIuZnJvbShwYXNzcGhyYXNlKVxuXHRdKSkuZGlnZXN0KCk7XG5cdHZhciBoYXNoMiA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKEJ1ZmZlci5jb25jYXQoW1xuXHRcdEJ1ZmZlci5mcm9tKFswLCAwLCAwLCAxXSksXG5cdFx0QnVmZmVyLmZyb20ocGFzc3BocmFzZSlcblx0XSkpLmRpZ2VzdCgpO1xuXHRyZXR1cm4gKEJ1ZmZlci5jb25jYXQoW2hhc2gxLCBoYXNoMl0pLnNsaWNlKDAsIDMyKSk7XG59XG5cbmZ1bmN0aW9uIHNwbGl0SGVhZGVyKGxpbmUpIHtcblx0dmFyIGlkeCA9IGxpbmUuaW5kZXhPZignOicpO1xuXHRpZiAoaWR4ID09PSAtMSlcblx0XHRyZXR1cm4gKG51bGwpO1xuXHR2YXIgaGVhZGVyID0gbGluZS5zbGljZSgwLCBpZHgpO1xuXHQrK2lkeDtcblx0d2hpbGUgKGxpbmVbaWR4XSA9PT0gJyAnKVxuXHRcdCsraWR4O1xuXHR2YXIgcmVzdCA9IGxpbmUuc2xpY2UoaWR4KTtcblx0cmV0dXJuIChbaGVhZGVyLCByZXN0XSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgb3B0aW9ucykge1xuXHRhc3NlcnQub2JqZWN0KGtleSk7XG5cdGlmICghS2V5LmlzS2V5KGtleSkpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignTXVzdCBiZSBhIHB1YmxpYyBrZXknKSk7XG5cblx0dmFyIGFsZyA9IHJmYzQyNTMua2V5VHlwZVRvQWxnKGtleSk7XG5cdHZhciBidWYgPSByZmM0MjUzLndyaXRlKGtleSk7XG5cdHZhciBjb21tZW50ID0ga2V5LmNvbW1lbnQgfHwgJyc7XG5cblx0dmFyIGI2NCA9IGJ1Zi50b1N0cmluZygnYmFzZTY0Jyk7XG5cdHZhciBsaW5lcyA9IHdyYXAoYjY0LCA2NCk7XG5cblx0bGluZXMudW5zaGlmdCgnUHVibGljLUxpbmVzOiAnICsgbGluZXMubGVuZ3RoKTtcblx0bGluZXMudW5zaGlmdCgnQ29tbWVudDogJyArIGNvbW1lbnQpO1xuXHRsaW5lcy51bnNoaWZ0KCdFbmNyeXB0aW9uOiBub25lJyk7XG5cdGxpbmVzLnVuc2hpZnQoJ1B1VFRZLVVzZXItS2V5LUZpbGUtMjogJyArIGFsZyk7XG5cblx0cmV0dXJuIChCdWZmZXIuZnJvbShsaW5lcy5qb2luKCdcXG4nKSArICdcXG4nKSk7XG59XG5cbmZ1bmN0aW9uIHdyYXAodHh0LCBsZW4pIHtcblx0dmFyIGxpbmVzID0gW107XG5cdHZhciBwb3MgPSAwO1xuXHR3aGlsZSAocG9zIDwgdHh0Lmxlbmd0aCkge1xuXHRcdGxpbmVzLnB1c2godHh0LnNsaWNlKHBvcywgcG9zICsgNjQpKTtcblx0XHRwb3MgKz0gNjQ7XG5cdH1cblx0cmV0dXJuIChsaW5lcyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/formats/putty.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/formats/putty.js":
/*!*************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/putty.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2018 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar rfc4253 = __webpack_require__(/*! ./rfc4253 */ \"(rsc)/./node_modules/sshpk/lib/formats/rfc4253.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ \"(rsc)/./node_modules/sshpk/lib/ssh-buffer.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\n\nvar errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/sshpk/lib/errors.js\");\n\n// https://tartarus.org/~simon/putty-prerel-snapshots/htmldoc/AppendixC.html\nfunction read(buf, options) {\n\tvar lines = buf.toString('ascii').split(/[\\r\\n]+/);\n\tvar found = false;\n\tvar parts;\n\tvar si = 0;\n\tvar formatVersion;\n\twhile (si < lines.length) {\n\t\tparts = splitHeader(lines[si++]);\n\t\tif (parts) {\n\t\t\tformatVersion = {\n\t\t\t\t'putty-user-key-file-2': 2,\n\t\t\t\t'putty-user-key-file-3': 3\n\t\t\t}[parts[0].toLowerCase()];\n\t\t\tif (formatVersion) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!found) {\n\t\tthrow (new Error('No PuTTY format first line found'));\n\t}\n\tvar alg = parts[1];\n\n\tparts = splitHeader(lines[si++]);\n\tassert.equal(parts[0].toLowerCase(), 'encryption');\n\tvar encryption = parts[1];\n\n\tparts = splitHeader(lines[si++]);\n\tassert.equal(parts[0].toLowerCase(), 'comment');\n\tvar comment = parts[1];\n\n\tparts = splitHeader(lines[si++]);\n\tassert.equal(parts[0].toLowerCase(), 'public-lines');\n\tvar publicLines = parseInt(parts[1], 10);\n\tif (!isFinite(publicLines) || publicLines < 0 ||\n\t    publicLines > lines.length) {\n\t\tthrow (new Error('Invalid public-lines count'));\n\t}\n\n\tvar publicBuf = Buffer.from(\n\t    lines.slice(si, si + publicLines).join(''), 'base64');\n\tvar keyType = rfc4253.algToKeyType(alg);\n\tvar key = rfc4253.read(publicBuf);\n\tif (key.type !== keyType) {\n\t\tthrow (new Error('Outer key algorithm mismatch'));\n\t}\n\n\tsi += publicLines;\n\tif (lines[si]) {\n\t\tparts = splitHeader(lines[si++]);\n\t\tassert.equal(parts[0].toLowerCase(), 'private-lines');\n\t\tvar privateLines = parseInt(parts[1], 10);\n\t\tif (!isFinite(privateLines) || privateLines < 0 ||\n\t\t    privateLines > lines.length) {\n\t\t\tthrow (new Error('Invalid private-lines count'));\n\t\t}\n\n\t\tvar privateBuf = Buffer.from(\n\t\t\tlines.slice(si, si + privateLines).join(''), 'base64');\n\n\t\tif (encryption !== 'none' && formatVersion === 3) {\n\t\t\tthrow new Error('Encrypted keys arenot supported for' +\n\t\t\t' PuTTY format version 3');\n\t\t}\n\n\t\tif (encryption === 'aes256-cbc') {\n\t\t\tif (!options.passphrase) {\n\t\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t\t\toptions.filename, 'PEM'));\n\t\t\t}\n\n\t\t\tvar iv = Buffer.alloc(16, 0);\n\t\t\tvar decipher = crypto.createDecipheriv(\n\t\t\t\t'aes-256-cbc',\n\t\t\t\tderivePPK2EncryptionKey(options.passphrase),\n\t\t\t\tiv);\n\t\t\tdecipher.setAutoPadding(false);\n\t\t\tprivateBuf = Buffer.concat([\n\t\t\t\tdecipher.update(privateBuf), decipher.final()]);\n\t\t}\n\n\t\tkey = new PrivateKey(key);\n\t\tif (key.type !== keyType) {\n\t\t\tthrow (new Error('Outer key algorithm mismatch'));\n\t\t}\n\n\t\tvar sshbuf = new SSHBuffer({buffer: privateBuf});\n\t\tvar privateKeyParts;\n\t\tif (alg === 'ssh-dss') {\n\t\t\tprivateKeyParts = [ {\n\t\t\t\tname: 'x',\n\t\t\t\tdata: sshbuf.readBuffer()\n\t\t\t}];\n\t\t} else if (alg === 'ssh-rsa') {\n\t\t\tprivateKeyParts = [\n\t\t\t\t{ name: 'd', data: sshbuf.readBuffer() },\n\t\t\t\t{ name: 'p', data: sshbuf.readBuffer() },\n\t\t\t\t{ name: 'q', data: sshbuf.readBuffer() },\n\t\t\t\t{ name: 'iqmp', data: sshbuf.readBuffer() }\n\t\t\t];\n\t\t} else if (alg.match(/^ecdsa-sha2-nistp/)) {\n\t\t\tprivateKeyParts = [ {\n\t\t\t\tname: 'd', data: sshbuf.readBuffer()\n\t\t\t} ];\n\t\t} else if (alg === 'ssh-ed25519') {\n\t\t\tprivateKeyParts = [ {\n\t\t\t\tname: 'k', data: sshbuf.readBuffer()\n\t\t\t} ];\n\t\t} else {\n\t\t\tthrow new Error('Unsupported PPK key type: ' + alg);\n\t\t}\n\n\t\tkey = new PrivateKey({\n\t\t\ttype: key.type,\n\t\t\tparts: key.parts.concat(privateKeyParts)\n\t\t});\n\t}\n\n\tkey.comment = comment;\n\treturn (key);\n}\n\nfunction derivePPK2EncryptionKey(passphrase) {\n\tvar hash1 = crypto.createHash('sha1').update(Buffer.concat([\n\t\tBuffer.from([0, 0, 0, 0]),\n\t\tBuffer.from(passphrase)\n\t])).digest();\n\tvar hash2 = crypto.createHash('sha1').update(Buffer.concat([\n\t\tBuffer.from([0, 0, 0, 1]),\n\t\tBuffer.from(passphrase)\n\t])).digest();\n\treturn (Buffer.concat([hash1, hash2]).slice(0, 32));\n}\n\nfunction splitHeader(line) {\n\tvar idx = line.indexOf(':');\n\tif (idx === -1)\n\t\treturn (null);\n\tvar header = line.slice(0, idx);\n\t++idx;\n\twhile (line[idx] === ' ')\n\t\t++idx;\n\tvar rest = line.slice(idx);\n\treturn ([header, rest]);\n}\n\nfunction write(key, options) {\n\tassert.object(key);\n\tif (!Key.isKey(key))\n\t\tthrow (new Error('Must be a public key'));\n\n\tvar alg = rfc4253.keyTypeToAlg(key);\n\tvar buf = rfc4253.write(key);\n\tvar comment = key.comment || '';\n\n\tvar b64 = buf.toString('base64');\n\tvar lines = wrap(b64, 64);\n\n\tlines.unshift('Public-Lines: ' + lines.length);\n\tlines.unshift('Comment: ' + comment);\n\tlines.unshift('Encryption: none');\n\tlines.unshift('PuTTY-User-Key-File-2: ' + alg);\n\n\treturn (Buffer.from(lines.join('\\n') + '\\n'));\n}\n\nfunction wrap(txt, len) {\n\tvar lines = [];\n\tvar pos = 0;\n\twhile (pos < txt.length) {\n\t\tlines.push(txt.slice(pos, pos + 64));\n\t\tpos += 64;\n\t}\n\treturn (lines);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvcHV0dHkuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLCtEQUFhO0FBQ2xDLGFBQWEsOEZBQThCO0FBQzNDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBVztBQUNqQyxVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWU7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFnQjs7QUFFekMsYUFBYSxtQkFBTyxDQUFDLDJEQUFXOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQSxNQUFNLHNDQUFzQztBQUM1QyxNQUFNLHNDQUFzQztBQUM1QyxNQUFNLHNDQUFzQztBQUM1QyxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvcHV0dHkuanM/YjYyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOCBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHJlYWQ6IHJlYWQsXG5cdHdyaXRlOiB3cml0ZVxufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xudmFyIHJmYzQyNTMgPSByZXF1aXJlKCcuL3JmYzQyNTMnKTtcbnZhciBLZXkgPSByZXF1aXJlKCcuLi9rZXknKTtcbnZhciBTU0hCdWZmZXIgPSByZXF1aXJlKCcuLi9zc2gtYnVmZmVyJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uL3ByaXZhdGUta2V5Jyk7XG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcblxuLy8gaHR0cHM6Ly90YXJ0YXJ1cy5vcmcvfnNpbW9uL3B1dHR5LXByZXJlbC1zbmFwc2hvdHMvaHRtbGRvYy9BcHBlbmRpeEMuaHRtbFxuZnVuY3Rpb24gcmVhZChidWYsIG9wdGlvbnMpIHtcblx0dmFyIGxpbmVzID0gYnVmLnRvU3RyaW5nKCdhc2NpaScpLnNwbGl0KC9bXFxyXFxuXSsvKTtcblx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdHZhciBwYXJ0cztcblx0dmFyIHNpID0gMDtcblx0dmFyIGZvcm1hdFZlcnNpb247XG5cdHdoaWxlIChzaSA8IGxpbmVzLmxlbmd0aCkge1xuXHRcdHBhcnRzID0gc3BsaXRIZWFkZXIobGluZXNbc2krK10pO1xuXHRcdGlmIChwYXJ0cykge1xuXHRcdFx0Zm9ybWF0VmVyc2lvbiA9IHtcblx0XHRcdFx0J3B1dHR5LXVzZXIta2V5LWZpbGUtMic6IDIsXG5cdFx0XHRcdCdwdXR0eS11c2VyLWtleS1maWxlLTMnOiAzXG5cdFx0XHR9W3BhcnRzWzBdLnRvTG93ZXJDYXNlKCldO1xuXHRcdFx0aWYgKGZvcm1hdFZlcnNpb24pIHtcblx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0aWYgKCFmb3VuZCkge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ05vIFB1VFRZIGZvcm1hdCBmaXJzdCBsaW5lIGZvdW5kJykpO1xuXHR9XG5cdHZhciBhbGcgPSBwYXJ0c1sxXTtcblxuXHRwYXJ0cyA9IHNwbGl0SGVhZGVyKGxpbmVzW3NpKytdKTtcblx0YXNzZXJ0LmVxdWFsKHBhcnRzWzBdLnRvTG93ZXJDYXNlKCksICdlbmNyeXB0aW9uJyk7XG5cdHZhciBlbmNyeXB0aW9uID0gcGFydHNbMV07XG5cblx0cGFydHMgPSBzcGxpdEhlYWRlcihsaW5lc1tzaSsrXSk7XG5cdGFzc2VydC5lcXVhbChwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLCAnY29tbWVudCcpO1xuXHR2YXIgY29tbWVudCA9IHBhcnRzWzFdO1xuXG5cdHBhcnRzID0gc3BsaXRIZWFkZXIobGluZXNbc2krK10pO1xuXHRhc3NlcnQuZXF1YWwocGFydHNbMF0udG9Mb3dlckNhc2UoKSwgJ3B1YmxpYy1saW5lcycpO1xuXHR2YXIgcHVibGljTGluZXMgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApO1xuXHRpZiAoIWlzRmluaXRlKHB1YmxpY0xpbmVzKSB8fCBwdWJsaWNMaW5lcyA8IDAgfHxcblx0ICAgIHB1YmxpY0xpbmVzID4gbGluZXMubGVuZ3RoKSB7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignSW52YWxpZCBwdWJsaWMtbGluZXMgY291bnQnKSk7XG5cdH1cblxuXHR2YXIgcHVibGljQnVmID0gQnVmZmVyLmZyb20oXG5cdCAgICBsaW5lcy5zbGljZShzaSwgc2kgKyBwdWJsaWNMaW5lcykuam9pbignJyksICdiYXNlNjQnKTtcblx0dmFyIGtleVR5cGUgPSByZmM0MjUzLmFsZ1RvS2V5VHlwZShhbGcpO1xuXHR2YXIga2V5ID0gcmZjNDI1My5yZWFkKHB1YmxpY0J1Zik7XG5cdGlmIChrZXkudHlwZSAhPT0ga2V5VHlwZSkge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ091dGVyIGtleSBhbGdvcml0aG0gbWlzbWF0Y2gnKSk7XG5cdH1cblxuXHRzaSArPSBwdWJsaWNMaW5lcztcblx0aWYgKGxpbmVzW3NpXSkge1xuXHRcdHBhcnRzID0gc3BsaXRIZWFkZXIobGluZXNbc2krK10pO1xuXHRcdGFzc2VydC5lcXVhbChwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLCAncHJpdmF0ZS1saW5lcycpO1xuXHRcdHZhciBwcml2YXRlTGluZXMgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApO1xuXHRcdGlmICghaXNGaW5pdGUocHJpdmF0ZUxpbmVzKSB8fCBwcml2YXRlTGluZXMgPCAwIHx8XG5cdFx0ICAgIHByaXZhdGVMaW5lcyA+IGxpbmVzLmxlbmd0aCkge1xuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignSW52YWxpZCBwcml2YXRlLWxpbmVzIGNvdW50JykpO1xuXHRcdH1cblxuXHRcdHZhciBwcml2YXRlQnVmID0gQnVmZmVyLmZyb20oXG5cdFx0XHRsaW5lcy5zbGljZShzaSwgc2kgKyBwcml2YXRlTGluZXMpLmpvaW4oJycpLCAnYmFzZTY0Jyk7XG5cblx0XHRpZiAoZW5jcnlwdGlvbiAhPT0gJ25vbmUnICYmIGZvcm1hdFZlcnNpb24gPT09IDMpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignRW5jcnlwdGVkIGtleXMgYXJlbm90IHN1cHBvcnRlZCBmb3InICtcblx0XHRcdCcgUHVUVFkgZm9ybWF0IHZlcnNpb24gMycpO1xuXHRcdH1cblxuXHRcdGlmIChlbmNyeXB0aW9uID09PSAnYWVzMjU2LWNiYycpIHtcblx0XHRcdGlmICghb3B0aW9ucy5wYXNzcGhyYXNlKSB7XG5cdFx0XHRcdHRocm93IChuZXcgZXJyb3JzLktleUVuY3J5cHRlZEVycm9yKFxuXHRcdFx0XHRcdG9wdGlvbnMuZmlsZW5hbWUsICdQRU0nKSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpdiA9IEJ1ZmZlci5hbGxvYygxNiwgMCk7XG5cdFx0XHR2YXIgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihcblx0XHRcdFx0J2Flcy0yNTYtY2JjJyxcblx0XHRcdFx0ZGVyaXZlUFBLMkVuY3J5cHRpb25LZXkob3B0aW9ucy5wYXNzcGhyYXNlKSxcblx0XHRcdFx0aXYpO1xuXHRcdFx0ZGVjaXBoZXIuc2V0QXV0b1BhZGRpbmcoZmFsc2UpO1xuXHRcdFx0cHJpdmF0ZUJ1ZiA9IEJ1ZmZlci5jb25jYXQoW1xuXHRcdFx0XHRkZWNpcGhlci51cGRhdGUocHJpdmF0ZUJ1ZiksIGRlY2lwaGVyLmZpbmFsKCldKTtcblx0XHR9XG5cblx0XHRrZXkgPSBuZXcgUHJpdmF0ZUtleShrZXkpO1xuXHRcdGlmIChrZXkudHlwZSAhPT0ga2V5VHlwZSkge1xuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignT3V0ZXIga2V5IGFsZ29yaXRobSBtaXNtYXRjaCcpKTtcblx0XHR9XG5cblx0XHR2YXIgc3NoYnVmID0gbmV3IFNTSEJ1ZmZlcih7YnVmZmVyOiBwcml2YXRlQnVmfSk7XG5cdFx0dmFyIHByaXZhdGVLZXlQYXJ0cztcblx0XHRpZiAoYWxnID09PSAnc3NoLWRzcycpIHtcblx0XHRcdHByaXZhdGVLZXlQYXJ0cyA9IFsge1xuXHRcdFx0XHRuYW1lOiAneCcsXG5cdFx0XHRcdGRhdGE6IHNzaGJ1Zi5yZWFkQnVmZmVyKClcblx0XHRcdH1dO1xuXHRcdH0gZWxzZSBpZiAoYWxnID09PSAnc3NoLXJzYScpIHtcblx0XHRcdHByaXZhdGVLZXlQYXJ0cyA9IFtcblx0XHRcdFx0eyBuYW1lOiAnZCcsIGRhdGE6IHNzaGJ1Zi5yZWFkQnVmZmVyKCkgfSxcblx0XHRcdFx0eyBuYW1lOiAncCcsIGRhdGE6IHNzaGJ1Zi5yZWFkQnVmZmVyKCkgfSxcblx0XHRcdFx0eyBuYW1lOiAncScsIGRhdGE6IHNzaGJ1Zi5yZWFkQnVmZmVyKCkgfSxcblx0XHRcdFx0eyBuYW1lOiAnaXFtcCcsIGRhdGE6IHNzaGJ1Zi5yZWFkQnVmZmVyKCkgfVxuXHRcdFx0XTtcblx0XHR9IGVsc2UgaWYgKGFsZy5tYXRjaCgvXmVjZHNhLXNoYTItbmlzdHAvKSkge1xuXHRcdFx0cHJpdmF0ZUtleVBhcnRzID0gWyB7XG5cdFx0XHRcdG5hbWU6ICdkJywgZGF0YTogc3NoYnVmLnJlYWRCdWZmZXIoKVxuXHRcdFx0fSBdO1xuXHRcdH0gZWxzZSBpZiAoYWxnID09PSAnc3NoLWVkMjU1MTknKSB7XG5cdFx0XHRwcml2YXRlS2V5UGFydHMgPSBbIHtcblx0XHRcdFx0bmFtZTogJ2snLCBkYXRhOiBzc2hidWYucmVhZEJ1ZmZlcigpXG5cdFx0XHR9IF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUFBLIGtleSB0eXBlOiAnICsgYWxnKTtcblx0XHR9XG5cblx0XHRrZXkgPSBuZXcgUHJpdmF0ZUtleSh7XG5cdFx0XHR0eXBlOiBrZXkudHlwZSxcblx0XHRcdHBhcnRzOiBrZXkucGFydHMuY29uY2F0KHByaXZhdGVLZXlQYXJ0cylcblx0XHR9KTtcblx0fVxuXG5cdGtleS5jb21tZW50ID0gY29tbWVudDtcblx0cmV0dXJuIChrZXkpO1xufVxuXG5mdW5jdGlvbiBkZXJpdmVQUEsyRW5jcnlwdGlvbktleShwYXNzcGhyYXNlKSB7XG5cdHZhciBoYXNoMSA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKEJ1ZmZlci5jb25jYXQoW1xuXHRcdEJ1ZmZlci5mcm9tKFswLCAwLCAwLCAwXSksXG5cdFx0QnVmZmVyLmZyb20ocGFzc3BocmFzZSlcblx0XSkpLmRpZ2VzdCgpO1xuXHR2YXIgaGFzaDIgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShCdWZmZXIuY29uY2F0KFtcblx0XHRCdWZmZXIuZnJvbShbMCwgMCwgMCwgMV0pLFxuXHRcdEJ1ZmZlci5mcm9tKHBhc3NwaHJhc2UpXG5cdF0pKS5kaWdlc3QoKTtcblx0cmV0dXJuIChCdWZmZXIuY29uY2F0KFtoYXNoMSwgaGFzaDJdKS5zbGljZSgwLCAzMikpO1xufVxuXG5mdW5jdGlvbiBzcGxpdEhlYWRlcihsaW5lKSB7XG5cdHZhciBpZHggPSBsaW5lLmluZGV4T2YoJzonKTtcblx0aWYgKGlkeCA9PT0gLTEpXG5cdFx0cmV0dXJuIChudWxsKTtcblx0dmFyIGhlYWRlciA9IGxpbmUuc2xpY2UoMCwgaWR4KTtcblx0KytpZHg7XG5cdHdoaWxlIChsaW5lW2lkeF0gPT09ICcgJylcblx0XHQrK2lkeDtcblx0dmFyIHJlc3QgPSBsaW5lLnNsaWNlKGlkeCk7XG5cdHJldHVybiAoW2hlYWRlciwgcmVzdF0pO1xufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIG9wdGlvbnMpIHtcblx0YXNzZXJ0Lm9iamVjdChrZXkpO1xuXHRpZiAoIUtleS5pc0tleShrZXkpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ011c3QgYmUgYSBwdWJsaWMga2V5JykpO1xuXG5cdHZhciBhbGcgPSByZmM0MjUzLmtleVR5cGVUb0FsZyhrZXkpO1xuXHR2YXIgYnVmID0gcmZjNDI1My53cml0ZShrZXkpO1xuXHR2YXIgY29tbWVudCA9IGtleS5jb21tZW50IHx8ICcnO1xuXG5cdHZhciBiNjQgPSBidWYudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXHR2YXIgbGluZXMgPSB3cmFwKGI2NCwgNjQpO1xuXG5cdGxpbmVzLnVuc2hpZnQoJ1B1YmxpYy1MaW5lczogJyArIGxpbmVzLmxlbmd0aCk7XG5cdGxpbmVzLnVuc2hpZnQoJ0NvbW1lbnQ6ICcgKyBjb21tZW50KTtcblx0bGluZXMudW5zaGlmdCgnRW5jcnlwdGlvbjogbm9uZScpO1xuXHRsaW5lcy51bnNoaWZ0KCdQdVRUWS1Vc2VyLUtleS1GaWxlLTI6ICcgKyBhbGcpO1xuXG5cdHJldHVybiAoQnVmZmVyLmZyb20obGluZXMuam9pbignXFxuJykgKyAnXFxuJykpO1xufVxuXG5mdW5jdGlvbiB3cmFwKHR4dCwgbGVuKSB7XG5cdHZhciBsaW5lcyA9IFtdO1xuXHR2YXIgcG9zID0gMDtcblx0d2hpbGUgKHBvcyA8IHR4dC5sZW5ndGgpIHtcblx0XHRsaW5lcy5wdXNoKHR4dC5zbGljZShwb3MsIHBvcyArIDY0KSk7XG5cdFx0cG9zICs9IDY0O1xuXHR9XG5cdHJldHVybiAobGluZXMpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/formats/putty.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/formats/rfc4253.js":
/*!***************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/rfc4253.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tread: read.bind(undefined, false, undefined),\n\treadType: read.bind(undefined, false),\n\twrite: write,\n\t/* semi-private api, used by sshpk-agent */\n\treadPartial: read.bind(undefined, true),\n\n\t/* shared with ssh format */\n\treadInternal: read,\n\tkeyTypeToAlg: keyTypeToAlg,\n\talgToKeyType: algToKeyType\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\nvar SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ \"(action-browser)/./node_modules/sshpk/lib/ssh-buffer.js\");\n\nfunction algToKeyType(alg) {\n\tassert.string(alg);\n\tif (alg === 'ssh-dss')\n\t\treturn ('dsa');\n\telse if (alg === 'ssh-rsa')\n\t\treturn ('rsa');\n\telse if (alg === 'ssh-ed25519')\n\t\treturn ('ed25519');\n\telse if (alg === 'ssh-curve25519')\n\t\treturn ('curve25519');\n\telse if (alg.match(/^ecdsa-sha2-/))\n\t\treturn ('ecdsa');\n\telse\n\t\tthrow (new Error('Unknown algorithm ' + alg));\n}\n\nfunction keyTypeToAlg(key) {\n\tassert.object(key);\n\tif (key.type === 'dsa')\n\t\treturn ('ssh-dss');\n\telse if (key.type === 'rsa')\n\t\treturn ('ssh-rsa');\n\telse if (key.type === 'ed25519')\n\t\treturn ('ssh-ed25519');\n\telse if (key.type === 'curve25519')\n\t\treturn ('ssh-curve25519');\n\telse if (key.type === 'ecdsa')\n\t\treturn ('ecdsa-sha2-' + key.part.curve.data.toString());\n\telse\n\t\tthrow (new Error('Unknown key type ' + key.type));\n}\n\nfunction read(partial, type, buf, options) {\n\tif (typeof (buf) === 'string')\n\t\tbuf = Buffer.from(buf);\n\tassert.buffer(buf, 'buf');\n\n\tvar key = {};\n\n\tvar parts = key.parts = [];\n\tvar sshbuf = new SSHBuffer({buffer: buf});\n\n\tvar alg = sshbuf.readString();\n\tassert.ok(!sshbuf.atEnd(), 'key must have at least one part');\n\n\tkey.type = algToKeyType(alg);\n\n\tvar partCount = algs.info[key.type].parts.length;\n\tif (type && type === 'private')\n\t\tpartCount = algs.privInfo[key.type].parts.length;\n\n\twhile (!sshbuf.atEnd() && parts.length < partCount)\n\t\tparts.push(sshbuf.readPart());\n\twhile (!partial && !sshbuf.atEnd())\n\t\tparts.push(sshbuf.readPart());\n\n\tassert.ok(parts.length >= 1,\n\t    'key must have at least one part');\n\tassert.ok(partial || sshbuf.atEnd(),\n\t    'leftover bytes at end of key');\n\n\tvar Constructor = Key;\n\tvar algInfo = algs.info[key.type];\n\tif (type === 'private' || algInfo.parts.length !== parts.length) {\n\t\talgInfo = algs.privInfo[key.type];\n\t\tConstructor = PrivateKey;\n\t}\n\tassert.strictEqual(algInfo.parts.length, parts.length);\n\n\tif (key.type === 'ecdsa') {\n\t\tvar res = /^ecdsa-sha2-(.+)$/.exec(alg);\n\t\tassert.ok(res !== null);\n\t\tassert.strictEqual(res[1], parts[0].data.toString());\n\t}\n\n\tvar normalized = true;\n\tfor (var i = 0; i < algInfo.parts.length; ++i) {\n\t\tvar p = parts[i];\n\t\tp.name = algInfo.parts[i];\n\t\t/*\n\t\t * OpenSSH stores ed25519 \"private\" keys as seed + public key\n\t\t * concat'd together (k followed by A). We want to keep them\n\t\t * separate for other formats that don't do this.\n\t\t */\n\t\tif (key.type === 'ed25519' && p.name === 'k')\n\t\t\tp.data = p.data.slice(0, 32);\n\n\t\tif (p.name !== 'curve' && algInfo.normalize !== false) {\n\t\t\tvar nd;\n\t\t\tif (key.type === 'ed25519') {\n\t\t\t\tnd = utils.zeroPadToLength(p.data, 32);\n\t\t\t} else {\n\t\t\t\tnd = utils.mpNormalize(p.data);\n\t\t\t}\n\t\t\tif (nd.toString('binary') !==\n\t\t\t    p.data.toString('binary')) {\n\t\t\t\tp.data = nd;\n\t\t\t\tnormalized = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (normalized)\n\t\tkey._rfc4253Cache = sshbuf.toBuffer();\n\n\tif (partial && typeof (partial) === 'object') {\n\t\tpartial.remainder = sshbuf.remainder();\n\t\tpartial.consumed = sshbuf._offset;\n\t}\n\n\treturn (new Constructor(key));\n}\n\nfunction write(key, options) {\n\tassert.object(key);\n\n\tvar alg = keyTypeToAlg(key);\n\tvar i;\n\n\tvar algInfo = algs.info[key.type];\n\tif (PrivateKey.isPrivateKey(key))\n\t\talgInfo = algs.privInfo[key.type];\n\tvar parts = algInfo.parts;\n\n\tvar buf = new SSHBuffer({});\n\n\tbuf.writeString(alg);\n\n\tfor (i = 0; i < parts.length; ++i) {\n\t\tvar data = key.part[parts[i]].data;\n\t\tif (algInfo.normalize !== false) {\n\t\t\tif (key.type === 'ed25519')\n\t\t\t\tdata = utils.zeroPadToLength(data, 32);\n\t\t\telse\n\t\t\t\tdata = utils.mpNormalize(data);\n\t\t}\n\t\tif (key.type === 'ed25519' && parts[i] === 'k')\n\t\t\tdata = Buffer.concat([data, key.part.A.data]);\n\t\tbuf.writeBuffer(data);\n\t}\n\n\treturn (buf.toBuffer());\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9yZmM0MjUzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywwRUFBYTtBQUNsQyxhQUFhLHlHQUE4QjtBQUMzQyxXQUFXLG1CQUFPLENBQUMsa0VBQVM7QUFDNUIsWUFBWSxtQkFBTyxDQUFDLG9FQUFVO0FBQzlCLFVBQVUsbUJBQU8sQ0FBQyxnRUFBUTtBQUMxQixpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBZ0I7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQWU7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkIsWUFBWTs7QUFFekM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9yZmM0MjUzLmpzPzY4MDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRyZWFkOiByZWFkLmJpbmQodW5kZWZpbmVkLCBmYWxzZSwgdW5kZWZpbmVkKSxcblx0cmVhZFR5cGU6IHJlYWQuYmluZCh1bmRlZmluZWQsIGZhbHNlKSxcblx0d3JpdGU6IHdyaXRlLFxuXHQvKiBzZW1pLXByaXZhdGUgYXBpLCB1c2VkIGJ5IHNzaHBrLWFnZW50ICovXG5cdHJlYWRQYXJ0aWFsOiByZWFkLmJpbmQodW5kZWZpbmVkLCB0cnVlKSxcblxuXHQvKiBzaGFyZWQgd2l0aCBzc2ggZm9ybWF0ICovXG5cdHJlYWRJbnRlcm5hbDogcmVhZCxcblx0a2V5VHlwZVRvQWxnOiBrZXlUeXBlVG9BbGcsXG5cdGFsZ1RvS2V5VHlwZTogYWxnVG9LZXlUeXBlXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4uL2FsZ3MnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgS2V5ID0gcmVxdWlyZSgnLi4va2V5Jyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uL3ByaXZhdGUta2V5Jyk7XG52YXIgU1NIQnVmZmVyID0gcmVxdWlyZSgnLi4vc3NoLWJ1ZmZlcicpO1xuXG5mdW5jdGlvbiBhbGdUb0tleVR5cGUoYWxnKSB7XG5cdGFzc2VydC5zdHJpbmcoYWxnKTtcblx0aWYgKGFsZyA9PT0gJ3NzaC1kc3MnKVxuXHRcdHJldHVybiAoJ2RzYScpO1xuXHRlbHNlIGlmIChhbGcgPT09ICdzc2gtcnNhJylcblx0XHRyZXR1cm4gKCdyc2EnKTtcblx0ZWxzZSBpZiAoYWxnID09PSAnc3NoLWVkMjU1MTknKVxuXHRcdHJldHVybiAoJ2VkMjU1MTknKTtcblx0ZWxzZSBpZiAoYWxnID09PSAnc3NoLWN1cnZlMjU1MTknKVxuXHRcdHJldHVybiAoJ2N1cnZlMjU1MTknKTtcblx0ZWxzZSBpZiAoYWxnLm1hdGNoKC9eZWNkc2Etc2hhMi0vKSlcblx0XHRyZXR1cm4gKCdlY2RzYScpO1xuXHRlbHNlXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biBhbGdvcml0aG0gJyArIGFsZykpO1xufVxuXG5mdW5jdGlvbiBrZXlUeXBlVG9BbGcoa2V5KSB7XG5cdGFzc2VydC5vYmplY3Qoa2V5KTtcblx0aWYgKGtleS50eXBlID09PSAnZHNhJylcblx0XHRyZXR1cm4gKCdzc2gtZHNzJyk7XG5cdGVsc2UgaWYgKGtleS50eXBlID09PSAncnNhJylcblx0XHRyZXR1cm4gKCdzc2gtcnNhJyk7XG5cdGVsc2UgaWYgKGtleS50eXBlID09PSAnZWQyNTUxOScpXG5cdFx0cmV0dXJuICgnc3NoLWVkMjU1MTknKTtcblx0ZWxzZSBpZiAoa2V5LnR5cGUgPT09ICdjdXJ2ZTI1NTE5Jylcblx0XHRyZXR1cm4gKCdzc2gtY3VydmUyNTUxOScpO1xuXHRlbHNlIGlmIChrZXkudHlwZSA9PT0gJ2VjZHNhJylcblx0XHRyZXR1cm4gKCdlY2RzYS1zaGEyLScgKyBrZXkucGFydC5jdXJ2ZS5kYXRhLnRvU3RyaW5nKCkpO1xuXHRlbHNlXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biBrZXkgdHlwZSAnICsga2V5LnR5cGUpKTtcbn1cblxuZnVuY3Rpb24gcmVhZChwYXJ0aWFsLCB0eXBlLCBidWYsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiAoYnVmKSA9PT0gJ3N0cmluZycpXG5cdFx0YnVmID0gQnVmZmVyLmZyb20oYnVmKTtcblx0YXNzZXJ0LmJ1ZmZlcihidWYsICdidWYnKTtcblxuXHR2YXIga2V5ID0ge307XG5cblx0dmFyIHBhcnRzID0ga2V5LnBhcnRzID0gW107XG5cdHZhciBzc2hidWYgPSBuZXcgU1NIQnVmZmVyKHtidWZmZXI6IGJ1Zn0pO1xuXG5cdHZhciBhbGcgPSBzc2hidWYucmVhZFN0cmluZygpO1xuXHRhc3NlcnQub2soIXNzaGJ1Zi5hdEVuZCgpLCAna2V5IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgcGFydCcpO1xuXG5cdGtleS50eXBlID0gYWxnVG9LZXlUeXBlKGFsZyk7XG5cblx0dmFyIHBhcnRDb3VudCA9IGFsZ3MuaW5mb1trZXkudHlwZV0ucGFydHMubGVuZ3RoO1xuXHRpZiAodHlwZSAmJiB0eXBlID09PSAncHJpdmF0ZScpXG5cdFx0cGFydENvdW50ID0gYWxncy5wcml2SW5mb1trZXkudHlwZV0ucGFydHMubGVuZ3RoO1xuXG5cdHdoaWxlICghc3NoYnVmLmF0RW5kKCkgJiYgcGFydHMubGVuZ3RoIDwgcGFydENvdW50KVxuXHRcdHBhcnRzLnB1c2goc3NoYnVmLnJlYWRQYXJ0KCkpO1xuXHR3aGlsZSAoIXBhcnRpYWwgJiYgIXNzaGJ1Zi5hdEVuZCgpKVxuXHRcdHBhcnRzLnB1c2goc3NoYnVmLnJlYWRQYXJ0KCkpO1xuXG5cdGFzc2VydC5vayhwYXJ0cy5sZW5ndGggPj0gMSxcblx0ICAgICdrZXkgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBwYXJ0Jyk7XG5cdGFzc2VydC5vayhwYXJ0aWFsIHx8IHNzaGJ1Zi5hdEVuZCgpLFxuXHQgICAgJ2xlZnRvdmVyIGJ5dGVzIGF0IGVuZCBvZiBrZXknKTtcblxuXHR2YXIgQ29uc3RydWN0b3IgPSBLZXk7XG5cdHZhciBhbGdJbmZvID0gYWxncy5pbmZvW2tleS50eXBlXTtcblx0aWYgKHR5cGUgPT09ICdwcml2YXRlJyB8fCBhbGdJbmZvLnBhcnRzLmxlbmd0aCAhPT0gcGFydHMubGVuZ3RoKSB7XG5cdFx0YWxnSW5mbyA9IGFsZ3MucHJpdkluZm9ba2V5LnR5cGVdO1xuXHRcdENvbnN0cnVjdG9yID0gUHJpdmF0ZUtleTtcblx0fVxuXHRhc3NlcnQuc3RyaWN0RXF1YWwoYWxnSW5mby5wYXJ0cy5sZW5ndGgsIHBhcnRzLmxlbmd0aCk7XG5cblx0aWYgKGtleS50eXBlID09PSAnZWNkc2EnKSB7XG5cdFx0dmFyIHJlcyA9IC9eZWNkc2Etc2hhMi0oLispJC8uZXhlYyhhbGcpO1xuXHRcdGFzc2VydC5vayhyZXMgIT09IG51bGwpO1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChyZXNbMV0sIHBhcnRzWzBdLmRhdGEudG9TdHJpbmcoKSk7XG5cdH1cblxuXHR2YXIgbm9ybWFsaXplZCA9IHRydWU7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYWxnSW5mby5wYXJ0cy5sZW5ndGg7ICsraSkge1xuXHRcdHZhciBwID0gcGFydHNbaV07XG5cdFx0cC5uYW1lID0gYWxnSW5mby5wYXJ0c1tpXTtcblx0XHQvKlxuXHRcdCAqIE9wZW5TU0ggc3RvcmVzIGVkMjU1MTkgXCJwcml2YXRlXCIga2V5cyBhcyBzZWVkICsgcHVibGljIGtleVxuXHRcdCAqIGNvbmNhdCdkIHRvZ2V0aGVyIChrIGZvbGxvd2VkIGJ5IEEpLiBXZSB3YW50IHRvIGtlZXAgdGhlbVxuXHRcdCAqIHNlcGFyYXRlIGZvciBvdGhlciBmb3JtYXRzIHRoYXQgZG9uJ3QgZG8gdGhpcy5cblx0XHQgKi9cblx0XHRpZiAoa2V5LnR5cGUgPT09ICdlZDI1NTE5JyAmJiBwLm5hbWUgPT09ICdrJylcblx0XHRcdHAuZGF0YSA9IHAuZGF0YS5zbGljZSgwLCAzMik7XG5cblx0XHRpZiAocC5uYW1lICE9PSAnY3VydmUnICYmIGFsZ0luZm8ubm9ybWFsaXplICE9PSBmYWxzZSkge1xuXHRcdFx0dmFyIG5kO1xuXHRcdFx0aWYgKGtleS50eXBlID09PSAnZWQyNTUxOScpIHtcblx0XHRcdFx0bmQgPSB1dGlscy56ZXJvUGFkVG9MZW5ndGgocC5kYXRhLCAzMik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZCA9IHV0aWxzLm1wTm9ybWFsaXplKHAuZGF0YSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobmQudG9TdHJpbmcoJ2JpbmFyeScpICE9PVxuXHRcdFx0ICAgIHAuZGF0YS50b1N0cmluZygnYmluYXJ5JykpIHtcblx0XHRcdFx0cC5kYXRhID0gbmQ7XG5cdFx0XHRcdG5vcm1hbGl6ZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAobm9ybWFsaXplZClcblx0XHRrZXkuX3JmYzQyNTNDYWNoZSA9IHNzaGJ1Zi50b0J1ZmZlcigpO1xuXG5cdGlmIChwYXJ0aWFsICYmIHR5cGVvZiAocGFydGlhbCkgPT09ICdvYmplY3QnKSB7XG5cdFx0cGFydGlhbC5yZW1haW5kZXIgPSBzc2hidWYucmVtYWluZGVyKCk7XG5cdFx0cGFydGlhbC5jb25zdW1lZCA9IHNzaGJ1Zi5fb2Zmc2V0O1xuXHR9XG5cblx0cmV0dXJuIChuZXcgQ29uc3RydWN0b3Ioa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgb3B0aW9ucykge1xuXHRhc3NlcnQub2JqZWN0KGtleSk7XG5cblx0dmFyIGFsZyA9IGtleVR5cGVUb0FsZyhrZXkpO1xuXHR2YXIgaTtcblxuXHR2YXIgYWxnSW5mbyA9IGFsZ3MuaW5mb1trZXkudHlwZV07XG5cdGlmIChQcml2YXRlS2V5LmlzUHJpdmF0ZUtleShrZXkpKVxuXHRcdGFsZ0luZm8gPSBhbGdzLnByaXZJbmZvW2tleS50eXBlXTtcblx0dmFyIHBhcnRzID0gYWxnSW5mby5wYXJ0cztcblxuXHR2YXIgYnVmID0gbmV3IFNTSEJ1ZmZlcih7fSk7XG5cblx0YnVmLndyaXRlU3RyaW5nKGFsZyk7XG5cblx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG5cdFx0dmFyIGRhdGEgPSBrZXkucGFydFtwYXJ0c1tpXV0uZGF0YTtcblx0XHRpZiAoYWxnSW5mby5ub3JtYWxpemUgIT09IGZhbHNlKSB7XG5cdFx0XHRpZiAoa2V5LnR5cGUgPT09ICdlZDI1NTE5Jylcblx0XHRcdFx0ZGF0YSA9IHV0aWxzLnplcm9QYWRUb0xlbmd0aChkYXRhLCAzMik7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGRhdGEgPSB1dGlscy5tcE5vcm1hbGl6ZShkYXRhKTtcblx0XHR9XG5cdFx0aWYgKGtleS50eXBlID09PSAnZWQyNTUxOScgJiYgcGFydHNbaV0gPT09ICdrJylcblx0XHRcdGRhdGEgPSBCdWZmZXIuY29uY2F0KFtkYXRhLCBrZXkucGFydC5BLmRhdGFdKTtcblx0XHRidWYud3JpdGVCdWZmZXIoZGF0YSk7XG5cdH1cblxuXHRyZXR1cm4gKGJ1Zi50b0J1ZmZlcigpKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/formats/rfc4253.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/formats/rfc4253.js":
/*!***************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/rfc4253.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tread: read.bind(undefined, false, undefined),\n\treadType: read.bind(undefined, false),\n\twrite: write,\n\t/* semi-private api, used by sshpk-agent */\n\treadPartial: read.bind(undefined, true),\n\n\t/* shared with ssh format */\n\treadInternal: read,\n\tkeyTypeToAlg: keyTypeToAlg,\n\talgToKeyType: algToKeyType\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\nvar SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ \"(rsc)/./node_modules/sshpk/lib/ssh-buffer.js\");\n\nfunction algToKeyType(alg) {\n\tassert.string(alg);\n\tif (alg === 'ssh-dss')\n\t\treturn ('dsa');\n\telse if (alg === 'ssh-rsa')\n\t\treturn ('rsa');\n\telse if (alg === 'ssh-ed25519')\n\t\treturn ('ed25519');\n\telse if (alg === 'ssh-curve25519')\n\t\treturn ('curve25519');\n\telse if (alg.match(/^ecdsa-sha2-/))\n\t\treturn ('ecdsa');\n\telse\n\t\tthrow (new Error('Unknown algorithm ' + alg));\n}\n\nfunction keyTypeToAlg(key) {\n\tassert.object(key);\n\tif (key.type === 'dsa')\n\t\treturn ('ssh-dss');\n\telse if (key.type === 'rsa')\n\t\treturn ('ssh-rsa');\n\telse if (key.type === 'ed25519')\n\t\treturn ('ssh-ed25519');\n\telse if (key.type === 'curve25519')\n\t\treturn ('ssh-curve25519');\n\telse if (key.type === 'ecdsa')\n\t\treturn ('ecdsa-sha2-' + key.part.curve.data.toString());\n\telse\n\t\tthrow (new Error('Unknown key type ' + key.type));\n}\n\nfunction read(partial, type, buf, options) {\n\tif (typeof (buf) === 'string')\n\t\tbuf = Buffer.from(buf);\n\tassert.buffer(buf, 'buf');\n\n\tvar key = {};\n\n\tvar parts = key.parts = [];\n\tvar sshbuf = new SSHBuffer({buffer: buf});\n\n\tvar alg = sshbuf.readString();\n\tassert.ok(!sshbuf.atEnd(), 'key must have at least one part');\n\n\tkey.type = algToKeyType(alg);\n\n\tvar partCount = algs.info[key.type].parts.length;\n\tif (type && type === 'private')\n\t\tpartCount = algs.privInfo[key.type].parts.length;\n\n\twhile (!sshbuf.atEnd() && parts.length < partCount)\n\t\tparts.push(sshbuf.readPart());\n\twhile (!partial && !sshbuf.atEnd())\n\t\tparts.push(sshbuf.readPart());\n\n\tassert.ok(parts.length >= 1,\n\t    'key must have at least one part');\n\tassert.ok(partial || sshbuf.atEnd(),\n\t    'leftover bytes at end of key');\n\n\tvar Constructor = Key;\n\tvar algInfo = algs.info[key.type];\n\tif (type === 'private' || algInfo.parts.length !== parts.length) {\n\t\talgInfo = algs.privInfo[key.type];\n\t\tConstructor = PrivateKey;\n\t}\n\tassert.strictEqual(algInfo.parts.length, parts.length);\n\n\tif (key.type === 'ecdsa') {\n\t\tvar res = /^ecdsa-sha2-(.+)$/.exec(alg);\n\t\tassert.ok(res !== null);\n\t\tassert.strictEqual(res[1], parts[0].data.toString());\n\t}\n\n\tvar normalized = true;\n\tfor (var i = 0; i < algInfo.parts.length; ++i) {\n\t\tvar p = parts[i];\n\t\tp.name = algInfo.parts[i];\n\t\t/*\n\t\t * OpenSSH stores ed25519 \"private\" keys as seed + public key\n\t\t * concat'd together (k followed by A). We want to keep them\n\t\t * separate for other formats that don't do this.\n\t\t */\n\t\tif (key.type === 'ed25519' && p.name === 'k')\n\t\t\tp.data = p.data.slice(0, 32);\n\n\t\tif (p.name !== 'curve' && algInfo.normalize !== false) {\n\t\t\tvar nd;\n\t\t\tif (key.type === 'ed25519') {\n\t\t\t\tnd = utils.zeroPadToLength(p.data, 32);\n\t\t\t} else {\n\t\t\t\tnd = utils.mpNormalize(p.data);\n\t\t\t}\n\t\t\tif (nd.toString('binary') !==\n\t\t\t    p.data.toString('binary')) {\n\t\t\t\tp.data = nd;\n\t\t\t\tnormalized = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (normalized)\n\t\tkey._rfc4253Cache = sshbuf.toBuffer();\n\n\tif (partial && typeof (partial) === 'object') {\n\t\tpartial.remainder = sshbuf.remainder();\n\t\tpartial.consumed = sshbuf._offset;\n\t}\n\n\treturn (new Constructor(key));\n}\n\nfunction write(key, options) {\n\tassert.object(key);\n\n\tvar alg = keyTypeToAlg(key);\n\tvar i;\n\n\tvar algInfo = algs.info[key.type];\n\tif (PrivateKey.isPrivateKey(key))\n\t\talgInfo = algs.privInfo[key.type];\n\tvar parts = algInfo.parts;\n\n\tvar buf = new SSHBuffer({});\n\n\tbuf.writeString(alg);\n\n\tfor (i = 0; i < parts.length; ++i) {\n\t\tvar data = key.part[parts[i]].data;\n\t\tif (algInfo.normalize !== false) {\n\t\t\tif (key.type === 'ed25519')\n\t\t\t\tdata = utils.zeroPadToLength(data, 32);\n\t\t\telse\n\t\t\t\tdata = utils.mpNormalize(data);\n\t\t}\n\t\tif (key.type === 'ed25519' && parts[i] === 'k')\n\t\t\tdata = Buffer.concat([data, key.part.A.data]);\n\t\tbuf.writeBuffer(data);\n\t}\n\n\treturn (buf.toBuffer());\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvcmZjNDI1My5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsK0RBQWE7QUFDbEMsYUFBYSw4RkFBOEI7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLHVEQUFTO0FBQzVCLFlBQVksbUJBQU8sQ0FBQyx5REFBVTtBQUM5QixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMscUVBQWdCO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFlOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCLFlBQVk7O0FBRXpDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7O0FBRTNCOztBQUVBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvcmZjNDI1My5qcz8xYTM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmVhZDogcmVhZC5iaW5kKHVuZGVmaW5lZCwgZmFsc2UsIHVuZGVmaW5lZCksXG5cdHJlYWRUeXBlOiByZWFkLmJpbmQodW5kZWZpbmVkLCBmYWxzZSksXG5cdHdyaXRlOiB3cml0ZSxcblx0Lyogc2VtaS1wcml2YXRlIGFwaSwgdXNlZCBieSBzc2hway1hZ2VudCAqL1xuXHRyZWFkUGFydGlhbDogcmVhZC5iaW5kKHVuZGVmaW5lZCwgdHJ1ZSksXG5cblx0Lyogc2hhcmVkIHdpdGggc3NoIGZvcm1hdCAqL1xuXHRyZWFkSW50ZXJuYWw6IHJlYWQsXG5cdGtleVR5cGVUb0FsZzoga2V5VHlwZVRvQWxnLFxuXHRhbGdUb0tleVR5cGU6IGFsZ1RvS2V5VHlwZVxufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuLi9hbGdzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEtleSA9IHJlcXVpcmUoJy4uL2tleScpO1xudmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuLi9wcml2YXRlLWtleScpO1xudmFyIFNTSEJ1ZmZlciA9IHJlcXVpcmUoJy4uL3NzaC1idWZmZXInKTtcblxuZnVuY3Rpb24gYWxnVG9LZXlUeXBlKGFsZykge1xuXHRhc3NlcnQuc3RyaW5nKGFsZyk7XG5cdGlmIChhbGcgPT09ICdzc2gtZHNzJylcblx0XHRyZXR1cm4gKCdkc2EnKTtcblx0ZWxzZSBpZiAoYWxnID09PSAnc3NoLXJzYScpXG5cdFx0cmV0dXJuICgncnNhJyk7XG5cdGVsc2UgaWYgKGFsZyA9PT0gJ3NzaC1lZDI1NTE5Jylcblx0XHRyZXR1cm4gKCdlZDI1NTE5Jyk7XG5cdGVsc2UgaWYgKGFsZyA9PT0gJ3NzaC1jdXJ2ZTI1NTE5Jylcblx0XHRyZXR1cm4gKCdjdXJ2ZTI1NTE5Jyk7XG5cdGVsc2UgaWYgKGFsZy5tYXRjaCgvXmVjZHNhLXNoYTItLykpXG5cdFx0cmV0dXJuICgnZWNkc2EnKTtcblx0ZWxzZVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1Vua25vd24gYWxnb3JpdGhtICcgKyBhbGcpKTtcbn1cblxuZnVuY3Rpb24ga2V5VHlwZVRvQWxnKGtleSkge1xuXHRhc3NlcnQub2JqZWN0KGtleSk7XG5cdGlmIChrZXkudHlwZSA9PT0gJ2RzYScpXG5cdFx0cmV0dXJuICgnc3NoLWRzcycpO1xuXHRlbHNlIGlmIChrZXkudHlwZSA9PT0gJ3JzYScpXG5cdFx0cmV0dXJuICgnc3NoLXJzYScpO1xuXHRlbHNlIGlmIChrZXkudHlwZSA9PT0gJ2VkMjU1MTknKVxuXHRcdHJldHVybiAoJ3NzaC1lZDI1NTE5Jyk7XG5cdGVsc2UgaWYgKGtleS50eXBlID09PSAnY3VydmUyNTUxOScpXG5cdFx0cmV0dXJuICgnc3NoLWN1cnZlMjU1MTknKTtcblx0ZWxzZSBpZiAoa2V5LnR5cGUgPT09ICdlY2RzYScpXG5cdFx0cmV0dXJuICgnZWNkc2Etc2hhMi0nICsga2V5LnBhcnQuY3VydmUuZGF0YS50b1N0cmluZygpKTtcblx0ZWxzZVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1Vua25vd24ga2V5IHR5cGUgJyArIGtleS50eXBlKSk7XG59XG5cbmZ1bmN0aW9uIHJlYWQocGFydGlhbCwgdHlwZSwgYnVmLCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgKGJ1ZikgPT09ICdzdHJpbmcnKVxuXHRcdGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1Zik7XG5cdGFzc2VydC5idWZmZXIoYnVmLCAnYnVmJyk7XG5cblx0dmFyIGtleSA9IHt9O1xuXG5cdHZhciBwYXJ0cyA9IGtleS5wYXJ0cyA9IFtdO1xuXHR2YXIgc3NoYnVmID0gbmV3IFNTSEJ1ZmZlcih7YnVmZmVyOiBidWZ9KTtcblxuXHR2YXIgYWxnID0gc3NoYnVmLnJlYWRTdHJpbmcoKTtcblx0YXNzZXJ0Lm9rKCFzc2hidWYuYXRFbmQoKSwgJ2tleSBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHBhcnQnKTtcblxuXHRrZXkudHlwZSA9IGFsZ1RvS2V5VHlwZShhbGcpO1xuXG5cdHZhciBwYXJ0Q291bnQgPSBhbGdzLmluZm9ba2V5LnR5cGVdLnBhcnRzLmxlbmd0aDtcblx0aWYgKHR5cGUgJiYgdHlwZSA9PT0gJ3ByaXZhdGUnKVxuXHRcdHBhcnRDb3VudCA9IGFsZ3MucHJpdkluZm9ba2V5LnR5cGVdLnBhcnRzLmxlbmd0aDtcblxuXHR3aGlsZSAoIXNzaGJ1Zi5hdEVuZCgpICYmIHBhcnRzLmxlbmd0aCA8IHBhcnRDb3VudClcblx0XHRwYXJ0cy5wdXNoKHNzaGJ1Zi5yZWFkUGFydCgpKTtcblx0d2hpbGUgKCFwYXJ0aWFsICYmICFzc2hidWYuYXRFbmQoKSlcblx0XHRwYXJ0cy5wdXNoKHNzaGJ1Zi5yZWFkUGFydCgpKTtcblxuXHRhc3NlcnQub2socGFydHMubGVuZ3RoID49IDEsXG5cdCAgICAna2V5IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgcGFydCcpO1xuXHRhc3NlcnQub2socGFydGlhbCB8fCBzc2hidWYuYXRFbmQoKSxcblx0ICAgICdsZWZ0b3ZlciBieXRlcyBhdCBlbmQgb2Yga2V5Jyk7XG5cblx0dmFyIENvbnN0cnVjdG9yID0gS2V5O1xuXHR2YXIgYWxnSW5mbyA9IGFsZ3MuaW5mb1trZXkudHlwZV07XG5cdGlmICh0eXBlID09PSAncHJpdmF0ZScgfHwgYWxnSW5mby5wYXJ0cy5sZW5ndGggIT09IHBhcnRzLmxlbmd0aCkge1xuXHRcdGFsZ0luZm8gPSBhbGdzLnByaXZJbmZvW2tleS50eXBlXTtcblx0XHRDb25zdHJ1Y3RvciA9IFByaXZhdGVLZXk7XG5cdH1cblx0YXNzZXJ0LnN0cmljdEVxdWFsKGFsZ0luZm8ucGFydHMubGVuZ3RoLCBwYXJ0cy5sZW5ndGgpO1xuXG5cdGlmIChrZXkudHlwZSA9PT0gJ2VjZHNhJykge1xuXHRcdHZhciByZXMgPSAvXmVjZHNhLXNoYTItKC4rKSQvLmV4ZWMoYWxnKTtcblx0XHRhc3NlcnQub2socmVzICE9PSBudWxsKTtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwocmVzWzFdLCBwYXJ0c1swXS5kYXRhLnRvU3RyaW5nKCkpO1xuXHR9XG5cblx0dmFyIG5vcm1hbGl6ZWQgPSB0cnVlO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFsZ0luZm8ucGFydHMubGVuZ3RoOyArK2kpIHtcblx0XHR2YXIgcCA9IHBhcnRzW2ldO1xuXHRcdHAubmFtZSA9IGFsZ0luZm8ucGFydHNbaV07XG5cdFx0Lypcblx0XHQgKiBPcGVuU1NIIHN0b3JlcyBlZDI1NTE5IFwicHJpdmF0ZVwiIGtleXMgYXMgc2VlZCArIHB1YmxpYyBrZXlcblx0XHQgKiBjb25jYXQnZCB0b2dldGhlciAoayBmb2xsb3dlZCBieSBBKS4gV2Ugd2FudCB0byBrZWVwIHRoZW1cblx0XHQgKiBzZXBhcmF0ZSBmb3Igb3RoZXIgZm9ybWF0cyB0aGF0IGRvbid0IGRvIHRoaXMuXG5cdFx0ICovXG5cdFx0aWYgKGtleS50eXBlID09PSAnZWQyNTUxOScgJiYgcC5uYW1lID09PSAnaycpXG5cdFx0XHRwLmRhdGEgPSBwLmRhdGEuc2xpY2UoMCwgMzIpO1xuXG5cdFx0aWYgKHAubmFtZSAhPT0gJ2N1cnZlJyAmJiBhbGdJbmZvLm5vcm1hbGl6ZSAhPT0gZmFsc2UpIHtcblx0XHRcdHZhciBuZDtcblx0XHRcdGlmIChrZXkudHlwZSA9PT0gJ2VkMjU1MTknKSB7XG5cdFx0XHRcdG5kID0gdXRpbHMuemVyb1BhZFRvTGVuZ3RoKHAuZGF0YSwgMzIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmQgPSB1dGlscy5tcE5vcm1hbGl6ZShwLmRhdGEpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG5kLnRvU3RyaW5nKCdiaW5hcnknKSAhPT1cblx0XHRcdCAgICBwLmRhdGEudG9TdHJpbmcoJ2JpbmFyeScpKSB7XG5cdFx0XHRcdHAuZGF0YSA9IG5kO1xuXHRcdFx0XHRub3JtYWxpemVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKG5vcm1hbGl6ZWQpXG5cdFx0a2V5Ll9yZmM0MjUzQ2FjaGUgPSBzc2hidWYudG9CdWZmZXIoKTtcblxuXHRpZiAocGFydGlhbCAmJiB0eXBlb2YgKHBhcnRpYWwpID09PSAnb2JqZWN0Jykge1xuXHRcdHBhcnRpYWwucmVtYWluZGVyID0gc3NoYnVmLnJlbWFpbmRlcigpO1xuXHRcdHBhcnRpYWwuY29uc3VtZWQgPSBzc2hidWYuX29mZnNldDtcblx0fVxuXG5cdHJldHVybiAobmV3IENvbnN0cnVjdG9yKGtleSkpO1xufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIG9wdGlvbnMpIHtcblx0YXNzZXJ0Lm9iamVjdChrZXkpO1xuXG5cdHZhciBhbGcgPSBrZXlUeXBlVG9BbGcoa2V5KTtcblx0dmFyIGk7XG5cblx0dmFyIGFsZ0luZm8gPSBhbGdzLmluZm9ba2V5LnR5cGVdO1xuXHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSlcblx0XHRhbGdJbmZvID0gYWxncy5wcml2SW5mb1trZXkudHlwZV07XG5cdHZhciBwYXJ0cyA9IGFsZ0luZm8ucGFydHM7XG5cblx0dmFyIGJ1ZiA9IG5ldyBTU0hCdWZmZXIoe30pO1xuXG5cdGJ1Zi53cml0ZVN0cmluZyhhbGcpO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuXHRcdHZhciBkYXRhID0ga2V5LnBhcnRbcGFydHNbaV1dLmRhdGE7XG5cdFx0aWYgKGFsZ0luZm8ubm9ybWFsaXplICE9PSBmYWxzZSkge1xuXHRcdFx0aWYgKGtleS50eXBlID09PSAnZWQyNTUxOScpXG5cdFx0XHRcdGRhdGEgPSB1dGlscy56ZXJvUGFkVG9MZW5ndGgoZGF0YSwgMzIpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRkYXRhID0gdXRpbHMubXBOb3JtYWxpemUoZGF0YSk7XG5cdFx0fVxuXHRcdGlmIChrZXkudHlwZSA9PT0gJ2VkMjU1MTknICYmIHBhcnRzW2ldID09PSAnaycpXG5cdFx0XHRkYXRhID0gQnVmZmVyLmNvbmNhdChbZGF0YSwga2V5LnBhcnQuQS5kYXRhXSk7XG5cdFx0YnVmLndyaXRlQnVmZmVyKGRhdGEpO1xuXHR9XG5cblx0cmV0dXJuIChidWYudG9CdWZmZXIoKSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/formats/rfc4253.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/formats/ssh-private.js":
/*!*******************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/ssh-private.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\treadSSHPrivate: readSSHPrivate,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(action-browser)/./node_modules/asn1/lib/index.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar Key = __webpack_require__(/*! ../key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\nvar pem = __webpack_require__(/*! ./pem */ \"(action-browser)/./node_modules/sshpk/lib/formats/pem.js\");\nvar rfc4253 = __webpack_require__(/*! ./rfc4253 */ \"(action-browser)/./node_modules/sshpk/lib/formats/rfc4253.js\");\nvar SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ \"(action-browser)/./node_modules/sshpk/lib/ssh-buffer.js\");\nvar errors = __webpack_require__(/*! ../errors */ \"(action-browser)/./node_modules/sshpk/lib/errors.js\");\n\nvar bcrypt;\n\nfunction read(buf, options) {\n\treturn (pem.read(buf, options));\n}\n\nvar MAGIC = 'openssh-key-v1';\n\nfunction readSSHPrivate(type, buf, options) {\n\tbuf = new SSHBuffer({buffer: buf});\n\n\tvar magic = buf.readCString();\n\tassert.strictEqual(magic, MAGIC, 'bad magic string');\n\n\tvar cipher = buf.readString();\n\tvar kdf = buf.readString();\n\tvar kdfOpts = buf.readBuffer();\n\n\tvar nkeys = buf.readInt();\n\tif (nkeys !== 1) {\n\t\tthrow (new Error('OpenSSH-format key file contains ' +\n\t\t    'multiple keys: this is unsupported.'));\n\t}\n\n\tvar pubKey = buf.readBuffer();\n\n\tif (type === 'public') {\n\t\tassert.ok(buf.atEnd(), 'excess bytes left after key');\n\t\treturn (rfc4253.read(pubKey));\n\t}\n\n\tvar privKeyBlob = buf.readBuffer();\n\tassert.ok(buf.atEnd(), 'excess bytes left after key');\n\n\tvar kdfOptsBuf = new SSHBuffer({ buffer: kdfOpts });\n\tswitch (kdf) {\n\tcase 'none':\n\t\tif (cipher !== 'none') {\n\t\t\tthrow (new Error('OpenSSH-format key uses KDF \"none\" ' +\n\t\t\t     'but specifies a cipher other than \"none\"'));\n\t\t}\n\t\tbreak;\n\tcase 'bcrypt':\n\t\tvar salt = kdfOptsBuf.readBuffer();\n\t\tvar rounds = kdfOptsBuf.readInt();\n\t\tvar cinf = utils.opensshCipherInfo(cipher);\n\t\tif (bcrypt === undefined) {\n\t\t\tbcrypt = __webpack_require__(/*! bcrypt-pbkdf */ \"(action-browser)/./node_modules/bcrypt-pbkdf/index.js\");\n\t\t}\n\n\t\tif (typeof (options.passphrase) === 'string') {\n\t\t\toptions.passphrase = Buffer.from(options.passphrase,\n\t\t\t    'utf-8');\n\t\t}\n\t\tif (!Buffer.isBuffer(options.passphrase)) {\n\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t    options.filename, 'OpenSSH'));\n\t\t}\n\n\t\tvar pass = new Uint8Array(options.passphrase);\n\t\tvar salti = new Uint8Array(salt);\n\t\t/* Use the pbkdf to derive both the key and the IV. */\n\t\tvar out = new Uint8Array(cinf.keySize + cinf.blockSize);\n\t\tvar res = bcrypt.pbkdf(pass, pass.length, salti, salti.length,\n\t\t    out, out.length, rounds);\n\t\tif (res !== 0) {\n\t\t\tthrow (new Error('bcrypt_pbkdf function returned ' +\n\t\t\t    'failure, parameters invalid'));\n\t\t}\n\t\tout = Buffer.from(out);\n\t\tvar ckey = out.slice(0, cinf.keySize);\n\t\tvar iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);\n\t\tvar cipherStream = crypto.createDecipheriv(cinf.opensslName,\n\t\t    ckey, iv);\n\t\tcipherStream.setAutoPadding(false);\n\t\tvar chunk, chunks = [];\n\t\tcipherStream.once('error', function (e) {\n\t\t\tif (e.toString().indexOf('bad decrypt') !== -1) {\n\t\t\t\tthrow (new Error('Incorrect passphrase ' +\n\t\t\t\t    'supplied, could not decrypt key'));\n\t\t\t}\n\t\t\tthrow (e);\n\t\t});\n\t\tcipherStream.write(privKeyBlob);\n\t\tcipherStream.end();\n\t\twhile ((chunk = cipherStream.read()) !== null)\n\t\t\tchunks.push(chunk);\n\t\tprivKeyBlob = Buffer.concat(chunks);\n\t\tbreak;\n\tdefault:\n\t\tthrow (new Error(\n\t\t    'OpenSSH-format key uses unknown KDF \"' + kdf + '\"'));\n\t}\n\n\tbuf = new SSHBuffer({buffer: privKeyBlob});\n\n\tvar checkInt1 = buf.readInt();\n\tvar checkInt2 = buf.readInt();\n\tif (checkInt1 !== checkInt2) {\n\t\tthrow (new Error('Incorrect passphrase supplied, could not ' +\n\t\t    'decrypt key'));\n\t}\n\n\tvar ret = {};\n\tvar key = rfc4253.readInternal(ret, 'private', buf.remainder());\n\n\tbuf.skip(ret.consumed);\n\n\tvar comment = buf.readString();\n\tkey.comment = comment;\n\n\treturn (key);\n}\n\nfunction write(key, options) {\n\tvar pubKey;\n\tif (PrivateKey.isPrivateKey(key))\n\t\tpubKey = key.toPublic();\n\telse\n\t\tpubKey = key;\n\n\tvar cipher = 'none';\n\tvar kdf = 'none';\n\tvar kdfopts = Buffer.alloc(0);\n\tvar cinf = { blockSize: 8 };\n\tvar passphrase;\n\tif (options !== undefined) {\n\t\tpassphrase = options.passphrase;\n\t\tif (typeof (passphrase) === 'string')\n\t\t\tpassphrase = Buffer.from(passphrase, 'utf-8');\n\t\tif (passphrase !== undefined) {\n\t\t\tassert.buffer(passphrase, 'options.passphrase');\n\t\t\tassert.optionalString(options.cipher, 'options.cipher');\n\t\t\tcipher = options.cipher;\n\t\t\tif (cipher === undefined)\n\t\t\t\tcipher = 'aes128-ctr';\n\t\t\tcinf = utils.opensshCipherInfo(cipher);\n\t\t\tkdf = 'bcrypt';\n\t\t}\n\t}\n\n\tvar privBuf;\n\tif (PrivateKey.isPrivateKey(key)) {\n\t\tprivBuf = new SSHBuffer({});\n\t\tvar checkInt = crypto.randomBytes(4).readUInt32BE(0);\n\t\tprivBuf.writeInt(checkInt);\n\t\tprivBuf.writeInt(checkInt);\n\t\tprivBuf.write(key.toBuffer('rfc4253'));\n\t\tprivBuf.writeString(key.comment || '');\n\n\t\tvar n = 1;\n\t\twhile (privBuf._offset % cinf.blockSize !== 0)\n\t\t\tprivBuf.writeChar(n++);\n\t\tprivBuf = privBuf.toBuffer();\n\t}\n\n\tswitch (kdf) {\n\tcase 'none':\n\t\tbreak;\n\tcase 'bcrypt':\n\t\tvar salt = crypto.randomBytes(16);\n\t\tvar rounds = 16;\n\t\tvar kdfssh = new SSHBuffer({});\n\t\tkdfssh.writeBuffer(salt);\n\t\tkdfssh.writeInt(rounds);\n\t\tkdfopts = kdfssh.toBuffer();\n\n\t\tif (bcrypt === undefined) {\n\t\t\tbcrypt = __webpack_require__(/*! bcrypt-pbkdf */ \"(action-browser)/./node_modules/bcrypt-pbkdf/index.js\");\n\t\t}\n\t\tvar pass = new Uint8Array(passphrase);\n\t\tvar salti = new Uint8Array(salt);\n\t\t/* Use the pbkdf to derive both the key and the IV. */\n\t\tvar out = new Uint8Array(cinf.keySize + cinf.blockSize);\n\t\tvar res = bcrypt.pbkdf(pass, pass.length, salti, salti.length,\n\t\t    out, out.length, rounds);\n\t\tif (res !== 0) {\n\t\t\tthrow (new Error('bcrypt_pbkdf function returned ' +\n\t\t\t    'failure, parameters invalid'));\n\t\t}\n\t\tout = Buffer.from(out);\n\t\tvar ckey = out.slice(0, cinf.keySize);\n\t\tvar iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);\n\n\t\tvar cipherStream = crypto.createCipheriv(cinf.opensslName,\n\t\t    ckey, iv);\n\t\tcipherStream.setAutoPadding(false);\n\t\tvar chunk, chunks = [];\n\t\tcipherStream.once('error', function (e) {\n\t\t\tthrow (e);\n\t\t});\n\t\tcipherStream.write(privBuf);\n\t\tcipherStream.end();\n\t\twhile ((chunk = cipherStream.read()) !== null)\n\t\t\tchunks.push(chunk);\n\t\tprivBuf = Buffer.concat(chunks);\n\t\tbreak;\n\tdefault:\n\t\tthrow (new Error('Unsupported kdf ' + kdf));\n\t}\n\n\tvar buf = new SSHBuffer({});\n\n\tbuf.writeCString(MAGIC);\n\tbuf.writeString(cipher);\t/* cipher */\n\tbuf.writeString(kdf);\t\t/* kdf */\n\tbuf.writeBuffer(kdfopts);\t/* kdfoptions */\n\n\tbuf.writeInt(1);\t\t/* nkeys */\n\tbuf.writeBuffer(pubKey.toBuffer('rfc4253'));\n\n\tif (privBuf)\n\t\tbuf.writeBuffer(privBuf);\n\n\tbuf = buf.toBuffer();\n\n\tvar header;\n\tif (PrivateKey.isPrivateKey(key))\n\t\theader = 'OPENSSH PRIVATE KEY';\n\telse\n\t\theader = 'OPENSSH PUBLIC KEY';\n\n\tvar tmp = buf.toString('base64');\n\tvar len = tmp.length + (tmp.length / 70) +\n\t    18 + 16 + header.length*2 + 10;\n\tbuf = Buffer.alloc(len);\n\tvar o = 0;\n\to += buf.write('-----BEGIN ' + header + '-----\\n', o);\n\tfor (var i = 0; i < tmp.length; ) {\n\t\tvar limit = i + 70;\n\t\tif (limit > tmp.length)\n\t\t\tlimit = tmp.length;\n\t\to += buf.write(tmp.slice(i, limit), o);\n\t\tbuf[o++] = 10;\n\t\ti = limit;\n\t}\n\to += buf.write('-----END ' + header + '-----\\n', o);\n\n\treturn (buf.slice(0, o));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9zc2gtcHJpdmF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywwRUFBYTtBQUNsQyxXQUFXLG1CQUFPLENBQUMsK0RBQU07QUFDekIsYUFBYSx5R0FBOEI7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLGtFQUFTO0FBQzVCLFlBQVksbUJBQU8sQ0FBQyxvRUFBVTtBQUM5QixhQUFhLG1CQUFPLENBQUMsc0JBQVE7O0FBRTdCLFVBQVUsbUJBQU8sQ0FBQyxnRUFBUTtBQUMxQixpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBZ0I7QUFDekMsVUFBVSxtQkFBTyxDQUFDLHVFQUFPO0FBQ3pCLGNBQWMsbUJBQU8sQ0FBQywrRUFBVztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBZTtBQUN2QyxhQUFhLG1CQUFPLENBQUMsc0VBQVc7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQixZQUFZOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFPLENBQUMsMkVBQWM7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixvQkFBb0I7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLDJFQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0EsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4QiwyQkFBMkI7O0FBRTNCLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9mb3JtYXRzL3NzaC1wcml2YXRlLmpzPzUyMmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRyZWFkOiByZWFkLFxuXHRyZWFkU1NIUHJpdmF0ZTogcmVhZFNTSFByaXZhdGUsXG5cdHdyaXRlOiB3cml0ZVxufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgYXNuMSA9IHJlcXVpcmUoJ2FzbjEnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4uL2FsZ3MnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbnZhciBLZXkgPSByZXF1aXJlKCcuLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZS1rZXknKTtcbnZhciBwZW0gPSByZXF1aXJlKCcuL3BlbScpO1xudmFyIHJmYzQyNTMgPSByZXF1aXJlKCcuL3JmYzQyNTMnKTtcbnZhciBTU0hCdWZmZXIgPSByZXF1aXJlKCcuLi9zc2gtYnVmZmVyJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5cbnZhciBiY3J5cHQ7XG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvcHRpb25zKSB7XG5cdHJldHVybiAocGVtLnJlYWQoYnVmLCBvcHRpb25zKSk7XG59XG5cbnZhciBNQUdJQyA9ICdvcGVuc3NoLWtleS12MSc7XG5cbmZ1bmN0aW9uIHJlYWRTU0hQcml2YXRlKHR5cGUsIGJ1Ziwgb3B0aW9ucykge1xuXHRidWYgPSBuZXcgU1NIQnVmZmVyKHtidWZmZXI6IGJ1Zn0pO1xuXG5cdHZhciBtYWdpYyA9IGJ1Zi5yZWFkQ1N0cmluZygpO1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwobWFnaWMsIE1BR0lDLCAnYmFkIG1hZ2ljIHN0cmluZycpO1xuXG5cdHZhciBjaXBoZXIgPSBidWYucmVhZFN0cmluZygpO1xuXHR2YXIga2RmID0gYnVmLnJlYWRTdHJpbmcoKTtcblx0dmFyIGtkZk9wdHMgPSBidWYucmVhZEJ1ZmZlcigpO1xuXG5cdHZhciBua2V5cyA9IGJ1Zi5yZWFkSW50KCk7XG5cdGlmIChua2V5cyAhPT0gMSkge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ09wZW5TU0gtZm9ybWF0IGtleSBmaWxlIGNvbnRhaW5zICcgK1xuXHRcdCAgICAnbXVsdGlwbGUga2V5czogdGhpcyBpcyB1bnN1cHBvcnRlZC4nKSk7XG5cdH1cblxuXHR2YXIgcHViS2V5ID0gYnVmLnJlYWRCdWZmZXIoKTtcblxuXHRpZiAodHlwZSA9PT0gJ3B1YmxpYycpIHtcblx0XHRhc3NlcnQub2soYnVmLmF0RW5kKCksICdleGNlc3MgYnl0ZXMgbGVmdCBhZnRlciBrZXknKTtcblx0XHRyZXR1cm4gKHJmYzQyNTMucmVhZChwdWJLZXkpKTtcblx0fVxuXG5cdHZhciBwcml2S2V5QmxvYiA9IGJ1Zi5yZWFkQnVmZmVyKCk7XG5cdGFzc2VydC5vayhidWYuYXRFbmQoKSwgJ2V4Y2VzcyBieXRlcyBsZWZ0IGFmdGVyIGtleScpO1xuXG5cdHZhciBrZGZPcHRzQnVmID0gbmV3IFNTSEJ1ZmZlcih7IGJ1ZmZlcjoga2RmT3B0cyB9KTtcblx0c3dpdGNoIChrZGYpIHtcblx0Y2FzZSAnbm9uZSc6XG5cdFx0aWYgKGNpcGhlciAhPT0gJ25vbmUnKSB7XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdPcGVuU1NILWZvcm1hdCBrZXkgdXNlcyBLREYgXCJub25lXCIgJyArXG5cdFx0XHQgICAgICdidXQgc3BlY2lmaWVzIGEgY2lwaGVyIG90aGVyIHRoYW4gXCJub25lXCInKSk7XG5cdFx0fVxuXHRcdGJyZWFrO1xuXHRjYXNlICdiY3J5cHQnOlxuXHRcdHZhciBzYWx0ID0ga2RmT3B0c0J1Zi5yZWFkQnVmZmVyKCk7XG5cdFx0dmFyIHJvdW5kcyA9IGtkZk9wdHNCdWYucmVhZEludCgpO1xuXHRcdHZhciBjaW5mID0gdXRpbHMub3BlbnNzaENpcGhlckluZm8oY2lwaGVyKTtcblx0XHRpZiAoYmNyeXB0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGJjcnlwdCA9IHJlcXVpcmUoJ2JjcnlwdC1wYmtkZicpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgKG9wdGlvbnMucGFzc3BocmFzZSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRvcHRpb25zLnBhc3NwaHJhc2UgPSBCdWZmZXIuZnJvbShvcHRpb25zLnBhc3NwaHJhc2UsXG5cdFx0XHQgICAgJ3V0Zi04Jyk7XG5cdFx0fVxuXHRcdGlmICghQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMucGFzc3BocmFzZSkpIHtcblx0XHRcdHRocm93IChuZXcgZXJyb3JzLktleUVuY3J5cHRlZEVycm9yKFxuXHRcdFx0ICAgIG9wdGlvbnMuZmlsZW5hbWUsICdPcGVuU1NIJykpO1xuXHRcdH1cblxuXHRcdHZhciBwYXNzID0gbmV3IFVpbnQ4QXJyYXkob3B0aW9ucy5wYXNzcGhyYXNlKTtcblx0XHR2YXIgc2FsdGkgPSBuZXcgVWludDhBcnJheShzYWx0KTtcblx0XHQvKiBVc2UgdGhlIHBia2RmIHRvIGRlcml2ZSBib3RoIHRoZSBrZXkgYW5kIHRoZSBJVi4gKi9cblx0XHR2YXIgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoY2luZi5rZXlTaXplICsgY2luZi5ibG9ja1NpemUpO1xuXHRcdHZhciByZXMgPSBiY3J5cHQucGJrZGYocGFzcywgcGFzcy5sZW5ndGgsIHNhbHRpLCBzYWx0aS5sZW5ndGgsXG5cdFx0ICAgIG91dCwgb3V0Lmxlbmd0aCwgcm91bmRzKTtcblx0XHRpZiAocmVzICE9PSAwKSB7XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdiY3J5cHRfcGJrZGYgZnVuY3Rpb24gcmV0dXJuZWQgJyArXG5cdFx0XHQgICAgJ2ZhaWx1cmUsIHBhcmFtZXRlcnMgaW52YWxpZCcpKTtcblx0XHR9XG5cdFx0b3V0ID0gQnVmZmVyLmZyb20ob3V0KTtcblx0XHR2YXIgY2tleSA9IG91dC5zbGljZSgwLCBjaW5mLmtleVNpemUpO1xuXHRcdHZhciBpdiA9IG91dC5zbGljZShjaW5mLmtleVNpemUsIGNpbmYua2V5U2l6ZSArIGNpbmYuYmxvY2tTaXplKTtcblx0XHR2YXIgY2lwaGVyU3RyZWFtID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoY2luZi5vcGVuc3NsTmFtZSxcblx0XHQgICAgY2tleSwgaXYpO1xuXHRcdGNpcGhlclN0cmVhbS5zZXRBdXRvUGFkZGluZyhmYWxzZSk7XG5cdFx0dmFyIGNodW5rLCBjaHVua3MgPSBbXTtcblx0XHRjaXBoZXJTdHJlYW0ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0aWYgKGUudG9TdHJpbmcoKS5pbmRleE9mKCdiYWQgZGVjcnlwdCcpICE9PSAtMSkge1xuXHRcdFx0XHR0aHJvdyAobmV3IEVycm9yKCdJbmNvcnJlY3QgcGFzc3BocmFzZSAnICtcblx0XHRcdFx0ICAgICdzdXBwbGllZCwgY291bGQgbm90IGRlY3J5cHQga2V5JykpO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgKGUpO1xuXHRcdH0pO1xuXHRcdGNpcGhlclN0cmVhbS53cml0ZShwcml2S2V5QmxvYik7XG5cdFx0Y2lwaGVyU3RyZWFtLmVuZCgpO1xuXHRcdHdoaWxlICgoY2h1bmsgPSBjaXBoZXJTdHJlYW0ucmVhZCgpKSAhPT0gbnVsbClcblx0XHRcdGNodW5rcy5wdXNoKGNodW5rKTtcblx0XHRwcml2S2V5QmxvYiA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzKTtcblx0XHRicmVhaztcblx0ZGVmYXVsdDpcblx0XHR0aHJvdyAobmV3IEVycm9yKFxuXHRcdCAgICAnT3BlblNTSC1mb3JtYXQga2V5IHVzZXMgdW5rbm93biBLREYgXCInICsga2RmICsgJ1wiJykpO1xuXHR9XG5cblx0YnVmID0gbmV3IFNTSEJ1ZmZlcih7YnVmZmVyOiBwcml2S2V5QmxvYn0pO1xuXG5cdHZhciBjaGVja0ludDEgPSBidWYucmVhZEludCgpO1xuXHR2YXIgY2hlY2tJbnQyID0gYnVmLnJlYWRJbnQoKTtcblx0aWYgKGNoZWNrSW50MSAhPT0gY2hlY2tJbnQyKSB7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignSW5jb3JyZWN0IHBhc3NwaHJhc2Ugc3VwcGxpZWQsIGNvdWxkIG5vdCAnICtcblx0XHQgICAgJ2RlY3J5cHQga2V5JykpO1xuXHR9XG5cblx0dmFyIHJldCA9IHt9O1xuXHR2YXIga2V5ID0gcmZjNDI1My5yZWFkSW50ZXJuYWwocmV0LCAncHJpdmF0ZScsIGJ1Zi5yZW1haW5kZXIoKSk7XG5cblx0YnVmLnNraXAocmV0LmNvbnN1bWVkKTtcblxuXHR2YXIgY29tbWVudCA9IGJ1Zi5yZWFkU3RyaW5nKCk7XG5cdGtleS5jb21tZW50ID0gY29tbWVudDtcblxuXHRyZXR1cm4gKGtleSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgb3B0aW9ucykge1xuXHR2YXIgcHViS2V5O1xuXHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSlcblx0XHRwdWJLZXkgPSBrZXkudG9QdWJsaWMoKTtcblx0ZWxzZVxuXHRcdHB1YktleSA9IGtleTtcblxuXHR2YXIgY2lwaGVyID0gJ25vbmUnO1xuXHR2YXIga2RmID0gJ25vbmUnO1xuXHR2YXIga2Rmb3B0cyA9IEJ1ZmZlci5hbGxvYygwKTtcblx0dmFyIGNpbmYgPSB7IGJsb2NrU2l6ZTogOCB9O1xuXHR2YXIgcGFzc3BocmFzZTtcblx0aWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuXHRcdHBhc3NwaHJhc2UgPSBvcHRpb25zLnBhc3NwaHJhc2U7XG5cdFx0aWYgKHR5cGVvZiAocGFzc3BocmFzZSkgPT09ICdzdHJpbmcnKVxuXHRcdFx0cGFzc3BocmFzZSA9IEJ1ZmZlci5mcm9tKHBhc3NwaHJhc2UsICd1dGYtOCcpO1xuXHRcdGlmIChwYXNzcGhyYXNlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGFzc2VydC5idWZmZXIocGFzc3BocmFzZSwgJ29wdGlvbnMucGFzc3BocmFzZScpO1xuXHRcdFx0YXNzZXJ0Lm9wdGlvbmFsU3RyaW5nKG9wdGlvbnMuY2lwaGVyLCAnb3B0aW9ucy5jaXBoZXInKTtcblx0XHRcdGNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuXHRcdFx0aWYgKGNpcGhlciA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRjaXBoZXIgPSAnYWVzMTI4LWN0cic7XG5cdFx0XHRjaW5mID0gdXRpbHMub3BlbnNzaENpcGhlckluZm8oY2lwaGVyKTtcblx0XHRcdGtkZiA9ICdiY3J5cHQnO1xuXHRcdH1cblx0fVxuXG5cdHZhciBwcml2QnVmO1xuXHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSkge1xuXHRcdHByaXZCdWYgPSBuZXcgU1NIQnVmZmVyKHt9KTtcblx0XHR2YXIgY2hlY2tJbnQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoNCkucmVhZFVJbnQzMkJFKDApO1xuXHRcdHByaXZCdWYud3JpdGVJbnQoY2hlY2tJbnQpO1xuXHRcdHByaXZCdWYud3JpdGVJbnQoY2hlY2tJbnQpO1xuXHRcdHByaXZCdWYud3JpdGUoa2V5LnRvQnVmZmVyKCdyZmM0MjUzJykpO1xuXHRcdHByaXZCdWYud3JpdGVTdHJpbmcoa2V5LmNvbW1lbnQgfHwgJycpO1xuXG5cdFx0dmFyIG4gPSAxO1xuXHRcdHdoaWxlIChwcml2QnVmLl9vZmZzZXQgJSBjaW5mLmJsb2NrU2l6ZSAhPT0gMClcblx0XHRcdHByaXZCdWYud3JpdGVDaGFyKG4rKyk7XG5cdFx0cHJpdkJ1ZiA9IHByaXZCdWYudG9CdWZmZXIoKTtcblx0fVxuXG5cdHN3aXRjaCAoa2RmKSB7XG5cdGNhc2UgJ25vbmUnOlxuXHRcdGJyZWFrO1xuXHRjYXNlICdiY3J5cHQnOlxuXHRcdHZhciBzYWx0ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KTtcblx0XHR2YXIgcm91bmRzID0gMTY7XG5cdFx0dmFyIGtkZnNzaCA9IG5ldyBTU0hCdWZmZXIoe30pO1xuXHRcdGtkZnNzaC53cml0ZUJ1ZmZlcihzYWx0KTtcblx0XHRrZGZzc2gud3JpdGVJbnQocm91bmRzKTtcblx0XHRrZGZvcHRzID0ga2Rmc3NoLnRvQnVmZmVyKCk7XG5cblx0XHRpZiAoYmNyeXB0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGJjcnlwdCA9IHJlcXVpcmUoJ2JjcnlwdC1wYmtkZicpO1xuXHRcdH1cblx0XHR2YXIgcGFzcyA9IG5ldyBVaW50OEFycmF5KHBhc3NwaHJhc2UpO1xuXHRcdHZhciBzYWx0aSA9IG5ldyBVaW50OEFycmF5KHNhbHQpO1xuXHRcdC8qIFVzZSB0aGUgcGJrZGYgdG8gZGVyaXZlIGJvdGggdGhlIGtleSBhbmQgdGhlIElWLiAqL1xuXHRcdHZhciBvdXQgPSBuZXcgVWludDhBcnJheShjaW5mLmtleVNpemUgKyBjaW5mLmJsb2NrU2l6ZSk7XG5cdFx0dmFyIHJlcyA9IGJjcnlwdC5wYmtkZihwYXNzLCBwYXNzLmxlbmd0aCwgc2FsdGksIHNhbHRpLmxlbmd0aCxcblx0XHQgICAgb3V0LCBvdXQubGVuZ3RoLCByb3VuZHMpO1xuXHRcdGlmIChyZXMgIT09IDApIHtcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ2JjcnlwdF9wYmtkZiBmdW5jdGlvbiByZXR1cm5lZCAnICtcblx0XHRcdCAgICAnZmFpbHVyZSwgcGFyYW1ldGVycyBpbnZhbGlkJykpO1xuXHRcdH1cblx0XHRvdXQgPSBCdWZmZXIuZnJvbShvdXQpO1xuXHRcdHZhciBja2V5ID0gb3V0LnNsaWNlKDAsIGNpbmYua2V5U2l6ZSk7XG5cdFx0dmFyIGl2ID0gb3V0LnNsaWNlKGNpbmYua2V5U2l6ZSwgY2luZi5rZXlTaXplICsgY2luZi5ibG9ja1NpemUpO1xuXG5cdFx0dmFyIGNpcGhlclN0cmVhbSA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihjaW5mLm9wZW5zc2xOYW1lLFxuXHRcdCAgICBja2V5LCBpdik7XG5cdFx0Y2lwaGVyU3RyZWFtLnNldEF1dG9QYWRkaW5nKGZhbHNlKTtcblx0XHR2YXIgY2h1bmssIGNodW5rcyA9IFtdO1xuXHRcdGNpcGhlclN0cmVhbS5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR0aHJvdyAoZSk7XG5cdFx0fSk7XG5cdFx0Y2lwaGVyU3RyZWFtLndyaXRlKHByaXZCdWYpO1xuXHRcdGNpcGhlclN0cmVhbS5lbmQoKTtcblx0XHR3aGlsZSAoKGNodW5rID0gY2lwaGVyU3RyZWFtLnJlYWQoKSkgIT09IG51bGwpXG5cdFx0XHRjaHVua3MucHVzaChjaHVuayk7XG5cdFx0cHJpdkJ1ZiA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzKTtcblx0XHRicmVhaztcblx0ZGVmYXVsdDpcblx0XHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZGYgJyArIGtkZikpO1xuXHR9XG5cblx0dmFyIGJ1ZiA9IG5ldyBTU0hCdWZmZXIoe30pO1xuXG5cdGJ1Zi53cml0ZUNTdHJpbmcoTUFHSUMpO1xuXHRidWYud3JpdGVTdHJpbmcoY2lwaGVyKTtcdC8qIGNpcGhlciAqL1xuXHRidWYud3JpdGVTdHJpbmcoa2RmKTtcdFx0Lyoga2RmICovXG5cdGJ1Zi53cml0ZUJ1ZmZlcihrZGZvcHRzKTtcdC8qIGtkZm9wdGlvbnMgKi9cblxuXHRidWYud3JpdGVJbnQoMSk7XHRcdC8qIG5rZXlzICovXG5cdGJ1Zi53cml0ZUJ1ZmZlcihwdWJLZXkudG9CdWZmZXIoJ3JmYzQyNTMnKSk7XG5cblx0aWYgKHByaXZCdWYpXG5cdFx0YnVmLndyaXRlQnVmZmVyKHByaXZCdWYpO1xuXG5cdGJ1ZiA9IGJ1Zi50b0J1ZmZlcigpO1xuXG5cdHZhciBoZWFkZXI7XG5cdGlmIChQcml2YXRlS2V5LmlzUHJpdmF0ZUtleShrZXkpKVxuXHRcdGhlYWRlciA9ICdPUEVOU1NIIFBSSVZBVEUgS0VZJztcblx0ZWxzZVxuXHRcdGhlYWRlciA9ICdPUEVOU1NIIFBVQkxJQyBLRVknO1xuXG5cdHZhciB0bXAgPSBidWYudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXHR2YXIgbGVuID0gdG1wLmxlbmd0aCArICh0bXAubGVuZ3RoIC8gNzApICtcblx0ICAgIDE4ICsgMTYgKyBoZWFkZXIubGVuZ3RoKjIgKyAxMDtcblx0YnVmID0gQnVmZmVyLmFsbG9jKGxlbik7XG5cdHZhciBvID0gMDtcblx0byArPSBidWYud3JpdGUoJy0tLS0tQkVHSU4gJyArIGhlYWRlciArICctLS0tLVxcbicsIG8pO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7ICkge1xuXHRcdHZhciBsaW1pdCA9IGkgKyA3MDtcblx0XHRpZiAobGltaXQgPiB0bXAubGVuZ3RoKVxuXHRcdFx0bGltaXQgPSB0bXAubGVuZ3RoO1xuXHRcdG8gKz0gYnVmLndyaXRlKHRtcC5zbGljZShpLCBsaW1pdCksIG8pO1xuXHRcdGJ1ZltvKytdID0gMTA7XG5cdFx0aSA9IGxpbWl0O1xuXHR9XG5cdG8gKz0gYnVmLndyaXRlKCctLS0tLUVORCAnICsgaGVhZGVyICsgJy0tLS0tXFxuJywgbyk7XG5cblx0cmV0dXJuIChidWYuc2xpY2UoMCwgbykpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/formats/ssh-private.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/formats/ssh-private.js":
/*!*******************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/ssh-private.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\treadSSHPrivate: readSSHPrivate,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(rsc)/./node_modules/asn1/lib/index.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar Key = __webpack_require__(/*! ../key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\nvar pem = __webpack_require__(/*! ./pem */ \"(rsc)/./node_modules/sshpk/lib/formats/pem.js\");\nvar rfc4253 = __webpack_require__(/*! ./rfc4253 */ \"(rsc)/./node_modules/sshpk/lib/formats/rfc4253.js\");\nvar SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ \"(rsc)/./node_modules/sshpk/lib/ssh-buffer.js\");\nvar errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/sshpk/lib/errors.js\");\n\nvar bcrypt;\n\nfunction read(buf, options) {\n\treturn (pem.read(buf, options));\n}\n\nvar MAGIC = 'openssh-key-v1';\n\nfunction readSSHPrivate(type, buf, options) {\n\tbuf = new SSHBuffer({buffer: buf});\n\n\tvar magic = buf.readCString();\n\tassert.strictEqual(magic, MAGIC, 'bad magic string');\n\n\tvar cipher = buf.readString();\n\tvar kdf = buf.readString();\n\tvar kdfOpts = buf.readBuffer();\n\n\tvar nkeys = buf.readInt();\n\tif (nkeys !== 1) {\n\t\tthrow (new Error('OpenSSH-format key file contains ' +\n\t\t    'multiple keys: this is unsupported.'));\n\t}\n\n\tvar pubKey = buf.readBuffer();\n\n\tif (type === 'public') {\n\t\tassert.ok(buf.atEnd(), 'excess bytes left after key');\n\t\treturn (rfc4253.read(pubKey));\n\t}\n\n\tvar privKeyBlob = buf.readBuffer();\n\tassert.ok(buf.atEnd(), 'excess bytes left after key');\n\n\tvar kdfOptsBuf = new SSHBuffer({ buffer: kdfOpts });\n\tswitch (kdf) {\n\tcase 'none':\n\t\tif (cipher !== 'none') {\n\t\t\tthrow (new Error('OpenSSH-format key uses KDF \"none\" ' +\n\t\t\t     'but specifies a cipher other than \"none\"'));\n\t\t}\n\t\tbreak;\n\tcase 'bcrypt':\n\t\tvar salt = kdfOptsBuf.readBuffer();\n\t\tvar rounds = kdfOptsBuf.readInt();\n\t\tvar cinf = utils.opensshCipherInfo(cipher);\n\t\tif (bcrypt === undefined) {\n\t\t\tbcrypt = __webpack_require__(/*! bcrypt-pbkdf */ \"(rsc)/./node_modules/bcrypt-pbkdf/index.js\");\n\t\t}\n\n\t\tif (typeof (options.passphrase) === 'string') {\n\t\t\toptions.passphrase = Buffer.from(options.passphrase,\n\t\t\t    'utf-8');\n\t\t}\n\t\tif (!Buffer.isBuffer(options.passphrase)) {\n\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t    options.filename, 'OpenSSH'));\n\t\t}\n\n\t\tvar pass = new Uint8Array(options.passphrase);\n\t\tvar salti = new Uint8Array(salt);\n\t\t/* Use the pbkdf to derive both the key and the IV. */\n\t\tvar out = new Uint8Array(cinf.keySize + cinf.blockSize);\n\t\tvar res = bcrypt.pbkdf(pass, pass.length, salti, salti.length,\n\t\t    out, out.length, rounds);\n\t\tif (res !== 0) {\n\t\t\tthrow (new Error('bcrypt_pbkdf function returned ' +\n\t\t\t    'failure, parameters invalid'));\n\t\t}\n\t\tout = Buffer.from(out);\n\t\tvar ckey = out.slice(0, cinf.keySize);\n\t\tvar iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);\n\t\tvar cipherStream = crypto.createDecipheriv(cinf.opensslName,\n\t\t    ckey, iv);\n\t\tcipherStream.setAutoPadding(false);\n\t\tvar chunk, chunks = [];\n\t\tcipherStream.once('error', function (e) {\n\t\t\tif (e.toString().indexOf('bad decrypt') !== -1) {\n\t\t\t\tthrow (new Error('Incorrect passphrase ' +\n\t\t\t\t    'supplied, could not decrypt key'));\n\t\t\t}\n\t\t\tthrow (e);\n\t\t});\n\t\tcipherStream.write(privKeyBlob);\n\t\tcipherStream.end();\n\t\twhile ((chunk = cipherStream.read()) !== null)\n\t\t\tchunks.push(chunk);\n\t\tprivKeyBlob = Buffer.concat(chunks);\n\t\tbreak;\n\tdefault:\n\t\tthrow (new Error(\n\t\t    'OpenSSH-format key uses unknown KDF \"' + kdf + '\"'));\n\t}\n\n\tbuf = new SSHBuffer({buffer: privKeyBlob});\n\n\tvar checkInt1 = buf.readInt();\n\tvar checkInt2 = buf.readInt();\n\tif (checkInt1 !== checkInt2) {\n\t\tthrow (new Error('Incorrect passphrase supplied, could not ' +\n\t\t    'decrypt key'));\n\t}\n\n\tvar ret = {};\n\tvar key = rfc4253.readInternal(ret, 'private', buf.remainder());\n\n\tbuf.skip(ret.consumed);\n\n\tvar comment = buf.readString();\n\tkey.comment = comment;\n\n\treturn (key);\n}\n\nfunction write(key, options) {\n\tvar pubKey;\n\tif (PrivateKey.isPrivateKey(key))\n\t\tpubKey = key.toPublic();\n\telse\n\t\tpubKey = key;\n\n\tvar cipher = 'none';\n\tvar kdf = 'none';\n\tvar kdfopts = Buffer.alloc(0);\n\tvar cinf = { blockSize: 8 };\n\tvar passphrase;\n\tif (options !== undefined) {\n\t\tpassphrase = options.passphrase;\n\t\tif (typeof (passphrase) === 'string')\n\t\t\tpassphrase = Buffer.from(passphrase, 'utf-8');\n\t\tif (passphrase !== undefined) {\n\t\t\tassert.buffer(passphrase, 'options.passphrase');\n\t\t\tassert.optionalString(options.cipher, 'options.cipher');\n\t\t\tcipher = options.cipher;\n\t\t\tif (cipher === undefined)\n\t\t\t\tcipher = 'aes128-ctr';\n\t\t\tcinf = utils.opensshCipherInfo(cipher);\n\t\t\tkdf = 'bcrypt';\n\t\t}\n\t}\n\n\tvar privBuf;\n\tif (PrivateKey.isPrivateKey(key)) {\n\t\tprivBuf = new SSHBuffer({});\n\t\tvar checkInt = crypto.randomBytes(4).readUInt32BE(0);\n\t\tprivBuf.writeInt(checkInt);\n\t\tprivBuf.writeInt(checkInt);\n\t\tprivBuf.write(key.toBuffer('rfc4253'));\n\t\tprivBuf.writeString(key.comment || '');\n\n\t\tvar n = 1;\n\t\twhile (privBuf._offset % cinf.blockSize !== 0)\n\t\t\tprivBuf.writeChar(n++);\n\t\tprivBuf = privBuf.toBuffer();\n\t}\n\n\tswitch (kdf) {\n\tcase 'none':\n\t\tbreak;\n\tcase 'bcrypt':\n\t\tvar salt = crypto.randomBytes(16);\n\t\tvar rounds = 16;\n\t\tvar kdfssh = new SSHBuffer({});\n\t\tkdfssh.writeBuffer(salt);\n\t\tkdfssh.writeInt(rounds);\n\t\tkdfopts = kdfssh.toBuffer();\n\n\t\tif (bcrypt === undefined) {\n\t\t\tbcrypt = __webpack_require__(/*! bcrypt-pbkdf */ \"(rsc)/./node_modules/bcrypt-pbkdf/index.js\");\n\t\t}\n\t\tvar pass = new Uint8Array(passphrase);\n\t\tvar salti = new Uint8Array(salt);\n\t\t/* Use the pbkdf to derive both the key and the IV. */\n\t\tvar out = new Uint8Array(cinf.keySize + cinf.blockSize);\n\t\tvar res = bcrypt.pbkdf(pass, pass.length, salti, salti.length,\n\t\t    out, out.length, rounds);\n\t\tif (res !== 0) {\n\t\t\tthrow (new Error('bcrypt_pbkdf function returned ' +\n\t\t\t    'failure, parameters invalid'));\n\t\t}\n\t\tout = Buffer.from(out);\n\t\tvar ckey = out.slice(0, cinf.keySize);\n\t\tvar iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);\n\n\t\tvar cipherStream = crypto.createCipheriv(cinf.opensslName,\n\t\t    ckey, iv);\n\t\tcipherStream.setAutoPadding(false);\n\t\tvar chunk, chunks = [];\n\t\tcipherStream.once('error', function (e) {\n\t\t\tthrow (e);\n\t\t});\n\t\tcipherStream.write(privBuf);\n\t\tcipherStream.end();\n\t\twhile ((chunk = cipherStream.read()) !== null)\n\t\t\tchunks.push(chunk);\n\t\tprivBuf = Buffer.concat(chunks);\n\t\tbreak;\n\tdefault:\n\t\tthrow (new Error('Unsupported kdf ' + kdf));\n\t}\n\n\tvar buf = new SSHBuffer({});\n\n\tbuf.writeCString(MAGIC);\n\tbuf.writeString(cipher);\t/* cipher */\n\tbuf.writeString(kdf);\t\t/* kdf */\n\tbuf.writeBuffer(kdfopts);\t/* kdfoptions */\n\n\tbuf.writeInt(1);\t\t/* nkeys */\n\tbuf.writeBuffer(pubKey.toBuffer('rfc4253'));\n\n\tif (privBuf)\n\t\tbuf.writeBuffer(privBuf);\n\n\tbuf = buf.toBuffer();\n\n\tvar header;\n\tif (PrivateKey.isPrivateKey(key))\n\t\theader = 'OPENSSH PRIVATE KEY';\n\telse\n\t\theader = 'OPENSSH PUBLIC KEY';\n\n\tvar tmp = buf.toString('base64');\n\tvar len = tmp.length + (tmp.length / 70) +\n\t    18 + 16 + header.length*2 + 10;\n\tbuf = Buffer.alloc(len);\n\tvar o = 0;\n\to += buf.write('-----BEGIN ' + header + '-----\\n', o);\n\tfor (var i = 0; i < tmp.length; ) {\n\t\tvar limit = i + 70;\n\t\tif (limit > tmp.length)\n\t\t\tlimit = tmp.length;\n\t\to += buf.write(tmp.slice(i, limit), o);\n\t\tbuf[o++] = 10;\n\t\ti = limit;\n\t}\n\to += buf.write('-----END ' + header + '-----\\n', o);\n\n\treturn (buf.slice(0, o));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvc3NoLXByaXZhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsK0RBQWE7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLG9EQUFNO0FBQ3pCLGFBQWEsOEZBQThCO0FBQzNDLFdBQVcsbUJBQU8sQ0FBQyx1REFBUztBQUM1QixZQUFZLG1CQUFPLENBQUMseURBQVU7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLHNCQUFROztBQUU3QixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMscUVBQWdCO0FBQ3pDLFVBQVUsbUJBQU8sQ0FBQyw0REFBTztBQUN6QixjQUFjLG1CQUFPLENBQUMsb0VBQVc7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWU7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLDJEQUFXOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0IsWUFBWTs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLGdFQUFjO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0Isb0JBQW9COztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyxnRUFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBLDBCQUEwQjtBQUMxQix3QkFBd0I7QUFDeEIsMkJBQTJCOztBQUUzQixtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9zc2gtcHJpdmF0ZS5qcz9kZjQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmVhZDogcmVhZCxcblx0cmVhZFNTSFByaXZhdGU6IHJlYWRTU0hQcml2YXRlLFxuXHR3cml0ZTogd3JpdGVcbn07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGFzbjEgPSByZXF1aXJlKCdhc24xJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuLi9hbGdzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG52YXIgS2V5ID0gcmVxdWlyZSgnLi4va2V5Jyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uL3ByaXZhdGUta2V5Jyk7XG52YXIgcGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcbnZhciByZmM0MjUzID0gcmVxdWlyZSgnLi9yZmM0MjUzJyk7XG52YXIgU1NIQnVmZmVyID0gcmVxdWlyZSgnLi4vc3NoLWJ1ZmZlcicpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuXG52YXIgYmNyeXB0O1xuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb3B0aW9ucykge1xuXHRyZXR1cm4gKHBlbS5yZWFkKGJ1Ziwgb3B0aW9ucykpO1xufVxuXG52YXIgTUFHSUMgPSAnb3BlbnNzaC1rZXktdjEnO1xuXG5mdW5jdGlvbiByZWFkU1NIUHJpdmF0ZSh0eXBlLCBidWYsIG9wdGlvbnMpIHtcblx0YnVmID0gbmV3IFNTSEJ1ZmZlcih7YnVmZmVyOiBidWZ9KTtcblxuXHR2YXIgbWFnaWMgPSBidWYucmVhZENTdHJpbmcoKTtcblx0YXNzZXJ0LnN0cmljdEVxdWFsKG1hZ2ljLCBNQUdJQywgJ2JhZCBtYWdpYyBzdHJpbmcnKTtcblxuXHR2YXIgY2lwaGVyID0gYnVmLnJlYWRTdHJpbmcoKTtcblx0dmFyIGtkZiA9IGJ1Zi5yZWFkU3RyaW5nKCk7XG5cdHZhciBrZGZPcHRzID0gYnVmLnJlYWRCdWZmZXIoKTtcblxuXHR2YXIgbmtleXMgPSBidWYucmVhZEludCgpO1xuXHRpZiAobmtleXMgIT09IDEpIHtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdPcGVuU1NILWZvcm1hdCBrZXkgZmlsZSBjb250YWlucyAnICtcblx0XHQgICAgJ211bHRpcGxlIGtleXM6IHRoaXMgaXMgdW5zdXBwb3J0ZWQuJykpO1xuXHR9XG5cblx0dmFyIHB1YktleSA9IGJ1Zi5yZWFkQnVmZmVyKCk7XG5cblx0aWYgKHR5cGUgPT09ICdwdWJsaWMnKSB7XG5cdFx0YXNzZXJ0Lm9rKGJ1Zi5hdEVuZCgpLCAnZXhjZXNzIGJ5dGVzIGxlZnQgYWZ0ZXIga2V5Jyk7XG5cdFx0cmV0dXJuIChyZmM0MjUzLnJlYWQocHViS2V5KSk7XG5cdH1cblxuXHR2YXIgcHJpdktleUJsb2IgPSBidWYucmVhZEJ1ZmZlcigpO1xuXHRhc3NlcnQub2soYnVmLmF0RW5kKCksICdleGNlc3MgYnl0ZXMgbGVmdCBhZnRlciBrZXknKTtcblxuXHR2YXIga2RmT3B0c0J1ZiA9IG5ldyBTU0hCdWZmZXIoeyBidWZmZXI6IGtkZk9wdHMgfSk7XG5cdHN3aXRjaCAoa2RmKSB7XG5cdGNhc2UgJ25vbmUnOlxuXHRcdGlmIChjaXBoZXIgIT09ICdub25lJykge1xuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignT3BlblNTSC1mb3JtYXQga2V5IHVzZXMgS0RGIFwibm9uZVwiICcgK1xuXHRcdFx0ICAgICAnYnV0IHNwZWNpZmllcyBhIGNpcGhlciBvdGhlciB0aGFuIFwibm9uZVwiJykpO1xuXHRcdH1cblx0XHRicmVhaztcblx0Y2FzZSAnYmNyeXB0Jzpcblx0XHR2YXIgc2FsdCA9IGtkZk9wdHNCdWYucmVhZEJ1ZmZlcigpO1xuXHRcdHZhciByb3VuZHMgPSBrZGZPcHRzQnVmLnJlYWRJbnQoKTtcblx0XHR2YXIgY2luZiA9IHV0aWxzLm9wZW5zc2hDaXBoZXJJbmZvKGNpcGhlcik7XG5cdFx0aWYgKGJjcnlwdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRiY3J5cHQgPSByZXF1aXJlKCdiY3J5cHQtcGJrZGYnKTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIChvcHRpb25zLnBhc3NwaHJhc2UpID09PSAnc3RyaW5nJykge1xuXHRcdFx0b3B0aW9ucy5wYXNzcGhyYXNlID0gQnVmZmVyLmZyb20ob3B0aW9ucy5wYXNzcGhyYXNlLFxuXHRcdFx0ICAgICd1dGYtOCcpO1xuXHRcdH1cblx0XHRpZiAoIUJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLnBhc3NwaHJhc2UpKSB7XG5cdFx0XHR0aHJvdyAobmV3IGVycm9ycy5LZXlFbmNyeXB0ZWRFcnJvcihcblx0XHRcdCAgICBvcHRpb25zLmZpbGVuYW1lLCAnT3BlblNTSCcpKTtcblx0XHR9XG5cblx0XHR2YXIgcGFzcyA9IG5ldyBVaW50OEFycmF5KG9wdGlvbnMucGFzc3BocmFzZSk7XG5cdFx0dmFyIHNhbHRpID0gbmV3IFVpbnQ4QXJyYXkoc2FsdCk7XG5cdFx0LyogVXNlIHRoZSBwYmtkZiB0byBkZXJpdmUgYm90aCB0aGUga2V5IGFuZCB0aGUgSVYuICovXG5cdFx0dmFyIG91dCA9IG5ldyBVaW50OEFycmF5KGNpbmYua2V5U2l6ZSArIGNpbmYuYmxvY2tTaXplKTtcblx0XHR2YXIgcmVzID0gYmNyeXB0LnBia2RmKHBhc3MsIHBhc3MubGVuZ3RoLCBzYWx0aSwgc2FsdGkubGVuZ3RoLFxuXHRcdCAgICBvdXQsIG91dC5sZW5ndGgsIHJvdW5kcyk7XG5cdFx0aWYgKHJlcyAhPT0gMCkge1xuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignYmNyeXB0X3Bia2RmIGZ1bmN0aW9uIHJldHVybmVkICcgK1xuXHRcdFx0ICAgICdmYWlsdXJlLCBwYXJhbWV0ZXJzIGludmFsaWQnKSk7XG5cdFx0fVxuXHRcdG91dCA9IEJ1ZmZlci5mcm9tKG91dCk7XG5cdFx0dmFyIGNrZXkgPSBvdXQuc2xpY2UoMCwgY2luZi5rZXlTaXplKTtcblx0XHR2YXIgaXYgPSBvdXQuc2xpY2UoY2luZi5rZXlTaXplLCBjaW5mLmtleVNpemUgKyBjaW5mLmJsb2NrU2l6ZSk7XG5cdFx0dmFyIGNpcGhlclN0cmVhbSA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGNpbmYub3BlbnNzbE5hbWUsXG5cdFx0ICAgIGNrZXksIGl2KTtcblx0XHRjaXBoZXJTdHJlYW0uc2V0QXV0b1BhZGRpbmcoZmFsc2UpO1xuXHRcdHZhciBjaHVuaywgY2h1bmtzID0gW107XG5cdFx0Y2lwaGVyU3RyZWFtLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChlLnRvU3RyaW5nKCkuaW5kZXhPZignYmFkIGRlY3J5cHQnKSAhPT0gLTEpIHtcblx0XHRcdFx0dGhyb3cgKG5ldyBFcnJvcignSW5jb3JyZWN0IHBhc3NwaHJhc2UgJyArXG5cdFx0XHRcdCAgICAnc3VwcGxpZWQsIGNvdWxkIG5vdCBkZWNyeXB0IGtleScpKTtcblx0XHRcdH1cblx0XHRcdHRocm93IChlKTtcblx0XHR9KTtcblx0XHRjaXBoZXJTdHJlYW0ud3JpdGUocHJpdktleUJsb2IpO1xuXHRcdGNpcGhlclN0cmVhbS5lbmQoKTtcblx0XHR3aGlsZSAoKGNodW5rID0gY2lwaGVyU3RyZWFtLnJlYWQoKSkgIT09IG51bGwpXG5cdFx0XHRjaHVua3MucHVzaChjaHVuayk7XG5cdFx0cHJpdktleUJsb2IgPSBCdWZmZXIuY29uY2F0KGNodW5rcyk7XG5cdFx0YnJlYWs7XG5cdGRlZmF1bHQ6XG5cdFx0dGhyb3cgKG5ldyBFcnJvcihcblx0XHQgICAgJ09wZW5TU0gtZm9ybWF0IGtleSB1c2VzIHVua25vd24gS0RGIFwiJyArIGtkZiArICdcIicpKTtcblx0fVxuXG5cdGJ1ZiA9IG5ldyBTU0hCdWZmZXIoe2J1ZmZlcjogcHJpdktleUJsb2J9KTtcblxuXHR2YXIgY2hlY2tJbnQxID0gYnVmLnJlYWRJbnQoKTtcblx0dmFyIGNoZWNrSW50MiA9IGJ1Zi5yZWFkSW50KCk7XG5cdGlmIChjaGVja0ludDEgIT09IGNoZWNrSW50Mikge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ0luY29ycmVjdCBwYXNzcGhyYXNlIHN1cHBsaWVkLCBjb3VsZCBub3QgJyArXG5cdFx0ICAgICdkZWNyeXB0IGtleScpKTtcblx0fVxuXG5cdHZhciByZXQgPSB7fTtcblx0dmFyIGtleSA9IHJmYzQyNTMucmVhZEludGVybmFsKHJldCwgJ3ByaXZhdGUnLCBidWYucmVtYWluZGVyKCkpO1xuXG5cdGJ1Zi5za2lwKHJldC5jb25zdW1lZCk7XG5cblx0dmFyIGNvbW1lbnQgPSBidWYucmVhZFN0cmluZygpO1xuXHRrZXkuY29tbWVudCA9IGNvbW1lbnQ7XG5cblx0cmV0dXJuIChrZXkpO1xufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIG9wdGlvbnMpIHtcblx0dmFyIHB1YktleTtcblx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpXG5cdFx0cHViS2V5ID0ga2V5LnRvUHVibGljKCk7XG5cdGVsc2Vcblx0XHRwdWJLZXkgPSBrZXk7XG5cblx0dmFyIGNpcGhlciA9ICdub25lJztcblx0dmFyIGtkZiA9ICdub25lJztcblx0dmFyIGtkZm9wdHMgPSBCdWZmZXIuYWxsb2MoMCk7XG5cdHZhciBjaW5mID0geyBibG9ja1NpemU6IDggfTtcblx0dmFyIHBhc3NwaHJhc2U7XG5cdGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcblx0XHRwYXNzcGhyYXNlID0gb3B0aW9ucy5wYXNzcGhyYXNlO1xuXHRcdGlmICh0eXBlb2YgKHBhc3NwaHJhc2UpID09PSAnc3RyaW5nJylcblx0XHRcdHBhc3NwaHJhc2UgPSBCdWZmZXIuZnJvbShwYXNzcGhyYXNlLCAndXRmLTgnKTtcblx0XHRpZiAocGFzc3BocmFzZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRhc3NlcnQuYnVmZmVyKHBhc3NwaHJhc2UsICdvcHRpb25zLnBhc3NwaHJhc2UnKTtcblx0XHRcdGFzc2VydC5vcHRpb25hbFN0cmluZyhvcHRpb25zLmNpcGhlciwgJ29wdGlvbnMuY2lwaGVyJyk7XG5cdFx0XHRjaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcblx0XHRcdGlmIChjaXBoZXIgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0Y2lwaGVyID0gJ2FlczEyOC1jdHInO1xuXHRcdFx0Y2luZiA9IHV0aWxzLm9wZW5zc2hDaXBoZXJJbmZvKGNpcGhlcik7XG5cdFx0XHRrZGYgPSAnYmNyeXB0Jztcblx0XHR9XG5cdH1cblxuXHR2YXIgcHJpdkJ1Zjtcblx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpIHtcblx0XHRwcml2QnVmID0gbmV3IFNTSEJ1ZmZlcih7fSk7XG5cdFx0dmFyIGNoZWNrSW50ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDQpLnJlYWRVSW50MzJCRSgwKTtcblx0XHRwcml2QnVmLndyaXRlSW50KGNoZWNrSW50KTtcblx0XHRwcml2QnVmLndyaXRlSW50KGNoZWNrSW50KTtcblx0XHRwcml2QnVmLndyaXRlKGtleS50b0J1ZmZlcigncmZjNDI1MycpKTtcblx0XHRwcml2QnVmLndyaXRlU3RyaW5nKGtleS5jb21tZW50IHx8ICcnKTtcblxuXHRcdHZhciBuID0gMTtcblx0XHR3aGlsZSAocHJpdkJ1Zi5fb2Zmc2V0ICUgY2luZi5ibG9ja1NpemUgIT09IDApXG5cdFx0XHRwcml2QnVmLndyaXRlQ2hhcihuKyspO1xuXHRcdHByaXZCdWYgPSBwcml2QnVmLnRvQnVmZmVyKCk7XG5cdH1cblxuXHRzd2l0Y2ggKGtkZikge1xuXHRjYXNlICdub25lJzpcblx0XHRicmVhaztcblx0Y2FzZSAnYmNyeXB0Jzpcblx0XHR2YXIgc2FsdCA9IGNyeXB0by5yYW5kb21CeXRlcygxNik7XG5cdFx0dmFyIHJvdW5kcyA9IDE2O1xuXHRcdHZhciBrZGZzc2ggPSBuZXcgU1NIQnVmZmVyKHt9KTtcblx0XHRrZGZzc2gud3JpdGVCdWZmZXIoc2FsdCk7XG5cdFx0a2Rmc3NoLndyaXRlSW50KHJvdW5kcyk7XG5cdFx0a2Rmb3B0cyA9IGtkZnNzaC50b0J1ZmZlcigpO1xuXG5cdFx0aWYgKGJjcnlwdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRiY3J5cHQgPSByZXF1aXJlKCdiY3J5cHQtcGJrZGYnKTtcblx0XHR9XG5cdFx0dmFyIHBhc3MgPSBuZXcgVWludDhBcnJheShwYXNzcGhyYXNlKTtcblx0XHR2YXIgc2FsdGkgPSBuZXcgVWludDhBcnJheShzYWx0KTtcblx0XHQvKiBVc2UgdGhlIHBia2RmIHRvIGRlcml2ZSBib3RoIHRoZSBrZXkgYW5kIHRoZSBJVi4gKi9cblx0XHR2YXIgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoY2luZi5rZXlTaXplICsgY2luZi5ibG9ja1NpemUpO1xuXHRcdHZhciByZXMgPSBiY3J5cHQucGJrZGYocGFzcywgcGFzcy5sZW5ndGgsIHNhbHRpLCBzYWx0aS5sZW5ndGgsXG5cdFx0ICAgIG91dCwgb3V0Lmxlbmd0aCwgcm91bmRzKTtcblx0XHRpZiAocmVzICE9PSAwKSB7XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdiY3J5cHRfcGJrZGYgZnVuY3Rpb24gcmV0dXJuZWQgJyArXG5cdFx0XHQgICAgJ2ZhaWx1cmUsIHBhcmFtZXRlcnMgaW52YWxpZCcpKTtcblx0XHR9XG5cdFx0b3V0ID0gQnVmZmVyLmZyb20ob3V0KTtcblx0XHR2YXIgY2tleSA9IG91dC5zbGljZSgwLCBjaW5mLmtleVNpemUpO1xuXHRcdHZhciBpdiA9IG91dC5zbGljZShjaW5mLmtleVNpemUsIGNpbmYua2V5U2l6ZSArIGNpbmYuYmxvY2tTaXplKTtcblxuXHRcdHZhciBjaXBoZXJTdHJlYW0gPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoY2luZi5vcGVuc3NsTmFtZSxcblx0XHQgICAgY2tleSwgaXYpO1xuXHRcdGNpcGhlclN0cmVhbS5zZXRBdXRvUGFkZGluZyhmYWxzZSk7XG5cdFx0dmFyIGNodW5rLCBjaHVua3MgPSBbXTtcblx0XHRjaXBoZXJTdHJlYW0ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dGhyb3cgKGUpO1xuXHRcdH0pO1xuXHRcdGNpcGhlclN0cmVhbS53cml0ZShwcml2QnVmKTtcblx0XHRjaXBoZXJTdHJlYW0uZW5kKCk7XG5cdFx0d2hpbGUgKChjaHVuayA9IGNpcGhlclN0cmVhbS5yZWFkKCkpICE9PSBudWxsKVxuXHRcdFx0Y2h1bmtzLnB1c2goY2h1bmspO1xuXHRcdHByaXZCdWYgPSBCdWZmZXIuY29uY2F0KGNodW5rcyk7XG5cdFx0YnJlYWs7XG5cdGRlZmF1bHQ6XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQga2RmICcgKyBrZGYpKTtcblx0fVxuXG5cdHZhciBidWYgPSBuZXcgU1NIQnVmZmVyKHt9KTtcblxuXHRidWYud3JpdGVDU3RyaW5nKE1BR0lDKTtcblx0YnVmLndyaXRlU3RyaW5nKGNpcGhlcik7XHQvKiBjaXBoZXIgKi9cblx0YnVmLndyaXRlU3RyaW5nKGtkZik7XHRcdC8qIGtkZiAqL1xuXHRidWYud3JpdGVCdWZmZXIoa2Rmb3B0cyk7XHQvKiBrZGZvcHRpb25zICovXG5cblx0YnVmLndyaXRlSW50KDEpO1x0XHQvKiBua2V5cyAqL1xuXHRidWYud3JpdGVCdWZmZXIocHViS2V5LnRvQnVmZmVyKCdyZmM0MjUzJykpO1xuXG5cdGlmIChwcml2QnVmKVxuXHRcdGJ1Zi53cml0ZUJ1ZmZlcihwcml2QnVmKTtcblxuXHRidWYgPSBidWYudG9CdWZmZXIoKTtcblxuXHR2YXIgaGVhZGVyO1xuXHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSlcblx0XHRoZWFkZXIgPSAnT1BFTlNTSCBQUklWQVRFIEtFWSc7XG5cdGVsc2Vcblx0XHRoZWFkZXIgPSAnT1BFTlNTSCBQVUJMSUMgS0VZJztcblxuXHR2YXIgdG1wID0gYnVmLnRvU3RyaW5nKCdiYXNlNjQnKTtcblx0dmFyIGxlbiA9IHRtcC5sZW5ndGggKyAodG1wLmxlbmd0aCAvIDcwKSArXG5cdCAgICAxOCArIDE2ICsgaGVhZGVyLmxlbmd0aCoyICsgMTA7XG5cdGJ1ZiA9IEJ1ZmZlci5hbGxvYyhsZW4pO1xuXHR2YXIgbyA9IDA7XG5cdG8gKz0gYnVmLndyaXRlKCctLS0tLUJFR0lOICcgKyBoZWFkZXIgKyAnLS0tLS1cXG4nLCBvKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyApIHtcblx0XHR2YXIgbGltaXQgPSBpICsgNzA7XG5cdFx0aWYgKGxpbWl0ID4gdG1wLmxlbmd0aClcblx0XHRcdGxpbWl0ID0gdG1wLmxlbmd0aDtcblx0XHRvICs9IGJ1Zi53cml0ZSh0bXAuc2xpY2UoaSwgbGltaXQpLCBvKTtcblx0XHRidWZbbysrXSA9IDEwO1xuXHRcdGkgPSBsaW1pdDtcblx0fVxuXHRvICs9IGJ1Zi53cml0ZSgnLS0tLS1FTkQgJyArIGhlYWRlciArICctLS0tLVxcbicsIG8pO1xuXG5cdHJldHVybiAoYnVmLnNsaWNlKDAsIG8pKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/formats/ssh-private.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/formats/ssh.js":
/*!***********************************************!*\
  !*** ./node_modules/sshpk/lib/formats/ssh.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar rfc4253 = __webpack_require__(/*! ./rfc4253 */ \"(action-browser)/./node_modules/sshpk/lib/formats/rfc4253.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\n\nvar sshpriv = __webpack_require__(/*! ./ssh-private */ \"(action-browser)/./node_modules/sshpk/lib/formats/ssh-private.js\");\n\n/*JSSTYLED*/\nvar SSHKEY_RE = /^([a-z0-9-]+)[ \\t]+([a-zA-Z0-9+\\/]+[=]*)([ \\t]+([^ \\t][^\\n]*[\\n]*)?)?$/;\n/*JSSTYLED*/\nvar SSHKEY_RE2 = /^([a-z0-9-]+)[ \\t\\n]+([a-zA-Z0-9+\\/][a-zA-Z0-9+\\/ \\t\\n=]*)([^a-zA-Z0-9+\\/ \\t\\n=].*)?$/;\n\nfunction read(buf, options) {\n\tif (typeof (buf) !== 'string') {\n\t\tassert.buffer(buf, 'buf');\n\t\tbuf = buf.toString('ascii');\n\t}\n\n\tvar trimmed = buf.trim().replace(/[\\\\\\r]/g, '');\n\tvar m = trimmed.match(SSHKEY_RE);\n\tif (!m)\n\t\tm = trimmed.match(SSHKEY_RE2);\n\tassert.ok(m, 'key must match regex');\n\n\tvar type = rfc4253.algToKeyType(m[1]);\n\tvar kbuf = Buffer.from(m[2], 'base64');\n\n\t/*\n\t * This is a bit tricky. If we managed to parse the key and locate the\n\t * key comment with the regex, then do a non-partial read and assert\n\t * that we have consumed all bytes. If we couldn't locate the key\n\t * comment, though, there may be whitespace shenanigans going on that\n\t * have conjoined the comment to the rest of the key. We do a partial\n\t * read in this case to try to make the best out of a sorry situation.\n\t */\n\tvar key;\n\tvar ret = {};\n\tif (m[4]) {\n\t\ttry {\n\t\t\tkey = rfc4253.read(kbuf);\n\n\t\t} catch (e) {\n\t\t\tm = trimmed.match(SSHKEY_RE2);\n\t\t\tassert.ok(m, 'key must match regex');\n\t\t\tkbuf = Buffer.from(m[2], 'base64');\n\t\t\tkey = rfc4253.readInternal(ret, 'public', kbuf);\n\t\t}\n\t} else {\n\t\tkey = rfc4253.readInternal(ret, 'public', kbuf);\n\t}\n\n\tassert.strictEqual(type, key.type);\n\n\tif (m[4] && m[4].length > 0) {\n\t\tkey.comment = m[4];\n\n\t} else if (ret.consumed) {\n\t\t/*\n\t\t * Now the magic: trying to recover the key comment when it's\n\t\t * gotten conjoined to the key or otherwise shenanigan'd.\n\t\t *\n\t\t * Work out how much base64 we used, then drop all non-base64\n\t\t * chars from the beginning up to this point in the the string.\n\t\t * Then offset in this and try to make up for missing = chars.\n\t\t */\n\t\tvar data = m[2] + (m[3] ? m[3] : '');\n\t\tvar realOffset = Math.ceil(ret.consumed / 3) * 4;\n\t\tdata = data.slice(0, realOffset - 2). /*JSSTYLED*/\n\t\t    replace(/[^a-zA-Z0-9+\\/=]/g, '') +\n\t\t    data.slice(realOffset - 2);\n\n\t\tvar padding = ret.consumed % 3;\n\t\tif (padding > 0 &&\n\t\t    data.slice(realOffset - 1, realOffset) !== '=')\n\t\t\trealOffset--;\n\t\twhile (data.slice(realOffset, realOffset + 1) === '=')\n\t\t\trealOffset++;\n\n\t\t/* Finally, grab what we think is the comment & clean it up. */\n\t\tvar trailer = data.slice(realOffset);\n\t\ttrailer = trailer.replace(/[\\r\\n]/g, ' ').\n\t\t    replace(/^\\s+/, '');\n\t\tif (trailer.match(/^[a-zA-Z0-9]/))\n\t\t\tkey.comment = trailer;\n\t}\n\n\treturn (key);\n}\n\nfunction write(key, options) {\n\tassert.object(key);\n\tif (!Key.isKey(key))\n\t\tthrow (new Error('Must be a public key'));\n\n\tvar parts = [];\n\tvar alg = rfc4253.keyTypeToAlg(key);\n\tparts.push(alg);\n\n\tvar buf = rfc4253.write(key);\n\tparts.push(buf.toString('base64'));\n\n\tif (key.comment)\n\t\tparts.push(key.comment);\n\n\treturn (Buffer.from(parts.join(' ')));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9zc2guanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDBFQUFhO0FBQ2xDLGFBQWEseUdBQThCO0FBQzNDLGNBQWMsbUJBQU8sQ0FBQywrRUFBVztBQUNqQyxZQUFZLG1CQUFPLENBQUMsb0VBQVU7QUFDOUIsVUFBVSxtQkFBTyxDQUFDLGdFQUFRO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLGdGQUFnQjs7QUFFekMsY0FBYyxtQkFBTyxDQUFDLHVGQUFlOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvc3NoLmpzP2Q3MzAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRyZWFkOiByZWFkLFxuXHR3cml0ZTogd3JpdGVcbn07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciByZmM0MjUzID0gcmVxdWlyZSgnLi9yZmM0MjUzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEtleSA9IHJlcXVpcmUoJy4uL2tleScpO1xudmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuLi9wcml2YXRlLWtleScpO1xuXG52YXIgc3NocHJpdiA9IHJlcXVpcmUoJy4vc3NoLXByaXZhdGUnKTtcblxuLypKU1NUWUxFRCovXG52YXIgU1NIS0VZX1JFID0gL14oW2EtejAtOS1dKylbIFxcdF0rKFthLXpBLVowLTkrXFwvXStbPV0qKShbIFxcdF0rKFteIFxcdF1bXlxcbl0qW1xcbl0qKT8pPyQvO1xuLypKU1NUWUxFRCovXG52YXIgU1NIS0VZX1JFMiA9IC9eKFthLXowLTktXSspWyBcXHRcXG5dKyhbYS16QS1aMC05K1xcL11bYS16QS1aMC05K1xcLyBcXHRcXG49XSopKFteYS16QS1aMC05K1xcLyBcXHRcXG49XS4qKT8kLztcblxuZnVuY3Rpb24gcmVhZChidWYsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiAoYnVmKSAhPT0gJ3N0cmluZycpIHtcblx0XHRhc3NlcnQuYnVmZmVyKGJ1ZiwgJ2J1ZicpO1xuXHRcdGJ1ZiA9IGJ1Zi50b1N0cmluZygnYXNjaWknKTtcblx0fVxuXG5cdHZhciB0cmltbWVkID0gYnVmLnRyaW0oKS5yZXBsYWNlKC9bXFxcXFxccl0vZywgJycpO1xuXHR2YXIgbSA9IHRyaW1tZWQubWF0Y2goU1NIS0VZX1JFKTtcblx0aWYgKCFtKVxuXHRcdG0gPSB0cmltbWVkLm1hdGNoKFNTSEtFWV9SRTIpO1xuXHRhc3NlcnQub2sobSwgJ2tleSBtdXN0IG1hdGNoIHJlZ2V4Jyk7XG5cblx0dmFyIHR5cGUgPSByZmM0MjUzLmFsZ1RvS2V5VHlwZShtWzFdKTtcblx0dmFyIGtidWYgPSBCdWZmZXIuZnJvbShtWzJdLCAnYmFzZTY0Jyk7XG5cblx0Lypcblx0ICogVGhpcyBpcyBhIGJpdCB0cmlja3kuIElmIHdlIG1hbmFnZWQgdG8gcGFyc2UgdGhlIGtleSBhbmQgbG9jYXRlIHRoZVxuXHQgKiBrZXkgY29tbWVudCB3aXRoIHRoZSByZWdleCwgdGhlbiBkbyBhIG5vbi1wYXJ0aWFsIHJlYWQgYW5kIGFzc2VydFxuXHQgKiB0aGF0IHdlIGhhdmUgY29uc3VtZWQgYWxsIGJ5dGVzLiBJZiB3ZSBjb3VsZG4ndCBsb2NhdGUgdGhlIGtleVxuXHQgKiBjb21tZW50LCB0aG91Z2gsIHRoZXJlIG1heSBiZSB3aGl0ZXNwYWNlIHNoZW5hbmlnYW5zIGdvaW5nIG9uIHRoYXRcblx0ICogaGF2ZSBjb25qb2luZWQgdGhlIGNvbW1lbnQgdG8gdGhlIHJlc3Qgb2YgdGhlIGtleS4gV2UgZG8gYSBwYXJ0aWFsXG5cdCAqIHJlYWQgaW4gdGhpcyBjYXNlIHRvIHRyeSB0byBtYWtlIHRoZSBiZXN0IG91dCBvZiBhIHNvcnJ5IHNpdHVhdGlvbi5cblx0ICovXG5cdHZhciBrZXk7XG5cdHZhciByZXQgPSB7fTtcblx0aWYgKG1bNF0pIHtcblx0XHR0cnkge1xuXHRcdFx0a2V5ID0gcmZjNDI1My5yZWFkKGtidWYpO1xuXG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0bSA9IHRyaW1tZWQubWF0Y2goU1NIS0VZX1JFMik7XG5cdFx0XHRhc3NlcnQub2sobSwgJ2tleSBtdXN0IG1hdGNoIHJlZ2V4Jyk7XG5cdFx0XHRrYnVmID0gQnVmZmVyLmZyb20obVsyXSwgJ2Jhc2U2NCcpO1xuXHRcdFx0a2V5ID0gcmZjNDI1My5yZWFkSW50ZXJuYWwocmV0LCAncHVibGljJywga2J1Zik7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGtleSA9IHJmYzQyNTMucmVhZEludGVybmFsKHJldCwgJ3B1YmxpYycsIGtidWYpO1xuXHR9XG5cblx0YXNzZXJ0LnN0cmljdEVxdWFsKHR5cGUsIGtleS50eXBlKTtcblxuXHRpZiAobVs0XSAmJiBtWzRdLmxlbmd0aCA+IDApIHtcblx0XHRrZXkuY29tbWVudCA9IG1bNF07XG5cblx0fSBlbHNlIGlmIChyZXQuY29uc3VtZWQpIHtcblx0XHQvKlxuXHRcdCAqIE5vdyB0aGUgbWFnaWM6IHRyeWluZyB0byByZWNvdmVyIHRoZSBrZXkgY29tbWVudCB3aGVuIGl0J3Ncblx0XHQgKiBnb3R0ZW4gY29uam9pbmVkIHRvIHRoZSBrZXkgb3Igb3RoZXJ3aXNlIHNoZW5hbmlnYW4nZC5cblx0XHQgKlxuXHRcdCAqIFdvcmsgb3V0IGhvdyBtdWNoIGJhc2U2NCB3ZSB1c2VkLCB0aGVuIGRyb3AgYWxsIG5vbi1iYXNlNjRcblx0XHQgKiBjaGFycyBmcm9tIHRoZSBiZWdpbm5pbmcgdXAgdG8gdGhpcyBwb2ludCBpbiB0aGUgdGhlIHN0cmluZy5cblx0XHQgKiBUaGVuIG9mZnNldCBpbiB0aGlzIGFuZCB0cnkgdG8gbWFrZSB1cCBmb3IgbWlzc2luZyA9IGNoYXJzLlxuXHRcdCAqL1xuXHRcdHZhciBkYXRhID0gbVsyXSArIChtWzNdID8gbVszXSA6ICcnKTtcblx0XHR2YXIgcmVhbE9mZnNldCA9IE1hdGguY2VpbChyZXQuY29uc3VtZWQgLyAzKSAqIDQ7XG5cdFx0ZGF0YSA9IGRhdGEuc2xpY2UoMCwgcmVhbE9mZnNldCAtIDIpLiAvKkpTU1RZTEVEKi9cblx0XHQgICAgcmVwbGFjZSgvW15hLXpBLVowLTkrXFwvPV0vZywgJycpICtcblx0XHQgICAgZGF0YS5zbGljZShyZWFsT2Zmc2V0IC0gMik7XG5cblx0XHR2YXIgcGFkZGluZyA9IHJldC5jb25zdW1lZCAlIDM7XG5cdFx0aWYgKHBhZGRpbmcgPiAwICYmXG5cdFx0ICAgIGRhdGEuc2xpY2UocmVhbE9mZnNldCAtIDEsIHJlYWxPZmZzZXQpICE9PSAnPScpXG5cdFx0XHRyZWFsT2Zmc2V0LS07XG5cdFx0d2hpbGUgKGRhdGEuc2xpY2UocmVhbE9mZnNldCwgcmVhbE9mZnNldCArIDEpID09PSAnPScpXG5cdFx0XHRyZWFsT2Zmc2V0Kys7XG5cblx0XHQvKiBGaW5hbGx5LCBncmFiIHdoYXQgd2UgdGhpbmsgaXMgdGhlIGNvbW1lbnQgJiBjbGVhbiBpdCB1cC4gKi9cblx0XHR2YXIgdHJhaWxlciA9IGRhdGEuc2xpY2UocmVhbE9mZnNldCk7XG5cdFx0dHJhaWxlciA9IHRyYWlsZXIucmVwbGFjZSgvW1xcclxcbl0vZywgJyAnKS5cblx0XHQgICAgcmVwbGFjZSgvXlxccysvLCAnJyk7XG5cdFx0aWYgKHRyYWlsZXIubWF0Y2goL15bYS16QS1aMC05XS8pKVxuXHRcdFx0a2V5LmNvbW1lbnQgPSB0cmFpbGVyO1xuXHR9XG5cblx0cmV0dXJuIChrZXkpO1xufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIG9wdGlvbnMpIHtcblx0YXNzZXJ0Lm9iamVjdChrZXkpO1xuXHRpZiAoIUtleS5pc0tleShrZXkpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ011c3QgYmUgYSBwdWJsaWMga2V5JykpO1xuXG5cdHZhciBwYXJ0cyA9IFtdO1xuXHR2YXIgYWxnID0gcmZjNDI1My5rZXlUeXBlVG9BbGcoa2V5KTtcblx0cGFydHMucHVzaChhbGcpO1xuXG5cdHZhciBidWYgPSByZmM0MjUzLndyaXRlKGtleSk7XG5cdHBhcnRzLnB1c2goYnVmLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG5cblx0aWYgKGtleS5jb21tZW50KVxuXHRcdHBhcnRzLnB1c2goa2V5LmNvbW1lbnQpO1xuXG5cdHJldHVybiAoQnVmZmVyLmZyb20ocGFydHMuam9pbignICcpKSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/formats/ssh.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/formats/ssh.js":
/*!***********************************************!*\
  !*** ./node_modules/sshpk/lib/formats/ssh.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar rfc4253 = __webpack_require__(/*! ./rfc4253 */ \"(rsc)/./node_modules/sshpk/lib/formats/rfc4253.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\n\nvar sshpriv = __webpack_require__(/*! ./ssh-private */ \"(rsc)/./node_modules/sshpk/lib/formats/ssh-private.js\");\n\n/*JSSTYLED*/\nvar SSHKEY_RE = /^([a-z0-9-]+)[ \\t]+([a-zA-Z0-9+\\/]+[=]*)([ \\t]+([^ \\t][^\\n]*[\\n]*)?)?$/;\n/*JSSTYLED*/\nvar SSHKEY_RE2 = /^([a-z0-9-]+)[ \\t\\n]+([a-zA-Z0-9+\\/][a-zA-Z0-9+\\/ \\t\\n=]*)([^a-zA-Z0-9+\\/ \\t\\n=].*)?$/;\n\nfunction read(buf, options) {\n\tif (typeof (buf) !== 'string') {\n\t\tassert.buffer(buf, 'buf');\n\t\tbuf = buf.toString('ascii');\n\t}\n\n\tvar trimmed = buf.trim().replace(/[\\\\\\r]/g, '');\n\tvar m = trimmed.match(SSHKEY_RE);\n\tif (!m)\n\t\tm = trimmed.match(SSHKEY_RE2);\n\tassert.ok(m, 'key must match regex');\n\n\tvar type = rfc4253.algToKeyType(m[1]);\n\tvar kbuf = Buffer.from(m[2], 'base64');\n\n\t/*\n\t * This is a bit tricky. If we managed to parse the key and locate the\n\t * key comment with the regex, then do a non-partial read and assert\n\t * that we have consumed all bytes. If we couldn't locate the key\n\t * comment, though, there may be whitespace shenanigans going on that\n\t * have conjoined the comment to the rest of the key. We do a partial\n\t * read in this case to try to make the best out of a sorry situation.\n\t */\n\tvar key;\n\tvar ret = {};\n\tif (m[4]) {\n\t\ttry {\n\t\t\tkey = rfc4253.read(kbuf);\n\n\t\t} catch (e) {\n\t\t\tm = trimmed.match(SSHKEY_RE2);\n\t\t\tassert.ok(m, 'key must match regex');\n\t\t\tkbuf = Buffer.from(m[2], 'base64');\n\t\t\tkey = rfc4253.readInternal(ret, 'public', kbuf);\n\t\t}\n\t} else {\n\t\tkey = rfc4253.readInternal(ret, 'public', kbuf);\n\t}\n\n\tassert.strictEqual(type, key.type);\n\n\tif (m[4] && m[4].length > 0) {\n\t\tkey.comment = m[4];\n\n\t} else if (ret.consumed) {\n\t\t/*\n\t\t * Now the magic: trying to recover the key comment when it's\n\t\t * gotten conjoined to the key or otherwise shenanigan'd.\n\t\t *\n\t\t * Work out how much base64 we used, then drop all non-base64\n\t\t * chars from the beginning up to this point in the the string.\n\t\t * Then offset in this and try to make up for missing = chars.\n\t\t */\n\t\tvar data = m[2] + (m[3] ? m[3] : '');\n\t\tvar realOffset = Math.ceil(ret.consumed / 3) * 4;\n\t\tdata = data.slice(0, realOffset - 2). /*JSSTYLED*/\n\t\t    replace(/[^a-zA-Z0-9+\\/=]/g, '') +\n\t\t    data.slice(realOffset - 2);\n\n\t\tvar padding = ret.consumed % 3;\n\t\tif (padding > 0 &&\n\t\t    data.slice(realOffset - 1, realOffset) !== '=')\n\t\t\trealOffset--;\n\t\twhile (data.slice(realOffset, realOffset + 1) === '=')\n\t\t\trealOffset++;\n\n\t\t/* Finally, grab what we think is the comment & clean it up. */\n\t\tvar trailer = data.slice(realOffset);\n\t\ttrailer = trailer.replace(/[\\r\\n]/g, ' ').\n\t\t    replace(/^\\s+/, '');\n\t\tif (trailer.match(/^[a-zA-Z0-9]/))\n\t\t\tkey.comment = trailer;\n\t}\n\n\treturn (key);\n}\n\nfunction write(key, options) {\n\tassert.object(key);\n\tif (!Key.isKey(key))\n\t\tthrow (new Error('Must be a public key'));\n\n\tvar parts = [];\n\tvar alg = rfc4253.keyTypeToAlg(key);\n\tparts.push(alg);\n\n\tvar buf = rfc4253.write(key);\n\tparts.push(buf.toString('base64'));\n\n\tif (key.comment)\n\t\tparts.push(key.comment);\n\n\treturn (Buffer.from(parts.join(' ')));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvc3NoLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrREFBYTtBQUNsQyxhQUFhLDhGQUE4QjtBQUMzQyxjQUFjLG1CQUFPLENBQUMsb0VBQVc7QUFDakMsWUFBWSxtQkFBTyxDQUFDLHlEQUFVO0FBQzlCLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixpQkFBaUIsbUJBQU8sQ0FBQyxxRUFBZ0I7O0FBRXpDLGNBQWMsbUJBQU8sQ0FBQyw0RUFBZTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9mb3JtYXRzL3NzaC5qcz8wNmQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgcmZjNDI1MyA9IHJlcXVpcmUoJy4vcmZjNDI1MycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBLZXkgPSByZXF1aXJlKCcuLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZS1rZXknKTtcblxudmFyIHNzaHByaXYgPSByZXF1aXJlKCcuL3NzaC1wcml2YXRlJyk7XG5cbi8qSlNTVFlMRUQqL1xudmFyIFNTSEtFWV9SRSA9IC9eKFthLXowLTktXSspWyBcXHRdKyhbYS16QS1aMC05K1xcL10rWz1dKikoWyBcXHRdKyhbXiBcXHRdW15cXG5dKltcXG5dKik/KT8kLztcbi8qSlNTVFlMRUQqL1xudmFyIFNTSEtFWV9SRTIgPSAvXihbYS16MC05LV0rKVsgXFx0XFxuXSsoW2EtekEtWjAtOStcXC9dW2EtekEtWjAtOStcXC8gXFx0XFxuPV0qKShbXmEtekEtWjAtOStcXC8gXFx0XFxuPV0uKik/JC87XG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgKGJ1ZikgIT09ICdzdHJpbmcnKSB7XG5cdFx0YXNzZXJ0LmJ1ZmZlcihidWYsICdidWYnKTtcblx0XHRidWYgPSBidWYudG9TdHJpbmcoJ2FzY2lpJyk7XG5cdH1cblxuXHR2YXIgdHJpbW1lZCA9IGJ1Zi50cmltKCkucmVwbGFjZSgvW1xcXFxcXHJdL2csICcnKTtcblx0dmFyIG0gPSB0cmltbWVkLm1hdGNoKFNTSEtFWV9SRSk7XG5cdGlmICghbSlcblx0XHRtID0gdHJpbW1lZC5tYXRjaChTU0hLRVlfUkUyKTtcblx0YXNzZXJ0Lm9rKG0sICdrZXkgbXVzdCBtYXRjaCByZWdleCcpO1xuXG5cdHZhciB0eXBlID0gcmZjNDI1My5hbGdUb0tleVR5cGUobVsxXSk7XG5cdHZhciBrYnVmID0gQnVmZmVyLmZyb20obVsyXSwgJ2Jhc2U2NCcpO1xuXG5cdC8qXG5cdCAqIFRoaXMgaXMgYSBiaXQgdHJpY2t5LiBJZiB3ZSBtYW5hZ2VkIHRvIHBhcnNlIHRoZSBrZXkgYW5kIGxvY2F0ZSB0aGVcblx0ICoga2V5IGNvbW1lbnQgd2l0aCB0aGUgcmVnZXgsIHRoZW4gZG8gYSBub24tcGFydGlhbCByZWFkIGFuZCBhc3NlcnRcblx0ICogdGhhdCB3ZSBoYXZlIGNvbnN1bWVkIGFsbCBieXRlcy4gSWYgd2UgY291bGRuJ3QgbG9jYXRlIHRoZSBrZXlcblx0ICogY29tbWVudCwgdGhvdWdoLCB0aGVyZSBtYXkgYmUgd2hpdGVzcGFjZSBzaGVuYW5pZ2FucyBnb2luZyBvbiB0aGF0XG5cdCAqIGhhdmUgY29uam9pbmVkIHRoZSBjb21tZW50IHRvIHRoZSByZXN0IG9mIHRoZSBrZXkuIFdlIGRvIGEgcGFydGlhbFxuXHQgKiByZWFkIGluIHRoaXMgY2FzZSB0byB0cnkgdG8gbWFrZSB0aGUgYmVzdCBvdXQgb2YgYSBzb3JyeSBzaXR1YXRpb24uXG5cdCAqL1xuXHR2YXIga2V5O1xuXHR2YXIgcmV0ID0ge307XG5cdGlmIChtWzRdKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGtleSA9IHJmYzQyNTMucmVhZChrYnVmKTtcblxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG0gPSB0cmltbWVkLm1hdGNoKFNTSEtFWV9SRTIpO1xuXHRcdFx0YXNzZXJ0Lm9rKG0sICdrZXkgbXVzdCBtYXRjaCByZWdleCcpO1xuXHRcdFx0a2J1ZiA9IEJ1ZmZlci5mcm9tKG1bMl0sICdiYXNlNjQnKTtcblx0XHRcdGtleSA9IHJmYzQyNTMucmVhZEludGVybmFsKHJldCwgJ3B1YmxpYycsIGtidWYpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRrZXkgPSByZmM0MjUzLnJlYWRJbnRlcm5hbChyZXQsICdwdWJsaWMnLCBrYnVmKTtcblx0fVxuXG5cdGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlLCBrZXkudHlwZSk7XG5cblx0aWYgKG1bNF0gJiYgbVs0XS5sZW5ndGggPiAwKSB7XG5cdFx0a2V5LmNvbW1lbnQgPSBtWzRdO1xuXG5cdH0gZWxzZSBpZiAocmV0LmNvbnN1bWVkKSB7XG5cdFx0Lypcblx0XHQgKiBOb3cgdGhlIG1hZ2ljOiB0cnlpbmcgdG8gcmVjb3ZlciB0aGUga2V5IGNvbW1lbnQgd2hlbiBpdCdzXG5cdFx0ICogZ290dGVuIGNvbmpvaW5lZCB0byB0aGUga2V5IG9yIG90aGVyd2lzZSBzaGVuYW5pZ2FuJ2QuXG5cdFx0ICpcblx0XHQgKiBXb3JrIG91dCBob3cgbXVjaCBiYXNlNjQgd2UgdXNlZCwgdGhlbiBkcm9wIGFsbCBub24tYmFzZTY0XG5cdFx0ICogY2hhcnMgZnJvbSB0aGUgYmVnaW5uaW5nIHVwIHRvIHRoaXMgcG9pbnQgaW4gdGhlIHRoZSBzdHJpbmcuXG5cdFx0ICogVGhlbiBvZmZzZXQgaW4gdGhpcyBhbmQgdHJ5IHRvIG1ha2UgdXAgZm9yIG1pc3NpbmcgPSBjaGFycy5cblx0XHQgKi9cblx0XHR2YXIgZGF0YSA9IG1bMl0gKyAobVszXSA/IG1bM10gOiAnJyk7XG5cdFx0dmFyIHJlYWxPZmZzZXQgPSBNYXRoLmNlaWwocmV0LmNvbnN1bWVkIC8gMykgKiA0O1xuXHRcdGRhdGEgPSBkYXRhLnNsaWNlKDAsIHJlYWxPZmZzZXQgLSAyKS4gLypKU1NUWUxFRCovXG5cdFx0ICAgIHJlcGxhY2UoL1teYS16QS1aMC05K1xcLz1dL2csICcnKSArXG5cdFx0ICAgIGRhdGEuc2xpY2UocmVhbE9mZnNldCAtIDIpO1xuXG5cdFx0dmFyIHBhZGRpbmcgPSByZXQuY29uc3VtZWQgJSAzO1xuXHRcdGlmIChwYWRkaW5nID4gMCAmJlxuXHRcdCAgICBkYXRhLnNsaWNlKHJlYWxPZmZzZXQgLSAxLCByZWFsT2Zmc2V0KSAhPT0gJz0nKVxuXHRcdFx0cmVhbE9mZnNldC0tO1xuXHRcdHdoaWxlIChkYXRhLnNsaWNlKHJlYWxPZmZzZXQsIHJlYWxPZmZzZXQgKyAxKSA9PT0gJz0nKVxuXHRcdFx0cmVhbE9mZnNldCsrO1xuXG5cdFx0LyogRmluYWxseSwgZ3JhYiB3aGF0IHdlIHRoaW5rIGlzIHRoZSBjb21tZW50ICYgY2xlYW4gaXQgdXAuICovXG5cdFx0dmFyIHRyYWlsZXIgPSBkYXRhLnNsaWNlKHJlYWxPZmZzZXQpO1xuXHRcdHRyYWlsZXIgPSB0cmFpbGVyLnJlcGxhY2UoL1tcXHJcXG5dL2csICcgJykuXG5cdFx0ICAgIHJlcGxhY2UoL15cXHMrLywgJycpO1xuXHRcdGlmICh0cmFpbGVyLm1hdGNoKC9eW2EtekEtWjAtOV0vKSlcblx0XHRcdGtleS5jb21tZW50ID0gdHJhaWxlcjtcblx0fVxuXG5cdHJldHVybiAoa2V5KTtcbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBvcHRpb25zKSB7XG5cdGFzc2VydC5vYmplY3Qoa2V5KTtcblx0aWYgKCFLZXkuaXNLZXkoa2V5KSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdNdXN0IGJlIGEgcHVibGljIGtleScpKTtcblxuXHR2YXIgcGFydHMgPSBbXTtcblx0dmFyIGFsZyA9IHJmYzQyNTMua2V5VHlwZVRvQWxnKGtleSk7XG5cdHBhcnRzLnB1c2goYWxnKTtcblxuXHR2YXIgYnVmID0gcmZjNDI1My53cml0ZShrZXkpO1xuXHRwYXJ0cy5wdXNoKGJ1Zi50b1N0cmluZygnYmFzZTY0JykpO1xuXG5cdGlmIChrZXkuY29tbWVudClcblx0XHRwYXJ0cy5wdXNoKGtleS5jb21tZW50KTtcblxuXHRyZXR1cm4gKEJ1ZmZlci5mcm9tKHBhcnRzLmpvaW4oJyAnKSkpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/formats/ssh.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/formats/x509-pem.js":
/*!****************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/x509-pem.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2016 Joyent, Inc.\n\nvar x509 = __webpack_require__(/*! ./x509 */ \"(action-browser)/./node_modules/sshpk/lib/formats/x509.js\");\n\nmodule.exports = {\n\tread: read,\n\tverify: x509.verify,\n\tsign: x509.sign,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(action-browser)/./node_modules/asn1/lib/index.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\nvar pem = __webpack_require__(/*! ./pem */ \"(action-browser)/./node_modules/sshpk/lib/formats/pem.js\");\nvar Identity = __webpack_require__(/*! ../identity */ \"(action-browser)/./node_modules/sshpk/lib/identity.js\");\nvar Signature = __webpack_require__(/*! ../signature */ \"(action-browser)/./node_modules/sshpk/lib/signature.js\");\nvar Certificate = __webpack_require__(/*! ../certificate */ \"(action-browser)/./node_modules/sshpk/lib/certificate.js\");\n\nfunction read(buf, options) {\n\tif (typeof (buf) !== 'string') {\n\t\tassert.buffer(buf, 'buf');\n\t\tbuf = buf.toString('ascii');\n\t}\n\n\tvar lines = buf.trim().split(/[\\r\\n]+/g);\n\n\tvar m;\n\tvar si = -1;\n\twhile (!m && si < lines.length) {\n\t\tm = lines[++si].match(/*JSSTYLED*/\n\t\t    /[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);\n\t}\n\tassert.ok(m, 'invalid PEM header');\n\n\tvar m2;\n\tvar ei = lines.length;\n\twhile (!m2 && ei > 0) {\n\t\tm2 = lines[--ei].match(/*JSSTYLED*/\n\t\t    /[-]+[ ]*END CERTIFICATE[ ]*[-]+/);\n\t}\n\tassert.ok(m2, 'invalid PEM footer');\n\n\tlines = lines.slice(si, ei + 1);\n\n\tvar headers = {};\n\twhile (true) {\n\t\tlines = lines.slice(1);\n\t\tm = lines[0].match(/*JSSTYLED*/\n\t\t    /^([A-Za-z0-9-]+): (.+)$/);\n\t\tif (!m)\n\t\t\tbreak;\n\t\theaders[m[1].toLowerCase()] = m[2];\n\t}\n\n\t/* Chop off the first and last lines */\n\tlines = lines.slice(0, -1).join('');\n\tbuf = Buffer.from(lines, 'base64');\n\n\treturn (x509.read(buf, options));\n}\n\nfunction write(cert, options) {\n\tvar dbuf = x509.write(cert, options);\n\n\tvar header = 'CERTIFICATE';\n\tvar tmp = dbuf.toString('base64');\n\tvar len = tmp.length + (tmp.length / 64) +\n\t    18 + 16 + header.length*2 + 10;\n\tvar buf = Buffer.alloc(len);\n\tvar o = 0;\n\to += buf.write('-----BEGIN ' + header + '-----\\n', o);\n\tfor (var i = 0; i < tmp.length; ) {\n\t\tvar limit = i + 64;\n\t\tif (limit > tmp.length)\n\t\t\tlimit = tmp.length;\n\t\to += buf.write(tmp.slice(i, limit), o);\n\t\tbuf[o++] = 10;\n\t\ti = limit;\n\t}\n\to += buf.write('-----END ' + header + '-----\\n', o);\n\n\treturn (buf.slice(0, o));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy94NTA5LXBlbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMseUVBQVE7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsMEVBQWE7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLCtEQUFNO0FBQ3pCLGFBQWEseUdBQThCO0FBQzNDLFdBQVcsbUJBQU8sQ0FBQyxrRUFBUztBQUM1QixZQUFZLG1CQUFPLENBQUMsb0VBQVU7QUFDOUIsVUFBVSxtQkFBTyxDQUFDLGdFQUFRO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLGdGQUFnQjtBQUN6QyxVQUFVLG1CQUFPLENBQUMsdUVBQU87QUFDekIsZUFBZSxtQkFBTyxDQUFDLDBFQUFhO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLDRFQUFjO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFnQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy94NTA5LXBlbS5qcz9hMTIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE2IEpveWVudCwgSW5jLlxuXG52YXIgeDUwOSA9IHJlcXVpcmUoJy4veDUwOScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmVhZDogcmVhZCxcblx0dmVyaWZ5OiB4NTA5LnZlcmlmeSxcblx0c2lnbjogeDUwOS5zaWduLFxuXHR3cml0ZTogd3JpdGVcbn07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGFzbjEgPSByZXF1aXJlKCdhc24xJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuLi9hbGdzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEtleSA9IHJlcXVpcmUoJy4uL2tleScpO1xudmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuLi9wcml2YXRlLWtleScpO1xudmFyIHBlbSA9IHJlcXVpcmUoJy4vcGVtJyk7XG52YXIgSWRlbnRpdHkgPSByZXF1aXJlKCcuLi9pZGVudGl0eScpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uL3NpZ25hdHVyZScpO1xudmFyIENlcnRpZmljYXRlID0gcmVxdWlyZSgnLi4vY2VydGlmaWNhdGUnKTtcblxuZnVuY3Rpb24gcmVhZChidWYsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiAoYnVmKSAhPT0gJ3N0cmluZycpIHtcblx0XHRhc3NlcnQuYnVmZmVyKGJ1ZiwgJ2J1ZicpO1xuXHRcdGJ1ZiA9IGJ1Zi50b1N0cmluZygnYXNjaWknKTtcblx0fVxuXG5cdHZhciBsaW5lcyA9IGJ1Zi50cmltKCkuc3BsaXQoL1tcXHJcXG5dKy9nKTtcblxuXHR2YXIgbTtcblx0dmFyIHNpID0gLTE7XG5cdHdoaWxlICghbSAmJiBzaSA8IGxpbmVzLmxlbmd0aCkge1xuXHRcdG0gPSBsaW5lc1srK3NpXS5tYXRjaCgvKkpTU1RZTEVEKi9cblx0XHQgICAgL1stXStbIF0qQkVHSU4gQ0VSVElGSUNBVEVbIF0qWy1dKy8pO1xuXHR9XG5cdGFzc2VydC5vayhtLCAnaW52YWxpZCBQRU0gaGVhZGVyJyk7XG5cblx0dmFyIG0yO1xuXHR2YXIgZWkgPSBsaW5lcy5sZW5ndGg7XG5cdHdoaWxlICghbTIgJiYgZWkgPiAwKSB7XG5cdFx0bTIgPSBsaW5lc1stLWVpXS5tYXRjaCgvKkpTU1RZTEVEKi9cblx0XHQgICAgL1stXStbIF0qRU5EIENFUlRJRklDQVRFWyBdKlstXSsvKTtcblx0fVxuXHRhc3NlcnQub2sobTIsICdpbnZhbGlkIFBFTSBmb290ZXInKTtcblxuXHRsaW5lcyA9IGxpbmVzLnNsaWNlKHNpLCBlaSArIDEpO1xuXG5cdHZhciBoZWFkZXJzID0ge307XG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0bGluZXMgPSBsaW5lcy5zbGljZSgxKTtcblx0XHRtID0gbGluZXNbMF0ubWF0Y2goLypKU1NUWUxFRCovXG5cdFx0ICAgIC9eKFtBLVphLXowLTktXSspOiAoLispJC8pO1xuXHRcdGlmICghbSlcblx0XHRcdGJyZWFrO1xuXHRcdGhlYWRlcnNbbVsxXS50b0xvd2VyQ2FzZSgpXSA9IG1bMl07XG5cdH1cblxuXHQvKiBDaG9wIG9mZiB0aGUgZmlyc3QgYW5kIGxhc3QgbGluZXMgKi9cblx0bGluZXMgPSBsaW5lcy5zbGljZSgwLCAtMSkuam9pbignJyk7XG5cdGJ1ZiA9IEJ1ZmZlci5mcm9tKGxpbmVzLCAnYmFzZTY0Jyk7XG5cblx0cmV0dXJuICh4NTA5LnJlYWQoYnVmLCBvcHRpb25zKSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlKGNlcnQsIG9wdGlvbnMpIHtcblx0dmFyIGRidWYgPSB4NTA5LndyaXRlKGNlcnQsIG9wdGlvbnMpO1xuXG5cdHZhciBoZWFkZXIgPSAnQ0VSVElGSUNBVEUnO1xuXHR2YXIgdG1wID0gZGJ1Zi50b1N0cmluZygnYmFzZTY0Jyk7XG5cdHZhciBsZW4gPSB0bXAubGVuZ3RoICsgKHRtcC5sZW5ndGggLyA2NCkgK1xuXHQgICAgMTggKyAxNiArIGhlYWRlci5sZW5ndGgqMiArIDEwO1xuXHR2YXIgYnVmID0gQnVmZmVyLmFsbG9jKGxlbik7XG5cdHZhciBvID0gMDtcblx0byArPSBidWYud3JpdGUoJy0tLS0tQkVHSU4gJyArIGhlYWRlciArICctLS0tLVxcbicsIG8pO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7ICkge1xuXHRcdHZhciBsaW1pdCA9IGkgKyA2NDtcblx0XHRpZiAobGltaXQgPiB0bXAubGVuZ3RoKVxuXHRcdFx0bGltaXQgPSB0bXAubGVuZ3RoO1xuXHRcdG8gKz0gYnVmLndyaXRlKHRtcC5zbGljZShpLCBsaW1pdCksIG8pO1xuXHRcdGJ1ZltvKytdID0gMTA7XG5cdFx0aSA9IGxpbWl0O1xuXHR9XG5cdG8gKz0gYnVmLndyaXRlKCctLS0tLUVORCAnICsgaGVhZGVyICsgJy0tLS0tXFxuJywgbyk7XG5cblx0cmV0dXJuIChidWYuc2xpY2UoMCwgbykpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/formats/x509-pem.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/formats/x509-pem.js":
/*!****************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/x509-pem.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2016 Joyent, Inc.\n\nvar x509 = __webpack_require__(/*! ./x509 */ \"(rsc)/./node_modules/sshpk/lib/formats/x509.js\");\n\nmodule.exports = {\n\tread: read,\n\tverify: x509.verify,\n\tsign: x509.sign,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(rsc)/./node_modules/asn1/lib/index.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\nvar pem = __webpack_require__(/*! ./pem */ \"(rsc)/./node_modules/sshpk/lib/formats/pem.js\");\nvar Identity = __webpack_require__(/*! ../identity */ \"(rsc)/./node_modules/sshpk/lib/identity.js\");\nvar Signature = __webpack_require__(/*! ../signature */ \"(rsc)/./node_modules/sshpk/lib/signature.js\");\nvar Certificate = __webpack_require__(/*! ../certificate */ \"(rsc)/./node_modules/sshpk/lib/certificate.js\");\n\nfunction read(buf, options) {\n\tif (typeof (buf) !== 'string') {\n\t\tassert.buffer(buf, 'buf');\n\t\tbuf = buf.toString('ascii');\n\t}\n\n\tvar lines = buf.trim().split(/[\\r\\n]+/g);\n\n\tvar m;\n\tvar si = -1;\n\twhile (!m && si < lines.length) {\n\t\tm = lines[++si].match(/*JSSTYLED*/\n\t\t    /[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);\n\t}\n\tassert.ok(m, 'invalid PEM header');\n\n\tvar m2;\n\tvar ei = lines.length;\n\twhile (!m2 && ei > 0) {\n\t\tm2 = lines[--ei].match(/*JSSTYLED*/\n\t\t    /[-]+[ ]*END CERTIFICATE[ ]*[-]+/);\n\t}\n\tassert.ok(m2, 'invalid PEM footer');\n\n\tlines = lines.slice(si, ei + 1);\n\n\tvar headers = {};\n\twhile (true) {\n\t\tlines = lines.slice(1);\n\t\tm = lines[0].match(/*JSSTYLED*/\n\t\t    /^([A-Za-z0-9-]+): (.+)$/);\n\t\tif (!m)\n\t\t\tbreak;\n\t\theaders[m[1].toLowerCase()] = m[2];\n\t}\n\n\t/* Chop off the first and last lines */\n\tlines = lines.slice(0, -1).join('');\n\tbuf = Buffer.from(lines, 'base64');\n\n\treturn (x509.read(buf, options));\n}\n\nfunction write(cert, options) {\n\tvar dbuf = x509.write(cert, options);\n\n\tvar header = 'CERTIFICATE';\n\tvar tmp = dbuf.toString('base64');\n\tvar len = tmp.length + (tmp.length / 64) +\n\t    18 + 16 + header.length*2 + 10;\n\tvar buf = Buffer.alloc(len);\n\tvar o = 0;\n\to += buf.write('-----BEGIN ' + header + '-----\\n', o);\n\tfor (var i = 0; i < tmp.length; ) {\n\t\tvar limit = i + 64;\n\t\tif (limit > tmp.length)\n\t\t\tlimit = tmp.length;\n\t\to += buf.write(tmp.slice(i, limit), o);\n\t\tbuf[o++] = 10;\n\t\ti = limit;\n\t}\n\to += buf.write('-----END ' + header + '-----\\n', o);\n\n\treturn (buf.slice(0, o));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMveDUwOS1wZW0uanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLDhEQUFROztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLCtEQUFhO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyxvREFBTTtBQUN6QixhQUFhLDhGQUE4QjtBQUMzQyxXQUFXLG1CQUFPLENBQUMsdURBQVM7QUFDNUIsWUFBWSxtQkFBTyxDQUFDLHlEQUFVO0FBQzlCLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixpQkFBaUIsbUJBQU8sQ0FBQyxxRUFBZ0I7QUFDekMsVUFBVSxtQkFBTyxDQUFDLDREQUFPO0FBQ3pCLGVBQWUsbUJBQU8sQ0FBQywrREFBYTtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBYztBQUN0QyxrQkFBa0IsbUJBQU8sQ0FBQyxxRUFBZ0I7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMveDUwOS1wZW0uanM/YWFhZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNiBKb3llbnQsIEluYy5cblxudmFyIHg1MDkgPSByZXF1aXJlKCcuL3g1MDknKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHJlYWQ6IHJlYWQsXG5cdHZlcmlmeTogeDUwOS52ZXJpZnksXG5cdHNpZ246IHg1MDkuc2lnbixcblx0d3JpdGU6IHdyaXRlXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMScpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBhbGdzID0gcmVxdWlyZSgnLi4vYWxncycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBLZXkgPSByZXF1aXJlKCcuLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZS1rZXknKTtcbnZhciBwZW0gPSByZXF1aXJlKCcuL3BlbScpO1xudmFyIElkZW50aXR5ID0gcmVxdWlyZSgnLi4vaWRlbnRpdHknKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuLi9zaWduYXR1cmUnKTtcbnZhciBDZXJ0aWZpY2F0ZSA9IHJlcXVpcmUoJy4uL2NlcnRpZmljYXRlJyk7XG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgKGJ1ZikgIT09ICdzdHJpbmcnKSB7XG5cdFx0YXNzZXJ0LmJ1ZmZlcihidWYsICdidWYnKTtcblx0XHRidWYgPSBidWYudG9TdHJpbmcoJ2FzY2lpJyk7XG5cdH1cblxuXHR2YXIgbGluZXMgPSBidWYudHJpbSgpLnNwbGl0KC9bXFxyXFxuXSsvZyk7XG5cblx0dmFyIG07XG5cdHZhciBzaSA9IC0xO1xuXHR3aGlsZSAoIW0gJiYgc2kgPCBsaW5lcy5sZW5ndGgpIHtcblx0XHRtID0gbGluZXNbKytzaV0ubWF0Y2goLypKU1NUWUxFRCovXG5cdFx0ICAgIC9bLV0rWyBdKkJFR0lOIENFUlRJRklDQVRFWyBdKlstXSsvKTtcblx0fVxuXHRhc3NlcnQub2sobSwgJ2ludmFsaWQgUEVNIGhlYWRlcicpO1xuXG5cdHZhciBtMjtcblx0dmFyIGVpID0gbGluZXMubGVuZ3RoO1xuXHR3aGlsZSAoIW0yICYmIGVpID4gMCkge1xuXHRcdG0yID0gbGluZXNbLS1laV0ubWF0Y2goLypKU1NUWUxFRCovXG5cdFx0ICAgIC9bLV0rWyBdKkVORCBDRVJUSUZJQ0FURVsgXSpbLV0rLyk7XG5cdH1cblx0YXNzZXJ0Lm9rKG0yLCAnaW52YWxpZCBQRU0gZm9vdGVyJyk7XG5cblx0bGluZXMgPSBsaW5lcy5zbGljZShzaSwgZWkgKyAxKTtcblxuXHR2YXIgaGVhZGVycyA9IHt9O1xuXHR3aGlsZSAodHJ1ZSkge1xuXHRcdGxpbmVzID0gbGluZXMuc2xpY2UoMSk7XG5cdFx0bSA9IGxpbmVzWzBdLm1hdGNoKC8qSlNTVFlMRUQqL1xuXHRcdCAgICAvXihbQS1aYS16MC05LV0rKTogKC4rKSQvKTtcblx0XHRpZiAoIW0pXG5cdFx0XHRicmVhaztcblx0XHRoZWFkZXJzW21bMV0udG9Mb3dlckNhc2UoKV0gPSBtWzJdO1xuXHR9XG5cblx0LyogQ2hvcCBvZmYgdGhlIGZpcnN0IGFuZCBsYXN0IGxpbmVzICovXG5cdGxpbmVzID0gbGluZXMuc2xpY2UoMCwgLTEpLmpvaW4oJycpO1xuXHRidWYgPSBCdWZmZXIuZnJvbShsaW5lcywgJ2Jhc2U2NCcpO1xuXG5cdHJldHVybiAoeDUwOS5yZWFkKGJ1Ziwgb3B0aW9ucykpO1xufVxuXG5mdW5jdGlvbiB3cml0ZShjZXJ0LCBvcHRpb25zKSB7XG5cdHZhciBkYnVmID0geDUwOS53cml0ZShjZXJ0LCBvcHRpb25zKTtcblxuXHR2YXIgaGVhZGVyID0gJ0NFUlRJRklDQVRFJztcblx0dmFyIHRtcCA9IGRidWYudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXHR2YXIgbGVuID0gdG1wLmxlbmd0aCArICh0bXAubGVuZ3RoIC8gNjQpICtcblx0ICAgIDE4ICsgMTYgKyBoZWFkZXIubGVuZ3RoKjIgKyAxMDtcblx0dmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyhsZW4pO1xuXHR2YXIgbyA9IDA7XG5cdG8gKz0gYnVmLndyaXRlKCctLS0tLUJFR0lOICcgKyBoZWFkZXIgKyAnLS0tLS1cXG4nLCBvKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyApIHtcblx0XHR2YXIgbGltaXQgPSBpICsgNjQ7XG5cdFx0aWYgKGxpbWl0ID4gdG1wLmxlbmd0aClcblx0XHRcdGxpbWl0ID0gdG1wLmxlbmd0aDtcblx0XHRvICs9IGJ1Zi53cml0ZSh0bXAuc2xpY2UoaSwgbGltaXQpLCBvKTtcblx0XHRidWZbbysrXSA9IDEwO1xuXHRcdGkgPSBsaW1pdDtcblx0fVxuXHRvICs9IGJ1Zi53cml0ZSgnLS0tLS1FTkQgJyArIGhlYWRlciArICctLS0tLVxcbicsIG8pO1xuXG5cdHJldHVybiAoYnVmLnNsaWNlKDAsIG8pKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/formats/x509-pem.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/formats/x509.js":
/*!************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/x509.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2017 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\tverify: verify,\n\tsign: sign,\n\tsignAsync: signAsync,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(action-browser)/./node_modules/asn1/lib/index.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\nvar pem = __webpack_require__(/*! ./pem */ \"(action-browser)/./node_modules/sshpk/lib/formats/pem.js\");\nvar Identity = __webpack_require__(/*! ../identity */ \"(action-browser)/./node_modules/sshpk/lib/identity.js\");\nvar Signature = __webpack_require__(/*! ../signature */ \"(action-browser)/./node_modules/sshpk/lib/signature.js\");\nvar Certificate = __webpack_require__(/*! ../certificate */ \"(action-browser)/./node_modules/sshpk/lib/certificate.js\");\nvar pkcs8 = __webpack_require__(/*! ./pkcs8 */ \"(action-browser)/./node_modules/sshpk/lib/formats/pkcs8.js\");\n\n/*\n * This file is based on RFC5280 (X.509).\n */\n\n/* Helper to read in a single mpint */\nfunction readMPInt(der, nm) {\n\tassert.strictEqual(der.peek(), asn1.Ber.Integer,\n\t    nm + ' is not an Integer');\n\treturn (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));\n}\n\nfunction verify(cert, key) {\n\tvar sig = cert.signatures.x509;\n\tassert.object(sig, 'x509 signature');\n\n\tvar algParts = sig.algo.split('-');\n\tif (algParts[0] !== key.type)\n\t\treturn (false);\n\n\tvar blob = sig.cache;\n\tif (blob === undefined) {\n\t\tvar der = new asn1.BerWriter();\n\t\twriteTBSCert(cert, der);\n\t\tblob = der.buffer;\n\t}\n\n\tvar verifier = key.createVerify(algParts[1]);\n\tverifier.write(blob);\n\treturn (verifier.verify(sig.signature));\n}\n\nfunction Local(i) {\n\treturn (asn1.Ber.Context | asn1.Ber.Constructor | i);\n}\n\nfunction Context(i) {\n\treturn (asn1.Ber.Context | i);\n}\n\nvar SIGN_ALGS = {\n\t'rsa-md5': '1.2.840.113549.1.1.4',\n\t'rsa-sha1': '1.2.840.113549.1.1.5',\n\t'rsa-sha256': '1.2.840.113549.1.1.11',\n\t'rsa-sha384': '1.2.840.113549.1.1.12',\n\t'rsa-sha512': '1.2.840.113549.1.1.13',\n\t'dsa-sha1': '1.2.840.10040.4.3',\n\t'dsa-sha256': '2.16.840.1.101.3.4.3.2',\n\t'ecdsa-sha1': '1.2.840.10045.4.1',\n\t'ecdsa-sha256': '1.2.840.10045.4.3.2',\n\t'ecdsa-sha384': '1.2.840.10045.4.3.3',\n\t'ecdsa-sha512': '1.2.840.10045.4.3.4',\n\t'ed25519-sha512': '1.3.101.112'\n};\nObject.keys(SIGN_ALGS).forEach(function (k) {\n\tSIGN_ALGS[SIGN_ALGS[k]] = k;\n});\nSIGN_ALGS['1.3.14.3.2.3'] = 'rsa-md5';\nSIGN_ALGS['1.3.14.3.2.29'] = 'rsa-sha1';\n\nvar EXTS = {\n\t'issuerKeyId': '2.5.29.35',\n\t'altName': '2.5.29.17',\n\t'basicConstraints': '2.5.29.19',\n\t'keyUsage': '2.5.29.15',\n\t'extKeyUsage': '2.5.29.37'\n};\n\nfunction read(buf, options) {\n\tif (typeof (buf) === 'string') {\n\t\tbuf = Buffer.from(buf, 'binary');\n\t}\n\tassert.buffer(buf, 'buf');\n\n\tvar der = new asn1.BerReader(buf);\n\n\tder.readSequence();\n\tif (Math.abs(der.length - der.remain) > 1) {\n\t\tthrow (new Error('DER sequence does not contain whole byte ' +\n\t\t    'stream'));\n\t}\n\n\tvar tbsStart = der.offset;\n\tder.readSequence();\n\tvar sigOffset = der.offset + der.length;\n\tvar tbsEnd = sigOffset;\n\n\tif (der.peek() === Local(0)) {\n\t\tder.readSequence(Local(0));\n\t\tvar version = der.readInt();\n\t\tassert.ok(version <= 3,\n\t\t    'only x.509 versions up to v3 supported');\n\t}\n\n\tvar cert = {};\n\tcert.signatures = {};\n\tvar sig = (cert.signatures.x509 = {});\n\tsig.extras = {};\n\n\tcert.serial = readMPInt(der, 'serial');\n\n\tder.readSequence();\n\tvar after = der.offset + der.length;\n\tvar certAlgOid = der.readOID();\n\tvar certAlg = SIGN_ALGS[certAlgOid];\n\tif (certAlg === undefined)\n\t\tthrow (new Error('unknown signature algorithm ' + certAlgOid));\n\n\tder._offset = after;\n\tcert.issuer = Identity.parseAsn1(der);\n\n\tder.readSequence();\n\tcert.validFrom = readDate(der);\n\tcert.validUntil = readDate(der);\n\n\tcert.subjects = [Identity.parseAsn1(der)];\n\n\tder.readSequence();\n\tafter = der.offset + der.length;\n\tcert.subjectKey = pkcs8.readPkcs8(undefined, 'public', der);\n\tder._offset = after;\n\n\t/* issuerUniqueID */\n\tif (der.peek() === Local(1)) {\n\t\tder.readSequence(Local(1));\n\t\tsig.extras.issuerUniqueID =\n\t\t    buf.slice(der.offset, der.offset + der.length);\n\t\tder._offset += der.length;\n\t}\n\n\t/* subjectUniqueID */\n\tif (der.peek() === Local(2)) {\n\t\tder.readSequence(Local(2));\n\t\tsig.extras.subjectUniqueID =\n\t\t    buf.slice(der.offset, der.offset + der.length);\n\t\tder._offset += der.length;\n\t}\n\n\t/* extensions */\n\tif (der.peek() === Local(3)) {\n\t\tder.readSequence(Local(3));\n\t\tvar extEnd = der.offset + der.length;\n\t\tder.readSequence();\n\n\t\twhile (der.offset < extEnd)\n\t\t\treadExtension(cert, buf, der);\n\n\t\tassert.strictEqual(der.offset, extEnd);\n\t}\n\n\tassert.strictEqual(der.offset, sigOffset);\n\n\tder.readSequence();\n\tafter = der.offset + der.length;\n\tvar sigAlgOid = der.readOID();\n\tvar sigAlg = SIGN_ALGS[sigAlgOid];\n\tif (sigAlg === undefined)\n\t\tthrow (new Error('unknown signature algorithm ' + sigAlgOid));\n\tder._offset = after;\n\n\tvar sigData = der.readString(asn1.Ber.BitString, true);\n\tif (sigData[0] === 0)\n\t\tsigData = sigData.slice(1);\n\tvar algParts = sigAlg.split('-');\n\n\tsig.signature = Signature.parse(sigData, algParts[0], 'asn1');\n\tsig.signature.hashAlgorithm = algParts[1];\n\tsig.algo = sigAlg;\n\tsig.cache = buf.slice(tbsStart, tbsEnd);\n\n\treturn (new Certificate(cert));\n}\n\nfunction readDate(der) {\n\tif (der.peek() === asn1.Ber.UTCTime) {\n\t\treturn (utcTimeToDate(der.readString(asn1.Ber.UTCTime)));\n\t} else if (der.peek() === asn1.Ber.GeneralizedTime) {\n\t\treturn (gTimeToDate(der.readString(asn1.Ber.GeneralizedTime)));\n\t} else {\n\t\tthrow (new Error('Unsupported date format'));\n\t}\n}\n\nfunction writeDate(der, date) {\n\tif (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {\n\t\tder.writeString(dateToGTime(date), asn1.Ber.GeneralizedTime);\n\t} else {\n\t\tder.writeString(dateToUTCTime(date), asn1.Ber.UTCTime);\n\t}\n}\n\n/* RFC5280, section 4.2.1.6 (GeneralName type) */\nvar ALTNAME = {\n\tOtherName: Local(0),\n\tRFC822Name: Context(1),\n\tDNSName: Context(2),\n\tX400Address: Local(3),\n\tDirectoryName: Local(4),\n\tEDIPartyName: Local(5),\n\tURI: Context(6),\n\tIPAddress: Context(7),\n\tOID: Context(8)\n};\n\n/* RFC5280, section 4.2.1.12 (KeyPurposeId) */\nvar EXTPURPOSE = {\n\t'serverAuth': '1.3.6.1.5.5.7.3.1',\n\t'clientAuth': '1.3.6.1.5.5.7.3.2',\n\t'codeSigning': '1.3.6.1.5.5.7.3.3',\n\n\t/* See https://github.com/joyent/oid-docs/blob/master/root.md */\n\t'joyentDocker': '1.3.6.1.4.1.38678.1.4.1',\n\t'joyentCmon': '1.3.6.1.4.1.38678.1.4.2'\n};\nvar EXTPURPOSE_REV = {};\nObject.keys(EXTPURPOSE).forEach(function (k) {\n\tEXTPURPOSE_REV[EXTPURPOSE[k]] = k;\n});\n\nvar KEYUSEBITS = [\n\t'signature', 'identity', 'keyEncryption',\n\t'encryption', 'keyAgreement', 'ca', 'crl'\n];\n\nfunction readExtension(cert, buf, der) {\n\tder.readSequence();\n\tvar after = der.offset + der.length;\n\tvar extId = der.readOID();\n\tvar id;\n\tvar sig = cert.signatures.x509;\n\tif (!sig.extras.exts)\n\t\tsig.extras.exts = [];\n\n\tvar critical;\n\tif (der.peek() === asn1.Ber.Boolean)\n\t\tcritical = der.readBoolean();\n\n\tswitch (extId) {\n\tcase (EXTS.basicConstraints):\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tder.readSequence();\n\t\tvar bcEnd = der.offset + der.length;\n\t\tvar ca = false;\n\t\tif (der.peek() === asn1.Ber.Boolean)\n\t\t\tca = der.readBoolean();\n\t\tif (cert.purposes === undefined)\n\t\t\tcert.purposes = [];\n\t\tif (ca === true)\n\t\t\tcert.purposes.push('ca');\n\t\tvar bc = { oid: extId, critical: critical };\n\t\tif (der.offset < bcEnd && der.peek() === asn1.Ber.Integer)\n\t\t\tbc.pathLen = der.readInt();\n\t\tsig.extras.exts.push(bc);\n\t\tbreak;\n\tcase (EXTS.extKeyUsage):\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tder.readSequence();\n\t\tif (cert.purposes === undefined)\n\t\t\tcert.purposes = [];\n\t\tvar ekEnd = der.offset + der.length;\n\t\twhile (der.offset < ekEnd) {\n\t\t\tvar oid = der.readOID();\n\t\t\tcert.purposes.push(EXTPURPOSE_REV[oid] || oid);\n\t\t}\n\t\t/*\n\t\t * This is a bit of a hack: in the case where we have a cert\n\t\t * that's only allowed to do serverAuth or clientAuth (and not\n\t\t * the other), we want to make sure all our Subjects are of\n\t\t * the right type. But we already parsed our Subjects and\n\t\t * decided if they were hosts or users earlier (since it appears\n\t\t * first in the cert).\n\t\t *\n\t\t * So we go through and mutate them into the right kind here if\n\t\t * it doesn't match. This might not be hugely beneficial, as it\n\t\t * seems that single-purpose certs are not often seen in the\n\t\t * wild.\n\t\t */\n\t\tif (cert.purposes.indexOf('serverAuth') !== -1 &&\n\t\t    cert.purposes.indexOf('clientAuth') === -1) {\n\t\t\tcert.subjects.forEach(function (ide) {\n\t\t\t\tif (ide.type !== 'host') {\n\t\t\t\t\tide.type = 'host';\n\t\t\t\t\tide.hostname = ide.uid ||\n\t\t\t\t\t    ide.email ||\n\t\t\t\t\t    ide.components[0].value;\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (cert.purposes.indexOf('clientAuth') !== -1 &&\n\t\t    cert.purposes.indexOf('serverAuth') === -1) {\n\t\t\tcert.subjects.forEach(function (ide) {\n\t\t\t\tif (ide.type !== 'user') {\n\t\t\t\t\tide.type = 'user';\n\t\t\t\t\tide.uid = ide.hostname ||\n\t\t\t\t\t    ide.email ||\n\t\t\t\t\t    ide.components[0].value;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tsig.extras.exts.push({ oid: extId, critical: critical });\n\t\tbreak;\n\tcase (EXTS.keyUsage):\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tvar bits = der.readString(asn1.Ber.BitString, true);\n\t\tvar setBits = readBitField(bits, KEYUSEBITS);\n\t\tsetBits.forEach(function (bit) {\n\t\t\tif (cert.purposes === undefined)\n\t\t\t\tcert.purposes = [];\n\t\t\tif (cert.purposes.indexOf(bit) === -1)\n\t\t\t\tcert.purposes.push(bit);\n\t\t});\n\t\tsig.extras.exts.push({ oid: extId, critical: critical,\n\t\t    bits: bits });\n\t\tbreak;\n\tcase (EXTS.altName):\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tder.readSequence();\n\t\tvar aeEnd = der.offset + der.length;\n\t\twhile (der.offset < aeEnd) {\n\t\t\tswitch (der.peek()) {\n\t\t\tcase ALTNAME.OtherName:\n\t\t\tcase ALTNAME.EDIPartyName:\n\t\t\t\tder.readSequence();\n\t\t\t\tder._offset += der.length;\n\t\t\t\tbreak;\n\t\t\tcase ALTNAME.OID:\n\t\t\t\tder.readOID(ALTNAME.OID);\n\t\t\t\tbreak;\n\t\t\tcase ALTNAME.RFC822Name:\n\t\t\t\t/* RFC822 specifies email addresses */\n\t\t\t\tvar email = der.readString(ALTNAME.RFC822Name);\n\t\t\t\tid = Identity.forEmail(email);\n\t\t\t\tif (!cert.subjects[0].equals(id))\n\t\t\t\t\tcert.subjects.push(id);\n\t\t\t\tbreak;\n\t\t\tcase ALTNAME.DirectoryName:\n\t\t\t\tder.readSequence(ALTNAME.DirectoryName);\n\t\t\t\tid = Identity.parseAsn1(der);\n\t\t\t\tif (!cert.subjects[0].equals(id))\n\t\t\t\t\tcert.subjects.push(id);\n\t\t\t\tbreak;\n\t\t\tcase ALTNAME.DNSName:\n\t\t\t\tvar host = der.readString(\n\t\t\t\t    ALTNAME.DNSName);\n\t\t\t\tid = Identity.forHost(host);\n\t\t\t\tif (!cert.subjects[0].equals(id))\n\t\t\t\t\tcert.subjects.push(id);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tder.readString(der.peek());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsig.extras.exts.push({ oid: extId, critical: critical });\n\t\tbreak;\n\tdefault:\n\t\tsig.extras.exts.push({\n\t\t\toid: extId,\n\t\t\tcritical: critical,\n\t\t\tdata: der.readString(asn1.Ber.OctetString, true)\n\t\t});\n\t\tbreak;\n\t}\n\n\tder._offset = after;\n}\n\nvar UTCTIME_RE =\n    /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;\nfunction utcTimeToDate(t) {\n\tvar m = t.match(UTCTIME_RE);\n\tassert.ok(m, 'timestamps must be in UTC');\n\tvar d = new Date();\n\n\tvar thisYear = d.getUTCFullYear();\n\tvar century = Math.floor(thisYear / 100) * 100;\n\n\tvar year = parseInt(m[1], 10);\n\tif (thisYear % 100 < 50 && year >= 60)\n\t\tyear += (century - 1);\n\telse\n\t\tyear += century;\n\td.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));\n\td.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));\n\tif (m[6] && m[6].length > 0)\n\t\td.setUTCSeconds(parseInt(m[6], 10));\n\treturn (d);\n}\n\nvar GTIME_RE =\n    /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;\nfunction gTimeToDate(t) {\n\tvar m = t.match(GTIME_RE);\n\tassert.ok(m);\n\tvar d = new Date();\n\n\td.setUTCFullYear(parseInt(m[1], 10), parseInt(m[2], 10) - 1,\n\t    parseInt(m[3], 10));\n\td.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));\n\tif (m[6] && m[6].length > 0)\n\t\td.setUTCSeconds(parseInt(m[6], 10));\n\treturn (d);\n}\n\nfunction zeroPad(n, m) {\n\tif (m === undefined)\n\t\tm = 2;\n\tvar s = '' + n;\n\twhile (s.length < m)\n\t\ts = '0' + s;\n\treturn (s);\n}\n\nfunction dateToUTCTime(d) {\n\tvar s = '';\n\ts += zeroPad(d.getUTCFullYear() % 100);\n\ts += zeroPad(d.getUTCMonth() + 1);\n\ts += zeroPad(d.getUTCDate());\n\ts += zeroPad(d.getUTCHours());\n\ts += zeroPad(d.getUTCMinutes());\n\ts += zeroPad(d.getUTCSeconds());\n\ts += 'Z';\n\treturn (s);\n}\n\nfunction dateToGTime(d) {\n\tvar s = '';\n\ts += zeroPad(d.getUTCFullYear(), 4);\n\ts += zeroPad(d.getUTCMonth() + 1);\n\ts += zeroPad(d.getUTCDate());\n\ts += zeroPad(d.getUTCHours());\n\ts += zeroPad(d.getUTCMinutes());\n\ts += zeroPad(d.getUTCSeconds());\n\ts += 'Z';\n\treturn (s);\n}\n\nfunction sign(cert, key) {\n\tif (cert.signatures.x509 === undefined)\n\t\tcert.signatures.x509 = {};\n\tvar sig = cert.signatures.x509;\n\n\tsig.algo = key.type + '-' + key.defaultHashAlgorithm();\n\tif (SIGN_ALGS[sig.algo] === undefined)\n\t\treturn (false);\n\n\tvar der = new asn1.BerWriter();\n\twriteTBSCert(cert, der);\n\tvar blob = der.buffer;\n\tsig.cache = blob;\n\n\tvar signer = key.createSign();\n\tsigner.write(blob);\n\tcert.signatures.x509.signature = signer.sign();\n\n\treturn (true);\n}\n\nfunction signAsync(cert, signer, done) {\n\tif (cert.signatures.x509 === undefined)\n\t\tcert.signatures.x509 = {};\n\tvar sig = cert.signatures.x509;\n\n\tvar der = new asn1.BerWriter();\n\twriteTBSCert(cert, der);\n\tvar blob = der.buffer;\n\tsig.cache = blob;\n\n\tsigner(blob, function (err, signature) {\n\t\tif (err) {\n\t\t\tdone(err);\n\t\t\treturn;\n\t\t}\n\t\tsig.algo = signature.type + '-' + signature.hashAlgorithm;\n\t\tif (SIGN_ALGS[sig.algo] === undefined) {\n\t\t\tdone(new Error('Invalid signing algorithm \"' +\n\t\t\t    sig.algo + '\"'));\n\t\t\treturn;\n\t\t}\n\t\tsig.signature = signature;\n\t\tdone();\n\t});\n}\n\nfunction write(cert, options) {\n\tvar sig = cert.signatures.x509;\n\tassert.object(sig, 'x509 signature');\n\n\tvar der = new asn1.BerWriter();\n\tder.startSequence();\n\tif (sig.cache) {\n\t\tder._ensure(sig.cache.length);\n\t\tsig.cache.copy(der._buf, der._offset);\n\t\tder._offset += sig.cache.length;\n\t} else {\n\t\twriteTBSCert(cert, der);\n\t}\n\n\tder.startSequence();\n\tder.writeOID(SIGN_ALGS[sig.algo]);\n\tif (sig.algo.match(/^rsa-/))\n\t\tder.writeNull();\n\tder.endSequence();\n\n\tvar sigData = sig.signature.toBuffer('asn1');\n\tvar data = Buffer.alloc(sigData.length + 1);\n\tdata[0] = 0;\n\tsigData.copy(data, 1);\n\tder.writeBuffer(data, asn1.Ber.BitString);\n\tder.endSequence();\n\n\treturn (der.buffer);\n}\n\nfunction writeTBSCert(cert, der) {\n\tvar sig = cert.signatures.x509;\n\tassert.object(sig, 'x509 signature');\n\n\tder.startSequence();\n\n\tder.startSequence(Local(0));\n\tder.writeInt(2);\n\tder.endSequence();\n\n\tder.writeBuffer(utils.mpNormalize(cert.serial), asn1.Ber.Integer);\n\n\tder.startSequence();\n\tder.writeOID(SIGN_ALGS[sig.algo]);\n\tif (sig.algo.match(/^rsa-/))\n\t\tder.writeNull();\n\tder.endSequence();\n\n\tcert.issuer.toAsn1(der);\n\n\tder.startSequence();\n\twriteDate(der, cert.validFrom);\n\twriteDate(der, cert.validUntil);\n\tder.endSequence();\n\n\tvar subject = cert.subjects[0];\n\tvar altNames = cert.subjects.slice(1);\n\tsubject.toAsn1(der);\n\n\tpkcs8.writePkcs8(der, cert.subjectKey);\n\n\tif (sig.extras && sig.extras.issuerUniqueID) {\n\t\tder.writeBuffer(sig.extras.issuerUniqueID, Local(1));\n\t}\n\n\tif (sig.extras && sig.extras.subjectUniqueID) {\n\t\tder.writeBuffer(sig.extras.subjectUniqueID, Local(2));\n\t}\n\n\tif (altNames.length > 0 || subject.type === 'host' ||\n\t    (cert.purposes !== undefined && cert.purposes.length > 0) ||\n\t    (sig.extras && sig.extras.exts)) {\n\t\tder.startSequence(Local(3));\n\t\tder.startSequence();\n\n\t\tvar exts = [];\n\t\tif (cert.purposes !== undefined && cert.purposes.length > 0) {\n\t\t\texts.push({\n\t\t\t\toid: EXTS.basicConstraints,\n\t\t\t\tcritical: true\n\t\t\t});\n\t\t\texts.push({\n\t\t\t\toid: EXTS.keyUsage,\n\t\t\t\tcritical: true\n\t\t\t});\n\t\t\texts.push({\n\t\t\t\toid: EXTS.extKeyUsage,\n\t\t\t\tcritical: true\n\t\t\t});\n\t\t}\n\t\texts.push({ oid: EXTS.altName });\n\t\tif (sig.extras && sig.extras.exts)\n\t\t\texts = sig.extras.exts;\n\n\t\tfor (var i = 0; i < exts.length; ++i) {\n\t\t\tder.startSequence();\n\t\t\tder.writeOID(exts[i].oid);\n\n\t\t\tif (exts[i].critical !== undefined)\n\t\t\t\tder.writeBoolean(exts[i].critical);\n\n\t\t\tif (exts[i].oid === EXTS.altName) {\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\n\t\t\t\tder.startSequence();\n\t\t\t\tif (subject.type === 'host') {\n\t\t\t\t\tder.writeString(subject.hostname,\n\t\t\t\t\t    Context(2));\n\t\t\t\t}\n\t\t\t\tfor (var j = 0; j < altNames.length; ++j) {\n\t\t\t\t\tif (altNames[j].type === 'host') {\n\t\t\t\t\t\tder.writeString(\n\t\t\t\t\t\t    altNames[j].hostname,\n\t\t\t\t\t\t    ALTNAME.DNSName);\n\t\t\t\t\t} else if (altNames[j].type ===\n\t\t\t\t\t    'email') {\n\t\t\t\t\t\tder.writeString(\n\t\t\t\t\t\t    altNames[j].email,\n\t\t\t\t\t\t    ALTNAME.RFC822Name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Encode anything else as a\n\t\t\t\t\t\t * DN style name for now.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tder.startSequence(\n\t\t\t\t\t\t    ALTNAME.DirectoryName);\n\t\t\t\t\t\taltNames[j].toAsn1(der);\n\t\t\t\t\t\tder.endSequence();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tder.endSequence();\n\t\t\t\tder.endSequence();\n\t\t\t} else if (exts[i].oid === EXTS.basicConstraints) {\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\n\t\t\t\tder.startSequence();\n\t\t\t\tvar ca = (cert.purposes.indexOf('ca') !== -1);\n\t\t\t\tvar pathLen = exts[i].pathLen;\n\t\t\t\tder.writeBoolean(ca);\n\t\t\t\tif (pathLen !== undefined)\n\t\t\t\t\tder.writeInt(pathLen);\n\t\t\t\tder.endSequence();\n\t\t\t\tder.endSequence();\n\t\t\t} else if (exts[i].oid === EXTS.extKeyUsage) {\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\n\t\t\t\tder.startSequence();\n\t\t\t\tcert.purposes.forEach(function (purpose) {\n\t\t\t\t\tif (purpose === 'ca')\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (KEYUSEBITS.indexOf(purpose) !== -1)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tvar oid = purpose;\n\t\t\t\t\tif (EXTPURPOSE[purpose] !== undefined)\n\t\t\t\t\t\toid = EXTPURPOSE[purpose];\n\t\t\t\t\tder.writeOID(oid);\n\t\t\t\t});\n\t\t\t\tder.endSequence();\n\t\t\t\tder.endSequence();\n\t\t\t} else if (exts[i].oid === EXTS.keyUsage) {\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\n\t\t\t\t/*\n\t\t\t\t * If we parsed this certificate from a byte\n\t\t\t\t * stream (i.e. we didn't generate it in sshpk)\n\t\t\t\t * then we'll have a \".bits\" property on the\n\t\t\t\t * ext with the original raw byte contents.\n\t\t\t\t *\n\t\t\t\t * If we have this, use it here instead of\n\t\t\t\t * regenerating it. This guarantees we output\n\t\t\t\t * the same data we parsed, so signatures still\n\t\t\t\t * validate.\n\t\t\t\t */\n\t\t\t\tif (exts[i].bits !== undefined) {\n\t\t\t\t\tder.writeBuffer(exts[i].bits,\n\t\t\t\t\t    asn1.Ber.BitString);\n\t\t\t\t} else {\n\t\t\t\t\tvar bits = writeBitField(cert.purposes,\n\t\t\t\t\t    KEYUSEBITS);\n\t\t\t\t\tder.writeBuffer(bits,\n\t\t\t\t\t    asn1.Ber.BitString);\n\t\t\t\t}\n\t\t\t\tder.endSequence();\n\t\t\t} else {\n\t\t\t\tder.writeBuffer(exts[i].data,\n\t\t\t\t    asn1.Ber.OctetString);\n\t\t\t}\n\n\t\t\tder.endSequence();\n\t\t}\n\n\t\tder.endSequence();\n\t\tder.endSequence();\n\t}\n\n\tder.endSequence();\n}\n\n/*\n * Reads an ASN.1 BER bitfield out of the Buffer produced by doing\n * `BerReader#readString(asn1.Ber.BitString)`. That function gives us the raw\n * contents of the BitString tag, which is a count of unused bits followed by\n * the bits as a right-padded byte string.\n *\n * `bits` is the Buffer, `bitIndex` should contain an array of string names\n * for the bits in the string, ordered starting with bit #0 in the ASN.1 spec.\n *\n * Returns an array of Strings, the names of the bits that were set to 1.\n */\nfunction readBitField(bits, bitIndex) {\n\tvar bitLen = 8 * (bits.length - 1) - bits[0];\n\tvar setBits = {};\n\tfor (var i = 0; i < bitLen; ++i) {\n\t\tvar byteN = 1 + Math.floor(i / 8);\n\t\tvar bit = 7 - (i % 8);\n\t\tvar mask = 1 << bit;\n\t\tvar bitVal = ((bits[byteN] & mask) !== 0);\n\t\tvar name = bitIndex[i];\n\t\tif (bitVal && typeof (name) === 'string') {\n\t\t\tsetBits[name] = true;\n\t\t}\n\t}\n\treturn (Object.keys(setBits));\n}\n\n/*\n * `setBits` is an array of strings, containing the names for each bit that\n * sould be set to 1. `bitIndex` is same as in `readBitField()`.\n *\n * Returns a Buffer, ready to be written out with `BerWriter#writeString()`.\n */\nfunction writeBitField(setBits, bitIndex) {\n\tvar bitLen = bitIndex.length;\n\tvar blen = Math.ceil(bitLen / 8);\n\tvar unused = blen * 8 - bitLen;\n\tvar bits = Buffer.alloc(1 + blen); // zero-filled\n\tbits[0] = unused;\n\tfor (var i = 0; i < bitLen; ++i) {\n\t\tvar byteN = 1 + Math.floor(i / 8);\n\t\tvar bit = 7 - (i % 8);\n\t\tvar mask = 1 << bit;\n\t\tvar name = bitIndex[i];\n\t\tif (name === undefined)\n\t\t\tcontinue;\n\t\tvar bitVal = (setBits.indexOf(name) !== -1);\n\t\tif (bitVal) {\n\t\t\tbits[byteN] |= mask;\n\t\t}\n\t}\n\treturn (bits);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy94NTA5LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywwRUFBYTtBQUNsQyxXQUFXLG1CQUFPLENBQUMsK0RBQU07QUFDekIsYUFBYSx5R0FBOEI7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLGtFQUFTO0FBQzVCLFlBQVksbUJBQU8sQ0FBQyxvRUFBVTtBQUM5QixVQUFVLG1CQUFPLENBQUMsZ0VBQVE7QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQWdCO0FBQ3pDLFVBQVUsbUJBQU8sQ0FBQyx1RUFBTztBQUN6QixlQUFlLG1CQUFPLENBQUMsMEVBQWE7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMsNEVBQWM7QUFDdEMsa0JBQWtCLG1CQUFPLENBQUMsZ0ZBQWdCO0FBQzFDLFlBQVksbUJBQU8sQ0FBQywyRUFBUzs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCO0FBQ3pCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9mb3JtYXRzL3g1MDkuanM/YTVhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNyBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHJlYWQ6IHJlYWQsXG5cdHZlcmlmeTogdmVyaWZ5LFxuXHRzaWduOiBzaWduLFxuXHRzaWduQXN5bmM6IHNpZ25Bc3luYyxcblx0d3JpdGU6IHdyaXRlXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMScpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBhbGdzID0gcmVxdWlyZSgnLi4vYWxncycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBLZXkgPSByZXF1aXJlKCcuLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZS1rZXknKTtcbnZhciBwZW0gPSByZXF1aXJlKCcuL3BlbScpO1xudmFyIElkZW50aXR5ID0gcmVxdWlyZSgnLi4vaWRlbnRpdHknKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuLi9zaWduYXR1cmUnKTtcbnZhciBDZXJ0aWZpY2F0ZSA9IHJlcXVpcmUoJy4uL2NlcnRpZmljYXRlJyk7XG52YXIgcGtjczggPSByZXF1aXJlKCcuL3BrY3M4Jyk7XG5cbi8qXG4gKiBUaGlzIGZpbGUgaXMgYmFzZWQgb24gUkZDNTI4MCAoWC41MDkpLlxuICovXG5cbi8qIEhlbHBlciB0byByZWFkIGluIGEgc2luZ2xlIG1waW50ICovXG5mdW5jdGlvbiByZWFkTVBJbnQoZGVyLCBubSkge1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwoZGVyLnBlZWsoKSwgYXNuMS5CZXIuSW50ZWdlcixcblx0ICAgIG5tICsgJyBpcyBub3QgYW4gSW50ZWdlcicpO1xuXHRyZXR1cm4gKHV0aWxzLm1wTm9ybWFsaXplKGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkludGVnZXIsIHRydWUpKSk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeShjZXJ0LCBrZXkpIHtcblx0dmFyIHNpZyA9IGNlcnQuc2lnbmF0dXJlcy54NTA5O1xuXHRhc3NlcnQub2JqZWN0KHNpZywgJ3g1MDkgc2lnbmF0dXJlJyk7XG5cblx0dmFyIGFsZ1BhcnRzID0gc2lnLmFsZ28uc3BsaXQoJy0nKTtcblx0aWYgKGFsZ1BhcnRzWzBdICE9PSBrZXkudHlwZSlcblx0XHRyZXR1cm4gKGZhbHNlKTtcblxuXHR2YXIgYmxvYiA9IHNpZy5jYWNoZTtcblx0aWYgKGJsb2IgPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBkZXIgPSBuZXcgYXNuMS5CZXJXcml0ZXIoKTtcblx0XHR3cml0ZVRCU0NlcnQoY2VydCwgZGVyKTtcblx0XHRibG9iID0gZGVyLmJ1ZmZlcjtcblx0fVxuXG5cdHZhciB2ZXJpZmllciA9IGtleS5jcmVhdGVWZXJpZnkoYWxnUGFydHNbMV0pO1xuXHR2ZXJpZmllci53cml0ZShibG9iKTtcblx0cmV0dXJuICh2ZXJpZmllci52ZXJpZnkoc2lnLnNpZ25hdHVyZSkpO1xufVxuXG5mdW5jdGlvbiBMb2NhbChpKSB7XG5cdHJldHVybiAoYXNuMS5CZXIuQ29udGV4dCB8IGFzbjEuQmVyLkNvbnN0cnVjdG9yIHwgaSk7XG59XG5cbmZ1bmN0aW9uIENvbnRleHQoaSkge1xuXHRyZXR1cm4gKGFzbjEuQmVyLkNvbnRleHQgfCBpKTtcbn1cblxudmFyIFNJR05fQUxHUyA9IHtcblx0J3JzYS1tZDUnOiAnMS4yLjg0MC4xMTM1NDkuMS4xLjQnLFxuXHQncnNhLXNoYTEnOiAnMS4yLjg0MC4xMTM1NDkuMS4xLjUnLFxuXHQncnNhLXNoYTI1Nic6ICcxLjIuODQwLjExMzU0OS4xLjEuMTEnLFxuXHQncnNhLXNoYTM4NCc6ICcxLjIuODQwLjExMzU0OS4xLjEuMTInLFxuXHQncnNhLXNoYTUxMic6ICcxLjIuODQwLjExMzU0OS4xLjEuMTMnLFxuXHQnZHNhLXNoYTEnOiAnMS4yLjg0MC4xMDA0MC40LjMnLFxuXHQnZHNhLXNoYTI1Nic6ICcyLjE2Ljg0MC4xLjEwMS4zLjQuMy4yJyxcblx0J2VjZHNhLXNoYTEnOiAnMS4yLjg0MC4xMDA0NS40LjEnLFxuXHQnZWNkc2Etc2hhMjU2JzogJzEuMi44NDAuMTAwNDUuNC4zLjInLFxuXHQnZWNkc2Etc2hhMzg0JzogJzEuMi44NDAuMTAwNDUuNC4zLjMnLFxuXHQnZWNkc2Etc2hhNTEyJzogJzEuMi44NDAuMTAwNDUuNC4zLjQnLFxuXHQnZWQyNTUxOS1zaGE1MTInOiAnMS4zLjEwMS4xMTInXG59O1xuT2JqZWN0LmtleXMoU0lHTl9BTEdTKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdFNJR05fQUxHU1tTSUdOX0FMR1Nba11dID0gaztcbn0pO1xuU0lHTl9BTEdTWycxLjMuMTQuMy4yLjMnXSA9ICdyc2EtbWQ1JztcblNJR05fQUxHU1snMS4zLjE0LjMuMi4yOSddID0gJ3JzYS1zaGExJztcblxudmFyIEVYVFMgPSB7XG5cdCdpc3N1ZXJLZXlJZCc6ICcyLjUuMjkuMzUnLFxuXHQnYWx0TmFtZSc6ICcyLjUuMjkuMTcnLFxuXHQnYmFzaWNDb25zdHJhaW50cyc6ICcyLjUuMjkuMTknLFxuXHQna2V5VXNhZ2UnOiAnMi41LjI5LjE1Jyxcblx0J2V4dEtleVVzYWdlJzogJzIuNS4yOS4zNydcbn07XG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgKGJ1ZikgPT09ICdzdHJpbmcnKSB7XG5cdFx0YnVmID0gQnVmZmVyLmZyb20oYnVmLCAnYmluYXJ5Jyk7XG5cdH1cblx0YXNzZXJ0LmJ1ZmZlcihidWYsICdidWYnKTtcblxuXHR2YXIgZGVyID0gbmV3IGFzbjEuQmVyUmVhZGVyKGJ1Zik7XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRpZiAoTWF0aC5hYnMoZGVyLmxlbmd0aCAtIGRlci5yZW1haW4pID4gMSkge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ0RFUiBzZXF1ZW5jZSBkb2VzIG5vdCBjb250YWluIHdob2xlIGJ5dGUgJyArXG5cdFx0ICAgICdzdHJlYW0nKSk7XG5cdH1cblxuXHR2YXIgdGJzU3RhcnQgPSBkZXIub2Zmc2V0O1xuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdHZhciBzaWdPZmZzZXQgPSBkZXIub2Zmc2V0ICsgZGVyLmxlbmd0aDtcblx0dmFyIHRic0VuZCA9IHNpZ09mZnNldDtcblxuXHRpZiAoZGVyLnBlZWsoKSA9PT0gTG9jYWwoMCkpIHtcblx0XHRkZXIucmVhZFNlcXVlbmNlKExvY2FsKDApKTtcblx0XHR2YXIgdmVyc2lvbiA9IGRlci5yZWFkSW50KCk7XG5cdFx0YXNzZXJ0Lm9rKHZlcnNpb24gPD0gMyxcblx0XHQgICAgJ29ubHkgeC41MDkgdmVyc2lvbnMgdXAgdG8gdjMgc3VwcG9ydGVkJyk7XG5cdH1cblxuXHR2YXIgY2VydCA9IHt9O1xuXHRjZXJ0LnNpZ25hdHVyZXMgPSB7fTtcblx0dmFyIHNpZyA9IChjZXJ0LnNpZ25hdHVyZXMueDUwOSA9IHt9KTtcblx0c2lnLmV4dHJhcyA9IHt9O1xuXG5cdGNlcnQuc2VyaWFsID0gcmVhZE1QSW50KGRlciwgJ3NlcmlhbCcpO1xuXG5cdGRlci5yZWFkU2VxdWVuY2UoKTtcblx0dmFyIGFmdGVyID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cdHZhciBjZXJ0QWxnT2lkID0gZGVyLnJlYWRPSUQoKTtcblx0dmFyIGNlcnRBbGcgPSBTSUdOX0FMR1NbY2VydEFsZ09pZF07XG5cdGlmIChjZXJ0QWxnID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndW5rbm93biBzaWduYXR1cmUgYWxnb3JpdGhtICcgKyBjZXJ0QWxnT2lkKSk7XG5cblx0ZGVyLl9vZmZzZXQgPSBhZnRlcjtcblx0Y2VydC5pc3N1ZXIgPSBJZGVudGl0eS5wYXJzZUFzbjEoZGVyKTtcblxuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdGNlcnQudmFsaWRGcm9tID0gcmVhZERhdGUoZGVyKTtcblx0Y2VydC52YWxpZFVudGlsID0gcmVhZERhdGUoZGVyKTtcblxuXHRjZXJ0LnN1YmplY3RzID0gW0lkZW50aXR5LnBhcnNlQXNuMShkZXIpXTtcblxuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdGFmdGVyID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cdGNlcnQuc3ViamVjdEtleSA9IHBrY3M4LnJlYWRQa2NzOCh1bmRlZmluZWQsICdwdWJsaWMnLCBkZXIpO1xuXHRkZXIuX29mZnNldCA9IGFmdGVyO1xuXG5cdC8qIGlzc3VlclVuaXF1ZUlEICovXG5cdGlmIChkZXIucGVlaygpID09PSBMb2NhbCgxKSkge1xuXHRcdGRlci5yZWFkU2VxdWVuY2UoTG9jYWwoMSkpO1xuXHRcdHNpZy5leHRyYXMuaXNzdWVyVW5pcXVlSUQgPVxuXHRcdCAgICBidWYuc2xpY2UoZGVyLm9mZnNldCwgZGVyLm9mZnNldCArIGRlci5sZW5ndGgpO1xuXHRcdGRlci5fb2Zmc2V0ICs9IGRlci5sZW5ndGg7XG5cdH1cblxuXHQvKiBzdWJqZWN0VW5pcXVlSUQgKi9cblx0aWYgKGRlci5wZWVrKCkgPT09IExvY2FsKDIpKSB7XG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZShMb2NhbCgyKSk7XG5cdFx0c2lnLmV4dHJhcy5zdWJqZWN0VW5pcXVlSUQgPVxuXHRcdCAgICBidWYuc2xpY2UoZGVyLm9mZnNldCwgZGVyLm9mZnNldCArIGRlci5sZW5ndGgpO1xuXHRcdGRlci5fb2Zmc2V0ICs9IGRlci5sZW5ndGg7XG5cdH1cblxuXHQvKiBleHRlbnNpb25zICovXG5cdGlmIChkZXIucGVlaygpID09PSBMb2NhbCgzKSkge1xuXHRcdGRlci5yZWFkU2VxdWVuY2UoTG9jYWwoMykpO1xuXHRcdHZhciBleHRFbmQgPSBkZXIub2Zmc2V0ICsgZGVyLmxlbmd0aDtcblx0XHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cblx0XHR3aGlsZSAoZGVyLm9mZnNldCA8IGV4dEVuZClcblx0XHRcdHJlYWRFeHRlbnNpb24oY2VydCwgYnVmLCBkZXIpO1xuXG5cdFx0YXNzZXJ0LnN0cmljdEVxdWFsKGRlci5vZmZzZXQsIGV4dEVuZCk7XG5cdH1cblxuXHRhc3NlcnQuc3RyaWN0RXF1YWwoZGVyLm9mZnNldCwgc2lnT2Zmc2V0KTtcblxuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdGFmdGVyID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cdHZhciBzaWdBbGdPaWQgPSBkZXIucmVhZE9JRCgpO1xuXHR2YXIgc2lnQWxnID0gU0lHTl9BTEdTW3NpZ0FsZ09pZF07XG5cdGlmIChzaWdBbGcgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCd1bmtub3duIHNpZ25hdHVyZSBhbGdvcml0aG0gJyArIHNpZ0FsZ09pZCkpO1xuXHRkZXIuX29mZnNldCA9IGFmdGVyO1xuXG5cdHZhciBzaWdEYXRhID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuQml0U3RyaW5nLCB0cnVlKTtcblx0aWYgKHNpZ0RhdGFbMF0gPT09IDApXG5cdFx0c2lnRGF0YSA9IHNpZ0RhdGEuc2xpY2UoMSk7XG5cdHZhciBhbGdQYXJ0cyA9IHNpZ0FsZy5zcGxpdCgnLScpO1xuXG5cdHNpZy5zaWduYXR1cmUgPSBTaWduYXR1cmUucGFyc2Uoc2lnRGF0YSwgYWxnUGFydHNbMF0sICdhc24xJyk7XG5cdHNpZy5zaWduYXR1cmUuaGFzaEFsZ29yaXRobSA9IGFsZ1BhcnRzWzFdO1xuXHRzaWcuYWxnbyA9IHNpZ0FsZztcblx0c2lnLmNhY2hlID0gYnVmLnNsaWNlKHRic1N0YXJ0LCB0YnNFbmQpO1xuXG5cdHJldHVybiAobmV3IENlcnRpZmljYXRlKGNlcnQpKTtcbn1cblxuZnVuY3Rpb24gcmVhZERhdGUoZGVyKSB7XG5cdGlmIChkZXIucGVlaygpID09PSBhc24xLkJlci5VVENUaW1lKSB7XG5cdFx0cmV0dXJuICh1dGNUaW1lVG9EYXRlKGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLlVUQ1RpbWUpKSk7XG5cdH0gZWxzZSBpZiAoZGVyLnBlZWsoKSA9PT0gYXNuMS5CZXIuR2VuZXJhbGl6ZWRUaW1lKSB7XG5cdFx0cmV0dXJuIChnVGltZVRvRGF0ZShkZXIucmVhZFN0cmluZyhhc24xLkJlci5HZW5lcmFsaXplZFRpbWUpKSk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZGF0ZSBmb3JtYXQnKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gd3JpdGVEYXRlKGRlciwgZGF0ZSkge1xuXHRpZiAoZGF0ZS5nZXRVVENGdWxsWWVhcigpID49IDIwNTAgfHwgZGF0ZS5nZXRVVENGdWxsWWVhcigpIDwgMTk1MCkge1xuXHRcdGRlci53cml0ZVN0cmluZyhkYXRlVG9HVGltZShkYXRlKSwgYXNuMS5CZXIuR2VuZXJhbGl6ZWRUaW1lKTtcblx0fSBlbHNlIHtcblx0XHRkZXIud3JpdGVTdHJpbmcoZGF0ZVRvVVRDVGltZShkYXRlKSwgYXNuMS5CZXIuVVRDVGltZSk7XG5cdH1cbn1cblxuLyogUkZDNTI4MCwgc2VjdGlvbiA0LjIuMS42IChHZW5lcmFsTmFtZSB0eXBlKSAqL1xudmFyIEFMVE5BTUUgPSB7XG5cdE90aGVyTmFtZTogTG9jYWwoMCksXG5cdFJGQzgyMk5hbWU6IENvbnRleHQoMSksXG5cdEROU05hbWU6IENvbnRleHQoMiksXG5cdFg0MDBBZGRyZXNzOiBMb2NhbCgzKSxcblx0RGlyZWN0b3J5TmFtZTogTG9jYWwoNCksXG5cdEVESVBhcnR5TmFtZTogTG9jYWwoNSksXG5cdFVSSTogQ29udGV4dCg2KSxcblx0SVBBZGRyZXNzOiBDb250ZXh0KDcpLFxuXHRPSUQ6IENvbnRleHQoOClcbn07XG5cbi8qIFJGQzUyODAsIHNlY3Rpb24gNC4yLjEuMTIgKEtleVB1cnBvc2VJZCkgKi9cbnZhciBFWFRQVVJQT1NFID0ge1xuXHQnc2VydmVyQXV0aCc6ICcxLjMuNi4xLjUuNS43LjMuMScsXG5cdCdjbGllbnRBdXRoJzogJzEuMy42LjEuNS41LjcuMy4yJyxcblx0J2NvZGVTaWduaW5nJzogJzEuMy42LjEuNS41LjcuMy4zJyxcblxuXHQvKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9vaWQtZG9jcy9ibG9iL21hc3Rlci9yb290Lm1kICovXG5cdCdqb3llbnREb2NrZXInOiAnMS4zLjYuMS40LjEuMzg2NzguMS40LjEnLFxuXHQnam95ZW50Q21vbic6ICcxLjMuNi4xLjQuMS4zODY3OC4xLjQuMidcbn07XG52YXIgRVhUUFVSUE9TRV9SRVYgPSB7fTtcbk9iamVjdC5rZXlzKEVYVFBVUlBPU0UpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0RVhUUFVSUE9TRV9SRVZbRVhUUFVSUE9TRVtrXV0gPSBrO1xufSk7XG5cbnZhciBLRVlVU0VCSVRTID0gW1xuXHQnc2lnbmF0dXJlJywgJ2lkZW50aXR5JywgJ2tleUVuY3J5cHRpb24nLFxuXHQnZW5jcnlwdGlvbicsICdrZXlBZ3JlZW1lbnQnLCAnY2EnLCAnY3JsJ1xuXTtcblxuZnVuY3Rpb24gcmVhZEV4dGVuc2lvbihjZXJ0LCBidWYsIGRlcikge1xuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdHZhciBhZnRlciA9IGRlci5vZmZzZXQgKyBkZXIubGVuZ3RoO1xuXHR2YXIgZXh0SWQgPSBkZXIucmVhZE9JRCgpO1xuXHR2YXIgaWQ7XG5cdHZhciBzaWcgPSBjZXJ0LnNpZ25hdHVyZXMueDUwOTtcblx0aWYgKCFzaWcuZXh0cmFzLmV4dHMpXG5cdFx0c2lnLmV4dHJhcy5leHRzID0gW107XG5cblx0dmFyIGNyaXRpY2FsO1xuXHRpZiAoZGVyLnBlZWsoKSA9PT0gYXNuMS5CZXIuQm9vbGVhbilcblx0XHRjcml0aWNhbCA9IGRlci5yZWFkQm9vbGVhbigpO1xuXG5cdHN3aXRjaCAoZXh0SWQpIHtcblx0Y2FzZSAoRVhUUy5iYXNpY0NvbnN0cmFpbnRzKTpcblx0XHRkZXIucmVhZFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0XHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdFx0dmFyIGJjRW5kID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cdFx0dmFyIGNhID0gZmFsc2U7XG5cdFx0aWYgKGRlci5wZWVrKCkgPT09IGFzbjEuQmVyLkJvb2xlYW4pXG5cdFx0XHRjYSA9IGRlci5yZWFkQm9vbGVhbigpO1xuXHRcdGlmIChjZXJ0LnB1cnBvc2VzID09PSB1bmRlZmluZWQpXG5cdFx0XHRjZXJ0LnB1cnBvc2VzID0gW107XG5cdFx0aWYgKGNhID09PSB0cnVlKVxuXHRcdFx0Y2VydC5wdXJwb3Nlcy5wdXNoKCdjYScpO1xuXHRcdHZhciBiYyA9IHsgb2lkOiBleHRJZCwgY3JpdGljYWw6IGNyaXRpY2FsIH07XG5cdFx0aWYgKGRlci5vZmZzZXQgPCBiY0VuZCAmJiBkZXIucGVlaygpID09PSBhc24xLkJlci5JbnRlZ2VyKVxuXHRcdFx0YmMucGF0aExlbiA9IGRlci5yZWFkSW50KCk7XG5cdFx0c2lnLmV4dHJhcy5leHRzLnB1c2goYmMpO1xuXHRcdGJyZWFrO1xuXHRjYXNlIChFWFRTLmV4dEtleVVzYWdlKTpcblx0XHRkZXIucmVhZFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0XHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdFx0aWYgKGNlcnQucHVycG9zZXMgPT09IHVuZGVmaW5lZClcblx0XHRcdGNlcnQucHVycG9zZXMgPSBbXTtcblx0XHR2YXIgZWtFbmQgPSBkZXIub2Zmc2V0ICsgZGVyLmxlbmd0aDtcblx0XHR3aGlsZSAoZGVyLm9mZnNldCA8IGVrRW5kKSB7XG5cdFx0XHR2YXIgb2lkID0gZGVyLnJlYWRPSUQoKTtcblx0XHRcdGNlcnQucHVycG9zZXMucHVzaChFWFRQVVJQT1NFX1JFVltvaWRdIHx8IG9pZCk7XG5cdFx0fVxuXHRcdC8qXG5cdFx0ICogVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2s6IGluIHRoZSBjYXNlIHdoZXJlIHdlIGhhdmUgYSBjZXJ0XG5cdFx0ICogdGhhdCdzIG9ubHkgYWxsb3dlZCB0byBkbyBzZXJ2ZXJBdXRoIG9yIGNsaWVudEF1dGggKGFuZCBub3Rcblx0XHQgKiB0aGUgb3RoZXIpLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSBhbGwgb3VyIFN1YmplY3RzIGFyZSBvZlxuXHRcdCAqIHRoZSByaWdodCB0eXBlLiBCdXQgd2UgYWxyZWFkeSBwYXJzZWQgb3VyIFN1YmplY3RzIGFuZFxuXHRcdCAqIGRlY2lkZWQgaWYgdGhleSB3ZXJlIGhvc3RzIG9yIHVzZXJzIGVhcmxpZXIgKHNpbmNlIGl0IGFwcGVhcnNcblx0XHQgKiBmaXJzdCBpbiB0aGUgY2VydCkuXG5cdFx0ICpcblx0XHQgKiBTbyB3ZSBnbyB0aHJvdWdoIGFuZCBtdXRhdGUgdGhlbSBpbnRvIHRoZSByaWdodCBraW5kIGhlcmUgaWZcblx0XHQgKiBpdCBkb2Vzbid0IG1hdGNoLiBUaGlzIG1pZ2h0IG5vdCBiZSBodWdlbHkgYmVuZWZpY2lhbCwgYXMgaXRcblx0XHQgKiBzZWVtcyB0aGF0IHNpbmdsZS1wdXJwb3NlIGNlcnRzIGFyZSBub3Qgb2Z0ZW4gc2VlbiBpbiB0aGVcblx0XHQgKiB3aWxkLlxuXHRcdCAqL1xuXHRcdGlmIChjZXJ0LnB1cnBvc2VzLmluZGV4T2YoJ3NlcnZlckF1dGgnKSAhPT0gLTEgJiZcblx0XHQgICAgY2VydC5wdXJwb3Nlcy5pbmRleE9mKCdjbGllbnRBdXRoJykgPT09IC0xKSB7XG5cdFx0XHRjZXJ0LnN1YmplY3RzLmZvckVhY2goZnVuY3Rpb24gKGlkZSkge1xuXHRcdFx0XHRpZiAoaWRlLnR5cGUgIT09ICdob3N0Jykge1xuXHRcdFx0XHRcdGlkZS50eXBlID0gJ2hvc3QnO1xuXHRcdFx0XHRcdGlkZS5ob3N0bmFtZSA9IGlkZS51aWQgfHxcblx0XHRcdFx0XHQgICAgaWRlLmVtYWlsIHx8XG5cdFx0XHRcdFx0ICAgIGlkZS5jb21wb25lbnRzWzBdLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKGNlcnQucHVycG9zZXMuaW5kZXhPZignY2xpZW50QXV0aCcpICE9PSAtMSAmJlxuXHRcdCAgICBjZXJ0LnB1cnBvc2VzLmluZGV4T2YoJ3NlcnZlckF1dGgnKSA9PT0gLTEpIHtcblx0XHRcdGNlcnQuc3ViamVjdHMuZm9yRWFjaChmdW5jdGlvbiAoaWRlKSB7XG5cdFx0XHRcdGlmIChpZGUudHlwZSAhPT0gJ3VzZXInKSB7XG5cdFx0XHRcdFx0aWRlLnR5cGUgPSAndXNlcic7XG5cdFx0XHRcdFx0aWRlLnVpZCA9IGlkZS5ob3N0bmFtZSB8fFxuXHRcdFx0XHRcdCAgICBpZGUuZW1haWwgfHxcblx0XHRcdFx0XHQgICAgaWRlLmNvbXBvbmVudHNbMF0udmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRzaWcuZXh0cmFzLmV4dHMucHVzaCh7IG9pZDogZXh0SWQsIGNyaXRpY2FsOiBjcml0aWNhbCB9KTtcblx0XHRicmVhaztcblx0Y2FzZSAoRVhUUy5rZXlVc2FnZSk6XG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdFx0dmFyIGJpdHMgPSBkZXIucmVhZFN0cmluZyhhc24xLkJlci5CaXRTdHJpbmcsIHRydWUpO1xuXHRcdHZhciBzZXRCaXRzID0gcmVhZEJpdEZpZWxkKGJpdHMsIEtFWVVTRUJJVFMpO1xuXHRcdHNldEJpdHMuZm9yRWFjaChmdW5jdGlvbiAoYml0KSB7XG5cdFx0XHRpZiAoY2VydC5wdXJwb3NlcyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRjZXJ0LnB1cnBvc2VzID0gW107XG5cdFx0XHRpZiAoY2VydC5wdXJwb3Nlcy5pbmRleE9mKGJpdCkgPT09IC0xKVxuXHRcdFx0XHRjZXJ0LnB1cnBvc2VzLnB1c2goYml0KTtcblx0XHR9KTtcblx0XHRzaWcuZXh0cmFzLmV4dHMucHVzaCh7IG9pZDogZXh0SWQsIGNyaXRpY2FsOiBjcml0aWNhbCxcblx0XHQgICAgYml0czogYml0cyB9KTtcblx0XHRicmVhaztcblx0Y2FzZSAoRVhUUy5hbHROYW1lKTpcblx0XHRkZXIucmVhZFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0XHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdFx0dmFyIGFlRW5kID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cdFx0d2hpbGUgKGRlci5vZmZzZXQgPCBhZUVuZCkge1xuXHRcdFx0c3dpdGNoIChkZXIucGVlaygpKSB7XG5cdFx0XHRjYXNlIEFMVE5BTUUuT3RoZXJOYW1lOlxuXHRcdFx0Y2FzZSBBTFROQU1FLkVESVBhcnR5TmFtZTpcblx0XHRcdFx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRcdFx0XHRkZXIuX29mZnNldCArPSBkZXIubGVuZ3RoO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgQUxUTkFNRS5PSUQ6XG5cdFx0XHRcdGRlci5yZWFkT0lEKEFMVE5BTUUuT0lEKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIEFMVE5BTUUuUkZDODIyTmFtZTpcblx0XHRcdFx0LyogUkZDODIyIHNwZWNpZmllcyBlbWFpbCBhZGRyZXNzZXMgKi9cblx0XHRcdFx0dmFyIGVtYWlsID0gZGVyLnJlYWRTdHJpbmcoQUxUTkFNRS5SRkM4MjJOYW1lKTtcblx0XHRcdFx0aWQgPSBJZGVudGl0eS5mb3JFbWFpbChlbWFpbCk7XG5cdFx0XHRcdGlmICghY2VydC5zdWJqZWN0c1swXS5lcXVhbHMoaWQpKVxuXHRcdFx0XHRcdGNlcnQuc3ViamVjdHMucHVzaChpZCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBBTFROQU1FLkRpcmVjdG9yeU5hbWU6XG5cdFx0XHRcdGRlci5yZWFkU2VxdWVuY2UoQUxUTkFNRS5EaXJlY3RvcnlOYW1lKTtcblx0XHRcdFx0aWQgPSBJZGVudGl0eS5wYXJzZUFzbjEoZGVyKTtcblx0XHRcdFx0aWYgKCFjZXJ0LnN1YmplY3RzWzBdLmVxdWFscyhpZCkpXG5cdFx0XHRcdFx0Y2VydC5zdWJqZWN0cy5wdXNoKGlkKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIEFMVE5BTUUuRE5TTmFtZTpcblx0XHRcdFx0dmFyIGhvc3QgPSBkZXIucmVhZFN0cmluZyhcblx0XHRcdFx0ICAgIEFMVE5BTUUuRE5TTmFtZSk7XG5cdFx0XHRcdGlkID0gSWRlbnRpdHkuZm9ySG9zdChob3N0KTtcblx0XHRcdFx0aWYgKCFjZXJ0LnN1YmplY3RzWzBdLmVxdWFscyhpZCkpXG5cdFx0XHRcdFx0Y2VydC5zdWJqZWN0cy5wdXNoKGlkKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRkZXIucmVhZFN0cmluZyhkZXIucGVlaygpKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHNpZy5leHRyYXMuZXh0cy5wdXNoKHsgb2lkOiBleHRJZCwgY3JpdGljYWw6IGNyaXRpY2FsIH0pO1xuXHRcdGJyZWFrO1xuXHRkZWZhdWx0OlxuXHRcdHNpZy5leHRyYXMuZXh0cy5wdXNoKHtcblx0XHRcdG9pZDogZXh0SWQsXG5cdFx0XHRjcml0aWNhbDogY3JpdGljYWwsXG5cdFx0XHRkYXRhOiBkZXIucmVhZFN0cmluZyhhc24xLkJlci5PY3RldFN0cmluZywgdHJ1ZSlcblx0XHR9KTtcblx0XHRicmVhaztcblx0fVxuXG5cdGRlci5fb2Zmc2V0ID0gYWZ0ZXI7XG59XG5cbnZhciBVVENUSU1FX1JFID1cbiAgICAvXihbMC05XXsyfSkoWzAtOV17Mn0pKFswLTldezJ9KShbMC05XXsyfSkoWzAtOV17Mn0pKFswLTldezJ9KT9aJC87XG5mdW5jdGlvbiB1dGNUaW1lVG9EYXRlKHQpIHtcblx0dmFyIG0gPSB0Lm1hdGNoKFVUQ1RJTUVfUkUpO1xuXHRhc3NlcnQub2sobSwgJ3RpbWVzdGFtcHMgbXVzdCBiZSBpbiBVVEMnKTtcblx0dmFyIGQgPSBuZXcgRGF0ZSgpO1xuXG5cdHZhciB0aGlzWWVhciA9IGQuZ2V0VVRDRnVsbFllYXIoKTtcblx0dmFyIGNlbnR1cnkgPSBNYXRoLmZsb29yKHRoaXNZZWFyIC8gMTAwKSAqIDEwMDtcblxuXHR2YXIgeWVhciA9IHBhcnNlSW50KG1bMV0sIDEwKTtcblx0aWYgKHRoaXNZZWFyICUgMTAwIDwgNTAgJiYgeWVhciA+PSA2MClcblx0XHR5ZWFyICs9IChjZW50dXJ5IC0gMSk7XG5cdGVsc2Vcblx0XHR5ZWFyICs9IGNlbnR1cnk7XG5cdGQuc2V0VVRDRnVsbFllYXIoeWVhciwgcGFyc2VJbnQobVsyXSwgMTApIC0gMSwgcGFyc2VJbnQobVszXSwgMTApKTtcblx0ZC5zZXRVVENIb3VycyhwYXJzZUludChtWzRdLCAxMCksIHBhcnNlSW50KG1bNV0sIDEwKSk7XG5cdGlmIChtWzZdICYmIG1bNl0ubGVuZ3RoID4gMClcblx0XHRkLnNldFVUQ1NlY29uZHMocGFyc2VJbnQobVs2XSwgMTApKTtcblx0cmV0dXJuIChkKTtcbn1cblxudmFyIEdUSU1FX1JFID1cbiAgICAvXihbMC05XXs0fSkoWzAtOV17Mn0pKFswLTldezJ9KShbMC05XXsyfSkoWzAtOV17Mn0pKFswLTldezJ9KT9aJC87XG5mdW5jdGlvbiBnVGltZVRvRGF0ZSh0KSB7XG5cdHZhciBtID0gdC5tYXRjaChHVElNRV9SRSk7XG5cdGFzc2VydC5vayhtKTtcblx0dmFyIGQgPSBuZXcgRGF0ZSgpO1xuXG5cdGQuc2V0VVRDRnVsbFllYXIocGFyc2VJbnQobVsxXSwgMTApLCBwYXJzZUludChtWzJdLCAxMCkgLSAxLFxuXHQgICAgcGFyc2VJbnQobVszXSwgMTApKTtcblx0ZC5zZXRVVENIb3VycyhwYXJzZUludChtWzRdLCAxMCksIHBhcnNlSW50KG1bNV0sIDEwKSk7XG5cdGlmIChtWzZdICYmIG1bNl0ubGVuZ3RoID4gMClcblx0XHRkLnNldFVUQ1NlY29uZHMocGFyc2VJbnQobVs2XSwgMTApKTtcblx0cmV0dXJuIChkKTtcbn1cblxuZnVuY3Rpb24gemVyb1BhZChuLCBtKSB7XG5cdGlmIChtID09PSB1bmRlZmluZWQpXG5cdFx0bSA9IDI7XG5cdHZhciBzID0gJycgKyBuO1xuXHR3aGlsZSAocy5sZW5ndGggPCBtKVxuXHRcdHMgPSAnMCcgKyBzO1xuXHRyZXR1cm4gKHMpO1xufVxuXG5mdW5jdGlvbiBkYXRlVG9VVENUaW1lKGQpIHtcblx0dmFyIHMgPSAnJztcblx0cyArPSB6ZXJvUGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMCk7XG5cdHMgKz0gemVyb1BhZChkLmdldFVUQ01vbnRoKCkgKyAxKTtcblx0cyArPSB6ZXJvUGFkKGQuZ2V0VVRDRGF0ZSgpKTtcblx0cyArPSB6ZXJvUGFkKGQuZ2V0VVRDSG91cnMoKSk7XG5cdHMgKz0gemVyb1BhZChkLmdldFVUQ01pbnV0ZXMoKSk7XG5cdHMgKz0gemVyb1BhZChkLmdldFVUQ1NlY29uZHMoKSk7XG5cdHMgKz0gJ1onO1xuXHRyZXR1cm4gKHMpO1xufVxuXG5mdW5jdGlvbiBkYXRlVG9HVGltZShkKSB7XG5cdHZhciBzID0gJyc7XG5cdHMgKz0gemVyb1BhZChkLmdldFVUQ0Z1bGxZZWFyKCksIDQpO1xuXHRzICs9IHplcm9QYWQoZC5nZXRVVENNb250aCgpICsgMSk7XG5cdHMgKz0gemVyb1BhZChkLmdldFVUQ0RhdGUoKSk7XG5cdHMgKz0gemVyb1BhZChkLmdldFVUQ0hvdXJzKCkpO1xuXHRzICs9IHplcm9QYWQoZC5nZXRVVENNaW51dGVzKCkpO1xuXHRzICs9IHplcm9QYWQoZC5nZXRVVENTZWNvbmRzKCkpO1xuXHRzICs9ICdaJztcblx0cmV0dXJuIChzKTtcbn1cblxuZnVuY3Rpb24gc2lnbihjZXJ0LCBrZXkpIHtcblx0aWYgKGNlcnQuc2lnbmF0dXJlcy54NTA5ID09PSB1bmRlZmluZWQpXG5cdFx0Y2VydC5zaWduYXR1cmVzLng1MDkgPSB7fTtcblx0dmFyIHNpZyA9IGNlcnQuc2lnbmF0dXJlcy54NTA5O1xuXG5cdHNpZy5hbGdvID0ga2V5LnR5cGUgKyAnLScgKyBrZXkuZGVmYXVsdEhhc2hBbGdvcml0aG0oKTtcblx0aWYgKFNJR05fQUxHU1tzaWcuYWxnb10gPT09IHVuZGVmaW5lZClcblx0XHRyZXR1cm4gKGZhbHNlKTtcblxuXHR2YXIgZGVyID0gbmV3IGFzbjEuQmVyV3JpdGVyKCk7XG5cdHdyaXRlVEJTQ2VydChjZXJ0LCBkZXIpO1xuXHR2YXIgYmxvYiA9IGRlci5idWZmZXI7XG5cdHNpZy5jYWNoZSA9IGJsb2I7XG5cblx0dmFyIHNpZ25lciA9IGtleS5jcmVhdGVTaWduKCk7XG5cdHNpZ25lci53cml0ZShibG9iKTtcblx0Y2VydC5zaWduYXR1cmVzLng1MDkuc2lnbmF0dXJlID0gc2lnbmVyLnNpZ24oKTtcblxuXHRyZXR1cm4gKHRydWUpO1xufVxuXG5mdW5jdGlvbiBzaWduQXN5bmMoY2VydCwgc2lnbmVyLCBkb25lKSB7XG5cdGlmIChjZXJ0LnNpZ25hdHVyZXMueDUwOSA9PT0gdW5kZWZpbmVkKVxuXHRcdGNlcnQuc2lnbmF0dXJlcy54NTA5ID0ge307XG5cdHZhciBzaWcgPSBjZXJ0LnNpZ25hdHVyZXMueDUwOTtcblxuXHR2YXIgZGVyID0gbmV3IGFzbjEuQmVyV3JpdGVyKCk7XG5cdHdyaXRlVEJTQ2VydChjZXJ0LCBkZXIpO1xuXHR2YXIgYmxvYiA9IGRlci5idWZmZXI7XG5cdHNpZy5jYWNoZSA9IGJsb2I7XG5cblx0c2lnbmVyKGJsb2IsIGZ1bmN0aW9uIChlcnIsIHNpZ25hdHVyZSkge1xuXHRcdGlmIChlcnIpIHtcblx0XHRcdGRvbmUoZXJyKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0c2lnLmFsZ28gPSBzaWduYXR1cmUudHlwZSArICctJyArIHNpZ25hdHVyZS5oYXNoQWxnb3JpdGhtO1xuXHRcdGlmIChTSUdOX0FMR1Nbc2lnLmFsZ29dID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGRvbmUobmV3IEVycm9yKCdJbnZhbGlkIHNpZ25pbmcgYWxnb3JpdGhtIFwiJyArXG5cdFx0XHQgICAgc2lnLmFsZ28gKyAnXCInKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHNpZy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG5cdFx0ZG9uZSgpO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gd3JpdGUoY2VydCwgb3B0aW9ucykge1xuXHR2YXIgc2lnID0gY2VydC5zaWduYXR1cmVzLng1MDk7XG5cdGFzc2VydC5vYmplY3Qoc2lnLCAneDUwOSBzaWduYXR1cmUnKTtcblxuXHR2YXIgZGVyID0gbmV3IGFzbjEuQmVyV3JpdGVyKCk7XG5cdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cdGlmIChzaWcuY2FjaGUpIHtcblx0XHRkZXIuX2Vuc3VyZShzaWcuY2FjaGUubGVuZ3RoKTtcblx0XHRzaWcuY2FjaGUuY29weShkZXIuX2J1ZiwgZGVyLl9vZmZzZXQpO1xuXHRcdGRlci5fb2Zmc2V0ICs9IHNpZy5jYWNoZS5sZW5ndGg7XG5cdH0gZWxzZSB7XG5cdFx0d3JpdGVUQlNDZXJ0KGNlcnQsIGRlcik7XG5cdH1cblxuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRkZXIud3JpdGVPSUQoU0lHTl9BTEdTW3NpZy5hbGdvXSk7XG5cdGlmIChzaWcuYWxnby5tYXRjaCgvXnJzYS0vKSlcblx0XHRkZXIud3JpdGVOdWxsKCk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdHZhciBzaWdEYXRhID0gc2lnLnNpZ25hdHVyZS50b0J1ZmZlcignYXNuMScpO1xuXHR2YXIgZGF0YSA9IEJ1ZmZlci5hbGxvYyhzaWdEYXRhLmxlbmd0aCArIDEpO1xuXHRkYXRhWzBdID0gMDtcblx0c2lnRGF0YS5jb3B5KGRhdGEsIDEpO1xuXHRkZXIud3JpdGVCdWZmZXIoZGF0YSwgYXNuMS5CZXIuQml0U3RyaW5nKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0cmV0dXJuIChkZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVUQlNDZXJ0KGNlcnQsIGRlcikge1xuXHR2YXIgc2lnID0gY2VydC5zaWduYXR1cmVzLng1MDk7XG5cdGFzc2VydC5vYmplY3Qoc2lnLCAneDUwOSBzaWduYXR1cmUnKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXG5cdGRlci5zdGFydFNlcXVlbmNlKExvY2FsKDApKTtcblx0ZGVyLndyaXRlSW50KDIpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRkZXIud3JpdGVCdWZmZXIodXRpbHMubXBOb3JtYWxpemUoY2VydC5zZXJpYWwpLCBhc24xLkJlci5JbnRlZ2VyKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRkZXIud3JpdGVPSUQoU0lHTl9BTEdTW3NpZy5hbGdvXSk7XG5cdGlmIChzaWcuYWxnby5tYXRjaCgvXnJzYS0vKSlcblx0XHRkZXIud3JpdGVOdWxsKCk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdGNlcnQuaXNzdWVyLnRvQXNuMShkZXIpO1xuXG5cdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cdHdyaXRlRGF0ZShkZXIsIGNlcnQudmFsaWRGcm9tKTtcblx0d3JpdGVEYXRlKGRlciwgY2VydC52YWxpZFVudGlsKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0dmFyIHN1YmplY3QgPSBjZXJ0LnN1YmplY3RzWzBdO1xuXHR2YXIgYWx0TmFtZXMgPSBjZXJ0LnN1YmplY3RzLnNsaWNlKDEpO1xuXHRzdWJqZWN0LnRvQXNuMShkZXIpO1xuXG5cdHBrY3M4LndyaXRlUGtjczgoZGVyLCBjZXJ0LnN1YmplY3RLZXkpO1xuXG5cdGlmIChzaWcuZXh0cmFzICYmIHNpZy5leHRyYXMuaXNzdWVyVW5pcXVlSUQpIHtcblx0XHRkZXIud3JpdGVCdWZmZXIoc2lnLmV4dHJhcy5pc3N1ZXJVbmlxdWVJRCwgTG9jYWwoMSkpO1xuXHR9XG5cblx0aWYgKHNpZy5leHRyYXMgJiYgc2lnLmV4dHJhcy5zdWJqZWN0VW5pcXVlSUQpIHtcblx0XHRkZXIud3JpdGVCdWZmZXIoc2lnLmV4dHJhcy5zdWJqZWN0VW5pcXVlSUQsIExvY2FsKDIpKTtcblx0fVxuXG5cdGlmIChhbHROYW1lcy5sZW5ndGggPiAwIHx8IHN1YmplY3QudHlwZSA9PT0gJ2hvc3QnIHx8XG5cdCAgICAoY2VydC5wdXJwb3NlcyAhPT0gdW5kZWZpbmVkICYmIGNlcnQucHVycG9zZXMubGVuZ3RoID4gMCkgfHxcblx0ICAgIChzaWcuZXh0cmFzICYmIHNpZy5leHRyYXMuZXh0cykpIHtcblx0XHRkZXIuc3RhcnRTZXF1ZW5jZShMb2NhbCgzKSk7XG5cdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblxuXHRcdHZhciBleHRzID0gW107XG5cdFx0aWYgKGNlcnQucHVycG9zZXMgIT09IHVuZGVmaW5lZCAmJiBjZXJ0LnB1cnBvc2VzLmxlbmd0aCA+IDApIHtcblx0XHRcdGV4dHMucHVzaCh7XG5cdFx0XHRcdG9pZDogRVhUUy5iYXNpY0NvbnN0cmFpbnRzLFxuXHRcdFx0XHRjcml0aWNhbDogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0XHRleHRzLnB1c2goe1xuXHRcdFx0XHRvaWQ6IEVYVFMua2V5VXNhZ2UsXG5cdFx0XHRcdGNyaXRpY2FsOiB0cnVlXG5cdFx0XHR9KTtcblx0XHRcdGV4dHMucHVzaCh7XG5cdFx0XHRcdG9pZDogRVhUUy5leHRLZXlVc2FnZSxcblx0XHRcdFx0Y3JpdGljYWw6IHRydWVcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRleHRzLnB1c2goeyBvaWQ6IEVYVFMuYWx0TmFtZSB9KTtcblx0XHRpZiAoc2lnLmV4dHJhcyAmJiBzaWcuZXh0cmFzLmV4dHMpXG5cdFx0XHRleHRzID0gc2lnLmV4dHJhcy5leHRzO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRcdFx0ZGVyLndyaXRlT0lEKGV4dHNbaV0ub2lkKTtcblxuXHRcdFx0aWYgKGV4dHNbaV0uY3JpdGljYWwgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0ZGVyLndyaXRlQm9vbGVhbihleHRzW2ldLmNyaXRpY2FsKTtcblxuXHRcdFx0aWYgKGV4dHNbaV0ub2lkID09PSBFWFRTLmFsdE5hbWUpIHtcblx0XHRcdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRcdFx0XHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRcdFx0XHRpZiAoc3ViamVjdC50eXBlID09PSAnaG9zdCcpIHtcblx0XHRcdFx0XHRkZXIud3JpdGVTdHJpbmcoc3ViamVjdC5ob3N0bmFtZSxcblx0XHRcdFx0XHQgICAgQ29udGV4dCgyKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBhbHROYW1lcy5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRcdGlmIChhbHROYW1lc1tqXS50eXBlID09PSAnaG9zdCcpIHtcblx0XHRcdFx0XHRcdGRlci53cml0ZVN0cmluZyhcblx0XHRcdFx0XHRcdCAgICBhbHROYW1lc1tqXS5ob3N0bmFtZSxcblx0XHRcdFx0XHRcdCAgICBBTFROQU1FLkROU05hbWUpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYWx0TmFtZXNbal0udHlwZSA9PT1cblx0XHRcdFx0XHQgICAgJ2VtYWlsJykge1xuXHRcdFx0XHRcdFx0ZGVyLndyaXRlU3RyaW5nKFxuXHRcdFx0XHRcdFx0ICAgIGFsdE5hbWVzW2pdLmVtYWlsLFxuXHRcdFx0XHRcdFx0ICAgIEFMVE5BTUUuUkZDODIyTmFtZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0XHQgKiBFbmNvZGUgYW55dGhpbmcgZWxzZSBhcyBhXG5cdFx0XHRcdFx0XHQgKiBETiBzdHlsZSBuYW1lIGZvciBub3cuXG5cdFx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRcdGRlci5zdGFydFNlcXVlbmNlKFxuXHRcdFx0XHRcdFx0ICAgIEFMVE5BTUUuRGlyZWN0b3J5TmFtZSk7XG5cdFx0XHRcdFx0XHRhbHROYW1lc1tqXS50b0FzbjEoZGVyKTtcblx0XHRcdFx0XHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0XHRcdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGV4dHNbaV0ub2lkID09PSBFWFRTLmJhc2ljQ29uc3RyYWludHMpIHtcblx0XHRcdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRcdFx0XHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRcdFx0XHR2YXIgY2EgPSAoY2VydC5wdXJwb3Nlcy5pbmRleE9mKCdjYScpICE9PSAtMSk7XG5cdFx0XHRcdHZhciBwYXRoTGVuID0gZXh0c1tpXS5wYXRoTGVuO1xuXHRcdFx0XHRkZXIud3JpdGVCb29sZWFuKGNhKTtcblx0XHRcdFx0aWYgKHBhdGhMZW4gIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRkZXIud3JpdGVJbnQocGF0aExlbik7XG5cdFx0XHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRcdFx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0XHRcdH0gZWxzZSBpZiAoZXh0c1tpXS5vaWQgPT09IEVYVFMuZXh0S2V5VXNhZ2UpIHtcblx0XHRcdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRcdFx0XHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRcdFx0XHRjZXJ0LnB1cnBvc2VzLmZvckVhY2goZnVuY3Rpb24gKHB1cnBvc2UpIHtcblx0XHRcdFx0XHRpZiAocHVycG9zZSA9PT0gJ2NhJylcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRpZiAoS0VZVVNFQklUUy5pbmRleE9mKHB1cnBvc2UpICE9PSAtMSlcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR2YXIgb2lkID0gcHVycG9zZTtcblx0XHRcdFx0XHRpZiAoRVhUUFVSUE9TRVtwdXJwb3NlXSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0b2lkID0gRVhUUFVSUE9TRVtwdXJwb3NlXTtcblx0XHRcdFx0XHRkZXIud3JpdGVPSUQob2lkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRcdFx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0XHRcdH0gZWxzZSBpZiAoZXh0c1tpXS5vaWQgPT09IEVYVFMua2V5VXNhZ2UpIHtcblx0XHRcdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRcdFx0XHQvKlxuXHRcdFx0XHQgKiBJZiB3ZSBwYXJzZWQgdGhpcyBjZXJ0aWZpY2F0ZSBmcm9tIGEgYnl0ZVxuXHRcdFx0XHQgKiBzdHJlYW0gKGkuZS4gd2UgZGlkbid0IGdlbmVyYXRlIGl0IGluIHNzaHBrKVxuXHRcdFx0XHQgKiB0aGVuIHdlJ2xsIGhhdmUgYSBcIi5iaXRzXCIgcHJvcGVydHkgb24gdGhlXG5cdFx0XHRcdCAqIGV4dCB3aXRoIHRoZSBvcmlnaW5hbCByYXcgYnl0ZSBjb250ZW50cy5cblx0XHRcdFx0ICpcblx0XHRcdFx0ICogSWYgd2UgaGF2ZSB0aGlzLCB1c2UgaXQgaGVyZSBpbnN0ZWFkIG9mXG5cdFx0XHRcdCAqIHJlZ2VuZXJhdGluZyBpdC4gVGhpcyBndWFyYW50ZWVzIHdlIG91dHB1dFxuXHRcdFx0XHQgKiB0aGUgc2FtZSBkYXRhIHdlIHBhcnNlZCwgc28gc2lnbmF0dXJlcyBzdGlsbFxuXHRcdFx0XHQgKiB2YWxpZGF0ZS5cblx0XHRcdFx0ICovXG5cdFx0XHRcdGlmIChleHRzW2ldLmJpdHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGRlci53cml0ZUJ1ZmZlcihleHRzW2ldLmJpdHMsXG5cdFx0XHRcdFx0ICAgIGFzbjEuQmVyLkJpdFN0cmluZyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGJpdHMgPSB3cml0ZUJpdEZpZWxkKGNlcnQucHVycG9zZXMsXG5cdFx0XHRcdFx0ICAgIEtFWVVTRUJJVFMpO1xuXHRcdFx0XHRcdGRlci53cml0ZUJ1ZmZlcihiaXRzLFxuXHRcdFx0XHRcdCAgICBhc24xLkJlci5CaXRTdHJpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVyLndyaXRlQnVmZmVyKGV4dHNbaV0uZGF0YSxcblx0XHRcdFx0ICAgIGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdFx0fVxuXG5cdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdH1cblxuXHRkZXIuZW5kU2VxdWVuY2UoKTtcbn1cblxuLypcbiAqIFJlYWRzIGFuIEFTTi4xIEJFUiBiaXRmaWVsZCBvdXQgb2YgdGhlIEJ1ZmZlciBwcm9kdWNlZCBieSBkb2luZ1xuICogYEJlclJlYWRlciNyZWFkU3RyaW5nKGFzbjEuQmVyLkJpdFN0cmluZylgLiBUaGF0IGZ1bmN0aW9uIGdpdmVzIHVzIHRoZSByYXdcbiAqIGNvbnRlbnRzIG9mIHRoZSBCaXRTdHJpbmcgdGFnLCB3aGljaCBpcyBhIGNvdW50IG9mIHVudXNlZCBiaXRzIGZvbGxvd2VkIGJ5XG4gKiB0aGUgYml0cyBhcyBhIHJpZ2h0LXBhZGRlZCBieXRlIHN0cmluZy5cbiAqXG4gKiBgYml0c2AgaXMgdGhlIEJ1ZmZlciwgYGJpdEluZGV4YCBzaG91bGQgY29udGFpbiBhbiBhcnJheSBvZiBzdHJpbmcgbmFtZXNcbiAqIGZvciB0aGUgYml0cyBpbiB0aGUgc3RyaW5nLCBvcmRlcmVkIHN0YXJ0aW5nIHdpdGggYml0ICMwIGluIHRoZSBBU04uMSBzcGVjLlxuICpcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgU3RyaW5ncywgdGhlIG5hbWVzIG9mIHRoZSBiaXRzIHRoYXQgd2VyZSBzZXQgdG8gMS5cbiAqL1xuZnVuY3Rpb24gcmVhZEJpdEZpZWxkKGJpdHMsIGJpdEluZGV4KSB7XG5cdHZhciBiaXRMZW4gPSA4ICogKGJpdHMubGVuZ3RoIC0gMSkgLSBiaXRzWzBdO1xuXHR2YXIgc2V0Qml0cyA9IHt9O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGJpdExlbjsgKytpKSB7XG5cdFx0dmFyIGJ5dGVOID0gMSArIE1hdGguZmxvb3IoaSAvIDgpO1xuXHRcdHZhciBiaXQgPSA3IC0gKGkgJSA4KTtcblx0XHR2YXIgbWFzayA9IDEgPDwgYml0O1xuXHRcdHZhciBiaXRWYWwgPSAoKGJpdHNbYnl0ZU5dICYgbWFzaykgIT09IDApO1xuXHRcdHZhciBuYW1lID0gYml0SW5kZXhbaV07XG5cdFx0aWYgKGJpdFZhbCAmJiB0eXBlb2YgKG5hbWUpID09PSAnc3RyaW5nJykge1xuXHRcdFx0c2V0Qml0c1tuYW1lXSA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAoT2JqZWN0LmtleXMoc2V0Qml0cykpO1xufVxuXG4vKlxuICogYHNldEJpdHNgIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIGNvbnRhaW5pbmcgdGhlIG5hbWVzIGZvciBlYWNoIGJpdCB0aGF0XG4gKiBzb3VsZCBiZSBzZXQgdG8gMS4gYGJpdEluZGV4YCBpcyBzYW1lIGFzIGluIGByZWFkQml0RmllbGQoKWAuXG4gKlxuICogUmV0dXJucyBhIEJ1ZmZlciwgcmVhZHkgdG8gYmUgd3JpdHRlbiBvdXQgd2l0aCBgQmVyV3JpdGVyI3dyaXRlU3RyaW5nKClgLlxuICovXG5mdW5jdGlvbiB3cml0ZUJpdEZpZWxkKHNldEJpdHMsIGJpdEluZGV4KSB7XG5cdHZhciBiaXRMZW4gPSBiaXRJbmRleC5sZW5ndGg7XG5cdHZhciBibGVuID0gTWF0aC5jZWlsKGJpdExlbiAvIDgpO1xuXHR2YXIgdW51c2VkID0gYmxlbiAqIDggLSBiaXRMZW47XG5cdHZhciBiaXRzID0gQnVmZmVyLmFsbG9jKDEgKyBibGVuKTsgLy8gemVyby1maWxsZWRcblx0Yml0c1swXSA9IHVudXNlZDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBiaXRMZW47ICsraSkge1xuXHRcdHZhciBieXRlTiA9IDEgKyBNYXRoLmZsb29yKGkgLyA4KTtcblx0XHR2YXIgYml0ID0gNyAtIChpICUgOCk7XG5cdFx0dmFyIG1hc2sgPSAxIDw8IGJpdDtcblx0XHR2YXIgbmFtZSA9IGJpdEluZGV4W2ldO1xuXHRcdGlmIChuYW1lID09PSB1bmRlZmluZWQpXG5cdFx0XHRjb250aW51ZTtcblx0XHR2YXIgYml0VmFsID0gKHNldEJpdHMuaW5kZXhPZihuYW1lKSAhPT0gLTEpO1xuXHRcdGlmIChiaXRWYWwpIHtcblx0XHRcdGJpdHNbYnl0ZU5dIHw9IG1hc2s7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAoYml0cyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/formats/x509.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/formats/x509.js":
/*!************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/x509.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2017 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\tverify: verify,\n\tsign: sign,\n\tsignAsync: signAsync,\n\twrite: write\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(rsc)/./node_modules/asn1/lib/index.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ../algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar Key = __webpack_require__(/*! ../key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar PrivateKey = __webpack_require__(/*! ../private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\nvar pem = __webpack_require__(/*! ./pem */ \"(rsc)/./node_modules/sshpk/lib/formats/pem.js\");\nvar Identity = __webpack_require__(/*! ../identity */ \"(rsc)/./node_modules/sshpk/lib/identity.js\");\nvar Signature = __webpack_require__(/*! ../signature */ \"(rsc)/./node_modules/sshpk/lib/signature.js\");\nvar Certificate = __webpack_require__(/*! ../certificate */ \"(rsc)/./node_modules/sshpk/lib/certificate.js\");\nvar pkcs8 = __webpack_require__(/*! ./pkcs8 */ \"(rsc)/./node_modules/sshpk/lib/formats/pkcs8.js\");\n\n/*\n * This file is based on RFC5280 (X.509).\n */\n\n/* Helper to read in a single mpint */\nfunction readMPInt(der, nm) {\n\tassert.strictEqual(der.peek(), asn1.Ber.Integer,\n\t    nm + ' is not an Integer');\n\treturn (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));\n}\n\nfunction verify(cert, key) {\n\tvar sig = cert.signatures.x509;\n\tassert.object(sig, 'x509 signature');\n\n\tvar algParts = sig.algo.split('-');\n\tif (algParts[0] !== key.type)\n\t\treturn (false);\n\n\tvar blob = sig.cache;\n\tif (blob === undefined) {\n\t\tvar der = new asn1.BerWriter();\n\t\twriteTBSCert(cert, der);\n\t\tblob = der.buffer;\n\t}\n\n\tvar verifier = key.createVerify(algParts[1]);\n\tverifier.write(blob);\n\treturn (verifier.verify(sig.signature));\n}\n\nfunction Local(i) {\n\treturn (asn1.Ber.Context | asn1.Ber.Constructor | i);\n}\n\nfunction Context(i) {\n\treturn (asn1.Ber.Context | i);\n}\n\nvar SIGN_ALGS = {\n\t'rsa-md5': '1.2.840.113549.1.1.4',\n\t'rsa-sha1': '1.2.840.113549.1.1.5',\n\t'rsa-sha256': '1.2.840.113549.1.1.11',\n\t'rsa-sha384': '1.2.840.113549.1.1.12',\n\t'rsa-sha512': '1.2.840.113549.1.1.13',\n\t'dsa-sha1': '1.2.840.10040.4.3',\n\t'dsa-sha256': '2.16.840.1.101.3.4.3.2',\n\t'ecdsa-sha1': '1.2.840.10045.4.1',\n\t'ecdsa-sha256': '1.2.840.10045.4.3.2',\n\t'ecdsa-sha384': '1.2.840.10045.4.3.3',\n\t'ecdsa-sha512': '1.2.840.10045.4.3.4',\n\t'ed25519-sha512': '1.3.101.112'\n};\nObject.keys(SIGN_ALGS).forEach(function (k) {\n\tSIGN_ALGS[SIGN_ALGS[k]] = k;\n});\nSIGN_ALGS['1.3.14.3.2.3'] = 'rsa-md5';\nSIGN_ALGS['1.3.14.3.2.29'] = 'rsa-sha1';\n\nvar EXTS = {\n\t'issuerKeyId': '2.5.29.35',\n\t'altName': '2.5.29.17',\n\t'basicConstraints': '2.5.29.19',\n\t'keyUsage': '2.5.29.15',\n\t'extKeyUsage': '2.5.29.37'\n};\n\nfunction read(buf, options) {\n\tif (typeof (buf) === 'string') {\n\t\tbuf = Buffer.from(buf, 'binary');\n\t}\n\tassert.buffer(buf, 'buf');\n\n\tvar der = new asn1.BerReader(buf);\n\n\tder.readSequence();\n\tif (Math.abs(der.length - der.remain) > 1) {\n\t\tthrow (new Error('DER sequence does not contain whole byte ' +\n\t\t    'stream'));\n\t}\n\n\tvar tbsStart = der.offset;\n\tder.readSequence();\n\tvar sigOffset = der.offset + der.length;\n\tvar tbsEnd = sigOffset;\n\n\tif (der.peek() === Local(0)) {\n\t\tder.readSequence(Local(0));\n\t\tvar version = der.readInt();\n\t\tassert.ok(version <= 3,\n\t\t    'only x.509 versions up to v3 supported');\n\t}\n\n\tvar cert = {};\n\tcert.signatures = {};\n\tvar sig = (cert.signatures.x509 = {});\n\tsig.extras = {};\n\n\tcert.serial = readMPInt(der, 'serial');\n\n\tder.readSequence();\n\tvar after = der.offset + der.length;\n\tvar certAlgOid = der.readOID();\n\tvar certAlg = SIGN_ALGS[certAlgOid];\n\tif (certAlg === undefined)\n\t\tthrow (new Error('unknown signature algorithm ' + certAlgOid));\n\n\tder._offset = after;\n\tcert.issuer = Identity.parseAsn1(der);\n\n\tder.readSequence();\n\tcert.validFrom = readDate(der);\n\tcert.validUntil = readDate(der);\n\n\tcert.subjects = [Identity.parseAsn1(der)];\n\n\tder.readSequence();\n\tafter = der.offset + der.length;\n\tcert.subjectKey = pkcs8.readPkcs8(undefined, 'public', der);\n\tder._offset = after;\n\n\t/* issuerUniqueID */\n\tif (der.peek() === Local(1)) {\n\t\tder.readSequence(Local(1));\n\t\tsig.extras.issuerUniqueID =\n\t\t    buf.slice(der.offset, der.offset + der.length);\n\t\tder._offset += der.length;\n\t}\n\n\t/* subjectUniqueID */\n\tif (der.peek() === Local(2)) {\n\t\tder.readSequence(Local(2));\n\t\tsig.extras.subjectUniqueID =\n\t\t    buf.slice(der.offset, der.offset + der.length);\n\t\tder._offset += der.length;\n\t}\n\n\t/* extensions */\n\tif (der.peek() === Local(3)) {\n\t\tder.readSequence(Local(3));\n\t\tvar extEnd = der.offset + der.length;\n\t\tder.readSequence();\n\n\t\twhile (der.offset < extEnd)\n\t\t\treadExtension(cert, buf, der);\n\n\t\tassert.strictEqual(der.offset, extEnd);\n\t}\n\n\tassert.strictEqual(der.offset, sigOffset);\n\n\tder.readSequence();\n\tafter = der.offset + der.length;\n\tvar sigAlgOid = der.readOID();\n\tvar sigAlg = SIGN_ALGS[sigAlgOid];\n\tif (sigAlg === undefined)\n\t\tthrow (new Error('unknown signature algorithm ' + sigAlgOid));\n\tder._offset = after;\n\n\tvar sigData = der.readString(asn1.Ber.BitString, true);\n\tif (sigData[0] === 0)\n\t\tsigData = sigData.slice(1);\n\tvar algParts = sigAlg.split('-');\n\n\tsig.signature = Signature.parse(sigData, algParts[0], 'asn1');\n\tsig.signature.hashAlgorithm = algParts[1];\n\tsig.algo = sigAlg;\n\tsig.cache = buf.slice(tbsStart, tbsEnd);\n\n\treturn (new Certificate(cert));\n}\n\nfunction readDate(der) {\n\tif (der.peek() === asn1.Ber.UTCTime) {\n\t\treturn (utcTimeToDate(der.readString(asn1.Ber.UTCTime)));\n\t} else if (der.peek() === asn1.Ber.GeneralizedTime) {\n\t\treturn (gTimeToDate(der.readString(asn1.Ber.GeneralizedTime)));\n\t} else {\n\t\tthrow (new Error('Unsupported date format'));\n\t}\n}\n\nfunction writeDate(der, date) {\n\tif (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {\n\t\tder.writeString(dateToGTime(date), asn1.Ber.GeneralizedTime);\n\t} else {\n\t\tder.writeString(dateToUTCTime(date), asn1.Ber.UTCTime);\n\t}\n}\n\n/* RFC5280, section 4.2.1.6 (GeneralName type) */\nvar ALTNAME = {\n\tOtherName: Local(0),\n\tRFC822Name: Context(1),\n\tDNSName: Context(2),\n\tX400Address: Local(3),\n\tDirectoryName: Local(4),\n\tEDIPartyName: Local(5),\n\tURI: Context(6),\n\tIPAddress: Context(7),\n\tOID: Context(8)\n};\n\n/* RFC5280, section 4.2.1.12 (KeyPurposeId) */\nvar EXTPURPOSE = {\n\t'serverAuth': '1.3.6.1.5.5.7.3.1',\n\t'clientAuth': '1.3.6.1.5.5.7.3.2',\n\t'codeSigning': '1.3.6.1.5.5.7.3.3',\n\n\t/* See https://github.com/joyent/oid-docs/blob/master/root.md */\n\t'joyentDocker': '1.3.6.1.4.1.38678.1.4.1',\n\t'joyentCmon': '1.3.6.1.4.1.38678.1.4.2'\n};\nvar EXTPURPOSE_REV = {};\nObject.keys(EXTPURPOSE).forEach(function (k) {\n\tEXTPURPOSE_REV[EXTPURPOSE[k]] = k;\n});\n\nvar KEYUSEBITS = [\n\t'signature', 'identity', 'keyEncryption',\n\t'encryption', 'keyAgreement', 'ca', 'crl'\n];\n\nfunction readExtension(cert, buf, der) {\n\tder.readSequence();\n\tvar after = der.offset + der.length;\n\tvar extId = der.readOID();\n\tvar id;\n\tvar sig = cert.signatures.x509;\n\tif (!sig.extras.exts)\n\t\tsig.extras.exts = [];\n\n\tvar critical;\n\tif (der.peek() === asn1.Ber.Boolean)\n\t\tcritical = der.readBoolean();\n\n\tswitch (extId) {\n\tcase (EXTS.basicConstraints):\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tder.readSequence();\n\t\tvar bcEnd = der.offset + der.length;\n\t\tvar ca = false;\n\t\tif (der.peek() === asn1.Ber.Boolean)\n\t\t\tca = der.readBoolean();\n\t\tif (cert.purposes === undefined)\n\t\t\tcert.purposes = [];\n\t\tif (ca === true)\n\t\t\tcert.purposes.push('ca');\n\t\tvar bc = { oid: extId, critical: critical };\n\t\tif (der.offset < bcEnd && der.peek() === asn1.Ber.Integer)\n\t\t\tbc.pathLen = der.readInt();\n\t\tsig.extras.exts.push(bc);\n\t\tbreak;\n\tcase (EXTS.extKeyUsage):\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tder.readSequence();\n\t\tif (cert.purposes === undefined)\n\t\t\tcert.purposes = [];\n\t\tvar ekEnd = der.offset + der.length;\n\t\twhile (der.offset < ekEnd) {\n\t\t\tvar oid = der.readOID();\n\t\t\tcert.purposes.push(EXTPURPOSE_REV[oid] || oid);\n\t\t}\n\t\t/*\n\t\t * This is a bit of a hack: in the case where we have a cert\n\t\t * that's only allowed to do serverAuth or clientAuth (and not\n\t\t * the other), we want to make sure all our Subjects are of\n\t\t * the right type. But we already parsed our Subjects and\n\t\t * decided if they were hosts or users earlier (since it appears\n\t\t * first in the cert).\n\t\t *\n\t\t * So we go through and mutate them into the right kind here if\n\t\t * it doesn't match. This might not be hugely beneficial, as it\n\t\t * seems that single-purpose certs are not often seen in the\n\t\t * wild.\n\t\t */\n\t\tif (cert.purposes.indexOf('serverAuth') !== -1 &&\n\t\t    cert.purposes.indexOf('clientAuth') === -1) {\n\t\t\tcert.subjects.forEach(function (ide) {\n\t\t\t\tif (ide.type !== 'host') {\n\t\t\t\t\tide.type = 'host';\n\t\t\t\t\tide.hostname = ide.uid ||\n\t\t\t\t\t    ide.email ||\n\t\t\t\t\t    ide.components[0].value;\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (cert.purposes.indexOf('clientAuth') !== -1 &&\n\t\t    cert.purposes.indexOf('serverAuth') === -1) {\n\t\t\tcert.subjects.forEach(function (ide) {\n\t\t\t\tif (ide.type !== 'user') {\n\t\t\t\t\tide.type = 'user';\n\t\t\t\t\tide.uid = ide.hostname ||\n\t\t\t\t\t    ide.email ||\n\t\t\t\t\t    ide.components[0].value;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tsig.extras.exts.push({ oid: extId, critical: critical });\n\t\tbreak;\n\tcase (EXTS.keyUsage):\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tvar bits = der.readString(asn1.Ber.BitString, true);\n\t\tvar setBits = readBitField(bits, KEYUSEBITS);\n\t\tsetBits.forEach(function (bit) {\n\t\t\tif (cert.purposes === undefined)\n\t\t\t\tcert.purposes = [];\n\t\t\tif (cert.purposes.indexOf(bit) === -1)\n\t\t\t\tcert.purposes.push(bit);\n\t\t});\n\t\tsig.extras.exts.push({ oid: extId, critical: critical,\n\t\t    bits: bits });\n\t\tbreak;\n\tcase (EXTS.altName):\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tder.readSequence();\n\t\tvar aeEnd = der.offset + der.length;\n\t\twhile (der.offset < aeEnd) {\n\t\t\tswitch (der.peek()) {\n\t\t\tcase ALTNAME.OtherName:\n\t\t\tcase ALTNAME.EDIPartyName:\n\t\t\t\tder.readSequence();\n\t\t\t\tder._offset += der.length;\n\t\t\t\tbreak;\n\t\t\tcase ALTNAME.OID:\n\t\t\t\tder.readOID(ALTNAME.OID);\n\t\t\t\tbreak;\n\t\t\tcase ALTNAME.RFC822Name:\n\t\t\t\t/* RFC822 specifies email addresses */\n\t\t\t\tvar email = der.readString(ALTNAME.RFC822Name);\n\t\t\t\tid = Identity.forEmail(email);\n\t\t\t\tif (!cert.subjects[0].equals(id))\n\t\t\t\t\tcert.subjects.push(id);\n\t\t\t\tbreak;\n\t\t\tcase ALTNAME.DirectoryName:\n\t\t\t\tder.readSequence(ALTNAME.DirectoryName);\n\t\t\t\tid = Identity.parseAsn1(der);\n\t\t\t\tif (!cert.subjects[0].equals(id))\n\t\t\t\t\tcert.subjects.push(id);\n\t\t\t\tbreak;\n\t\t\tcase ALTNAME.DNSName:\n\t\t\t\tvar host = der.readString(\n\t\t\t\t    ALTNAME.DNSName);\n\t\t\t\tid = Identity.forHost(host);\n\t\t\t\tif (!cert.subjects[0].equals(id))\n\t\t\t\t\tcert.subjects.push(id);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tder.readString(der.peek());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsig.extras.exts.push({ oid: extId, critical: critical });\n\t\tbreak;\n\tdefault:\n\t\tsig.extras.exts.push({\n\t\t\toid: extId,\n\t\t\tcritical: critical,\n\t\t\tdata: der.readString(asn1.Ber.OctetString, true)\n\t\t});\n\t\tbreak;\n\t}\n\n\tder._offset = after;\n}\n\nvar UTCTIME_RE =\n    /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;\nfunction utcTimeToDate(t) {\n\tvar m = t.match(UTCTIME_RE);\n\tassert.ok(m, 'timestamps must be in UTC');\n\tvar d = new Date();\n\n\tvar thisYear = d.getUTCFullYear();\n\tvar century = Math.floor(thisYear / 100) * 100;\n\n\tvar year = parseInt(m[1], 10);\n\tif (thisYear % 100 < 50 && year >= 60)\n\t\tyear += (century - 1);\n\telse\n\t\tyear += century;\n\td.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));\n\td.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));\n\tif (m[6] && m[6].length > 0)\n\t\td.setUTCSeconds(parseInt(m[6], 10));\n\treturn (d);\n}\n\nvar GTIME_RE =\n    /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;\nfunction gTimeToDate(t) {\n\tvar m = t.match(GTIME_RE);\n\tassert.ok(m);\n\tvar d = new Date();\n\n\td.setUTCFullYear(parseInt(m[1], 10), parseInt(m[2], 10) - 1,\n\t    parseInt(m[3], 10));\n\td.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));\n\tif (m[6] && m[6].length > 0)\n\t\td.setUTCSeconds(parseInt(m[6], 10));\n\treturn (d);\n}\n\nfunction zeroPad(n, m) {\n\tif (m === undefined)\n\t\tm = 2;\n\tvar s = '' + n;\n\twhile (s.length < m)\n\t\ts = '0' + s;\n\treturn (s);\n}\n\nfunction dateToUTCTime(d) {\n\tvar s = '';\n\ts += zeroPad(d.getUTCFullYear() % 100);\n\ts += zeroPad(d.getUTCMonth() + 1);\n\ts += zeroPad(d.getUTCDate());\n\ts += zeroPad(d.getUTCHours());\n\ts += zeroPad(d.getUTCMinutes());\n\ts += zeroPad(d.getUTCSeconds());\n\ts += 'Z';\n\treturn (s);\n}\n\nfunction dateToGTime(d) {\n\tvar s = '';\n\ts += zeroPad(d.getUTCFullYear(), 4);\n\ts += zeroPad(d.getUTCMonth() + 1);\n\ts += zeroPad(d.getUTCDate());\n\ts += zeroPad(d.getUTCHours());\n\ts += zeroPad(d.getUTCMinutes());\n\ts += zeroPad(d.getUTCSeconds());\n\ts += 'Z';\n\treturn (s);\n}\n\nfunction sign(cert, key) {\n\tif (cert.signatures.x509 === undefined)\n\t\tcert.signatures.x509 = {};\n\tvar sig = cert.signatures.x509;\n\n\tsig.algo = key.type + '-' + key.defaultHashAlgorithm();\n\tif (SIGN_ALGS[sig.algo] === undefined)\n\t\treturn (false);\n\n\tvar der = new asn1.BerWriter();\n\twriteTBSCert(cert, der);\n\tvar blob = der.buffer;\n\tsig.cache = blob;\n\n\tvar signer = key.createSign();\n\tsigner.write(blob);\n\tcert.signatures.x509.signature = signer.sign();\n\n\treturn (true);\n}\n\nfunction signAsync(cert, signer, done) {\n\tif (cert.signatures.x509 === undefined)\n\t\tcert.signatures.x509 = {};\n\tvar sig = cert.signatures.x509;\n\n\tvar der = new asn1.BerWriter();\n\twriteTBSCert(cert, der);\n\tvar blob = der.buffer;\n\tsig.cache = blob;\n\n\tsigner(blob, function (err, signature) {\n\t\tif (err) {\n\t\t\tdone(err);\n\t\t\treturn;\n\t\t}\n\t\tsig.algo = signature.type + '-' + signature.hashAlgorithm;\n\t\tif (SIGN_ALGS[sig.algo] === undefined) {\n\t\t\tdone(new Error('Invalid signing algorithm \"' +\n\t\t\t    sig.algo + '\"'));\n\t\t\treturn;\n\t\t}\n\t\tsig.signature = signature;\n\t\tdone();\n\t});\n}\n\nfunction write(cert, options) {\n\tvar sig = cert.signatures.x509;\n\tassert.object(sig, 'x509 signature');\n\n\tvar der = new asn1.BerWriter();\n\tder.startSequence();\n\tif (sig.cache) {\n\t\tder._ensure(sig.cache.length);\n\t\tsig.cache.copy(der._buf, der._offset);\n\t\tder._offset += sig.cache.length;\n\t} else {\n\t\twriteTBSCert(cert, der);\n\t}\n\n\tder.startSequence();\n\tder.writeOID(SIGN_ALGS[sig.algo]);\n\tif (sig.algo.match(/^rsa-/))\n\t\tder.writeNull();\n\tder.endSequence();\n\n\tvar sigData = sig.signature.toBuffer('asn1');\n\tvar data = Buffer.alloc(sigData.length + 1);\n\tdata[0] = 0;\n\tsigData.copy(data, 1);\n\tder.writeBuffer(data, asn1.Ber.BitString);\n\tder.endSequence();\n\n\treturn (der.buffer);\n}\n\nfunction writeTBSCert(cert, der) {\n\tvar sig = cert.signatures.x509;\n\tassert.object(sig, 'x509 signature');\n\n\tder.startSequence();\n\n\tder.startSequence(Local(0));\n\tder.writeInt(2);\n\tder.endSequence();\n\n\tder.writeBuffer(utils.mpNormalize(cert.serial), asn1.Ber.Integer);\n\n\tder.startSequence();\n\tder.writeOID(SIGN_ALGS[sig.algo]);\n\tif (sig.algo.match(/^rsa-/))\n\t\tder.writeNull();\n\tder.endSequence();\n\n\tcert.issuer.toAsn1(der);\n\n\tder.startSequence();\n\twriteDate(der, cert.validFrom);\n\twriteDate(der, cert.validUntil);\n\tder.endSequence();\n\n\tvar subject = cert.subjects[0];\n\tvar altNames = cert.subjects.slice(1);\n\tsubject.toAsn1(der);\n\n\tpkcs8.writePkcs8(der, cert.subjectKey);\n\n\tif (sig.extras && sig.extras.issuerUniqueID) {\n\t\tder.writeBuffer(sig.extras.issuerUniqueID, Local(1));\n\t}\n\n\tif (sig.extras && sig.extras.subjectUniqueID) {\n\t\tder.writeBuffer(sig.extras.subjectUniqueID, Local(2));\n\t}\n\n\tif (altNames.length > 0 || subject.type === 'host' ||\n\t    (cert.purposes !== undefined && cert.purposes.length > 0) ||\n\t    (sig.extras && sig.extras.exts)) {\n\t\tder.startSequence(Local(3));\n\t\tder.startSequence();\n\n\t\tvar exts = [];\n\t\tif (cert.purposes !== undefined && cert.purposes.length > 0) {\n\t\t\texts.push({\n\t\t\t\toid: EXTS.basicConstraints,\n\t\t\t\tcritical: true\n\t\t\t});\n\t\t\texts.push({\n\t\t\t\toid: EXTS.keyUsage,\n\t\t\t\tcritical: true\n\t\t\t});\n\t\t\texts.push({\n\t\t\t\toid: EXTS.extKeyUsage,\n\t\t\t\tcritical: true\n\t\t\t});\n\t\t}\n\t\texts.push({ oid: EXTS.altName });\n\t\tif (sig.extras && sig.extras.exts)\n\t\t\texts = sig.extras.exts;\n\n\t\tfor (var i = 0; i < exts.length; ++i) {\n\t\t\tder.startSequence();\n\t\t\tder.writeOID(exts[i].oid);\n\n\t\t\tif (exts[i].critical !== undefined)\n\t\t\t\tder.writeBoolean(exts[i].critical);\n\n\t\t\tif (exts[i].oid === EXTS.altName) {\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\n\t\t\t\tder.startSequence();\n\t\t\t\tif (subject.type === 'host') {\n\t\t\t\t\tder.writeString(subject.hostname,\n\t\t\t\t\t    Context(2));\n\t\t\t\t}\n\t\t\t\tfor (var j = 0; j < altNames.length; ++j) {\n\t\t\t\t\tif (altNames[j].type === 'host') {\n\t\t\t\t\t\tder.writeString(\n\t\t\t\t\t\t    altNames[j].hostname,\n\t\t\t\t\t\t    ALTNAME.DNSName);\n\t\t\t\t\t} else if (altNames[j].type ===\n\t\t\t\t\t    'email') {\n\t\t\t\t\t\tder.writeString(\n\t\t\t\t\t\t    altNames[j].email,\n\t\t\t\t\t\t    ALTNAME.RFC822Name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Encode anything else as a\n\t\t\t\t\t\t * DN style name for now.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tder.startSequence(\n\t\t\t\t\t\t    ALTNAME.DirectoryName);\n\t\t\t\t\t\taltNames[j].toAsn1(der);\n\t\t\t\t\t\tder.endSequence();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tder.endSequence();\n\t\t\t\tder.endSequence();\n\t\t\t} else if (exts[i].oid === EXTS.basicConstraints) {\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\n\t\t\t\tder.startSequence();\n\t\t\t\tvar ca = (cert.purposes.indexOf('ca') !== -1);\n\t\t\t\tvar pathLen = exts[i].pathLen;\n\t\t\t\tder.writeBoolean(ca);\n\t\t\t\tif (pathLen !== undefined)\n\t\t\t\t\tder.writeInt(pathLen);\n\t\t\t\tder.endSequence();\n\t\t\t\tder.endSequence();\n\t\t\t} else if (exts[i].oid === EXTS.extKeyUsage) {\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\n\t\t\t\tder.startSequence();\n\t\t\t\tcert.purposes.forEach(function (purpose) {\n\t\t\t\t\tif (purpose === 'ca')\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (KEYUSEBITS.indexOf(purpose) !== -1)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tvar oid = purpose;\n\t\t\t\t\tif (EXTPURPOSE[purpose] !== undefined)\n\t\t\t\t\t\toid = EXTPURPOSE[purpose];\n\t\t\t\t\tder.writeOID(oid);\n\t\t\t\t});\n\t\t\t\tder.endSequence();\n\t\t\t\tder.endSequence();\n\t\t\t} else if (exts[i].oid === EXTS.keyUsage) {\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\n\t\t\t\t/*\n\t\t\t\t * If we parsed this certificate from a byte\n\t\t\t\t * stream (i.e. we didn't generate it in sshpk)\n\t\t\t\t * then we'll have a \".bits\" property on the\n\t\t\t\t * ext with the original raw byte contents.\n\t\t\t\t *\n\t\t\t\t * If we have this, use it here instead of\n\t\t\t\t * regenerating it. This guarantees we output\n\t\t\t\t * the same data we parsed, so signatures still\n\t\t\t\t * validate.\n\t\t\t\t */\n\t\t\t\tif (exts[i].bits !== undefined) {\n\t\t\t\t\tder.writeBuffer(exts[i].bits,\n\t\t\t\t\t    asn1.Ber.BitString);\n\t\t\t\t} else {\n\t\t\t\t\tvar bits = writeBitField(cert.purposes,\n\t\t\t\t\t    KEYUSEBITS);\n\t\t\t\t\tder.writeBuffer(bits,\n\t\t\t\t\t    asn1.Ber.BitString);\n\t\t\t\t}\n\t\t\t\tder.endSequence();\n\t\t\t} else {\n\t\t\t\tder.writeBuffer(exts[i].data,\n\t\t\t\t    asn1.Ber.OctetString);\n\t\t\t}\n\n\t\t\tder.endSequence();\n\t\t}\n\n\t\tder.endSequence();\n\t\tder.endSequence();\n\t}\n\n\tder.endSequence();\n}\n\n/*\n * Reads an ASN.1 BER bitfield out of the Buffer produced by doing\n * `BerReader#readString(asn1.Ber.BitString)`. That function gives us the raw\n * contents of the BitString tag, which is a count of unused bits followed by\n * the bits as a right-padded byte string.\n *\n * `bits` is the Buffer, `bitIndex` should contain an array of string names\n * for the bits in the string, ordered starting with bit #0 in the ASN.1 spec.\n *\n * Returns an array of Strings, the names of the bits that were set to 1.\n */\nfunction readBitField(bits, bitIndex) {\n\tvar bitLen = 8 * (bits.length - 1) - bits[0];\n\tvar setBits = {};\n\tfor (var i = 0; i < bitLen; ++i) {\n\t\tvar byteN = 1 + Math.floor(i / 8);\n\t\tvar bit = 7 - (i % 8);\n\t\tvar mask = 1 << bit;\n\t\tvar bitVal = ((bits[byteN] & mask) !== 0);\n\t\tvar name = bitIndex[i];\n\t\tif (bitVal && typeof (name) === 'string') {\n\t\t\tsetBits[name] = true;\n\t\t}\n\t}\n\treturn (Object.keys(setBits));\n}\n\n/*\n * `setBits` is an array of strings, containing the names for each bit that\n * sould be set to 1. `bitIndex` is same as in `readBitField()`.\n *\n * Returns a Buffer, ready to be written out with `BerWriter#writeString()`.\n */\nfunction writeBitField(setBits, bitIndex) {\n\tvar bitLen = bitIndex.length;\n\tvar blen = Math.ceil(bitLen / 8);\n\tvar unused = blen * 8 - bitLen;\n\tvar bits = Buffer.alloc(1 + blen); // zero-filled\n\tbits[0] = unused;\n\tfor (var i = 0; i < bitLen; ++i) {\n\t\tvar byteN = 1 + Math.floor(i / 8);\n\t\tvar bit = 7 - (i % 8);\n\t\tvar mask = 1 << bit;\n\t\tvar name = bitIndex[i];\n\t\tif (name === undefined)\n\t\t\tcontinue;\n\t\tvar bitVal = (setBits.indexOf(name) !== -1);\n\t\tif (bitVal) {\n\t\t\tbits[byteN] |= mask;\n\t\t}\n\t}\n\treturn (bits);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMveDUwOS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsK0RBQWE7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLG9EQUFNO0FBQ3pCLGFBQWEsOEZBQThCO0FBQzNDLFdBQVcsbUJBQU8sQ0FBQyx1REFBUztBQUM1QixZQUFZLG1CQUFPLENBQUMseURBQVU7QUFDOUIsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFnQjtBQUN6QyxVQUFVLG1CQUFPLENBQUMsNERBQU87QUFDekIsZUFBZSxtQkFBTyxDQUFDLCtEQUFhO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLGlFQUFjO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLHFFQUFnQjtBQUMxQyxZQUFZLG1CQUFPLENBQUMsZ0VBQVM7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QjtBQUN6QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy94NTA5LmpzPzBkYjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTcgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRyZWFkOiByZWFkLFxuXHR2ZXJpZnk6IHZlcmlmeSxcblx0c2lnbjogc2lnbixcblx0c2lnbkFzeW5jOiBzaWduQXN5bmMsXG5cdHdyaXRlOiB3cml0ZVxufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgYXNuMSA9IHJlcXVpcmUoJ2FzbjEnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4uL2FsZ3MnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgS2V5ID0gcmVxdWlyZSgnLi4va2V5Jyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uL3ByaXZhdGUta2V5Jyk7XG52YXIgcGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcbnZhciBJZGVudGl0eSA9IHJlcXVpcmUoJy4uL2lkZW50aXR5Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vc2lnbmF0dXJlJyk7XG52YXIgQ2VydGlmaWNhdGUgPSByZXF1aXJlKCcuLi9jZXJ0aWZpY2F0ZScpO1xudmFyIHBrY3M4ID0gcmVxdWlyZSgnLi9wa2NzOCcpO1xuXG4vKlxuICogVGhpcyBmaWxlIGlzIGJhc2VkIG9uIFJGQzUyODAgKFguNTA5KS5cbiAqL1xuXG4vKiBIZWxwZXIgdG8gcmVhZCBpbiBhIHNpbmdsZSBtcGludCAqL1xuZnVuY3Rpb24gcmVhZE1QSW50KGRlciwgbm0pIHtcblx0YXNzZXJ0LnN0cmljdEVxdWFsKGRlci5wZWVrKCksIGFzbjEuQmVyLkludGVnZXIsXG5cdCAgICBubSArICcgaXMgbm90IGFuIEludGVnZXInKTtcblx0cmV0dXJuICh1dGlscy5tcE5vcm1hbGl6ZShkZXIucmVhZFN0cmluZyhhc24xLkJlci5JbnRlZ2VyLCB0cnVlKSkpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnkoY2VydCwga2V5KSB7XG5cdHZhciBzaWcgPSBjZXJ0LnNpZ25hdHVyZXMueDUwOTtcblx0YXNzZXJ0Lm9iamVjdChzaWcsICd4NTA5IHNpZ25hdHVyZScpO1xuXG5cdHZhciBhbGdQYXJ0cyA9IHNpZy5hbGdvLnNwbGl0KCctJyk7XG5cdGlmIChhbGdQYXJ0c1swXSAhPT0ga2V5LnR5cGUpXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cblx0dmFyIGJsb2IgPSBzaWcuY2FjaGU7XG5cdGlmIChibG9iID09PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgZGVyID0gbmV3IGFzbjEuQmVyV3JpdGVyKCk7XG5cdFx0d3JpdGVUQlNDZXJ0KGNlcnQsIGRlcik7XG5cdFx0YmxvYiA9IGRlci5idWZmZXI7XG5cdH1cblxuXHR2YXIgdmVyaWZpZXIgPSBrZXkuY3JlYXRlVmVyaWZ5KGFsZ1BhcnRzWzFdKTtcblx0dmVyaWZpZXIud3JpdGUoYmxvYik7XG5cdHJldHVybiAodmVyaWZpZXIudmVyaWZ5KHNpZy5zaWduYXR1cmUpKTtcbn1cblxuZnVuY3Rpb24gTG9jYWwoaSkge1xuXHRyZXR1cm4gKGFzbjEuQmVyLkNvbnRleHQgfCBhc24xLkJlci5Db25zdHJ1Y3RvciB8IGkpO1xufVxuXG5mdW5jdGlvbiBDb250ZXh0KGkpIHtcblx0cmV0dXJuIChhc24xLkJlci5Db250ZXh0IHwgaSk7XG59XG5cbnZhciBTSUdOX0FMR1MgPSB7XG5cdCdyc2EtbWQ1JzogJzEuMi44NDAuMTEzNTQ5LjEuMS40Jyxcblx0J3JzYS1zaGExJzogJzEuMi44NDAuMTEzNTQ5LjEuMS41Jyxcblx0J3JzYS1zaGEyNTYnOiAnMS4yLjg0MC4xMTM1NDkuMS4xLjExJyxcblx0J3JzYS1zaGEzODQnOiAnMS4yLjg0MC4xMTM1NDkuMS4xLjEyJyxcblx0J3JzYS1zaGE1MTInOiAnMS4yLjg0MC4xMTM1NDkuMS4xLjEzJyxcblx0J2RzYS1zaGExJzogJzEuMi44NDAuMTAwNDAuNC4zJyxcblx0J2RzYS1zaGEyNTYnOiAnMi4xNi44NDAuMS4xMDEuMy40LjMuMicsXG5cdCdlY2RzYS1zaGExJzogJzEuMi44NDAuMTAwNDUuNC4xJyxcblx0J2VjZHNhLXNoYTI1Nic6ICcxLjIuODQwLjEwMDQ1LjQuMy4yJyxcblx0J2VjZHNhLXNoYTM4NCc6ICcxLjIuODQwLjEwMDQ1LjQuMy4zJyxcblx0J2VjZHNhLXNoYTUxMic6ICcxLjIuODQwLjEwMDQ1LjQuMy40Jyxcblx0J2VkMjU1MTktc2hhNTEyJzogJzEuMy4xMDEuMTEyJ1xufTtcbk9iamVjdC5rZXlzKFNJR05fQUxHUykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRTSUdOX0FMR1NbU0lHTl9BTEdTW2tdXSA9IGs7XG59KTtcblNJR05fQUxHU1snMS4zLjE0LjMuMi4zJ10gPSAncnNhLW1kNSc7XG5TSUdOX0FMR1NbJzEuMy4xNC4zLjIuMjknXSA9ICdyc2Etc2hhMSc7XG5cbnZhciBFWFRTID0ge1xuXHQnaXNzdWVyS2V5SWQnOiAnMi41LjI5LjM1Jyxcblx0J2FsdE5hbWUnOiAnMi41LjI5LjE3Jyxcblx0J2Jhc2ljQ29uc3RyYWludHMnOiAnMi41LjI5LjE5Jyxcblx0J2tleVVzYWdlJzogJzIuNS4yOS4xNScsXG5cdCdleHRLZXlVc2FnZSc6ICcyLjUuMjkuMzcnXG59O1xuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIChidWYpID09PSAnc3RyaW5nJykge1xuXHRcdGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZiwgJ2JpbmFyeScpO1xuXHR9XG5cdGFzc2VydC5idWZmZXIoYnVmLCAnYnVmJyk7XG5cblx0dmFyIGRlciA9IG5ldyBhc24xLkJlclJlYWRlcihidWYpO1xuXG5cdGRlci5yZWFkU2VxdWVuY2UoKTtcblx0aWYgKE1hdGguYWJzKGRlci5sZW5ndGggLSBkZXIucmVtYWluKSA+IDEpIHtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdERVIgc2VxdWVuY2UgZG9lcyBub3QgY29udGFpbiB3aG9sZSBieXRlICcgK1xuXHRcdCAgICAnc3RyZWFtJykpO1xuXHR9XG5cblx0dmFyIHRic1N0YXJ0ID0gZGVyLm9mZnNldDtcblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHR2YXIgc2lnT2Zmc2V0ID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cdHZhciB0YnNFbmQgPSBzaWdPZmZzZXQ7XG5cblx0aWYgKGRlci5wZWVrKCkgPT09IExvY2FsKDApKSB7XG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZShMb2NhbCgwKSk7XG5cdFx0dmFyIHZlcnNpb24gPSBkZXIucmVhZEludCgpO1xuXHRcdGFzc2VydC5vayh2ZXJzaW9uIDw9IDMsXG5cdFx0ICAgICdvbmx5IHguNTA5IHZlcnNpb25zIHVwIHRvIHYzIHN1cHBvcnRlZCcpO1xuXHR9XG5cblx0dmFyIGNlcnQgPSB7fTtcblx0Y2VydC5zaWduYXR1cmVzID0ge307XG5cdHZhciBzaWcgPSAoY2VydC5zaWduYXR1cmVzLng1MDkgPSB7fSk7XG5cdHNpZy5leHRyYXMgPSB7fTtcblxuXHRjZXJ0LnNlcmlhbCA9IHJlYWRNUEludChkZXIsICdzZXJpYWwnKTtcblxuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdHZhciBhZnRlciA9IGRlci5vZmZzZXQgKyBkZXIubGVuZ3RoO1xuXHR2YXIgY2VydEFsZ09pZCA9IGRlci5yZWFkT0lEKCk7XG5cdHZhciBjZXJ0QWxnID0gU0lHTl9BTEdTW2NlcnRBbGdPaWRdO1xuXHRpZiAoY2VydEFsZyA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3Vua25vd24gc2lnbmF0dXJlIGFsZ29yaXRobSAnICsgY2VydEFsZ09pZCkpO1xuXG5cdGRlci5fb2Zmc2V0ID0gYWZ0ZXI7XG5cdGNlcnQuaXNzdWVyID0gSWRlbnRpdHkucGFyc2VBc24xKGRlcik7XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRjZXJ0LnZhbGlkRnJvbSA9IHJlYWREYXRlKGRlcik7XG5cdGNlcnQudmFsaWRVbnRpbCA9IHJlYWREYXRlKGRlcik7XG5cblx0Y2VydC5zdWJqZWN0cyA9IFtJZGVudGl0eS5wYXJzZUFzbjEoZGVyKV07XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRhZnRlciA9IGRlci5vZmZzZXQgKyBkZXIubGVuZ3RoO1xuXHRjZXJ0LnN1YmplY3RLZXkgPSBwa2NzOC5yZWFkUGtjczgodW5kZWZpbmVkLCAncHVibGljJywgZGVyKTtcblx0ZGVyLl9vZmZzZXQgPSBhZnRlcjtcblxuXHQvKiBpc3N1ZXJVbmlxdWVJRCAqL1xuXHRpZiAoZGVyLnBlZWsoKSA9PT0gTG9jYWwoMSkpIHtcblx0XHRkZXIucmVhZFNlcXVlbmNlKExvY2FsKDEpKTtcblx0XHRzaWcuZXh0cmFzLmlzc3VlclVuaXF1ZUlEID1cblx0XHQgICAgYnVmLnNsaWNlKGRlci5vZmZzZXQsIGRlci5vZmZzZXQgKyBkZXIubGVuZ3RoKTtcblx0XHRkZXIuX29mZnNldCArPSBkZXIubGVuZ3RoO1xuXHR9XG5cblx0Lyogc3ViamVjdFVuaXF1ZUlEICovXG5cdGlmIChkZXIucGVlaygpID09PSBMb2NhbCgyKSkge1xuXHRcdGRlci5yZWFkU2VxdWVuY2UoTG9jYWwoMikpO1xuXHRcdHNpZy5leHRyYXMuc3ViamVjdFVuaXF1ZUlEID1cblx0XHQgICAgYnVmLnNsaWNlKGRlci5vZmZzZXQsIGRlci5vZmZzZXQgKyBkZXIubGVuZ3RoKTtcblx0XHRkZXIuX29mZnNldCArPSBkZXIubGVuZ3RoO1xuXHR9XG5cblx0LyogZXh0ZW5zaW9ucyAqL1xuXHRpZiAoZGVyLnBlZWsoKSA9PT0gTG9jYWwoMykpIHtcblx0XHRkZXIucmVhZFNlcXVlbmNlKExvY2FsKDMpKTtcblx0XHR2YXIgZXh0RW5kID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXG5cdFx0d2hpbGUgKGRlci5vZmZzZXQgPCBleHRFbmQpXG5cdFx0XHRyZWFkRXh0ZW5zaW9uKGNlcnQsIGJ1ZiwgZGVyKTtcblxuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChkZXIub2Zmc2V0LCBleHRFbmQpO1xuXHR9XG5cblx0YXNzZXJ0LnN0cmljdEVxdWFsKGRlci5vZmZzZXQsIHNpZ09mZnNldCk7XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRhZnRlciA9IGRlci5vZmZzZXQgKyBkZXIubGVuZ3RoO1xuXHR2YXIgc2lnQWxnT2lkID0gZGVyLnJlYWRPSUQoKTtcblx0dmFyIHNpZ0FsZyA9IFNJR05fQUxHU1tzaWdBbGdPaWRdO1xuXHRpZiAoc2lnQWxnID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndW5rbm93biBzaWduYXR1cmUgYWxnb3JpdGhtICcgKyBzaWdBbGdPaWQpKTtcblx0ZGVyLl9vZmZzZXQgPSBhZnRlcjtcblxuXHR2YXIgc2lnRGF0YSA9IGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkJpdFN0cmluZywgdHJ1ZSk7XG5cdGlmIChzaWdEYXRhWzBdID09PSAwKVxuXHRcdHNpZ0RhdGEgPSBzaWdEYXRhLnNsaWNlKDEpO1xuXHR2YXIgYWxnUGFydHMgPSBzaWdBbGcuc3BsaXQoJy0nKTtcblxuXHRzaWcuc2lnbmF0dXJlID0gU2lnbmF0dXJlLnBhcnNlKHNpZ0RhdGEsIGFsZ1BhcnRzWzBdLCAnYXNuMScpO1xuXHRzaWcuc2lnbmF0dXJlLmhhc2hBbGdvcml0aG0gPSBhbGdQYXJ0c1sxXTtcblx0c2lnLmFsZ28gPSBzaWdBbGc7XG5cdHNpZy5jYWNoZSA9IGJ1Zi5zbGljZSh0YnNTdGFydCwgdGJzRW5kKTtcblxuXHRyZXR1cm4gKG5ldyBDZXJ0aWZpY2F0ZShjZXJ0KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWREYXRlKGRlcikge1xuXHRpZiAoZGVyLnBlZWsoKSA9PT0gYXNuMS5CZXIuVVRDVGltZSkge1xuXHRcdHJldHVybiAodXRjVGltZVRvRGF0ZShkZXIucmVhZFN0cmluZyhhc24xLkJlci5VVENUaW1lKSkpO1xuXHR9IGVsc2UgaWYgKGRlci5wZWVrKCkgPT09IGFzbjEuQmVyLkdlbmVyYWxpemVkVGltZSkge1xuXHRcdHJldHVybiAoZ1RpbWVUb0RhdGUoZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuR2VuZXJhbGl6ZWRUaW1lKSkpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGRhdGUgZm9ybWF0JykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHdyaXRlRGF0ZShkZXIsIGRhdGUpIHtcblx0aWYgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA+PSAyMDUwIHx8IGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA8IDE5NTApIHtcblx0XHRkZXIud3JpdGVTdHJpbmcoZGF0ZVRvR1RpbWUoZGF0ZSksIGFzbjEuQmVyLkdlbmVyYWxpemVkVGltZSk7XG5cdH0gZWxzZSB7XG5cdFx0ZGVyLndyaXRlU3RyaW5nKGRhdGVUb1VUQ1RpbWUoZGF0ZSksIGFzbjEuQmVyLlVUQ1RpbWUpO1xuXHR9XG59XG5cbi8qIFJGQzUyODAsIHNlY3Rpb24gNC4yLjEuNiAoR2VuZXJhbE5hbWUgdHlwZSkgKi9cbnZhciBBTFROQU1FID0ge1xuXHRPdGhlck5hbWU6IExvY2FsKDApLFxuXHRSRkM4MjJOYW1lOiBDb250ZXh0KDEpLFxuXHRETlNOYW1lOiBDb250ZXh0KDIpLFxuXHRYNDAwQWRkcmVzczogTG9jYWwoMyksXG5cdERpcmVjdG9yeU5hbWU6IExvY2FsKDQpLFxuXHRFRElQYXJ0eU5hbWU6IExvY2FsKDUpLFxuXHRVUkk6IENvbnRleHQoNiksXG5cdElQQWRkcmVzczogQ29udGV4dCg3KSxcblx0T0lEOiBDb250ZXh0KDgpXG59O1xuXG4vKiBSRkM1MjgwLCBzZWN0aW9uIDQuMi4xLjEyIChLZXlQdXJwb3NlSWQpICovXG52YXIgRVhUUFVSUE9TRSA9IHtcblx0J3NlcnZlckF1dGgnOiAnMS4zLjYuMS41LjUuNy4zLjEnLFxuXHQnY2xpZW50QXV0aCc6ICcxLjMuNi4xLjUuNS43LjMuMicsXG5cdCdjb2RlU2lnbmluZyc6ICcxLjMuNi4xLjUuNS43LjMuMycsXG5cblx0LyogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvb2lkLWRvY3MvYmxvYi9tYXN0ZXIvcm9vdC5tZCAqL1xuXHQnam95ZW50RG9ja2VyJzogJzEuMy42LjEuNC4xLjM4Njc4LjEuNC4xJyxcblx0J2pveWVudENtb24nOiAnMS4zLjYuMS40LjEuMzg2NzguMS40LjInXG59O1xudmFyIEVYVFBVUlBPU0VfUkVWID0ge307XG5PYmplY3Qua2V5cyhFWFRQVVJQT1NFKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdEVYVFBVUlBPU0VfUkVWW0VYVFBVUlBPU0Vba11dID0gaztcbn0pO1xuXG52YXIgS0VZVVNFQklUUyA9IFtcblx0J3NpZ25hdHVyZScsICdpZGVudGl0eScsICdrZXlFbmNyeXB0aW9uJyxcblx0J2VuY3J5cHRpb24nLCAna2V5QWdyZWVtZW50JywgJ2NhJywgJ2NybCdcbl07XG5cbmZ1bmN0aW9uIHJlYWRFeHRlbnNpb24oY2VydCwgYnVmLCBkZXIpIHtcblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHR2YXIgYWZ0ZXIgPSBkZXIub2Zmc2V0ICsgZGVyLmxlbmd0aDtcblx0dmFyIGV4dElkID0gZGVyLnJlYWRPSUQoKTtcblx0dmFyIGlkO1xuXHR2YXIgc2lnID0gY2VydC5zaWduYXR1cmVzLng1MDk7XG5cdGlmICghc2lnLmV4dHJhcy5leHRzKVxuXHRcdHNpZy5leHRyYXMuZXh0cyA9IFtdO1xuXG5cdHZhciBjcml0aWNhbDtcblx0aWYgKGRlci5wZWVrKCkgPT09IGFzbjEuQmVyLkJvb2xlYW4pXG5cdFx0Y3JpdGljYWwgPSBkZXIucmVhZEJvb2xlYW4oKTtcblxuXHRzd2l0Y2ggKGV4dElkKSB7XG5cdGNhc2UgKEVYVFMuYmFzaWNDb25zdHJhaW50cyk6XG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRcdHZhciBiY0VuZCA9IGRlci5vZmZzZXQgKyBkZXIubGVuZ3RoO1xuXHRcdHZhciBjYSA9IGZhbHNlO1xuXHRcdGlmIChkZXIucGVlaygpID09PSBhc24xLkJlci5Cb29sZWFuKVxuXHRcdFx0Y2EgPSBkZXIucmVhZEJvb2xlYW4oKTtcblx0XHRpZiAoY2VydC5wdXJwb3NlcyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0Y2VydC5wdXJwb3NlcyA9IFtdO1xuXHRcdGlmIChjYSA9PT0gdHJ1ZSlcblx0XHRcdGNlcnQucHVycG9zZXMucHVzaCgnY2EnKTtcblx0XHR2YXIgYmMgPSB7IG9pZDogZXh0SWQsIGNyaXRpY2FsOiBjcml0aWNhbCB9O1xuXHRcdGlmIChkZXIub2Zmc2V0IDwgYmNFbmQgJiYgZGVyLnBlZWsoKSA9PT0gYXNuMS5CZXIuSW50ZWdlcilcblx0XHRcdGJjLnBhdGhMZW4gPSBkZXIucmVhZEludCgpO1xuXHRcdHNpZy5leHRyYXMuZXh0cy5wdXNoKGJjKTtcblx0XHRicmVhaztcblx0Y2FzZSAoRVhUUy5leHRLZXlVc2FnZSk6XG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRcdGlmIChjZXJ0LnB1cnBvc2VzID09PSB1bmRlZmluZWQpXG5cdFx0XHRjZXJ0LnB1cnBvc2VzID0gW107XG5cdFx0dmFyIGVrRW5kID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cdFx0d2hpbGUgKGRlci5vZmZzZXQgPCBla0VuZCkge1xuXHRcdFx0dmFyIG9pZCA9IGRlci5yZWFkT0lEKCk7XG5cdFx0XHRjZXJ0LnB1cnBvc2VzLnB1c2goRVhUUFVSUE9TRV9SRVZbb2lkXSB8fCBvaWQpO1xuXHRcdH1cblx0XHQvKlxuXHRcdCAqIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrOiBpbiB0aGUgY2FzZSB3aGVyZSB3ZSBoYXZlIGEgY2VydFxuXHRcdCAqIHRoYXQncyBvbmx5IGFsbG93ZWQgdG8gZG8gc2VydmVyQXV0aCBvciBjbGllbnRBdXRoIChhbmQgbm90XG5cdFx0ICogdGhlIG90aGVyKSwgd2Ugd2FudCB0byBtYWtlIHN1cmUgYWxsIG91ciBTdWJqZWN0cyBhcmUgb2Zcblx0XHQgKiB0aGUgcmlnaHQgdHlwZS4gQnV0IHdlIGFscmVhZHkgcGFyc2VkIG91ciBTdWJqZWN0cyBhbmRcblx0XHQgKiBkZWNpZGVkIGlmIHRoZXkgd2VyZSBob3N0cyBvciB1c2VycyBlYXJsaWVyIChzaW5jZSBpdCBhcHBlYXJzXG5cdFx0ICogZmlyc3QgaW4gdGhlIGNlcnQpLlxuXHRcdCAqXG5cdFx0ICogU28gd2UgZ28gdGhyb3VnaCBhbmQgbXV0YXRlIHRoZW0gaW50byB0aGUgcmlnaHQga2luZCBoZXJlIGlmXG5cdFx0ICogaXQgZG9lc24ndCBtYXRjaC4gVGhpcyBtaWdodCBub3QgYmUgaHVnZWx5IGJlbmVmaWNpYWwsIGFzIGl0XG5cdFx0ICogc2VlbXMgdGhhdCBzaW5nbGUtcHVycG9zZSBjZXJ0cyBhcmUgbm90IG9mdGVuIHNlZW4gaW4gdGhlXG5cdFx0ICogd2lsZC5cblx0XHQgKi9cblx0XHRpZiAoY2VydC5wdXJwb3Nlcy5pbmRleE9mKCdzZXJ2ZXJBdXRoJykgIT09IC0xICYmXG5cdFx0ICAgIGNlcnQucHVycG9zZXMuaW5kZXhPZignY2xpZW50QXV0aCcpID09PSAtMSkge1xuXHRcdFx0Y2VydC5zdWJqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChpZGUpIHtcblx0XHRcdFx0aWYgKGlkZS50eXBlICE9PSAnaG9zdCcpIHtcblx0XHRcdFx0XHRpZGUudHlwZSA9ICdob3N0Jztcblx0XHRcdFx0XHRpZGUuaG9zdG5hbWUgPSBpZGUudWlkIHx8XG5cdFx0XHRcdFx0ICAgIGlkZS5lbWFpbCB8fFxuXHRcdFx0XHRcdCAgICBpZGUuY29tcG9uZW50c1swXS52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmIChjZXJ0LnB1cnBvc2VzLmluZGV4T2YoJ2NsaWVudEF1dGgnKSAhPT0gLTEgJiZcblx0XHQgICAgY2VydC5wdXJwb3Nlcy5pbmRleE9mKCdzZXJ2ZXJBdXRoJykgPT09IC0xKSB7XG5cdFx0XHRjZXJ0LnN1YmplY3RzLmZvckVhY2goZnVuY3Rpb24gKGlkZSkge1xuXHRcdFx0XHRpZiAoaWRlLnR5cGUgIT09ICd1c2VyJykge1xuXHRcdFx0XHRcdGlkZS50eXBlID0gJ3VzZXInO1xuXHRcdFx0XHRcdGlkZS51aWQgPSBpZGUuaG9zdG5hbWUgfHxcblx0XHRcdFx0XHQgICAgaWRlLmVtYWlsIHx8XG5cdFx0XHRcdFx0ICAgIGlkZS5jb21wb25lbnRzWzBdLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0c2lnLmV4dHJhcy5leHRzLnB1c2goeyBvaWQ6IGV4dElkLCBjcml0aWNhbDogY3JpdGljYWwgfSk7XG5cdFx0YnJlYWs7XG5cdGNhc2UgKEVYVFMua2V5VXNhZ2UpOlxuXHRcdGRlci5yZWFkU2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRcdHZhciBiaXRzID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuQml0U3RyaW5nLCB0cnVlKTtcblx0XHR2YXIgc2V0Qml0cyA9IHJlYWRCaXRGaWVsZChiaXRzLCBLRVlVU0VCSVRTKTtcblx0XHRzZXRCaXRzLmZvckVhY2goZnVuY3Rpb24gKGJpdCkge1xuXHRcdFx0aWYgKGNlcnQucHVycG9zZXMgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0Y2VydC5wdXJwb3NlcyA9IFtdO1xuXHRcdFx0aWYgKGNlcnQucHVycG9zZXMuaW5kZXhPZihiaXQpID09PSAtMSlcblx0XHRcdFx0Y2VydC5wdXJwb3Nlcy5wdXNoKGJpdCk7XG5cdFx0fSk7XG5cdFx0c2lnLmV4dHJhcy5leHRzLnB1c2goeyBvaWQ6IGV4dElkLCBjcml0aWNhbDogY3JpdGljYWwsXG5cdFx0ICAgIGJpdHM6IGJpdHMgfSk7XG5cdFx0YnJlYWs7XG5cdGNhc2UgKEVYVFMuYWx0TmFtZSk6XG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRcdHZhciBhZUVuZCA9IGRlci5vZmZzZXQgKyBkZXIubGVuZ3RoO1xuXHRcdHdoaWxlIChkZXIub2Zmc2V0IDwgYWVFbmQpIHtcblx0XHRcdHN3aXRjaCAoZGVyLnBlZWsoKSkge1xuXHRcdFx0Y2FzZSBBTFROQU1FLk90aGVyTmFtZTpcblx0XHRcdGNhc2UgQUxUTkFNRS5FRElQYXJ0eU5hbWU6XG5cdFx0XHRcdGRlci5yZWFkU2VxdWVuY2UoKTtcblx0XHRcdFx0ZGVyLl9vZmZzZXQgKz0gZGVyLmxlbmd0aDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIEFMVE5BTUUuT0lEOlxuXHRcdFx0XHRkZXIucmVhZE9JRChBTFROQU1FLk9JRCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBBTFROQU1FLlJGQzgyMk5hbWU6XG5cdFx0XHRcdC8qIFJGQzgyMiBzcGVjaWZpZXMgZW1haWwgYWRkcmVzc2VzICovXG5cdFx0XHRcdHZhciBlbWFpbCA9IGRlci5yZWFkU3RyaW5nKEFMVE5BTUUuUkZDODIyTmFtZSk7XG5cdFx0XHRcdGlkID0gSWRlbnRpdHkuZm9yRW1haWwoZW1haWwpO1xuXHRcdFx0XHRpZiAoIWNlcnQuc3ViamVjdHNbMF0uZXF1YWxzKGlkKSlcblx0XHRcdFx0XHRjZXJ0LnN1YmplY3RzLnB1c2goaWQpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgQUxUTkFNRS5EaXJlY3RvcnlOYW1lOlxuXHRcdFx0XHRkZXIucmVhZFNlcXVlbmNlKEFMVE5BTUUuRGlyZWN0b3J5TmFtZSk7XG5cdFx0XHRcdGlkID0gSWRlbnRpdHkucGFyc2VBc24xKGRlcik7XG5cdFx0XHRcdGlmICghY2VydC5zdWJqZWN0c1swXS5lcXVhbHMoaWQpKVxuXHRcdFx0XHRcdGNlcnQuc3ViamVjdHMucHVzaChpZCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBBTFROQU1FLkROU05hbWU6XG5cdFx0XHRcdHZhciBob3N0ID0gZGVyLnJlYWRTdHJpbmcoXG5cdFx0XHRcdCAgICBBTFROQU1FLkROU05hbWUpO1xuXHRcdFx0XHRpZCA9IElkZW50aXR5LmZvckhvc3QoaG9zdCk7XG5cdFx0XHRcdGlmICghY2VydC5zdWJqZWN0c1swXS5lcXVhbHMoaWQpKVxuXHRcdFx0XHRcdGNlcnQuc3ViamVjdHMucHVzaChpZCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0ZGVyLnJlYWRTdHJpbmcoZGVyLnBlZWsoKSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRzaWcuZXh0cmFzLmV4dHMucHVzaCh7IG9pZDogZXh0SWQsIGNyaXRpY2FsOiBjcml0aWNhbCB9KTtcblx0XHRicmVhaztcblx0ZGVmYXVsdDpcblx0XHRzaWcuZXh0cmFzLmV4dHMucHVzaCh7XG5cdFx0XHRvaWQ6IGV4dElkLFxuXHRcdFx0Y3JpdGljYWw6IGNyaXRpY2FsLFxuXHRcdFx0ZGF0YTogZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuT2N0ZXRTdHJpbmcsIHRydWUpXG5cdFx0fSk7XG5cdFx0YnJlYWs7XG5cdH1cblxuXHRkZXIuX29mZnNldCA9IGFmdGVyO1xufVxuXG52YXIgVVRDVElNRV9SRSA9XG4gICAgL14oWzAtOV17Mn0pKFswLTldezJ9KShbMC05XXsyfSkoWzAtOV17Mn0pKFswLTldezJ9KShbMC05XXsyfSk/WiQvO1xuZnVuY3Rpb24gdXRjVGltZVRvRGF0ZSh0KSB7XG5cdHZhciBtID0gdC5tYXRjaChVVENUSU1FX1JFKTtcblx0YXNzZXJ0Lm9rKG0sICd0aW1lc3RhbXBzIG11c3QgYmUgaW4gVVRDJyk7XG5cdHZhciBkID0gbmV3IERhdGUoKTtcblxuXHR2YXIgdGhpc1llYXIgPSBkLmdldFVUQ0Z1bGxZZWFyKCk7XG5cdHZhciBjZW50dXJ5ID0gTWF0aC5mbG9vcih0aGlzWWVhciAvIDEwMCkgKiAxMDA7XG5cblx0dmFyIHllYXIgPSBwYXJzZUludChtWzFdLCAxMCk7XG5cdGlmICh0aGlzWWVhciAlIDEwMCA8IDUwICYmIHllYXIgPj0gNjApXG5cdFx0eWVhciArPSAoY2VudHVyeSAtIDEpO1xuXHRlbHNlXG5cdFx0eWVhciArPSBjZW50dXJ5O1xuXHRkLnNldFVUQ0Z1bGxZZWFyKHllYXIsIHBhcnNlSW50KG1bMl0sIDEwKSAtIDEsIHBhcnNlSW50KG1bM10sIDEwKSk7XG5cdGQuc2V0VVRDSG91cnMocGFyc2VJbnQobVs0XSwgMTApLCBwYXJzZUludChtWzVdLCAxMCkpO1xuXHRpZiAobVs2XSAmJiBtWzZdLmxlbmd0aCA+IDApXG5cdFx0ZC5zZXRVVENTZWNvbmRzKHBhcnNlSW50KG1bNl0sIDEwKSk7XG5cdHJldHVybiAoZCk7XG59XG5cbnZhciBHVElNRV9SRSA9XG4gICAgL14oWzAtOV17NH0pKFswLTldezJ9KShbMC05XXsyfSkoWzAtOV17Mn0pKFswLTldezJ9KShbMC05XXsyfSk/WiQvO1xuZnVuY3Rpb24gZ1RpbWVUb0RhdGUodCkge1xuXHR2YXIgbSA9IHQubWF0Y2goR1RJTUVfUkUpO1xuXHRhc3NlcnQub2sobSk7XG5cdHZhciBkID0gbmV3IERhdGUoKTtcblxuXHRkLnNldFVUQ0Z1bGxZZWFyKHBhcnNlSW50KG1bMV0sIDEwKSwgcGFyc2VJbnQobVsyXSwgMTApIC0gMSxcblx0ICAgIHBhcnNlSW50KG1bM10sIDEwKSk7XG5cdGQuc2V0VVRDSG91cnMocGFyc2VJbnQobVs0XSwgMTApLCBwYXJzZUludChtWzVdLCAxMCkpO1xuXHRpZiAobVs2XSAmJiBtWzZdLmxlbmd0aCA+IDApXG5cdFx0ZC5zZXRVVENTZWNvbmRzKHBhcnNlSW50KG1bNl0sIDEwKSk7XG5cdHJldHVybiAoZCk7XG59XG5cbmZ1bmN0aW9uIHplcm9QYWQobiwgbSkge1xuXHRpZiAobSA9PT0gdW5kZWZpbmVkKVxuXHRcdG0gPSAyO1xuXHR2YXIgcyA9ICcnICsgbjtcblx0d2hpbGUgKHMubGVuZ3RoIDwgbSlcblx0XHRzID0gJzAnICsgcztcblx0cmV0dXJuIChzKTtcbn1cblxuZnVuY3Rpb24gZGF0ZVRvVVRDVGltZShkKSB7XG5cdHZhciBzID0gJyc7XG5cdHMgKz0gemVyb1BhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDApO1xuXHRzICs9IHplcm9QYWQoZC5nZXRVVENNb250aCgpICsgMSk7XG5cdHMgKz0gemVyb1BhZChkLmdldFVUQ0RhdGUoKSk7XG5cdHMgKz0gemVyb1BhZChkLmdldFVUQ0hvdXJzKCkpO1xuXHRzICs9IHplcm9QYWQoZC5nZXRVVENNaW51dGVzKCkpO1xuXHRzICs9IHplcm9QYWQoZC5nZXRVVENTZWNvbmRzKCkpO1xuXHRzICs9ICdaJztcblx0cmV0dXJuIChzKTtcbn1cblxuZnVuY3Rpb24gZGF0ZVRvR1RpbWUoZCkge1xuXHR2YXIgcyA9ICcnO1xuXHRzICs9IHplcm9QYWQoZC5nZXRVVENGdWxsWWVhcigpLCA0KTtcblx0cyArPSB6ZXJvUGFkKGQuZ2V0VVRDTW9udGgoKSArIDEpO1xuXHRzICs9IHplcm9QYWQoZC5nZXRVVENEYXRlKCkpO1xuXHRzICs9IHplcm9QYWQoZC5nZXRVVENIb3VycygpKTtcblx0cyArPSB6ZXJvUGFkKGQuZ2V0VVRDTWludXRlcygpKTtcblx0cyArPSB6ZXJvUGFkKGQuZ2V0VVRDU2Vjb25kcygpKTtcblx0cyArPSAnWic7XG5cdHJldHVybiAocyk7XG59XG5cbmZ1bmN0aW9uIHNpZ24oY2VydCwga2V5KSB7XG5cdGlmIChjZXJ0LnNpZ25hdHVyZXMueDUwOSA9PT0gdW5kZWZpbmVkKVxuXHRcdGNlcnQuc2lnbmF0dXJlcy54NTA5ID0ge307XG5cdHZhciBzaWcgPSBjZXJ0LnNpZ25hdHVyZXMueDUwOTtcblxuXHRzaWcuYWxnbyA9IGtleS50eXBlICsgJy0nICsga2V5LmRlZmF1bHRIYXNoQWxnb3JpdGhtKCk7XG5cdGlmIChTSUdOX0FMR1Nbc2lnLmFsZ29dID09PSB1bmRlZmluZWQpXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cblx0dmFyIGRlciA9IG5ldyBhc24xLkJlcldyaXRlcigpO1xuXHR3cml0ZVRCU0NlcnQoY2VydCwgZGVyKTtcblx0dmFyIGJsb2IgPSBkZXIuYnVmZmVyO1xuXHRzaWcuY2FjaGUgPSBibG9iO1xuXG5cdHZhciBzaWduZXIgPSBrZXkuY3JlYXRlU2lnbigpO1xuXHRzaWduZXIud3JpdGUoYmxvYik7XG5cdGNlcnQuc2lnbmF0dXJlcy54NTA5LnNpZ25hdHVyZSA9IHNpZ25lci5zaWduKCk7XG5cblx0cmV0dXJuICh0cnVlKTtcbn1cblxuZnVuY3Rpb24gc2lnbkFzeW5jKGNlcnQsIHNpZ25lciwgZG9uZSkge1xuXHRpZiAoY2VydC5zaWduYXR1cmVzLng1MDkgPT09IHVuZGVmaW5lZClcblx0XHRjZXJ0LnNpZ25hdHVyZXMueDUwOSA9IHt9O1xuXHR2YXIgc2lnID0gY2VydC5zaWduYXR1cmVzLng1MDk7XG5cblx0dmFyIGRlciA9IG5ldyBhc24xLkJlcldyaXRlcigpO1xuXHR3cml0ZVRCU0NlcnQoY2VydCwgZGVyKTtcblx0dmFyIGJsb2IgPSBkZXIuYnVmZmVyO1xuXHRzaWcuY2FjaGUgPSBibG9iO1xuXG5cdHNpZ25lcihibG9iLCBmdW5jdGlvbiAoZXJyLCBzaWduYXR1cmUpIHtcblx0XHRpZiAoZXJyKSB7XG5cdFx0XHRkb25lKGVycik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHNpZy5hbGdvID0gc2lnbmF0dXJlLnR5cGUgKyAnLScgKyBzaWduYXR1cmUuaGFzaEFsZ29yaXRobTtcblx0XHRpZiAoU0lHTl9BTEdTW3NpZy5hbGdvXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkb25lKG5ldyBFcnJvcignSW52YWxpZCBzaWduaW5nIGFsZ29yaXRobSBcIicgK1xuXHRcdFx0ICAgIHNpZy5hbGdvICsgJ1wiJykpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRzaWcuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuXHRcdGRvbmUoKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlKGNlcnQsIG9wdGlvbnMpIHtcblx0dmFyIHNpZyA9IGNlcnQuc2lnbmF0dXJlcy54NTA5O1xuXHRhc3NlcnQub2JqZWN0KHNpZywgJ3g1MDkgc2lnbmF0dXJlJyk7XG5cblx0dmFyIGRlciA9IG5ldyBhc24xLkJlcldyaXRlcigpO1xuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRpZiAoc2lnLmNhY2hlKSB7XG5cdFx0ZGVyLl9lbnN1cmUoc2lnLmNhY2hlLmxlbmd0aCk7XG5cdFx0c2lnLmNhY2hlLmNvcHkoZGVyLl9idWYsIGRlci5fb2Zmc2V0KTtcblx0XHRkZXIuX29mZnNldCArPSBzaWcuY2FjaGUubGVuZ3RoO1xuXHR9IGVsc2Uge1xuXHRcdHdyaXRlVEJTQ2VydChjZXJ0LCBkZXIpO1xuXHR9XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblx0ZGVyLndyaXRlT0lEKFNJR05fQUxHU1tzaWcuYWxnb10pO1xuXHRpZiAoc2lnLmFsZ28ubWF0Y2goL15yc2EtLykpXG5cdFx0ZGVyLndyaXRlTnVsbCgpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHR2YXIgc2lnRGF0YSA9IHNpZy5zaWduYXR1cmUudG9CdWZmZXIoJ2FzbjEnKTtcblx0dmFyIGRhdGEgPSBCdWZmZXIuYWxsb2Moc2lnRGF0YS5sZW5ndGggKyAxKTtcblx0ZGF0YVswXSA9IDA7XG5cdHNpZ0RhdGEuY29weShkYXRhLCAxKTtcblx0ZGVyLndyaXRlQnVmZmVyKGRhdGEsIGFzbjEuQmVyLkJpdFN0cmluZyk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdHJldHVybiAoZGVyLmJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIHdyaXRlVEJTQ2VydChjZXJ0LCBkZXIpIHtcblx0dmFyIHNpZyA9IGNlcnQuc2lnbmF0dXJlcy54NTA5O1xuXHRhc3NlcnQub2JqZWN0KHNpZywgJ3g1MDkgc2lnbmF0dXJlJyk7XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZShMb2NhbCgwKSk7XG5cdGRlci53cml0ZUludCgyKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0ZGVyLndyaXRlQnVmZmVyKHV0aWxzLm1wTm9ybWFsaXplKGNlcnQuc2VyaWFsKSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblx0ZGVyLndyaXRlT0lEKFNJR05fQUxHU1tzaWcuYWxnb10pO1xuXHRpZiAoc2lnLmFsZ28ubWF0Y2goL15yc2EtLykpXG5cdFx0ZGVyLndyaXRlTnVsbCgpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRjZXJ0Lmlzc3Vlci50b0FzbjEoZGVyKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHR3cml0ZURhdGUoZGVyLCBjZXJ0LnZhbGlkRnJvbSk7XG5cdHdyaXRlRGF0ZShkZXIsIGNlcnQudmFsaWRVbnRpbCk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdHZhciBzdWJqZWN0ID0gY2VydC5zdWJqZWN0c1swXTtcblx0dmFyIGFsdE5hbWVzID0gY2VydC5zdWJqZWN0cy5zbGljZSgxKTtcblx0c3ViamVjdC50b0FzbjEoZGVyKTtcblxuXHRwa2NzOC53cml0ZVBrY3M4KGRlciwgY2VydC5zdWJqZWN0S2V5KTtcblxuXHRpZiAoc2lnLmV4dHJhcyAmJiBzaWcuZXh0cmFzLmlzc3VlclVuaXF1ZUlEKSB7XG5cdFx0ZGVyLndyaXRlQnVmZmVyKHNpZy5leHRyYXMuaXNzdWVyVW5pcXVlSUQsIExvY2FsKDEpKTtcblx0fVxuXG5cdGlmIChzaWcuZXh0cmFzICYmIHNpZy5leHRyYXMuc3ViamVjdFVuaXF1ZUlEKSB7XG5cdFx0ZGVyLndyaXRlQnVmZmVyKHNpZy5leHRyYXMuc3ViamVjdFVuaXF1ZUlELCBMb2NhbCgyKSk7XG5cdH1cblxuXHRpZiAoYWx0TmFtZXMubGVuZ3RoID4gMCB8fCBzdWJqZWN0LnR5cGUgPT09ICdob3N0JyB8fFxuXHQgICAgKGNlcnQucHVycG9zZXMgIT09IHVuZGVmaW5lZCAmJiBjZXJ0LnB1cnBvc2VzLmxlbmd0aCA+IDApIHx8XG5cdCAgICAoc2lnLmV4dHJhcyAmJiBzaWcuZXh0cmFzLmV4dHMpKSB7XG5cdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoTG9jYWwoMykpO1xuXHRcdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cblx0XHR2YXIgZXh0cyA9IFtdO1xuXHRcdGlmIChjZXJ0LnB1cnBvc2VzICE9PSB1bmRlZmluZWQgJiYgY2VydC5wdXJwb3Nlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRleHRzLnB1c2goe1xuXHRcdFx0XHRvaWQ6IEVYVFMuYmFzaWNDb25zdHJhaW50cyxcblx0XHRcdFx0Y3JpdGljYWw6IHRydWVcblx0XHRcdH0pO1xuXHRcdFx0ZXh0cy5wdXNoKHtcblx0XHRcdFx0b2lkOiBFWFRTLmtleVVzYWdlLFxuXHRcdFx0XHRjcml0aWNhbDogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0XHRleHRzLnB1c2goe1xuXHRcdFx0XHRvaWQ6IEVYVFMuZXh0S2V5VXNhZ2UsXG5cdFx0XHRcdGNyaXRpY2FsOiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZXh0cy5wdXNoKHsgb2lkOiBFWFRTLmFsdE5hbWUgfSk7XG5cdFx0aWYgKHNpZy5leHRyYXMgJiYgc2lnLmV4dHJhcy5leHRzKVxuXHRcdFx0ZXh0cyA9IHNpZy5leHRyYXMuZXh0cztcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXh0cy5sZW5ndGg7ICsraSkge1xuXHRcdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblx0XHRcdGRlci53cml0ZU9JRChleHRzW2ldLm9pZCk7XG5cblx0XHRcdGlmIChleHRzW2ldLmNyaXRpY2FsICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdGRlci53cml0ZUJvb2xlYW4oZXh0c1tpXS5jcml0aWNhbCk7XG5cblx0XHRcdGlmIChleHRzW2ldLm9pZCA9PT0gRVhUUy5hbHROYW1lKSB7XG5cdFx0XHRcdGRlci5zdGFydFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0XHRcdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblx0XHRcdFx0aWYgKHN1YmplY3QudHlwZSA9PT0gJ2hvc3QnKSB7XG5cdFx0XHRcdFx0ZGVyLndyaXRlU3RyaW5nKHN1YmplY3QuaG9zdG5hbWUsXG5cdFx0XHRcdFx0ICAgIENvbnRleHQoMikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgYWx0TmFtZXMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0XHRpZiAoYWx0TmFtZXNbal0udHlwZSA9PT0gJ2hvc3QnKSB7XG5cdFx0XHRcdFx0XHRkZXIud3JpdGVTdHJpbmcoXG5cdFx0XHRcdFx0XHQgICAgYWx0TmFtZXNbal0uaG9zdG5hbWUsXG5cdFx0XHRcdFx0XHQgICAgQUxUTkFNRS5ETlNOYW1lKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGFsdE5hbWVzW2pdLnR5cGUgPT09XG5cdFx0XHRcdFx0ICAgICdlbWFpbCcpIHtcblx0XHRcdFx0XHRcdGRlci53cml0ZVN0cmluZyhcblx0XHRcdFx0XHRcdCAgICBhbHROYW1lc1tqXS5lbWFpbCxcblx0XHRcdFx0XHRcdCAgICBBTFROQU1FLlJGQzgyMk5hbWUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdFx0ICogRW5jb2RlIGFueXRoaW5nIGVsc2UgYXMgYVxuXHRcdFx0XHRcdFx0ICogRE4gc3R5bGUgbmFtZSBmb3Igbm93LlxuXHRcdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0XHRkZXIuc3RhcnRTZXF1ZW5jZShcblx0XHRcdFx0XHRcdCAgICBBTFROQU1FLkRpcmVjdG9yeU5hbWUpO1xuXHRcdFx0XHRcdFx0YWx0TmFtZXNbal0udG9Bc24xKGRlcik7XG5cdFx0XHRcdFx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdFx0XHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRcdFx0fSBlbHNlIGlmIChleHRzW2ldLm9pZCA9PT0gRVhUUy5iYXNpY0NvbnN0cmFpbnRzKSB7XG5cdFx0XHRcdGRlci5zdGFydFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0XHRcdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblx0XHRcdFx0dmFyIGNhID0gKGNlcnQucHVycG9zZXMuaW5kZXhPZignY2EnKSAhPT0gLTEpO1xuXHRcdFx0XHR2YXIgcGF0aExlbiA9IGV4dHNbaV0ucGF0aExlbjtcblx0XHRcdFx0ZGVyLndyaXRlQm9vbGVhbihjYSk7XG5cdFx0XHRcdGlmIChwYXRoTGVuICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0ZGVyLndyaXRlSW50KHBhdGhMZW4pO1xuXHRcdFx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0XHRcdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGV4dHNbaV0ub2lkID09PSBFWFRTLmV4dEtleVVzYWdlKSB7XG5cdFx0XHRcdGRlci5zdGFydFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0XHRcdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblx0XHRcdFx0Y2VydC5wdXJwb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChwdXJwb3NlKSB7XG5cdFx0XHRcdFx0aWYgKHB1cnBvc2UgPT09ICdjYScpXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0aWYgKEtFWVVTRUJJVFMuaW5kZXhPZihwdXJwb3NlKSAhPT0gLTEpXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0dmFyIG9pZCA9IHB1cnBvc2U7XG5cdFx0XHRcdFx0aWYgKEVYVFBVUlBPU0VbcHVycG9zZV0gIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdG9pZCA9IEVYVFBVUlBPU0VbcHVycG9zZV07XG5cdFx0XHRcdFx0ZGVyLndyaXRlT0lEKG9pZCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0XHRcdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGV4dHNbaV0ub2lkID09PSBFWFRTLmtleVVzYWdlKSB7XG5cdFx0XHRcdGRlci5zdGFydFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0XHRcdFx0Lypcblx0XHRcdFx0ICogSWYgd2UgcGFyc2VkIHRoaXMgY2VydGlmaWNhdGUgZnJvbSBhIGJ5dGVcblx0XHRcdFx0ICogc3RyZWFtIChpLmUuIHdlIGRpZG4ndCBnZW5lcmF0ZSBpdCBpbiBzc2hwaylcblx0XHRcdFx0ICogdGhlbiB3ZSdsbCBoYXZlIGEgXCIuYml0c1wiIHByb3BlcnR5IG9uIHRoZVxuXHRcdFx0XHQgKiBleHQgd2l0aCB0aGUgb3JpZ2luYWwgcmF3IGJ5dGUgY29udGVudHMuXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIElmIHdlIGhhdmUgdGhpcywgdXNlIGl0IGhlcmUgaW5zdGVhZCBvZlxuXHRcdFx0XHQgKiByZWdlbmVyYXRpbmcgaXQuIFRoaXMgZ3VhcmFudGVlcyB3ZSBvdXRwdXRcblx0XHRcdFx0ICogdGhlIHNhbWUgZGF0YSB3ZSBwYXJzZWQsIHNvIHNpZ25hdHVyZXMgc3RpbGxcblx0XHRcdFx0ICogdmFsaWRhdGUuXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRpZiAoZXh0c1tpXS5iaXRzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRkZXIud3JpdGVCdWZmZXIoZXh0c1tpXS5iaXRzLFxuXHRcdFx0XHRcdCAgICBhc24xLkJlci5CaXRTdHJpbmcpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBiaXRzID0gd3JpdGVCaXRGaWVsZChjZXJ0LnB1cnBvc2VzLFxuXHRcdFx0XHRcdCAgICBLRVlVU0VCSVRTKTtcblx0XHRcdFx0XHRkZXIud3JpdGVCdWZmZXIoYml0cyxcblx0XHRcdFx0XHQgICAgYXNuMS5CZXIuQml0U3RyaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlci53cml0ZUJ1ZmZlcihleHRzW2ldLmRhdGEsXG5cdFx0XHRcdCAgICBhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRcdH1cblxuXHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHR9XG5cblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG59XG5cbi8qXG4gKiBSZWFkcyBhbiBBU04uMSBCRVIgYml0ZmllbGQgb3V0IG9mIHRoZSBCdWZmZXIgcHJvZHVjZWQgYnkgZG9pbmdcbiAqIGBCZXJSZWFkZXIjcmVhZFN0cmluZyhhc24xLkJlci5CaXRTdHJpbmcpYC4gVGhhdCBmdW5jdGlvbiBnaXZlcyB1cyB0aGUgcmF3XG4gKiBjb250ZW50cyBvZiB0aGUgQml0U3RyaW5nIHRhZywgd2hpY2ggaXMgYSBjb3VudCBvZiB1bnVzZWQgYml0cyBmb2xsb3dlZCBieVxuICogdGhlIGJpdHMgYXMgYSByaWdodC1wYWRkZWQgYnl0ZSBzdHJpbmcuXG4gKlxuICogYGJpdHNgIGlzIHRoZSBCdWZmZXIsIGBiaXRJbmRleGAgc2hvdWxkIGNvbnRhaW4gYW4gYXJyYXkgb2Ygc3RyaW5nIG5hbWVzXG4gKiBmb3IgdGhlIGJpdHMgaW4gdGhlIHN0cmluZywgb3JkZXJlZCBzdGFydGluZyB3aXRoIGJpdCAjMCBpbiB0aGUgQVNOLjEgc3BlYy5cbiAqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIFN0cmluZ3MsIHRoZSBuYW1lcyBvZiB0aGUgYml0cyB0aGF0IHdlcmUgc2V0IHRvIDEuXG4gKi9cbmZ1bmN0aW9uIHJlYWRCaXRGaWVsZChiaXRzLCBiaXRJbmRleCkge1xuXHR2YXIgYml0TGVuID0gOCAqIChiaXRzLmxlbmd0aCAtIDEpIC0gYml0c1swXTtcblx0dmFyIHNldEJpdHMgPSB7fTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBiaXRMZW47ICsraSkge1xuXHRcdHZhciBieXRlTiA9IDEgKyBNYXRoLmZsb29yKGkgLyA4KTtcblx0XHR2YXIgYml0ID0gNyAtIChpICUgOCk7XG5cdFx0dmFyIG1hc2sgPSAxIDw8IGJpdDtcblx0XHR2YXIgYml0VmFsID0gKChiaXRzW2J5dGVOXSAmIG1hc2spICE9PSAwKTtcblx0XHR2YXIgbmFtZSA9IGJpdEluZGV4W2ldO1xuXHRcdGlmIChiaXRWYWwgJiYgdHlwZW9mIChuYW1lKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHNldEJpdHNbbmFtZV0gPSB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gKE9iamVjdC5rZXlzKHNldEJpdHMpKTtcbn1cblxuLypcbiAqIGBzZXRCaXRzYCBpcyBhbiBhcnJheSBvZiBzdHJpbmdzLCBjb250YWluaW5nIHRoZSBuYW1lcyBmb3IgZWFjaCBiaXQgdGhhdFxuICogc291bGQgYmUgc2V0IHRvIDEuIGBiaXRJbmRleGAgaXMgc2FtZSBhcyBpbiBgcmVhZEJpdEZpZWxkKClgLlxuICpcbiAqIFJldHVybnMgYSBCdWZmZXIsIHJlYWR5IHRvIGJlIHdyaXR0ZW4gb3V0IHdpdGggYEJlcldyaXRlciN3cml0ZVN0cmluZygpYC5cbiAqL1xuZnVuY3Rpb24gd3JpdGVCaXRGaWVsZChzZXRCaXRzLCBiaXRJbmRleCkge1xuXHR2YXIgYml0TGVuID0gYml0SW5kZXgubGVuZ3RoO1xuXHR2YXIgYmxlbiA9IE1hdGguY2VpbChiaXRMZW4gLyA4KTtcblx0dmFyIHVudXNlZCA9IGJsZW4gKiA4IC0gYml0TGVuO1xuXHR2YXIgYml0cyA9IEJ1ZmZlci5hbGxvYygxICsgYmxlbik7IC8vIHplcm8tZmlsbGVkXG5cdGJpdHNbMF0gPSB1bnVzZWQ7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYml0TGVuOyArK2kpIHtcblx0XHR2YXIgYnl0ZU4gPSAxICsgTWF0aC5mbG9vcihpIC8gOCk7XG5cdFx0dmFyIGJpdCA9IDcgLSAoaSAlIDgpO1xuXHRcdHZhciBtYXNrID0gMSA8PCBiaXQ7XG5cdFx0dmFyIG5hbWUgPSBiaXRJbmRleFtpXTtcblx0XHRpZiAobmFtZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0Y29udGludWU7XG5cdFx0dmFyIGJpdFZhbCA9IChzZXRCaXRzLmluZGV4T2YobmFtZSkgIT09IC0xKTtcblx0XHRpZiAoYml0VmFsKSB7XG5cdFx0XHRiaXRzW2J5dGVOXSB8PSBtYXNrO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gKGJpdHMpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/formats/x509.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/identity.js":
/*!********************************************!*\
  !*** ./node_modules/sshpk/lib/identity.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2017 Joyent, Inc.\n\nmodule.exports = Identity;\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar algs = __webpack_require__(/*! ./algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar Fingerprint = __webpack_require__(/*! ./fingerprint */ \"(action-browser)/./node_modules/sshpk/lib/fingerprint.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"(action-browser)/./node_modules/sshpk/lib/signature.js\");\nvar errs = __webpack_require__(/*! ./errors */ \"(action-browser)/./node_modules/sshpk/lib/errors.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar utils = __webpack_require__(/*! ./utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(action-browser)/./node_modules/asn1/lib/index.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\n\n/*JSSTYLED*/\nvar DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\\-]{0,62})(?:\\.([*]|[a-z0-9][a-z0-9\\-]{0,62}))*$/i;\n\nvar oids = {};\noids.cn = '2.5.4.3';\noids.o = '2.5.4.10';\noids.ou = '2.5.4.11';\noids.l = '2.5.4.7';\noids.s = '2.5.4.8';\noids.c = '2.5.4.6';\noids.sn = '2.5.4.4';\noids.postalCode = '2.5.4.17';\noids.serialNumber = '2.5.4.5';\noids.street = '2.5.4.9';\noids.x500UniqueIdentifier = '2.5.4.45';\noids.role = '2.5.4.72';\noids.telephoneNumber = '2.5.4.20';\noids.description = '2.5.4.13';\noids.dc = '0.9.2342.19200300.100.1.25';\noids.uid = '0.9.2342.19200300.100.1.1';\noids.mail = '0.9.2342.19200300.100.1.3';\noids.title = '2.5.4.12';\noids.gn = '2.5.4.42';\noids.initials = '2.5.4.43';\noids.pseudonym = '2.5.4.65';\noids.emailAddress = '1.2.840.113549.1.9.1';\n\nvar unoids = {};\nObject.keys(oids).forEach(function (k) {\n\tunoids[oids[k]] = k;\n});\n\nfunction Identity(opts) {\n\tvar self = this;\n\tassert.object(opts, 'options');\n\tassert.arrayOfObject(opts.components, 'options.components');\n\tthis.components = opts.components;\n\tthis.componentLookup = {};\n\tthis.components.forEach(function (c) {\n\t\tif (c.name && !c.oid)\n\t\t\tc.oid = oids[c.name];\n\t\tif (c.oid && !c.name)\n\t\t\tc.name = unoids[c.oid];\n\t\tif (self.componentLookup[c.name] === undefined)\n\t\t\tself.componentLookup[c.name] = [];\n\t\tself.componentLookup[c.name].push(c);\n\t});\n\tif (this.componentLookup.cn && this.componentLookup.cn.length > 0) {\n\t\tthis.cn = this.componentLookup.cn[0].value;\n\t}\n\tassert.optionalString(opts.type, 'options.type');\n\tif (opts.type === undefined) {\n\t\tif (this.components.length === 1 &&\n\t\t    this.componentLookup.cn &&\n\t\t    this.componentLookup.cn.length === 1 &&\n\t\t    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {\n\t\t\tthis.type = 'host';\n\t\t\tthis.hostname = this.componentLookup.cn[0].value;\n\n\t\t} else if (this.componentLookup.dc &&\n\t\t    this.components.length === this.componentLookup.dc.length) {\n\t\t\tthis.type = 'host';\n\t\t\tthis.hostname = this.componentLookup.dc.map(\n\t\t\t    function (c) {\n\t\t\t\treturn (c.value);\n\t\t\t}).join('.');\n\n\t\t} else if (this.componentLookup.uid &&\n\t\t    this.components.length ===\n\t\t    this.componentLookup.uid.length) {\n\t\t\tthis.type = 'user';\n\t\t\tthis.uid = this.componentLookup.uid[0].value;\n\n\t\t} else if (this.componentLookup.cn &&\n\t\t    this.componentLookup.cn.length === 1 &&\n\t\t    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {\n\t\t\tthis.type = 'host';\n\t\t\tthis.hostname = this.componentLookup.cn[0].value;\n\n\t\t} else if (this.componentLookup.uid &&\n\t\t    this.componentLookup.uid.length === 1) {\n\t\t\tthis.type = 'user';\n\t\t\tthis.uid = this.componentLookup.uid[0].value;\n\n\t\t} else if (this.componentLookup.mail &&\n\t\t    this.componentLookup.mail.length === 1) {\n\t\t\tthis.type = 'email';\n\t\t\tthis.email = this.componentLookup.mail[0].value;\n\n\t\t} else if (this.componentLookup.cn &&\n\t\t    this.componentLookup.cn.length === 1) {\n\t\t\tthis.type = 'user';\n\t\t\tthis.uid = this.componentLookup.cn[0].value;\n\n\t\t} else {\n\t\t\tthis.type = 'unknown';\n\t\t}\n\t} else {\n\t\tthis.type = opts.type;\n\t\tif (this.type === 'host')\n\t\t\tthis.hostname = opts.hostname;\n\t\telse if (this.type === 'user')\n\t\t\tthis.uid = opts.uid;\n\t\telse if (this.type === 'email')\n\t\t\tthis.email = opts.email;\n\t\telse\n\t\t\tthrow (new Error('Unknown type ' + this.type));\n\t}\n}\n\nIdentity.prototype.toString = function () {\n\treturn (this.components.map(function (c) {\n\t\tvar n = c.name.toUpperCase();\n\t\t/*JSSTYLED*/\n\t\tn = n.replace(/=/g, '\\\\=');\n\t\tvar v = c.value;\n\t\t/*JSSTYLED*/\n\t\tv = v.replace(/,/g, '\\\\,');\n\t\treturn (n + '=' + v);\n\t}).join(', '));\n};\n\nIdentity.prototype.get = function (name, asArray) {\n\tassert.string(name, 'name');\n\tvar arr = this.componentLookup[name];\n\tif (arr === undefined || arr.length === 0)\n\t\treturn (undefined);\n\tif (!asArray && arr.length > 1)\n\t\tthrow (new Error('Multiple values for attribute ' + name));\n\tif (!asArray)\n\t\treturn (arr[0].value);\n\treturn (arr.map(function (c) {\n\t\treturn (c.value);\n\t}));\n};\n\nIdentity.prototype.toArray = function (idx) {\n\treturn (this.components.map(function (c) {\n\t\treturn ({\n\t\t\tname: c.name,\n\t\t\tvalue: c.value\n\t\t});\n\t}));\n};\n\n/*\n * These are from X.680 -- PrintableString allowed chars are in section 37.4\n * table 8. Spec for IA5Strings is \"1,6 + SPACE + DEL\" where 1 refers to\n * ISO IR #001 (standard ASCII control characters) and 6 refers to ISO IR #006\n * (the basic ASCII character set).\n */\n/* JSSTYLED */\nvar NOT_PRINTABLE = /[^a-zA-Z0-9 '(),+.\\/:=?-]/;\n/* JSSTYLED */\nvar NOT_IA5 = /[^\\x00-\\x7f]/;\n\nIdentity.prototype.toAsn1 = function (der, tag) {\n\tder.startSequence(tag);\n\tthis.components.forEach(function (c) {\n\t\tder.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);\n\t\tder.startSequence();\n\t\tder.writeOID(c.oid);\n\t\t/*\n\t\t * If we fit in a PrintableString, use that. Otherwise use an\n\t\t * IA5String or UTF8String.\n\t\t *\n\t\t * If this identity was parsed from a DN, use the ASN.1 types\n\t\t * from the original representation (otherwise this might not\n\t\t * be a full match for the original in some validators).\n\t\t */\n\t\tif (c.asn1type === asn1.Ber.Utf8String ||\n\t\t    c.value.match(NOT_IA5)) {\n\t\t\tvar v = Buffer.from(c.value, 'utf8');\n\t\t\tder.writeBuffer(v, asn1.Ber.Utf8String);\n\n\t\t} else if (c.asn1type === asn1.Ber.IA5String ||\n\t\t    c.value.match(NOT_PRINTABLE)) {\n\t\t\tder.writeString(c.value, asn1.Ber.IA5String);\n\n\t\t} else {\n\t\t\tvar type = asn1.Ber.PrintableString;\n\t\t\tif (c.asn1type !== undefined)\n\t\t\t\ttype = c.asn1type;\n\t\t\tder.writeString(c.value, type);\n\t\t}\n\t\tder.endSequence();\n\t\tder.endSequence();\n\t});\n\tder.endSequence();\n};\n\nfunction globMatch(a, b) {\n\tif (a === '**' || b === '**')\n\t\treturn (true);\n\tvar aParts = a.split('.');\n\tvar bParts = b.split('.');\n\tif (aParts.length !== bParts.length)\n\t\treturn (false);\n\tfor (var i = 0; i < aParts.length; ++i) {\n\t\tif (aParts[i] === '*' || bParts[i] === '*')\n\t\t\tcontinue;\n\t\tif (aParts[i] !== bParts[i])\n\t\t\treturn (false);\n\t}\n\treturn (true);\n}\n\nIdentity.prototype.equals = function (other) {\n\tif (!Identity.isIdentity(other, [1, 0]))\n\t\treturn (false);\n\tif (other.components.length !== this.components.length)\n\t\treturn (false);\n\tfor (var i = 0; i < this.components.length; ++i) {\n\t\tif (this.components[i].oid !== other.components[i].oid)\n\t\t\treturn (false);\n\t\tif (!globMatch(this.components[i].value,\n\t\t    other.components[i].value)) {\n\t\t\treturn (false);\n\t\t}\n\t}\n\treturn (true);\n};\n\nIdentity.forHost = function (hostname) {\n\tassert.string(hostname, 'hostname');\n\treturn (new Identity({\n\t\ttype: 'host',\n\t\thostname: hostname,\n\t\tcomponents: [ { name: 'cn', value: hostname } ]\n\t}));\n};\n\nIdentity.forUser = function (uid) {\n\tassert.string(uid, 'uid');\n\treturn (new Identity({\n\t\ttype: 'user',\n\t\tuid: uid,\n\t\tcomponents: [ { name: 'uid', value: uid } ]\n\t}));\n};\n\nIdentity.forEmail = function (email) {\n\tassert.string(email, 'email');\n\treturn (new Identity({\n\t\ttype: 'email',\n\t\temail: email,\n\t\tcomponents: [ { name: 'mail', value: email } ]\n\t}));\n};\n\nIdentity.parseDN = function (dn) {\n\tassert.string(dn, 'dn');\n\tvar parts = [''];\n\tvar idx = 0;\n\tvar rem = dn;\n\twhile (rem.length > 0) {\n\t\tvar m;\n\t\t/*JSSTYLED*/\n\t\tif ((m = /^,/.exec(rem)) !== null) {\n\t\t\tparts[++idx] = '';\n\t\t\trem = rem.slice(m[0].length);\n\t\t/*JSSTYLED*/\n\t\t} else if ((m = /^\\\\,/.exec(rem)) !== null) {\n\t\t\tparts[idx] += ',';\n\t\t\trem = rem.slice(m[0].length);\n\t\t/*JSSTYLED*/\n\t\t} else if ((m = /^\\\\./.exec(rem)) !== null) {\n\t\t\tparts[idx] += m[0];\n\t\t\trem = rem.slice(m[0].length);\n\t\t/*JSSTYLED*/\n\t\t} else if ((m = /^[^\\\\,]+/.exec(rem)) !== null) {\n\t\t\tparts[idx] += m[0];\n\t\t\trem = rem.slice(m[0].length);\n\t\t} else {\n\t\t\tthrow (new Error('Failed to parse DN'));\n\t\t}\n\t}\n\tvar cmps = parts.map(function (c) {\n\t\tc = c.trim();\n\t\tvar eqPos = c.indexOf('=');\n\t\twhile (eqPos > 0 && c.charAt(eqPos - 1) === '\\\\')\n\t\t\teqPos = c.indexOf('=', eqPos + 1);\n\t\tif (eqPos === -1) {\n\t\t\tthrow (new Error('Failed to parse DN'));\n\t\t}\n\t\t/*JSSTYLED*/\n\t\tvar name = c.slice(0, eqPos).toLowerCase().replace(/\\\\=/g, '=');\n\t\tvar value = c.slice(eqPos + 1);\n\t\treturn ({ name: name, value: value });\n\t});\n\treturn (new Identity({ components: cmps }));\n};\n\nIdentity.fromArray = function (components) {\n\tassert.arrayOfObject(components, 'components');\n\tcomponents.forEach(function (cmp) {\n\t\tassert.object(cmp, 'component');\n\t\tassert.string(cmp.name, 'component.name');\n\t\tif (!Buffer.isBuffer(cmp.value) &&\n\t\t    !(typeof (cmp.value) === 'string')) {\n\t\t\tthrow (new Error('Invalid component value'));\n\t\t}\n\t});\n\treturn (new Identity({ components: components }));\n};\n\nIdentity.parseAsn1 = function (der, top) {\n\tvar components = [];\n\tder.readSequence(top);\n\tvar end = der.offset + der.length;\n\twhile (der.offset < end) {\n\t\tder.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);\n\t\tvar after = der.offset + der.length;\n\t\tder.readSequence();\n\t\tvar oid = der.readOID();\n\t\tvar type = der.peek();\n\t\tvar value;\n\t\tswitch (type) {\n\t\tcase asn1.Ber.PrintableString:\n\t\tcase asn1.Ber.IA5String:\n\t\tcase asn1.Ber.OctetString:\n\t\tcase asn1.Ber.T61String:\n\t\t\tvalue = der.readString(type);\n\t\t\tbreak;\n\t\tcase asn1.Ber.Utf8String:\n\t\t\tvalue = der.readString(type, true);\n\t\t\tvalue = value.toString('utf8');\n\t\t\tbreak;\n\t\tcase asn1.Ber.CharacterString:\n\t\tcase asn1.Ber.BMPString:\n\t\t\tvalue = der.readString(type, true);\n\t\t\tvalue = value.toString('utf16le');\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new Error('Unknown asn1 type ' + type));\n\t\t}\n\t\tcomponents.push({ oid: oid, asn1type: type, value: value });\n\t\tder._offset = after;\n\t}\n\tder._offset = end;\n\treturn (new Identity({\n\t\tcomponents: components\n\t}));\n};\n\nIdentity.isIdentity = function (obj, ver) {\n\treturn (utils.isCompatible(obj, Identity, ver));\n};\n\n/*\n * API versions for Identity:\n * [1,0] -- initial ver\n */\nIdentity.prototype._sshpkApiVersion = [1, 0];\n\nIdentity._oldVersionDetect = function (obj) {\n\treturn ([1, 0]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvaWRlbnRpdHkuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDBFQUFhO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyxpRUFBUTtBQUMzQixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMsK0VBQWU7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsMkVBQWE7QUFDckMsV0FBVyxtQkFBTyxDQUFDLHFFQUFVO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsbUVBQVM7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLCtEQUFNO0FBQ3pCLGFBQWEseUdBQThCOztBQUUzQztBQUNBLDRDQUE0QyxLQUFLLDhCQUE4QixLQUFLOztBQUVwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZCQUE2QjtBQUMvQyxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEMsRUFBRTtBQUNGLHdCQUF3QixrQkFBa0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLHdCQUF3Qix3QkFBd0I7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdDQUF3QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2lkZW50aXR5LmpzPzAzNWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTcgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0gSWRlbnRpdHk7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuL2FsZ3MnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBGaW5nZXJwcmludCA9IHJlcXVpcmUoJy4vZmluZ2VycHJpbnQnKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xudmFyIGVycnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYXNuMSA9IHJlcXVpcmUoJ2FzbjEnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG5cbi8qSlNTVFlMRUQqL1xudmFyIEROU19OQU1FX1JFID0gL14oWypdfFthLXowLTldW2EtejAtOVxcLV17MCw2Mn0pKD86XFwuKFsqXXxbYS16MC05XVthLXowLTlcXC1dezAsNjJ9KSkqJC9pO1xuXG52YXIgb2lkcyA9IHt9O1xub2lkcy5jbiA9ICcyLjUuNC4zJztcbm9pZHMubyA9ICcyLjUuNC4xMCc7XG5vaWRzLm91ID0gJzIuNS40LjExJztcbm9pZHMubCA9ICcyLjUuNC43Jztcbm9pZHMucyA9ICcyLjUuNC44Jztcbm9pZHMuYyA9ICcyLjUuNC42Jztcbm9pZHMuc24gPSAnMi41LjQuNCc7XG5vaWRzLnBvc3RhbENvZGUgPSAnMi41LjQuMTcnO1xub2lkcy5zZXJpYWxOdW1iZXIgPSAnMi41LjQuNSc7XG5vaWRzLnN0cmVldCA9ICcyLjUuNC45Jztcbm9pZHMueDUwMFVuaXF1ZUlkZW50aWZpZXIgPSAnMi41LjQuNDUnO1xub2lkcy5yb2xlID0gJzIuNS40LjcyJztcbm9pZHMudGVsZXBob25lTnVtYmVyID0gJzIuNS40LjIwJztcbm9pZHMuZGVzY3JpcHRpb24gPSAnMi41LjQuMTMnO1xub2lkcy5kYyA9ICcwLjkuMjM0Mi4xOTIwMDMwMC4xMDAuMS4yNSc7XG5vaWRzLnVpZCA9ICcwLjkuMjM0Mi4xOTIwMDMwMC4xMDAuMS4xJztcbm9pZHMubWFpbCA9ICcwLjkuMjM0Mi4xOTIwMDMwMC4xMDAuMS4zJztcbm9pZHMudGl0bGUgPSAnMi41LjQuMTInO1xub2lkcy5nbiA9ICcyLjUuNC40Mic7XG5vaWRzLmluaXRpYWxzID0gJzIuNS40LjQzJztcbm9pZHMucHNldWRvbnltID0gJzIuNS40LjY1Jztcbm9pZHMuZW1haWxBZGRyZXNzID0gJzEuMi44NDAuMTEzNTQ5LjEuOS4xJztcblxudmFyIHVub2lkcyA9IHt9O1xuT2JqZWN0LmtleXMob2lkcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHR1bm9pZHNbb2lkc1trXV0gPSBrO1xufSk7XG5cbmZ1bmN0aW9uIElkZW50aXR5KG9wdHMpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRhc3NlcnQub2JqZWN0KG9wdHMsICdvcHRpb25zJyk7XG5cdGFzc2VydC5hcnJheU9mT2JqZWN0KG9wdHMuY29tcG9uZW50cywgJ29wdGlvbnMuY29tcG9uZW50cycpO1xuXHR0aGlzLmNvbXBvbmVudHMgPSBvcHRzLmNvbXBvbmVudHM7XG5cdHRoaXMuY29tcG9uZW50TG9va3VwID0ge307XG5cdHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG5cdFx0aWYgKGMubmFtZSAmJiAhYy5vaWQpXG5cdFx0XHRjLm9pZCA9IG9pZHNbYy5uYW1lXTtcblx0XHRpZiAoYy5vaWQgJiYgIWMubmFtZSlcblx0XHRcdGMubmFtZSA9IHVub2lkc1tjLm9pZF07XG5cdFx0aWYgKHNlbGYuY29tcG9uZW50TG9va3VwW2MubmFtZV0gPT09IHVuZGVmaW5lZClcblx0XHRcdHNlbGYuY29tcG9uZW50TG9va3VwW2MubmFtZV0gPSBbXTtcblx0XHRzZWxmLmNvbXBvbmVudExvb2t1cFtjLm5hbWVdLnB1c2goYyk7XG5cdH0pO1xuXHRpZiAodGhpcy5jb21wb25lbnRMb29rdXAuY24gJiYgdGhpcy5jb21wb25lbnRMb29rdXAuY24ubGVuZ3RoID4gMCkge1xuXHRcdHRoaXMuY24gPSB0aGlzLmNvbXBvbmVudExvb2t1cC5jblswXS52YWx1ZTtcblx0fVxuXHRhc3NlcnQub3B0aW9uYWxTdHJpbmcob3B0cy50eXBlLCAnb3B0aW9ucy50eXBlJyk7XG5cdGlmIChvcHRzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdGlmICh0aGlzLmNvbXBvbmVudHMubGVuZ3RoID09PSAxICYmXG5cdFx0ICAgIHRoaXMuY29tcG9uZW50TG9va3VwLmNuICYmXG5cdFx0ICAgIHRoaXMuY29tcG9uZW50TG9va3VwLmNuLmxlbmd0aCA9PT0gMSAmJlxuXHRcdCAgICB0aGlzLmNvbXBvbmVudExvb2t1cC5jblswXS52YWx1ZS5tYXRjaChETlNfTkFNRV9SRSkpIHtcblx0XHRcdHRoaXMudHlwZSA9ICdob3N0Jztcblx0XHRcdHRoaXMuaG9zdG5hbWUgPSB0aGlzLmNvbXBvbmVudExvb2t1cC5jblswXS52YWx1ZTtcblxuXHRcdH0gZWxzZSBpZiAodGhpcy5jb21wb25lbnRMb29rdXAuZGMgJiZcblx0XHQgICAgdGhpcy5jb21wb25lbnRzLmxlbmd0aCA9PT0gdGhpcy5jb21wb25lbnRMb29rdXAuZGMubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSAnaG9zdCc7XG5cdFx0XHR0aGlzLmhvc3RuYW1lID0gdGhpcy5jb21wb25lbnRMb29rdXAuZGMubWFwKFxuXHRcdFx0ICAgIGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdHJldHVybiAoYy52YWx1ZSk7XG5cdFx0XHR9KS5qb2luKCcuJyk7XG5cblx0XHR9IGVsc2UgaWYgKHRoaXMuY29tcG9uZW50TG9va3VwLnVpZCAmJlxuXHRcdCAgICB0aGlzLmNvbXBvbmVudHMubGVuZ3RoID09PVxuXHRcdCAgICB0aGlzLmNvbXBvbmVudExvb2t1cC51aWQubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSAndXNlcic7XG5cdFx0XHR0aGlzLnVpZCA9IHRoaXMuY29tcG9uZW50TG9va3VwLnVpZFswXS52YWx1ZTtcblxuXHRcdH0gZWxzZSBpZiAodGhpcy5jb21wb25lbnRMb29rdXAuY24gJiZcblx0XHQgICAgdGhpcy5jb21wb25lbnRMb29rdXAuY24ubGVuZ3RoID09PSAxICYmXG5cdFx0ICAgIHRoaXMuY29tcG9uZW50TG9va3VwLmNuWzBdLnZhbHVlLm1hdGNoKEROU19OQU1FX1JFKSkge1xuXHRcdFx0dGhpcy50eXBlID0gJ2hvc3QnO1xuXHRcdFx0dGhpcy5ob3N0bmFtZSA9IHRoaXMuY29tcG9uZW50TG9va3VwLmNuWzBdLnZhbHVlO1xuXG5cdFx0fSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudExvb2t1cC51aWQgJiZcblx0XHQgICAgdGhpcy5jb21wb25lbnRMb29rdXAudWlkLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dGhpcy50eXBlID0gJ3VzZXInO1xuXHRcdFx0dGhpcy51aWQgPSB0aGlzLmNvbXBvbmVudExvb2t1cC51aWRbMF0udmFsdWU7XG5cblx0XHR9IGVsc2UgaWYgKHRoaXMuY29tcG9uZW50TG9va3VwLm1haWwgJiZcblx0XHQgICAgdGhpcy5jb21wb25lbnRMb29rdXAubWFpbC5sZW5ndGggPT09IDEpIHtcblx0XHRcdHRoaXMudHlwZSA9ICdlbWFpbCc7XG5cdFx0XHR0aGlzLmVtYWlsID0gdGhpcy5jb21wb25lbnRMb29rdXAubWFpbFswXS52YWx1ZTtcblxuXHRcdH0gZWxzZSBpZiAodGhpcy5jb21wb25lbnRMb29rdXAuY24gJiZcblx0XHQgICAgdGhpcy5jb21wb25lbnRMb29rdXAuY24ubGVuZ3RoID09PSAxKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSAndXNlcic7XG5cdFx0XHR0aGlzLnVpZCA9IHRoaXMuY29tcG9uZW50TG9va3VwLmNuWzBdLnZhbHVlO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudHlwZSA9ICd1bmtub3duJztcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gb3B0cy50eXBlO1xuXHRcdGlmICh0aGlzLnR5cGUgPT09ICdob3N0Jylcblx0XHRcdHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuXHRcdGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ3VzZXInKVxuXHRcdFx0dGhpcy51aWQgPSBvcHRzLnVpZDtcblx0XHRlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdlbWFpbCcpXG5cdFx0XHR0aGlzLmVtYWlsID0gb3B0cy5lbWFpbDtcblx0XHRlbHNlXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdVbmtub3duIHR5cGUgJyArIHRoaXMudHlwZSkpO1xuXHR9XG59XG5cbklkZW50aXR5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICh0aGlzLmNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjKSB7XG5cdFx0dmFyIG4gPSBjLm5hbWUudG9VcHBlckNhc2UoKTtcblx0XHQvKkpTU1RZTEVEKi9cblx0XHRuID0gbi5yZXBsYWNlKC89L2csICdcXFxcPScpO1xuXHRcdHZhciB2ID0gYy52YWx1ZTtcblx0XHQvKkpTU1RZTEVEKi9cblx0XHR2ID0gdi5yZXBsYWNlKC8sL2csICdcXFxcLCcpO1xuXHRcdHJldHVybiAobiArICc9JyArIHYpO1xuXHR9KS5qb2luKCcsICcpKTtcbn07XG5cbklkZW50aXR5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSwgYXNBcnJheSkge1xuXHRhc3NlcnQuc3RyaW5nKG5hbWUsICduYW1lJyk7XG5cdHZhciBhcnIgPSB0aGlzLmNvbXBvbmVudExvb2t1cFtuYW1lXTtcblx0aWYgKGFyciA9PT0gdW5kZWZpbmVkIHx8IGFyci5sZW5ndGggPT09IDApXG5cdFx0cmV0dXJuICh1bmRlZmluZWQpO1xuXHRpZiAoIWFzQXJyYXkgJiYgYXJyLmxlbmd0aCA+IDEpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignTXVsdGlwbGUgdmFsdWVzIGZvciBhdHRyaWJ1dGUgJyArIG5hbWUpKTtcblx0aWYgKCFhc0FycmF5KVxuXHRcdHJldHVybiAoYXJyWzBdLnZhbHVlKTtcblx0cmV0dXJuIChhcnIubWFwKGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuIChjLnZhbHVlKTtcblx0fSkpO1xufTtcblxuSWRlbnRpdHkucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoaWR4KSB7XG5cdHJldHVybiAodGhpcy5jb21wb25lbnRzLm1hcChmdW5jdGlvbiAoYykge1xuXHRcdHJldHVybiAoe1xuXHRcdFx0bmFtZTogYy5uYW1lLFxuXHRcdFx0dmFsdWU6IGMudmFsdWVcblx0XHR9KTtcblx0fSkpO1xufTtcblxuLypcbiAqIFRoZXNlIGFyZSBmcm9tIFguNjgwIC0tIFByaW50YWJsZVN0cmluZyBhbGxvd2VkIGNoYXJzIGFyZSBpbiBzZWN0aW9uIDM3LjRcbiAqIHRhYmxlIDguIFNwZWMgZm9yIElBNVN0cmluZ3MgaXMgXCIxLDYgKyBTUEFDRSArIERFTFwiIHdoZXJlIDEgcmVmZXJzIHRvXG4gKiBJU08gSVIgIzAwMSAoc3RhbmRhcmQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzKSBhbmQgNiByZWZlcnMgdG8gSVNPIElSICMwMDZcbiAqICh0aGUgYmFzaWMgQVNDSUkgY2hhcmFjdGVyIHNldCkuXG4gKi9cbi8qIEpTU1RZTEVEICovXG52YXIgTk9UX1BSSU5UQUJMRSA9IC9bXmEtekEtWjAtOSAnKCksKy5cXC86PT8tXS87XG4vKiBKU1NUWUxFRCAqL1xudmFyIE5PVF9JQTUgPSAvW15cXHgwMC1cXHg3Zl0vO1xuXG5JZGVudGl0eS5wcm90b3R5cGUudG9Bc24xID0gZnVuY3Rpb24gKGRlciwgdGFnKSB7XG5cdGRlci5zdGFydFNlcXVlbmNlKHRhZyk7XG5cdHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG5cdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuQ29uc3RydWN0b3IgfCBhc24xLkJlci5TZXQpO1xuXHRcdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cdFx0ZGVyLndyaXRlT0lEKGMub2lkKTtcblx0XHQvKlxuXHRcdCAqIElmIHdlIGZpdCBpbiBhIFByaW50YWJsZVN0cmluZywgdXNlIHRoYXQuIE90aGVyd2lzZSB1c2UgYW5cblx0XHQgKiBJQTVTdHJpbmcgb3IgVVRGOFN0cmluZy5cblx0XHQgKlxuXHRcdCAqIElmIHRoaXMgaWRlbnRpdHkgd2FzIHBhcnNlZCBmcm9tIGEgRE4sIHVzZSB0aGUgQVNOLjEgdHlwZXNcblx0XHQgKiBmcm9tIHRoZSBvcmlnaW5hbCByZXByZXNlbnRhdGlvbiAob3RoZXJ3aXNlIHRoaXMgbWlnaHQgbm90XG5cdFx0ICogYmUgYSBmdWxsIG1hdGNoIGZvciB0aGUgb3JpZ2luYWwgaW4gc29tZSB2YWxpZGF0b3JzKS5cblx0XHQgKi9cblx0XHRpZiAoYy5hc24xdHlwZSA9PT0gYXNuMS5CZXIuVXRmOFN0cmluZyB8fFxuXHRcdCAgICBjLnZhbHVlLm1hdGNoKE5PVF9JQTUpKSB7XG5cdFx0XHR2YXIgdiA9IEJ1ZmZlci5mcm9tKGMudmFsdWUsICd1dGY4Jyk7XG5cdFx0XHRkZXIud3JpdGVCdWZmZXIodiwgYXNuMS5CZXIuVXRmOFN0cmluZyk7XG5cblx0XHR9IGVsc2UgaWYgKGMuYXNuMXR5cGUgPT09IGFzbjEuQmVyLklBNVN0cmluZyB8fFxuXHRcdCAgICBjLnZhbHVlLm1hdGNoKE5PVF9QUklOVEFCTEUpKSB7XG5cdFx0XHRkZXIud3JpdGVTdHJpbmcoYy52YWx1ZSwgYXNuMS5CZXIuSUE1U3RyaW5nKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdHlwZSA9IGFzbjEuQmVyLlByaW50YWJsZVN0cmluZztcblx0XHRcdGlmIChjLmFzbjF0eXBlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdHR5cGUgPSBjLmFzbjF0eXBlO1xuXHRcdFx0ZGVyLndyaXRlU3RyaW5nKGMudmFsdWUsIHR5cGUpO1xuXHRcdH1cblx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0fSk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xufTtcblxuZnVuY3Rpb24gZ2xvYk1hdGNoKGEsIGIpIHtcblx0aWYgKGEgPT09ICcqKicgfHwgYiA9PT0gJyoqJylcblx0XHRyZXR1cm4gKHRydWUpO1xuXHR2YXIgYVBhcnRzID0gYS5zcGxpdCgnLicpO1xuXHR2YXIgYlBhcnRzID0gYi5zcGxpdCgnLicpO1xuXHRpZiAoYVBhcnRzLmxlbmd0aCAhPT0gYlBhcnRzLmxlbmd0aClcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhUGFydHMubGVuZ3RoOyArK2kpIHtcblx0XHRpZiAoYVBhcnRzW2ldID09PSAnKicgfHwgYlBhcnRzW2ldID09PSAnKicpXG5cdFx0XHRjb250aW51ZTtcblx0XHRpZiAoYVBhcnRzW2ldICE9PSBiUGFydHNbaV0pXG5cdFx0XHRyZXR1cm4gKGZhbHNlKTtcblx0fVxuXHRyZXR1cm4gKHRydWUpO1xufVxuXG5JZGVudGl0eS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdGlmICghSWRlbnRpdHkuaXNJZGVudGl0eShvdGhlciwgWzEsIDBdKSlcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0aWYgKG90aGVyLmNvbXBvbmVudHMubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKVxuXHRcdHJldHVybiAoZmFsc2UpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tcG9uZW50cy5sZW5ndGg7ICsraSkge1xuXHRcdGlmICh0aGlzLmNvbXBvbmVudHNbaV0ub2lkICE9PSBvdGhlci5jb21wb25lbnRzW2ldLm9pZClcblx0XHRcdHJldHVybiAoZmFsc2UpO1xuXHRcdGlmICghZ2xvYk1hdGNoKHRoaXMuY29tcG9uZW50c1tpXS52YWx1ZSxcblx0XHQgICAgb3RoZXIuY29tcG9uZW50c1tpXS52YWx1ZSkpIHtcblx0XHRcdHJldHVybiAoZmFsc2UpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gKHRydWUpO1xufTtcblxuSWRlbnRpdHkuZm9ySG9zdCA9IGZ1bmN0aW9uIChob3N0bmFtZSkge1xuXHRhc3NlcnQuc3RyaW5nKGhvc3RuYW1lLCAnaG9zdG5hbWUnKTtcblx0cmV0dXJuIChuZXcgSWRlbnRpdHkoe1xuXHRcdHR5cGU6ICdob3N0Jyxcblx0XHRob3N0bmFtZTogaG9zdG5hbWUsXG5cdFx0Y29tcG9uZW50czogWyB7IG5hbWU6ICdjbicsIHZhbHVlOiBob3N0bmFtZSB9IF1cblx0fSkpO1xufTtcblxuSWRlbnRpdHkuZm9yVXNlciA9IGZ1bmN0aW9uICh1aWQpIHtcblx0YXNzZXJ0LnN0cmluZyh1aWQsICd1aWQnKTtcblx0cmV0dXJuIChuZXcgSWRlbnRpdHkoe1xuXHRcdHR5cGU6ICd1c2VyJyxcblx0XHR1aWQ6IHVpZCxcblx0XHRjb21wb25lbnRzOiBbIHsgbmFtZTogJ3VpZCcsIHZhbHVlOiB1aWQgfSBdXG5cdH0pKTtcbn07XG5cbklkZW50aXR5LmZvckVtYWlsID0gZnVuY3Rpb24gKGVtYWlsKSB7XG5cdGFzc2VydC5zdHJpbmcoZW1haWwsICdlbWFpbCcpO1xuXHRyZXR1cm4gKG5ldyBJZGVudGl0eSh7XG5cdFx0dHlwZTogJ2VtYWlsJyxcblx0XHRlbWFpbDogZW1haWwsXG5cdFx0Y29tcG9uZW50czogWyB7IG5hbWU6ICdtYWlsJywgdmFsdWU6IGVtYWlsIH0gXVxuXHR9KSk7XG59O1xuXG5JZGVudGl0eS5wYXJzZUROID0gZnVuY3Rpb24gKGRuKSB7XG5cdGFzc2VydC5zdHJpbmcoZG4sICdkbicpO1xuXHR2YXIgcGFydHMgPSBbJyddO1xuXHR2YXIgaWR4ID0gMDtcblx0dmFyIHJlbSA9IGRuO1xuXHR3aGlsZSAocmVtLmxlbmd0aCA+IDApIHtcblx0XHR2YXIgbTtcblx0XHQvKkpTU1RZTEVEKi9cblx0XHRpZiAoKG0gPSAvXiwvLmV4ZWMocmVtKSkgIT09IG51bGwpIHtcblx0XHRcdHBhcnRzWysraWR4XSA9ICcnO1xuXHRcdFx0cmVtID0gcmVtLnNsaWNlKG1bMF0ubGVuZ3RoKTtcblx0XHQvKkpTU1RZTEVEKi9cblx0XHR9IGVsc2UgaWYgKChtID0gL15cXFxcLC8uZXhlYyhyZW0pKSAhPT0gbnVsbCkge1xuXHRcdFx0cGFydHNbaWR4XSArPSAnLCc7XG5cdFx0XHRyZW0gPSByZW0uc2xpY2UobVswXS5sZW5ndGgpO1xuXHRcdC8qSlNTVFlMRUQqL1xuXHRcdH0gZWxzZSBpZiAoKG0gPSAvXlxcXFwuLy5leGVjKHJlbSkpICE9PSBudWxsKSB7XG5cdFx0XHRwYXJ0c1tpZHhdICs9IG1bMF07XG5cdFx0XHRyZW0gPSByZW0uc2xpY2UobVswXS5sZW5ndGgpO1xuXHRcdC8qSlNTVFlMRUQqL1xuXHRcdH0gZWxzZSBpZiAoKG0gPSAvXlteXFxcXCxdKy8uZXhlYyhyZW0pKSAhPT0gbnVsbCkge1xuXHRcdFx0cGFydHNbaWR4XSArPSBtWzBdO1xuXHRcdFx0cmVtID0gcmVtLnNsaWNlKG1bMF0ubGVuZ3RoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIEROJykpO1xuXHRcdH1cblx0fVxuXHR2YXIgY21wcyA9IHBhcnRzLm1hcChmdW5jdGlvbiAoYykge1xuXHRcdGMgPSBjLnRyaW0oKTtcblx0XHR2YXIgZXFQb3MgPSBjLmluZGV4T2YoJz0nKTtcblx0XHR3aGlsZSAoZXFQb3MgPiAwICYmIGMuY2hhckF0KGVxUG9zIC0gMSkgPT09ICdcXFxcJylcblx0XHRcdGVxUG9zID0gYy5pbmRleE9mKCc9JywgZXFQb3MgKyAxKTtcblx0XHRpZiAoZXFQb3MgPT09IC0xKSB7XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgRE4nKSk7XG5cdFx0fVxuXHRcdC8qSlNTVFlMRUQqL1xuXHRcdHZhciBuYW1lID0gYy5zbGljZSgwLCBlcVBvcykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXFxcPS9nLCAnPScpO1xuXHRcdHZhciB2YWx1ZSA9IGMuc2xpY2UoZXFQb3MgKyAxKTtcblx0XHRyZXR1cm4gKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xuXHR9KTtcblx0cmV0dXJuIChuZXcgSWRlbnRpdHkoeyBjb21wb25lbnRzOiBjbXBzIH0pKTtcbn07XG5cbklkZW50aXR5LmZyb21BcnJheSA9IGZ1bmN0aW9uIChjb21wb25lbnRzKSB7XG5cdGFzc2VydC5hcnJheU9mT2JqZWN0KGNvbXBvbmVudHMsICdjb21wb25lbnRzJyk7XG5cdGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY21wKSB7XG5cdFx0YXNzZXJ0Lm9iamVjdChjbXAsICdjb21wb25lbnQnKTtcblx0XHRhc3NlcnQuc3RyaW5nKGNtcC5uYW1lLCAnY29tcG9uZW50Lm5hbWUnKTtcblx0XHRpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjbXAudmFsdWUpICYmXG5cdFx0ICAgICEodHlwZW9mIChjbXAudmFsdWUpID09PSAnc3RyaW5nJykpIHtcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ0ludmFsaWQgY29tcG9uZW50IHZhbHVlJykpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiAobmV3IElkZW50aXR5KHsgY29tcG9uZW50czogY29tcG9uZW50cyB9KSk7XG59O1xuXG5JZGVudGl0eS5wYXJzZUFzbjEgPSBmdW5jdGlvbiAoZGVyLCB0b3ApIHtcblx0dmFyIGNvbXBvbmVudHMgPSBbXTtcblx0ZGVyLnJlYWRTZXF1ZW5jZSh0b3ApO1xuXHR2YXIgZW5kID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cdHdoaWxlIChkZXIub2Zmc2V0IDwgZW5kKSB7XG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5Db25zdHJ1Y3RvciB8IGFzbjEuQmVyLlNldCk7XG5cdFx0dmFyIGFmdGVyID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRcdHZhciBvaWQgPSBkZXIucmVhZE9JRCgpO1xuXHRcdHZhciB0eXBlID0gZGVyLnBlZWsoKTtcblx0XHR2YXIgdmFsdWU7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0Y2FzZSBhc24xLkJlci5QcmludGFibGVTdHJpbmc6XG5cdFx0Y2FzZSBhc24xLkJlci5JQTVTdHJpbmc6XG5cdFx0Y2FzZSBhc24xLkJlci5PY3RldFN0cmluZzpcblx0XHRjYXNlIGFzbjEuQmVyLlQ2MVN0cmluZzpcblx0XHRcdHZhbHVlID0gZGVyLnJlYWRTdHJpbmcodHlwZSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFzbjEuQmVyLlV0ZjhTdHJpbmc6XG5cdFx0XHR2YWx1ZSA9IGRlci5yZWFkU3RyaW5nKHR5cGUsIHRydWUpO1xuXHRcdFx0dmFsdWUgPSB2YWx1ZS50b1N0cmluZygndXRmOCcpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhc24xLkJlci5DaGFyYWN0ZXJTdHJpbmc6XG5cdFx0Y2FzZSBhc24xLkJlci5CTVBTdHJpbmc6XG5cdFx0XHR2YWx1ZSA9IGRlci5yZWFkU3RyaW5nKHR5cGUsIHRydWUpO1xuXHRcdFx0dmFsdWUgPSB2YWx1ZS50b1N0cmluZygndXRmMTZsZScpO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ1Vua25vd24gYXNuMSB0eXBlICcgKyB0eXBlKSk7XG5cdFx0fVxuXHRcdGNvbXBvbmVudHMucHVzaCh7IG9pZDogb2lkLCBhc24xdHlwZTogdHlwZSwgdmFsdWU6IHZhbHVlIH0pO1xuXHRcdGRlci5fb2Zmc2V0ID0gYWZ0ZXI7XG5cdH1cblx0ZGVyLl9vZmZzZXQgPSBlbmQ7XG5cdHJldHVybiAobmV3IElkZW50aXR5KHtcblx0XHRjb21wb25lbnRzOiBjb21wb25lbnRzXG5cdH0pKTtcbn07XG5cbklkZW50aXR5LmlzSWRlbnRpdHkgPSBmdW5jdGlvbiAob2JqLCB2ZXIpIHtcblx0cmV0dXJuICh1dGlscy5pc0NvbXBhdGlibGUob2JqLCBJZGVudGl0eSwgdmVyKSk7XG59O1xuXG4vKlxuICogQVBJIHZlcnNpb25zIGZvciBJZGVudGl0eTpcbiAqIFsxLDBdIC0tIGluaXRpYWwgdmVyXG4gKi9cbklkZW50aXR5LnByb3RvdHlwZS5fc3NocGtBcGlWZXJzaW9uID0gWzEsIDBdO1xuXG5JZGVudGl0eS5fb2xkVmVyc2lvbkRldGVjdCA9IGZ1bmN0aW9uIChvYmopIHtcblx0cmV0dXJuIChbMSwgMF0pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/identity.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/identity.js":
/*!********************************************!*\
  !*** ./node_modules/sshpk/lib/identity.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2017 Joyent, Inc.\n\nmodule.exports = Identity;\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar algs = __webpack_require__(/*! ./algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar Fingerprint = __webpack_require__(/*! ./fingerprint */ \"(rsc)/./node_modules/sshpk/lib/fingerprint.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"(rsc)/./node_modules/sshpk/lib/signature.js\");\nvar errs = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/sshpk/lib/errors.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(rsc)/./node_modules/asn1/lib/index.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\n\n/*JSSTYLED*/\nvar DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\\-]{0,62})(?:\\.([*]|[a-z0-9][a-z0-9\\-]{0,62}))*$/i;\n\nvar oids = {};\noids.cn = '2.5.4.3';\noids.o = '2.5.4.10';\noids.ou = '2.5.4.11';\noids.l = '2.5.4.7';\noids.s = '2.5.4.8';\noids.c = '2.5.4.6';\noids.sn = '2.5.4.4';\noids.postalCode = '2.5.4.17';\noids.serialNumber = '2.5.4.5';\noids.street = '2.5.4.9';\noids.x500UniqueIdentifier = '2.5.4.45';\noids.role = '2.5.4.72';\noids.telephoneNumber = '2.5.4.20';\noids.description = '2.5.4.13';\noids.dc = '0.9.2342.19200300.100.1.25';\noids.uid = '0.9.2342.19200300.100.1.1';\noids.mail = '0.9.2342.19200300.100.1.3';\noids.title = '2.5.4.12';\noids.gn = '2.5.4.42';\noids.initials = '2.5.4.43';\noids.pseudonym = '2.5.4.65';\noids.emailAddress = '1.2.840.113549.1.9.1';\n\nvar unoids = {};\nObject.keys(oids).forEach(function (k) {\n\tunoids[oids[k]] = k;\n});\n\nfunction Identity(opts) {\n\tvar self = this;\n\tassert.object(opts, 'options');\n\tassert.arrayOfObject(opts.components, 'options.components');\n\tthis.components = opts.components;\n\tthis.componentLookup = {};\n\tthis.components.forEach(function (c) {\n\t\tif (c.name && !c.oid)\n\t\t\tc.oid = oids[c.name];\n\t\tif (c.oid && !c.name)\n\t\t\tc.name = unoids[c.oid];\n\t\tif (self.componentLookup[c.name] === undefined)\n\t\t\tself.componentLookup[c.name] = [];\n\t\tself.componentLookup[c.name].push(c);\n\t});\n\tif (this.componentLookup.cn && this.componentLookup.cn.length > 0) {\n\t\tthis.cn = this.componentLookup.cn[0].value;\n\t}\n\tassert.optionalString(opts.type, 'options.type');\n\tif (opts.type === undefined) {\n\t\tif (this.components.length === 1 &&\n\t\t    this.componentLookup.cn &&\n\t\t    this.componentLookup.cn.length === 1 &&\n\t\t    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {\n\t\t\tthis.type = 'host';\n\t\t\tthis.hostname = this.componentLookup.cn[0].value;\n\n\t\t} else if (this.componentLookup.dc &&\n\t\t    this.components.length === this.componentLookup.dc.length) {\n\t\t\tthis.type = 'host';\n\t\t\tthis.hostname = this.componentLookup.dc.map(\n\t\t\t    function (c) {\n\t\t\t\treturn (c.value);\n\t\t\t}).join('.');\n\n\t\t} else if (this.componentLookup.uid &&\n\t\t    this.components.length ===\n\t\t    this.componentLookup.uid.length) {\n\t\t\tthis.type = 'user';\n\t\t\tthis.uid = this.componentLookup.uid[0].value;\n\n\t\t} else if (this.componentLookup.cn &&\n\t\t    this.componentLookup.cn.length === 1 &&\n\t\t    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {\n\t\t\tthis.type = 'host';\n\t\t\tthis.hostname = this.componentLookup.cn[0].value;\n\n\t\t} else if (this.componentLookup.uid &&\n\t\t    this.componentLookup.uid.length === 1) {\n\t\t\tthis.type = 'user';\n\t\t\tthis.uid = this.componentLookup.uid[0].value;\n\n\t\t} else if (this.componentLookup.mail &&\n\t\t    this.componentLookup.mail.length === 1) {\n\t\t\tthis.type = 'email';\n\t\t\tthis.email = this.componentLookup.mail[0].value;\n\n\t\t} else if (this.componentLookup.cn &&\n\t\t    this.componentLookup.cn.length === 1) {\n\t\t\tthis.type = 'user';\n\t\t\tthis.uid = this.componentLookup.cn[0].value;\n\n\t\t} else {\n\t\t\tthis.type = 'unknown';\n\t\t}\n\t} else {\n\t\tthis.type = opts.type;\n\t\tif (this.type === 'host')\n\t\t\tthis.hostname = opts.hostname;\n\t\telse if (this.type === 'user')\n\t\t\tthis.uid = opts.uid;\n\t\telse if (this.type === 'email')\n\t\t\tthis.email = opts.email;\n\t\telse\n\t\t\tthrow (new Error('Unknown type ' + this.type));\n\t}\n}\n\nIdentity.prototype.toString = function () {\n\treturn (this.components.map(function (c) {\n\t\tvar n = c.name.toUpperCase();\n\t\t/*JSSTYLED*/\n\t\tn = n.replace(/=/g, '\\\\=');\n\t\tvar v = c.value;\n\t\t/*JSSTYLED*/\n\t\tv = v.replace(/,/g, '\\\\,');\n\t\treturn (n + '=' + v);\n\t}).join(', '));\n};\n\nIdentity.prototype.get = function (name, asArray) {\n\tassert.string(name, 'name');\n\tvar arr = this.componentLookup[name];\n\tif (arr === undefined || arr.length === 0)\n\t\treturn (undefined);\n\tif (!asArray && arr.length > 1)\n\t\tthrow (new Error('Multiple values for attribute ' + name));\n\tif (!asArray)\n\t\treturn (arr[0].value);\n\treturn (arr.map(function (c) {\n\t\treturn (c.value);\n\t}));\n};\n\nIdentity.prototype.toArray = function (idx) {\n\treturn (this.components.map(function (c) {\n\t\treturn ({\n\t\t\tname: c.name,\n\t\t\tvalue: c.value\n\t\t});\n\t}));\n};\n\n/*\n * These are from X.680 -- PrintableString allowed chars are in section 37.4\n * table 8. Spec for IA5Strings is \"1,6 + SPACE + DEL\" where 1 refers to\n * ISO IR #001 (standard ASCII control characters) and 6 refers to ISO IR #006\n * (the basic ASCII character set).\n */\n/* JSSTYLED */\nvar NOT_PRINTABLE = /[^a-zA-Z0-9 '(),+.\\/:=?-]/;\n/* JSSTYLED */\nvar NOT_IA5 = /[^\\x00-\\x7f]/;\n\nIdentity.prototype.toAsn1 = function (der, tag) {\n\tder.startSequence(tag);\n\tthis.components.forEach(function (c) {\n\t\tder.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);\n\t\tder.startSequence();\n\t\tder.writeOID(c.oid);\n\t\t/*\n\t\t * If we fit in a PrintableString, use that. Otherwise use an\n\t\t * IA5String or UTF8String.\n\t\t *\n\t\t * If this identity was parsed from a DN, use the ASN.1 types\n\t\t * from the original representation (otherwise this might not\n\t\t * be a full match for the original in some validators).\n\t\t */\n\t\tif (c.asn1type === asn1.Ber.Utf8String ||\n\t\t    c.value.match(NOT_IA5)) {\n\t\t\tvar v = Buffer.from(c.value, 'utf8');\n\t\t\tder.writeBuffer(v, asn1.Ber.Utf8String);\n\n\t\t} else if (c.asn1type === asn1.Ber.IA5String ||\n\t\t    c.value.match(NOT_PRINTABLE)) {\n\t\t\tder.writeString(c.value, asn1.Ber.IA5String);\n\n\t\t} else {\n\t\t\tvar type = asn1.Ber.PrintableString;\n\t\t\tif (c.asn1type !== undefined)\n\t\t\t\ttype = c.asn1type;\n\t\t\tder.writeString(c.value, type);\n\t\t}\n\t\tder.endSequence();\n\t\tder.endSequence();\n\t});\n\tder.endSequence();\n};\n\nfunction globMatch(a, b) {\n\tif (a === '**' || b === '**')\n\t\treturn (true);\n\tvar aParts = a.split('.');\n\tvar bParts = b.split('.');\n\tif (aParts.length !== bParts.length)\n\t\treturn (false);\n\tfor (var i = 0; i < aParts.length; ++i) {\n\t\tif (aParts[i] === '*' || bParts[i] === '*')\n\t\t\tcontinue;\n\t\tif (aParts[i] !== bParts[i])\n\t\t\treturn (false);\n\t}\n\treturn (true);\n}\n\nIdentity.prototype.equals = function (other) {\n\tif (!Identity.isIdentity(other, [1, 0]))\n\t\treturn (false);\n\tif (other.components.length !== this.components.length)\n\t\treturn (false);\n\tfor (var i = 0; i < this.components.length; ++i) {\n\t\tif (this.components[i].oid !== other.components[i].oid)\n\t\t\treturn (false);\n\t\tif (!globMatch(this.components[i].value,\n\t\t    other.components[i].value)) {\n\t\t\treturn (false);\n\t\t}\n\t}\n\treturn (true);\n};\n\nIdentity.forHost = function (hostname) {\n\tassert.string(hostname, 'hostname');\n\treturn (new Identity({\n\t\ttype: 'host',\n\t\thostname: hostname,\n\t\tcomponents: [ { name: 'cn', value: hostname } ]\n\t}));\n};\n\nIdentity.forUser = function (uid) {\n\tassert.string(uid, 'uid');\n\treturn (new Identity({\n\t\ttype: 'user',\n\t\tuid: uid,\n\t\tcomponents: [ { name: 'uid', value: uid } ]\n\t}));\n};\n\nIdentity.forEmail = function (email) {\n\tassert.string(email, 'email');\n\treturn (new Identity({\n\t\ttype: 'email',\n\t\temail: email,\n\t\tcomponents: [ { name: 'mail', value: email } ]\n\t}));\n};\n\nIdentity.parseDN = function (dn) {\n\tassert.string(dn, 'dn');\n\tvar parts = [''];\n\tvar idx = 0;\n\tvar rem = dn;\n\twhile (rem.length > 0) {\n\t\tvar m;\n\t\t/*JSSTYLED*/\n\t\tif ((m = /^,/.exec(rem)) !== null) {\n\t\t\tparts[++idx] = '';\n\t\t\trem = rem.slice(m[0].length);\n\t\t/*JSSTYLED*/\n\t\t} else if ((m = /^\\\\,/.exec(rem)) !== null) {\n\t\t\tparts[idx] += ',';\n\t\t\trem = rem.slice(m[0].length);\n\t\t/*JSSTYLED*/\n\t\t} else if ((m = /^\\\\./.exec(rem)) !== null) {\n\t\t\tparts[idx] += m[0];\n\t\t\trem = rem.slice(m[0].length);\n\t\t/*JSSTYLED*/\n\t\t} else if ((m = /^[^\\\\,]+/.exec(rem)) !== null) {\n\t\t\tparts[idx] += m[0];\n\t\t\trem = rem.slice(m[0].length);\n\t\t} else {\n\t\t\tthrow (new Error('Failed to parse DN'));\n\t\t}\n\t}\n\tvar cmps = parts.map(function (c) {\n\t\tc = c.trim();\n\t\tvar eqPos = c.indexOf('=');\n\t\twhile (eqPos > 0 && c.charAt(eqPos - 1) === '\\\\')\n\t\t\teqPos = c.indexOf('=', eqPos + 1);\n\t\tif (eqPos === -1) {\n\t\t\tthrow (new Error('Failed to parse DN'));\n\t\t}\n\t\t/*JSSTYLED*/\n\t\tvar name = c.slice(0, eqPos).toLowerCase().replace(/\\\\=/g, '=');\n\t\tvar value = c.slice(eqPos + 1);\n\t\treturn ({ name: name, value: value });\n\t});\n\treturn (new Identity({ components: cmps }));\n};\n\nIdentity.fromArray = function (components) {\n\tassert.arrayOfObject(components, 'components');\n\tcomponents.forEach(function (cmp) {\n\t\tassert.object(cmp, 'component');\n\t\tassert.string(cmp.name, 'component.name');\n\t\tif (!Buffer.isBuffer(cmp.value) &&\n\t\t    !(typeof (cmp.value) === 'string')) {\n\t\t\tthrow (new Error('Invalid component value'));\n\t\t}\n\t});\n\treturn (new Identity({ components: components }));\n};\n\nIdentity.parseAsn1 = function (der, top) {\n\tvar components = [];\n\tder.readSequence(top);\n\tvar end = der.offset + der.length;\n\twhile (der.offset < end) {\n\t\tder.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);\n\t\tvar after = der.offset + der.length;\n\t\tder.readSequence();\n\t\tvar oid = der.readOID();\n\t\tvar type = der.peek();\n\t\tvar value;\n\t\tswitch (type) {\n\t\tcase asn1.Ber.PrintableString:\n\t\tcase asn1.Ber.IA5String:\n\t\tcase asn1.Ber.OctetString:\n\t\tcase asn1.Ber.T61String:\n\t\t\tvalue = der.readString(type);\n\t\t\tbreak;\n\t\tcase asn1.Ber.Utf8String:\n\t\t\tvalue = der.readString(type, true);\n\t\t\tvalue = value.toString('utf8');\n\t\t\tbreak;\n\t\tcase asn1.Ber.CharacterString:\n\t\tcase asn1.Ber.BMPString:\n\t\t\tvalue = der.readString(type, true);\n\t\t\tvalue = value.toString('utf16le');\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new Error('Unknown asn1 type ' + type));\n\t\t}\n\t\tcomponents.push({ oid: oid, asn1type: type, value: value });\n\t\tder._offset = after;\n\t}\n\tder._offset = end;\n\treturn (new Identity({\n\t\tcomponents: components\n\t}));\n};\n\nIdentity.isIdentity = function (obj, ver) {\n\treturn (utils.isCompatible(obj, Identity, ver));\n};\n\n/*\n * API versions for Identity:\n * [1,0] -- initial ver\n */\nIdentity.prototype._sshpkApiVersion = [1, 0];\n\nIdentity._oldVersionDetect = function (obj) {\n\treturn ([1, 0]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2lkZW50aXR5LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrREFBYTtBQUNsQyxXQUFXLG1CQUFPLENBQUMsc0RBQVE7QUFDM0IsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGtCQUFrQixtQkFBTyxDQUFDLG9FQUFlO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFhO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQywwREFBVTtBQUM3QixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLHdEQUFTO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxvREFBTTtBQUN6QixhQUFhLDhGQUE4Qjs7QUFFM0M7QUFDQSw0Q0FBNEMsS0FBSyw4QkFBOEIsS0FBSzs7QUFFcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCO0FBQ2hELEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QyxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0MsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDLEVBQUU7QUFDRix3QkFBd0Isa0JBQWtCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRix3QkFBd0Isd0JBQXdCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3Q0FBd0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9pZGVudGl0eS5qcz8xNjE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE3IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IElkZW50aXR5O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBhbGdzID0gcmVxdWlyZSgnLi9hbGdzJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgRmluZ2VycHJpbnQgPSByZXF1aXJlKCcuL2ZpbmdlcnByaW50Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcbnZhciBlcnJzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGFzbjEgPSByZXF1aXJlKCdhc24xJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xuXG4vKkpTU1RZTEVEKi9cbnZhciBETlNfTkFNRV9SRSA9IC9eKFsqXXxbYS16MC05XVthLXowLTlcXC1dezAsNjJ9KSg/OlxcLihbKl18W2EtejAtOV1bYS16MC05XFwtXXswLDYyfSkpKiQvaTtcblxudmFyIG9pZHMgPSB7fTtcbm9pZHMuY24gPSAnMi41LjQuMyc7XG5vaWRzLm8gPSAnMi41LjQuMTAnO1xub2lkcy5vdSA9ICcyLjUuNC4xMSc7XG5vaWRzLmwgPSAnMi41LjQuNyc7XG5vaWRzLnMgPSAnMi41LjQuOCc7XG5vaWRzLmMgPSAnMi41LjQuNic7XG5vaWRzLnNuID0gJzIuNS40LjQnO1xub2lkcy5wb3N0YWxDb2RlID0gJzIuNS40LjE3Jztcbm9pZHMuc2VyaWFsTnVtYmVyID0gJzIuNS40LjUnO1xub2lkcy5zdHJlZXQgPSAnMi41LjQuOSc7XG5vaWRzLng1MDBVbmlxdWVJZGVudGlmaWVyID0gJzIuNS40LjQ1Jztcbm9pZHMucm9sZSA9ICcyLjUuNC43Mic7XG5vaWRzLnRlbGVwaG9uZU51bWJlciA9ICcyLjUuNC4yMCc7XG5vaWRzLmRlc2NyaXB0aW9uID0gJzIuNS40LjEzJztcbm9pZHMuZGMgPSAnMC45LjIzNDIuMTkyMDAzMDAuMTAwLjEuMjUnO1xub2lkcy51aWQgPSAnMC45LjIzNDIuMTkyMDAzMDAuMTAwLjEuMSc7XG5vaWRzLm1haWwgPSAnMC45LjIzNDIuMTkyMDAzMDAuMTAwLjEuMyc7XG5vaWRzLnRpdGxlID0gJzIuNS40LjEyJztcbm9pZHMuZ24gPSAnMi41LjQuNDInO1xub2lkcy5pbml0aWFscyA9ICcyLjUuNC40Myc7XG5vaWRzLnBzZXVkb255bSA9ICcyLjUuNC42NSc7XG5vaWRzLmVtYWlsQWRkcmVzcyA9ICcxLjIuODQwLjExMzU0OS4xLjkuMSc7XG5cbnZhciB1bm9pZHMgPSB7fTtcbk9iamVjdC5rZXlzKG9pZHMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0dW5vaWRzW29pZHNba11dID0gaztcbn0pO1xuXG5mdW5jdGlvbiBJZGVudGl0eShvcHRzKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0YXNzZXJ0Lm9iamVjdChvcHRzLCAnb3B0aW9ucycpO1xuXHRhc3NlcnQuYXJyYXlPZk9iamVjdChvcHRzLmNvbXBvbmVudHMsICdvcHRpb25zLmNvbXBvbmVudHMnKTtcblx0dGhpcy5jb21wb25lbnRzID0gb3B0cy5jb21wb25lbnRzO1xuXHR0aGlzLmNvbXBvbmVudExvb2t1cCA9IHt9O1xuXHR0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuXHRcdGlmIChjLm5hbWUgJiYgIWMub2lkKVxuXHRcdFx0Yy5vaWQgPSBvaWRzW2MubmFtZV07XG5cdFx0aWYgKGMub2lkICYmICFjLm5hbWUpXG5cdFx0XHRjLm5hbWUgPSB1bm9pZHNbYy5vaWRdO1xuXHRcdGlmIChzZWxmLmNvbXBvbmVudExvb2t1cFtjLm5hbWVdID09PSB1bmRlZmluZWQpXG5cdFx0XHRzZWxmLmNvbXBvbmVudExvb2t1cFtjLm5hbWVdID0gW107XG5cdFx0c2VsZi5jb21wb25lbnRMb29rdXBbYy5uYW1lXS5wdXNoKGMpO1xuXHR9KTtcblx0aWYgKHRoaXMuY29tcG9uZW50TG9va3VwLmNuICYmIHRoaXMuY29tcG9uZW50TG9va3VwLmNuLmxlbmd0aCA+IDApIHtcblx0XHR0aGlzLmNuID0gdGhpcy5jb21wb25lbnRMb29rdXAuY25bMF0udmFsdWU7XG5cdH1cblx0YXNzZXJ0Lm9wdGlvbmFsU3RyaW5nKG9wdHMudHlwZSwgJ29wdGlvbnMudHlwZScpO1xuXHRpZiAob3B0cy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRpZiAodGhpcy5jb21wb25lbnRzLmxlbmd0aCA9PT0gMSAmJlxuXHRcdCAgICB0aGlzLmNvbXBvbmVudExvb2t1cC5jbiAmJlxuXHRcdCAgICB0aGlzLmNvbXBvbmVudExvb2t1cC5jbi5sZW5ndGggPT09IDEgJiZcblx0XHQgICAgdGhpcy5jb21wb25lbnRMb29rdXAuY25bMF0udmFsdWUubWF0Y2goRE5TX05BTUVfUkUpKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSAnaG9zdCc7XG5cdFx0XHR0aGlzLmhvc3RuYW1lID0gdGhpcy5jb21wb25lbnRMb29rdXAuY25bMF0udmFsdWU7XG5cblx0XHR9IGVsc2UgaWYgKHRoaXMuY29tcG9uZW50TG9va3VwLmRjICYmXG5cdFx0ICAgIHRoaXMuY29tcG9uZW50cy5sZW5ndGggPT09IHRoaXMuY29tcG9uZW50TG9va3VwLmRjLmxlbmd0aCkge1xuXHRcdFx0dGhpcy50eXBlID0gJ2hvc3QnO1xuXHRcdFx0dGhpcy5ob3N0bmFtZSA9IHRoaXMuY29tcG9uZW50TG9va3VwLmRjLm1hcChcblx0XHRcdCAgICBmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRyZXR1cm4gKGMudmFsdWUpO1xuXHRcdFx0fSkuam9pbignLicpO1xuXG5cdFx0fSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudExvb2t1cC51aWQgJiZcblx0XHQgICAgdGhpcy5jb21wb25lbnRzLmxlbmd0aCA9PT1cblx0XHQgICAgdGhpcy5jb21wb25lbnRMb29rdXAudWlkLmxlbmd0aCkge1xuXHRcdFx0dGhpcy50eXBlID0gJ3VzZXInO1xuXHRcdFx0dGhpcy51aWQgPSB0aGlzLmNvbXBvbmVudExvb2t1cC51aWRbMF0udmFsdWU7XG5cblx0XHR9IGVsc2UgaWYgKHRoaXMuY29tcG9uZW50TG9va3VwLmNuICYmXG5cdFx0ICAgIHRoaXMuY29tcG9uZW50TG9va3VwLmNuLmxlbmd0aCA9PT0gMSAmJlxuXHRcdCAgICB0aGlzLmNvbXBvbmVudExvb2t1cC5jblswXS52YWx1ZS5tYXRjaChETlNfTkFNRV9SRSkpIHtcblx0XHRcdHRoaXMudHlwZSA9ICdob3N0Jztcblx0XHRcdHRoaXMuaG9zdG5hbWUgPSB0aGlzLmNvbXBvbmVudExvb2t1cC5jblswXS52YWx1ZTtcblxuXHRcdH0gZWxzZSBpZiAodGhpcy5jb21wb25lbnRMb29rdXAudWlkICYmXG5cdFx0ICAgIHRoaXMuY29tcG9uZW50TG9va3VwLnVpZC5sZW5ndGggPT09IDEpIHtcblx0XHRcdHRoaXMudHlwZSA9ICd1c2VyJztcblx0XHRcdHRoaXMudWlkID0gdGhpcy5jb21wb25lbnRMb29rdXAudWlkWzBdLnZhbHVlO1xuXG5cdFx0fSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudExvb2t1cC5tYWlsICYmXG5cdFx0ICAgIHRoaXMuY29tcG9uZW50TG9va3VwLm1haWwubGVuZ3RoID09PSAxKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSAnZW1haWwnO1xuXHRcdFx0dGhpcy5lbWFpbCA9IHRoaXMuY29tcG9uZW50TG9va3VwLm1haWxbMF0udmFsdWU7XG5cblx0XHR9IGVsc2UgaWYgKHRoaXMuY29tcG9uZW50TG9va3VwLmNuICYmXG5cdFx0ICAgIHRoaXMuY29tcG9uZW50TG9va3VwLmNuLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dGhpcy50eXBlID0gJ3VzZXInO1xuXHRcdFx0dGhpcy51aWQgPSB0aGlzLmNvbXBvbmVudExvb2t1cC5jblswXS52YWx1ZTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnR5cGUgPSAndW5rbm93bic7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IG9wdHMudHlwZTtcblx0XHRpZiAodGhpcy50eXBlID09PSAnaG9zdCcpXG5cdFx0XHR0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZTtcblx0XHRlbHNlIGlmICh0aGlzLnR5cGUgPT09ICd1c2VyJylcblx0XHRcdHRoaXMudWlkID0gb3B0cy51aWQ7XG5cdFx0ZWxzZSBpZiAodGhpcy50eXBlID09PSAnZW1haWwnKVxuXHRcdFx0dGhpcy5lbWFpbCA9IG9wdHMuZW1haWw7XG5cdFx0ZWxzZVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biB0eXBlICcgKyB0aGlzLnR5cGUpKTtcblx0fVxufVxuXG5JZGVudGl0eS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAodGhpcy5jb21wb25lbnRzLm1hcChmdW5jdGlvbiAoYykge1xuXHRcdHZhciBuID0gYy5uYW1lLnRvVXBwZXJDYXNlKCk7XG5cdFx0LypKU1NUWUxFRCovXG5cdFx0biA9IG4ucmVwbGFjZSgvPS9nLCAnXFxcXD0nKTtcblx0XHR2YXIgdiA9IGMudmFsdWU7XG5cdFx0LypKU1NUWUxFRCovXG5cdFx0diA9IHYucmVwbGFjZSgvLC9nLCAnXFxcXCwnKTtcblx0XHRyZXR1cm4gKG4gKyAnPScgKyB2KTtcblx0fSkuam9pbignLCAnKSk7XG59O1xuXG5JZGVudGl0eS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUsIGFzQXJyYXkpIHtcblx0YXNzZXJ0LnN0cmluZyhuYW1lLCAnbmFtZScpO1xuXHR2YXIgYXJyID0gdGhpcy5jb21wb25lbnRMb29rdXBbbmFtZV07XG5cdGlmIChhcnIgPT09IHVuZGVmaW5lZCB8fCBhcnIubGVuZ3RoID09PSAwKVxuXHRcdHJldHVybiAodW5kZWZpbmVkKTtcblx0aWYgKCFhc0FycmF5ICYmIGFyci5sZW5ndGggPiAxKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ011bHRpcGxlIHZhbHVlcyBmb3IgYXR0cmlidXRlICcgKyBuYW1lKSk7XG5cdGlmICghYXNBcnJheSlcblx0XHRyZXR1cm4gKGFyclswXS52YWx1ZSk7XG5cdHJldHVybiAoYXJyLm1hcChmdW5jdGlvbiAoYykge1xuXHRcdHJldHVybiAoYy52YWx1ZSk7XG5cdH0pKTtcbn07XG5cbklkZW50aXR5LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKGlkeCkge1xuXHRyZXR1cm4gKHRoaXMuY29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGMpIHtcblx0XHRyZXR1cm4gKHtcblx0XHRcdG5hbWU6IGMubmFtZSxcblx0XHRcdHZhbHVlOiBjLnZhbHVlXG5cdFx0fSk7XG5cdH0pKTtcbn07XG5cbi8qXG4gKiBUaGVzZSBhcmUgZnJvbSBYLjY4MCAtLSBQcmludGFibGVTdHJpbmcgYWxsb3dlZCBjaGFycyBhcmUgaW4gc2VjdGlvbiAzNy40XG4gKiB0YWJsZSA4LiBTcGVjIGZvciBJQTVTdHJpbmdzIGlzIFwiMSw2ICsgU1BBQ0UgKyBERUxcIiB3aGVyZSAxIHJlZmVycyB0b1xuICogSVNPIElSICMwMDEgKHN0YW5kYXJkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycykgYW5kIDYgcmVmZXJzIHRvIElTTyBJUiAjMDA2XG4gKiAodGhlIGJhc2ljIEFTQ0lJIGNoYXJhY3RlciBzZXQpLlxuICovXG4vKiBKU1NUWUxFRCAqL1xudmFyIE5PVF9QUklOVEFCTEUgPSAvW15hLXpBLVowLTkgJygpLCsuXFwvOj0/LV0vO1xuLyogSlNTVFlMRUQgKi9cbnZhciBOT1RfSUE1ID0gL1teXFx4MDAtXFx4N2ZdLztcblxuSWRlbnRpdHkucHJvdG90eXBlLnRvQXNuMSA9IGZ1bmN0aW9uIChkZXIsIHRhZykge1xuXHRkZXIuc3RhcnRTZXF1ZW5jZSh0YWcpO1xuXHR0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuXHRcdGRlci5zdGFydFNlcXVlbmNlKGFzbjEuQmVyLkNvbnN0cnVjdG9yIHwgYXNuMS5CZXIuU2V0KTtcblx0XHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRcdGRlci53cml0ZU9JRChjLm9pZCk7XG5cdFx0Lypcblx0XHQgKiBJZiB3ZSBmaXQgaW4gYSBQcmludGFibGVTdHJpbmcsIHVzZSB0aGF0LiBPdGhlcndpc2UgdXNlIGFuXG5cdFx0ICogSUE1U3RyaW5nIG9yIFVURjhTdHJpbmcuXG5cdFx0ICpcblx0XHQgKiBJZiB0aGlzIGlkZW50aXR5IHdhcyBwYXJzZWQgZnJvbSBhIEROLCB1c2UgdGhlIEFTTi4xIHR5cGVzXG5cdFx0ICogZnJvbSB0aGUgb3JpZ2luYWwgcmVwcmVzZW50YXRpb24gKG90aGVyd2lzZSB0aGlzIG1pZ2h0IG5vdFxuXHRcdCAqIGJlIGEgZnVsbCBtYXRjaCBmb3IgdGhlIG9yaWdpbmFsIGluIHNvbWUgdmFsaWRhdG9ycykuXG5cdFx0ICovXG5cdFx0aWYgKGMuYXNuMXR5cGUgPT09IGFzbjEuQmVyLlV0ZjhTdHJpbmcgfHxcblx0XHQgICAgYy52YWx1ZS5tYXRjaChOT1RfSUE1KSkge1xuXHRcdFx0dmFyIHYgPSBCdWZmZXIuZnJvbShjLnZhbHVlLCAndXRmOCcpO1xuXHRcdFx0ZGVyLndyaXRlQnVmZmVyKHYsIGFzbjEuQmVyLlV0ZjhTdHJpbmcpO1xuXG5cdFx0fSBlbHNlIGlmIChjLmFzbjF0eXBlID09PSBhc24xLkJlci5JQTVTdHJpbmcgfHxcblx0XHQgICAgYy52YWx1ZS5tYXRjaChOT1RfUFJJTlRBQkxFKSkge1xuXHRcdFx0ZGVyLndyaXRlU3RyaW5nKGMudmFsdWUsIGFzbjEuQmVyLklBNVN0cmluZyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHR5cGUgPSBhc24xLkJlci5QcmludGFibGVTdHJpbmc7XG5cdFx0XHRpZiAoYy5hc24xdHlwZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHR0eXBlID0gYy5hc24xdHlwZTtcblx0XHRcdGRlci53cml0ZVN0cmluZyhjLnZhbHVlLCB0eXBlKTtcblx0XHR9XG5cdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdH0pO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcbn07XG5cbmZ1bmN0aW9uIGdsb2JNYXRjaChhLCBiKSB7XG5cdGlmIChhID09PSAnKionIHx8IGIgPT09ICcqKicpXG5cdFx0cmV0dXJuICh0cnVlKTtcblx0dmFyIGFQYXJ0cyA9IGEuc3BsaXQoJy4nKTtcblx0dmFyIGJQYXJ0cyA9IGIuc3BsaXQoJy4nKTtcblx0aWYgKGFQYXJ0cy5sZW5ndGggIT09IGJQYXJ0cy5sZW5ndGgpXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYVBhcnRzLmxlbmd0aDsgKytpKSB7XG5cdFx0aWYgKGFQYXJ0c1tpXSA9PT0gJyonIHx8IGJQYXJ0c1tpXSA9PT0gJyonKVxuXHRcdFx0Y29udGludWU7XG5cdFx0aWYgKGFQYXJ0c1tpXSAhPT0gYlBhcnRzW2ldKVxuXHRcdFx0cmV0dXJuIChmYWxzZSk7XG5cdH1cblx0cmV0dXJuICh0cnVlKTtcbn1cblxuSWRlbnRpdHkucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRpZiAoIUlkZW50aXR5LmlzSWRlbnRpdHkob3RoZXIsIFsxLCAwXSkpXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cdGlmIChvdGhlci5jb21wb25lbnRzLmxlbmd0aCAhPT0gdGhpcy5jb21wb25lbnRzLmxlbmd0aClcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcblx0XHRpZiAodGhpcy5jb21wb25lbnRzW2ldLm9pZCAhPT0gb3RoZXIuY29tcG9uZW50c1tpXS5vaWQpXG5cdFx0XHRyZXR1cm4gKGZhbHNlKTtcblx0XHRpZiAoIWdsb2JNYXRjaCh0aGlzLmNvbXBvbmVudHNbaV0udmFsdWUsXG5cdFx0ICAgIG90aGVyLmNvbXBvbmVudHNbaV0udmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gKGZhbHNlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuICh0cnVlKTtcbn07XG5cbklkZW50aXR5LmZvckhvc3QgPSBmdW5jdGlvbiAoaG9zdG5hbWUpIHtcblx0YXNzZXJ0LnN0cmluZyhob3N0bmFtZSwgJ2hvc3RuYW1lJyk7XG5cdHJldHVybiAobmV3IElkZW50aXR5KHtcblx0XHR0eXBlOiAnaG9zdCcsXG5cdFx0aG9zdG5hbWU6IGhvc3RuYW1lLFxuXHRcdGNvbXBvbmVudHM6IFsgeyBuYW1lOiAnY24nLCB2YWx1ZTogaG9zdG5hbWUgfSBdXG5cdH0pKTtcbn07XG5cbklkZW50aXR5LmZvclVzZXIgPSBmdW5jdGlvbiAodWlkKSB7XG5cdGFzc2VydC5zdHJpbmcodWlkLCAndWlkJyk7XG5cdHJldHVybiAobmV3IElkZW50aXR5KHtcblx0XHR0eXBlOiAndXNlcicsXG5cdFx0dWlkOiB1aWQsXG5cdFx0Y29tcG9uZW50czogWyB7IG5hbWU6ICd1aWQnLCB2YWx1ZTogdWlkIH0gXVxuXHR9KSk7XG59O1xuXG5JZGVudGl0eS5mb3JFbWFpbCA9IGZ1bmN0aW9uIChlbWFpbCkge1xuXHRhc3NlcnQuc3RyaW5nKGVtYWlsLCAnZW1haWwnKTtcblx0cmV0dXJuIChuZXcgSWRlbnRpdHkoe1xuXHRcdHR5cGU6ICdlbWFpbCcsXG5cdFx0ZW1haWw6IGVtYWlsLFxuXHRcdGNvbXBvbmVudHM6IFsgeyBuYW1lOiAnbWFpbCcsIHZhbHVlOiBlbWFpbCB9IF1cblx0fSkpO1xufTtcblxuSWRlbnRpdHkucGFyc2VETiA9IGZ1bmN0aW9uIChkbikge1xuXHRhc3NlcnQuc3RyaW5nKGRuLCAnZG4nKTtcblx0dmFyIHBhcnRzID0gWycnXTtcblx0dmFyIGlkeCA9IDA7XG5cdHZhciByZW0gPSBkbjtcblx0d2hpbGUgKHJlbS5sZW5ndGggPiAwKSB7XG5cdFx0dmFyIG07XG5cdFx0LypKU1NUWUxFRCovXG5cdFx0aWYgKChtID0gL14sLy5leGVjKHJlbSkpICE9PSBudWxsKSB7XG5cdFx0XHRwYXJ0c1srK2lkeF0gPSAnJztcblx0XHRcdHJlbSA9IHJlbS5zbGljZShtWzBdLmxlbmd0aCk7XG5cdFx0LypKU1NUWUxFRCovXG5cdFx0fSBlbHNlIGlmICgobSA9IC9eXFxcXCwvLmV4ZWMocmVtKSkgIT09IG51bGwpIHtcblx0XHRcdHBhcnRzW2lkeF0gKz0gJywnO1xuXHRcdFx0cmVtID0gcmVtLnNsaWNlKG1bMF0ubGVuZ3RoKTtcblx0XHQvKkpTU1RZTEVEKi9cblx0XHR9IGVsc2UgaWYgKChtID0gL15cXFxcLi8uZXhlYyhyZW0pKSAhPT0gbnVsbCkge1xuXHRcdFx0cGFydHNbaWR4XSArPSBtWzBdO1xuXHRcdFx0cmVtID0gcmVtLnNsaWNlKG1bMF0ubGVuZ3RoKTtcblx0XHQvKkpTU1RZTEVEKi9cblx0XHR9IGVsc2UgaWYgKChtID0gL15bXlxcXFwsXSsvLmV4ZWMocmVtKSkgIT09IG51bGwpIHtcblx0XHRcdHBhcnRzW2lkeF0gKz0gbVswXTtcblx0XHRcdHJlbSA9IHJlbS5zbGljZShtWzBdLmxlbmd0aCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBETicpKTtcblx0XHR9XG5cdH1cblx0dmFyIGNtcHMgPSBwYXJ0cy5tYXAoZnVuY3Rpb24gKGMpIHtcblx0XHRjID0gYy50cmltKCk7XG5cdFx0dmFyIGVxUG9zID0gYy5pbmRleE9mKCc9Jyk7XG5cdFx0d2hpbGUgKGVxUG9zID4gMCAmJiBjLmNoYXJBdChlcVBvcyAtIDEpID09PSAnXFxcXCcpXG5cdFx0XHRlcVBvcyA9IGMuaW5kZXhPZignPScsIGVxUG9zICsgMSk7XG5cdFx0aWYgKGVxUG9zID09PSAtMSkge1xuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIEROJykpO1xuXHRcdH1cblx0XHQvKkpTU1RZTEVEKi9cblx0XHR2YXIgbmFtZSA9IGMuc2xpY2UoMCwgZXFQb3MpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxcXD0vZywgJz0nKTtcblx0XHR2YXIgdmFsdWUgPSBjLnNsaWNlKGVxUG9zICsgMSk7XG5cdFx0cmV0dXJuICh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcblx0fSk7XG5cdHJldHVybiAobmV3IElkZW50aXR5KHsgY29tcG9uZW50czogY21wcyB9KSk7XG59O1xuXG5JZGVudGl0eS5mcm9tQXJyYXkgPSBmdW5jdGlvbiAoY29tcG9uZW50cykge1xuXHRhc3NlcnQuYXJyYXlPZk9iamVjdChjb21wb25lbnRzLCAnY29tcG9uZW50cycpO1xuXHRjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNtcCkge1xuXHRcdGFzc2VydC5vYmplY3QoY21wLCAnY29tcG9uZW50Jyk7XG5cdFx0YXNzZXJ0LnN0cmluZyhjbXAubmFtZSwgJ2NvbXBvbmVudC5uYW1lJyk7XG5cdFx0aWYgKCFCdWZmZXIuaXNCdWZmZXIoY21wLnZhbHVlKSAmJlxuXHRcdCAgICAhKHR5cGVvZiAoY21wLnZhbHVlKSA9PT0gJ3N0cmluZycpKSB7XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdJbnZhbGlkIGNvbXBvbmVudCB2YWx1ZScpKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gKG5ldyBJZGVudGl0eSh7IGNvbXBvbmVudHM6IGNvbXBvbmVudHMgfSkpO1xufTtcblxuSWRlbnRpdHkucGFyc2VBc24xID0gZnVuY3Rpb24gKGRlciwgdG9wKSB7XG5cdHZhciBjb21wb25lbnRzID0gW107XG5cdGRlci5yZWFkU2VxdWVuY2UodG9wKTtcblx0dmFyIGVuZCA9IGRlci5vZmZzZXQgKyBkZXIubGVuZ3RoO1xuXHR3aGlsZSAoZGVyLm9mZnNldCA8IGVuZCkge1xuXHRcdGRlci5yZWFkU2VxdWVuY2UoYXNuMS5CZXIuQ29uc3RydWN0b3IgfCBhc24xLkJlci5TZXQpO1xuXHRcdHZhciBhZnRlciA9IGRlci5vZmZzZXQgKyBkZXIubGVuZ3RoO1xuXHRcdGRlci5yZWFkU2VxdWVuY2UoKTtcblx0XHR2YXIgb2lkID0gZGVyLnJlYWRPSUQoKTtcblx0XHR2YXIgdHlwZSA9IGRlci5wZWVrKCk7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdGNhc2UgYXNuMS5CZXIuUHJpbnRhYmxlU3RyaW5nOlxuXHRcdGNhc2UgYXNuMS5CZXIuSUE1U3RyaW5nOlxuXHRcdGNhc2UgYXNuMS5CZXIuT2N0ZXRTdHJpbmc6XG5cdFx0Y2FzZSBhc24xLkJlci5UNjFTdHJpbmc6XG5cdFx0XHR2YWx1ZSA9IGRlci5yZWFkU3RyaW5nKHR5cGUpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhc24xLkJlci5VdGY4U3RyaW5nOlxuXHRcdFx0dmFsdWUgPSBkZXIucmVhZFN0cmluZyh0eXBlLCB0cnVlKTtcblx0XHRcdHZhbHVlID0gdmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgYXNuMS5CZXIuQ2hhcmFjdGVyU3RyaW5nOlxuXHRcdGNhc2UgYXNuMS5CZXIuQk1QU3RyaW5nOlxuXHRcdFx0dmFsdWUgPSBkZXIucmVhZFN0cmluZyh0eXBlLCB0cnVlKTtcblx0XHRcdHZhbHVlID0gdmFsdWUudG9TdHJpbmcoJ3V0ZjE2bGUnKTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdVbmtub3duIGFzbjEgdHlwZSAnICsgdHlwZSkpO1xuXHRcdH1cblx0XHRjb21wb25lbnRzLnB1c2goeyBvaWQ6IG9pZCwgYXNuMXR5cGU6IHR5cGUsIHZhbHVlOiB2YWx1ZSB9KTtcblx0XHRkZXIuX29mZnNldCA9IGFmdGVyO1xuXHR9XG5cdGRlci5fb2Zmc2V0ID0gZW5kO1xuXHRyZXR1cm4gKG5ldyBJZGVudGl0eSh7XG5cdFx0Y29tcG9uZW50czogY29tcG9uZW50c1xuXHR9KSk7XG59O1xuXG5JZGVudGl0eS5pc0lkZW50aXR5ID0gZnVuY3Rpb24gKG9iaiwgdmVyKSB7XG5cdHJldHVybiAodXRpbHMuaXNDb21wYXRpYmxlKG9iaiwgSWRlbnRpdHksIHZlcikpO1xufTtcblxuLypcbiAqIEFQSSB2ZXJzaW9ucyBmb3IgSWRlbnRpdHk6XG4gKiBbMSwwXSAtLSBpbml0aWFsIHZlclxuICovXG5JZGVudGl0eS5wcm90b3R5cGUuX3NzaHBrQXBpVmVyc2lvbiA9IFsxLCAwXTtcblxuSWRlbnRpdHkuX29sZFZlcnNpb25EZXRlY3QgPSBmdW5jdGlvbiAob2JqKSB7XG5cdHJldHVybiAoWzEsIDBdKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/identity.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/sshpk/lib/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nvar Key = __webpack_require__(/*! ./key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar Fingerprint = __webpack_require__(/*! ./fingerprint */ \"(action-browser)/./node_modules/sshpk/lib/fingerprint.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"(action-browser)/./node_modules/sshpk/lib/signature.js\");\nvar PrivateKey = __webpack_require__(/*! ./private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\nvar Certificate = __webpack_require__(/*! ./certificate */ \"(action-browser)/./node_modules/sshpk/lib/certificate.js\");\nvar Identity = __webpack_require__(/*! ./identity */ \"(action-browser)/./node_modules/sshpk/lib/identity.js\");\nvar errs = __webpack_require__(/*! ./errors */ \"(action-browser)/./node_modules/sshpk/lib/errors.js\");\n\nmodule.exports = {\n\t/* top-level classes */\n\tKey: Key,\n\tparseKey: Key.parse,\n\tFingerprint: Fingerprint,\n\tparseFingerprint: Fingerprint.parse,\n\tSignature: Signature,\n\tparseSignature: Signature.parse,\n\tPrivateKey: PrivateKey,\n\tparsePrivateKey: PrivateKey.parse,\n\tgeneratePrivateKey: PrivateKey.generate,\n\tCertificate: Certificate,\n\tparseCertificate: Certificate.parse,\n\tcreateSelfSignedCertificate: Certificate.createSelfSigned,\n\tcreateCertificate: Certificate.create,\n\tIdentity: Identity,\n\tidentityFromDN: Identity.parseDN,\n\tidentityForHost: Identity.forHost,\n\tidentityForUser: Identity.forUser,\n\tidentityForEmail: Identity.forEmail,\n\tidentityFromArray: Identity.fromArray,\n\n\t/* errors */\n\tFingerprintFormatError: errs.FingerprintFormatError,\n\tInvalidAlgorithmError: errs.InvalidAlgorithmError,\n\tKeyParseError: errs.KeyParseError,\n\tSignatureParseError: errs.SignatureParseError,\n\tKeyEncryptedError: errs.KeyEncryptedError,\n\tCertificateParseError: errs.CertificateParseError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLCtEQUFPO0FBQ3pCLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFlO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFhO0FBQ3JDLGlCQUFpQixtQkFBTyxDQUFDLCtFQUFlO0FBQ3hDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFlO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyx5RUFBWTtBQUNuQyxXQUFXLG1CQUFPLENBQUMscUVBQVU7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvaW5kZXguanM/YjMzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNSBKb3llbnQsIEluYy5cblxudmFyIEtleSA9IHJlcXVpcmUoJy4va2V5Jyk7XG52YXIgRmluZ2VycHJpbnQgPSByZXF1aXJlKCcuL2ZpbmdlcnByaW50Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi9wcml2YXRlLWtleScpO1xudmFyIENlcnRpZmljYXRlID0gcmVxdWlyZSgnLi9jZXJ0aWZpY2F0ZScpO1xudmFyIElkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xudmFyIGVycnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0LyogdG9wLWxldmVsIGNsYXNzZXMgKi9cblx0S2V5OiBLZXksXG5cdHBhcnNlS2V5OiBLZXkucGFyc2UsXG5cdEZpbmdlcnByaW50OiBGaW5nZXJwcmludCxcblx0cGFyc2VGaW5nZXJwcmludDogRmluZ2VycHJpbnQucGFyc2UsXG5cdFNpZ25hdHVyZTogU2lnbmF0dXJlLFxuXHRwYXJzZVNpZ25hdHVyZTogU2lnbmF0dXJlLnBhcnNlLFxuXHRQcml2YXRlS2V5OiBQcml2YXRlS2V5LFxuXHRwYXJzZVByaXZhdGVLZXk6IFByaXZhdGVLZXkucGFyc2UsXG5cdGdlbmVyYXRlUHJpdmF0ZUtleTogUHJpdmF0ZUtleS5nZW5lcmF0ZSxcblx0Q2VydGlmaWNhdGU6IENlcnRpZmljYXRlLFxuXHRwYXJzZUNlcnRpZmljYXRlOiBDZXJ0aWZpY2F0ZS5wYXJzZSxcblx0Y3JlYXRlU2VsZlNpZ25lZENlcnRpZmljYXRlOiBDZXJ0aWZpY2F0ZS5jcmVhdGVTZWxmU2lnbmVkLFxuXHRjcmVhdGVDZXJ0aWZpY2F0ZTogQ2VydGlmaWNhdGUuY3JlYXRlLFxuXHRJZGVudGl0eTogSWRlbnRpdHksXG5cdGlkZW50aXR5RnJvbUROOiBJZGVudGl0eS5wYXJzZUROLFxuXHRpZGVudGl0eUZvckhvc3Q6IElkZW50aXR5LmZvckhvc3QsXG5cdGlkZW50aXR5Rm9yVXNlcjogSWRlbnRpdHkuZm9yVXNlcixcblx0aWRlbnRpdHlGb3JFbWFpbDogSWRlbnRpdHkuZm9yRW1haWwsXG5cdGlkZW50aXR5RnJvbUFycmF5OiBJZGVudGl0eS5mcm9tQXJyYXksXG5cblx0LyogZXJyb3JzICovXG5cdEZpbmdlcnByaW50Rm9ybWF0RXJyb3I6IGVycnMuRmluZ2VycHJpbnRGb3JtYXRFcnJvcixcblx0SW52YWxpZEFsZ29yaXRobUVycm9yOiBlcnJzLkludmFsaWRBbGdvcml0aG1FcnJvcixcblx0S2V5UGFyc2VFcnJvcjogZXJycy5LZXlQYXJzZUVycm9yLFxuXHRTaWduYXR1cmVQYXJzZUVycm9yOiBlcnJzLlNpZ25hdHVyZVBhcnNlRXJyb3IsXG5cdEtleUVuY3J5cHRlZEVycm9yOiBlcnJzLktleUVuY3J5cHRlZEVycm9yLFxuXHRDZXJ0aWZpY2F0ZVBhcnNlRXJyb3I6IGVycnMuQ2VydGlmaWNhdGVQYXJzZUVycm9yXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/sshpk/lib/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nvar Key = __webpack_require__(/*! ./key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar Fingerprint = __webpack_require__(/*! ./fingerprint */ \"(rsc)/./node_modules/sshpk/lib/fingerprint.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"(rsc)/./node_modules/sshpk/lib/signature.js\");\nvar PrivateKey = __webpack_require__(/*! ./private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\nvar Certificate = __webpack_require__(/*! ./certificate */ \"(rsc)/./node_modules/sshpk/lib/certificate.js\");\nvar Identity = __webpack_require__(/*! ./identity */ \"(rsc)/./node_modules/sshpk/lib/identity.js\");\nvar errs = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/sshpk/lib/errors.js\");\n\nmodule.exports = {\n\t/* top-level classes */\n\tKey: Key,\n\tparseKey: Key.parse,\n\tFingerprint: Fingerprint,\n\tparseFingerprint: Fingerprint.parse,\n\tSignature: Signature,\n\tparseSignature: Signature.parse,\n\tPrivateKey: PrivateKey,\n\tparsePrivateKey: PrivateKey.parse,\n\tgeneratePrivateKey: PrivateKey.generate,\n\tCertificate: Certificate,\n\tparseCertificate: Certificate.parse,\n\tcreateSelfSignedCertificate: Certificate.createSelfSigned,\n\tcreateCertificate: Certificate.create,\n\tIdentity: Identity,\n\tidentityFromDN: Identity.parseDN,\n\tidentityForHost: Identity.forHost,\n\tidentityForUser: Identity.forUser,\n\tidentityForEmail: Identity.forEmail,\n\tidentityFromArray: Identity.fromArray,\n\n\t/* errors */\n\tFingerprintFormatError: errs.FingerprintFormatError,\n\tInvalidAlgorithmError: errs.InvalidAlgorithmError,\n\tKeyParseError: errs.KeyParseError,\n\tSignatureParseError: errs.SignatureParseError,\n\tKeyEncryptedError: errs.KeyEncryptedError,\n\tCertificateParseError: errs.CertificateParseError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBLFVBQVUsbUJBQU8sQ0FBQyxvREFBTztBQUN6QixrQkFBa0IsbUJBQU8sQ0FBQyxvRUFBZTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBYTtBQUNyQyxpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBZTtBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyxvRUFBZTtBQUN6QyxlQUFlLG1CQUFPLENBQUMsOERBQVk7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLDBEQUFVOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2luZGV4LmpzPzQzYTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbnZhciBLZXkgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIEZpbmdlcnByaW50ID0gcmVxdWlyZSgnLi9maW5nZXJwcmludCcpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vcHJpdmF0ZS1rZXknKTtcbnZhciBDZXJ0aWZpY2F0ZSA9IHJlcXVpcmUoJy4vY2VydGlmaWNhdGUnKTtcbnZhciBJZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcbnZhciBlcnJzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdC8qIHRvcC1sZXZlbCBjbGFzc2VzICovXG5cdEtleTogS2V5LFxuXHRwYXJzZUtleTogS2V5LnBhcnNlLFxuXHRGaW5nZXJwcmludDogRmluZ2VycHJpbnQsXG5cdHBhcnNlRmluZ2VycHJpbnQ6IEZpbmdlcnByaW50LnBhcnNlLFxuXHRTaWduYXR1cmU6IFNpZ25hdHVyZSxcblx0cGFyc2VTaWduYXR1cmU6IFNpZ25hdHVyZS5wYXJzZSxcblx0UHJpdmF0ZUtleTogUHJpdmF0ZUtleSxcblx0cGFyc2VQcml2YXRlS2V5OiBQcml2YXRlS2V5LnBhcnNlLFxuXHRnZW5lcmF0ZVByaXZhdGVLZXk6IFByaXZhdGVLZXkuZ2VuZXJhdGUsXG5cdENlcnRpZmljYXRlOiBDZXJ0aWZpY2F0ZSxcblx0cGFyc2VDZXJ0aWZpY2F0ZTogQ2VydGlmaWNhdGUucGFyc2UsXG5cdGNyZWF0ZVNlbGZTaWduZWRDZXJ0aWZpY2F0ZTogQ2VydGlmaWNhdGUuY3JlYXRlU2VsZlNpZ25lZCxcblx0Y3JlYXRlQ2VydGlmaWNhdGU6IENlcnRpZmljYXRlLmNyZWF0ZSxcblx0SWRlbnRpdHk6IElkZW50aXR5LFxuXHRpZGVudGl0eUZyb21ETjogSWRlbnRpdHkucGFyc2VETixcblx0aWRlbnRpdHlGb3JIb3N0OiBJZGVudGl0eS5mb3JIb3N0LFxuXHRpZGVudGl0eUZvclVzZXI6IElkZW50aXR5LmZvclVzZXIsXG5cdGlkZW50aXR5Rm9yRW1haWw6IElkZW50aXR5LmZvckVtYWlsLFxuXHRpZGVudGl0eUZyb21BcnJheTogSWRlbnRpdHkuZnJvbUFycmF5LFxuXG5cdC8qIGVycm9ycyAqL1xuXHRGaW5nZXJwcmludEZvcm1hdEVycm9yOiBlcnJzLkZpbmdlcnByaW50Rm9ybWF0RXJyb3IsXG5cdEludmFsaWRBbGdvcml0aG1FcnJvcjogZXJycy5JbnZhbGlkQWxnb3JpdGhtRXJyb3IsXG5cdEtleVBhcnNlRXJyb3I6IGVycnMuS2V5UGFyc2VFcnJvcixcblx0U2lnbmF0dXJlUGFyc2VFcnJvcjogZXJycy5TaWduYXR1cmVQYXJzZUVycm9yLFxuXHRLZXlFbmNyeXB0ZWRFcnJvcjogZXJycy5LZXlFbmNyeXB0ZWRFcnJvcixcblx0Q2VydGlmaWNhdGVQYXJzZUVycm9yOiBlcnJzLkNlcnRpZmljYXRlUGFyc2VFcnJvclxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/key.js":
/*!***************************************!*\
  !*** ./node_modules/sshpk/lib/key.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2018 Joyent, Inc.\n\nmodule.exports = Key;\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar algs = __webpack_require__(/*! ./algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar Fingerprint = __webpack_require__(/*! ./fingerprint */ \"(action-browser)/./node_modules/sshpk/lib/fingerprint.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"(action-browser)/./node_modules/sshpk/lib/signature.js\");\nvar DiffieHellman = (__webpack_require__(/*! ./dhe */ \"(action-browser)/./node_modules/sshpk/lib/dhe.js\").DiffieHellman);\nvar errs = __webpack_require__(/*! ./errors */ \"(action-browser)/./node_modules/sshpk/lib/errors.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar PrivateKey = __webpack_require__(/*! ./private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\nvar edCompat;\n\ntry {\n\tedCompat = __webpack_require__(/*! ./ed-compat */ \"(action-browser)/./node_modules/sshpk/lib/ed-compat.js\");\n} catch (e) {\n\t/* Just continue through, and bail out if we try to use it. */\n}\n\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\nvar KeyParseError = errs.KeyParseError;\n\nvar formats = {};\nformats['auto'] = __webpack_require__(/*! ./formats/auto */ \"(action-browser)/./node_modules/sshpk/lib/formats/auto.js\");\nformats['pem'] = __webpack_require__(/*! ./formats/pem */ \"(action-browser)/./node_modules/sshpk/lib/formats/pem.js\");\nformats['pkcs1'] = __webpack_require__(/*! ./formats/pkcs1 */ \"(action-browser)/./node_modules/sshpk/lib/formats/pkcs1.js\");\nformats['pkcs8'] = __webpack_require__(/*! ./formats/pkcs8 */ \"(action-browser)/./node_modules/sshpk/lib/formats/pkcs8.js\");\nformats['rfc4253'] = __webpack_require__(/*! ./formats/rfc4253 */ \"(action-browser)/./node_modules/sshpk/lib/formats/rfc4253.js\");\nformats['ssh'] = __webpack_require__(/*! ./formats/ssh */ \"(action-browser)/./node_modules/sshpk/lib/formats/ssh.js\");\nformats['ssh-private'] = __webpack_require__(/*! ./formats/ssh-private */ \"(action-browser)/./node_modules/sshpk/lib/formats/ssh-private.js\");\nformats['openssh'] = formats['ssh-private'];\nformats['dnssec'] = __webpack_require__(/*! ./formats/dnssec */ \"(action-browser)/./node_modules/sshpk/lib/formats/dnssec.js\");\nformats['putty'] = __webpack_require__(/*! ./formats/putty */ \"(action-browser)/./node_modules/sshpk/lib/formats/putty.js\");\nformats['ppk'] = formats['putty'];\n\nfunction Key(opts) {\n\tassert.object(opts, 'options');\n\tassert.arrayOfObject(opts.parts, 'options.parts');\n\tassert.string(opts.type, 'options.type');\n\tassert.optionalString(opts.comment, 'options.comment');\n\n\tvar algInfo = algs.info[opts.type];\n\tif (typeof (algInfo) !== 'object')\n\t\tthrow (new InvalidAlgorithmError(opts.type));\n\n\tvar partLookup = {};\n\tfor (var i = 0; i < opts.parts.length; ++i) {\n\t\tvar part = opts.parts[i];\n\t\tpartLookup[part.name] = part;\n\t}\n\n\tthis.type = opts.type;\n\tthis.parts = opts.parts;\n\tthis.part = partLookup;\n\tthis.comment = undefined;\n\tthis.source = opts.source;\n\n\t/* for speeding up hashing/fingerprint operations */\n\tthis._rfc4253Cache = opts._rfc4253Cache;\n\tthis._hashCache = {};\n\n\tvar sz;\n\tthis.curve = undefined;\n\tif (this.type === 'ecdsa') {\n\t\tvar curve = this.part.curve.data.toString();\n\t\tthis.curve = curve;\n\t\tsz = algs.curves[curve].size;\n\t} else if (this.type === 'ed25519' || this.type === 'curve25519') {\n\t\tsz = 256;\n\t\tthis.curve = 'curve25519';\n\t} else {\n\t\tvar szPart = this.part[algInfo.sizePart];\n\t\tsz = szPart.data.length;\n\t\tsz = sz * 8 - utils.countZeros(szPart.data);\n\t}\n\tthis.size = sz;\n}\n\nKey.formats = formats;\n\nKey.prototype.toBuffer = function (format, options) {\n\tif (format === undefined)\n\t\tformat = 'ssh';\n\tassert.string(format, 'format');\n\tassert.object(formats[format], 'formats[format]');\n\tassert.optionalObject(options, 'options');\n\n\tif (format === 'rfc4253') {\n\t\tif (this._rfc4253Cache === undefined)\n\t\t\tthis._rfc4253Cache = formats['rfc4253'].write(this);\n\t\treturn (this._rfc4253Cache);\n\t}\n\n\treturn (formats[format].write(this, options));\n};\n\nKey.prototype.toString = function (format, options) {\n\treturn (this.toBuffer(format, options).toString());\n};\n\nKey.prototype.hash = function (algo, type) {\n\tassert.string(algo, 'algorithm');\n\tassert.optionalString(type, 'type');\n\tif (type === undefined)\n\t\ttype = 'ssh';\n\talgo = algo.toLowerCase();\n\tif (algs.hashAlgs[algo] === undefined)\n\t\tthrow (new InvalidAlgorithmError(algo));\n\n\tvar cacheKey = algo + '||' + type;\n\tif (this._hashCache[cacheKey])\n\t\treturn (this._hashCache[cacheKey]);\n\n\tvar buf;\n\tif (type === 'ssh') {\n\t\tbuf = this.toBuffer('rfc4253');\n\t} else if (type === 'spki') {\n\t\tbuf = formats.pkcs8.pkcs8ToBuffer(this);\n\t} else {\n\t\tthrow (new Error('Hash type ' + type + ' not supported'));\n\t}\n\tvar hash = crypto.createHash(algo).update(buf).digest();\n\tthis._hashCache[cacheKey] = hash;\n\treturn (hash);\n};\n\nKey.prototype.fingerprint = function (algo, type) {\n\tif (algo === undefined)\n\t\talgo = 'sha256';\n\tif (type === undefined)\n\t\ttype = 'ssh';\n\tassert.string(algo, 'algorithm');\n\tassert.string(type, 'type');\n\tvar opts = {\n\t\ttype: 'key',\n\t\thash: this.hash(algo, type),\n\t\talgorithm: algo,\n\t\thashType: type\n\t};\n\treturn (new Fingerprint(opts));\n};\n\nKey.prototype.defaultHashAlgorithm = function () {\n\tvar hashAlgo = 'sha1';\n\tif (this.type === 'rsa')\n\t\thashAlgo = 'sha256';\n\tif (this.type === 'dsa' && this.size > 1024)\n\t\thashAlgo = 'sha256';\n\tif (this.type === 'ed25519')\n\t\thashAlgo = 'sha512';\n\tif (this.type === 'ecdsa') {\n\t\tif (this.size <= 256)\n\t\t\thashAlgo = 'sha256';\n\t\telse if (this.size <= 384)\n\t\t\thashAlgo = 'sha384';\n\t\telse\n\t\t\thashAlgo = 'sha512';\n\t}\n\treturn (hashAlgo);\n};\n\nKey.prototype.createVerify = function (hashAlgo) {\n\tif (hashAlgo === undefined)\n\t\thashAlgo = this.defaultHashAlgorithm();\n\tassert.string(hashAlgo, 'hash algorithm');\n\n\t/* ED25519 is not supported by OpenSSL, use a javascript impl. */\n\tif (this.type === 'ed25519' && edCompat !== undefined)\n\t\treturn (new edCompat.Verifier(this, hashAlgo));\n\tif (this.type === 'curve25519')\n\t\tthrow (new Error('Curve25519 keys are not suitable for ' +\n\t\t    'signing or verification'));\n\n\tvar v, nm, err;\n\ttry {\n\t\tnm = hashAlgo.toUpperCase();\n\t\tv = crypto.createVerify(nm);\n\t} catch (e) {\n\t\terr = e;\n\t}\n\tif (v === undefined || (err instanceof Error &&\n\t    err.message.match(/Unknown message digest/))) {\n\t\tnm = 'RSA-';\n\t\tnm += hashAlgo.toUpperCase();\n\t\tv = crypto.createVerify(nm);\n\t}\n\tassert.ok(v, 'failed to create verifier');\n\tvar oldVerify = v.verify.bind(v);\n\tvar key = this.toBuffer('pkcs8');\n\tvar curve = this.curve;\n\tvar self = this;\n\tv.verify = function (signature, fmt) {\n\t\tif (Signature.isSignature(signature, [2, 0])) {\n\t\t\tif (signature.type !== self.type)\n\t\t\t\treturn (false);\n\t\t\tif (signature.hashAlgorithm &&\n\t\t\t    signature.hashAlgorithm !== hashAlgo)\n\t\t\t\treturn (false);\n\t\t\tif (signature.curve && self.type === 'ecdsa' &&\n\t\t\t    signature.curve !== curve)\n\t\t\t\treturn (false);\n\t\t\treturn (oldVerify(key, signature.toBuffer('asn1')));\n\n\t\t} else if (typeof (signature) === 'string' ||\n\t\t    Buffer.isBuffer(signature)) {\n\t\t\treturn (oldVerify(key, signature, fmt));\n\n\t\t/*\n\t\t * Avoid doing this on valid arguments, walking the prototype\n\t\t * chain can be quite slow.\n\t\t */\n\t\t} else if (Signature.isSignature(signature, [1, 0])) {\n\t\t\tthrow (new Error('signature was created by too old ' +\n\t\t\t    'a version of sshpk and cannot be verified'));\n\n\t\t} else {\n\t\t\tthrow (new TypeError('signature must be a string, ' +\n\t\t\t    'Buffer, or Signature object'));\n\t\t}\n\t};\n\treturn (v);\n};\n\nKey.prototype.createDiffieHellman = function () {\n\tif (this.type === 'rsa')\n\t\tthrow (new Error('RSA keys do not support Diffie-Hellman'));\n\n\treturn (new DiffieHellman(this));\n};\nKey.prototype.createDH = Key.prototype.createDiffieHellman;\n\nKey.parse = function (data, format, options) {\n\tif (typeof (data) !== 'string')\n\t\tassert.buffer(data, 'data');\n\tif (format === undefined)\n\t\tformat = 'auto';\n\tassert.string(format, 'format');\n\tif (typeof (options) === 'string')\n\t\toptions = { filename: options };\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.optionalString(options.filename, 'options.filename');\n\tif (options.filename === undefined)\n\t\toptions.filename = '(unnamed)';\n\n\tassert.object(formats[format], 'formats[format]');\n\n\ttry {\n\t\tvar k = formats[format].read(data, options);\n\t\tif (k instanceof PrivateKey)\n\t\t\tk = k.toPublic();\n\t\tif (!k.comment)\n\t\t\tk.comment = options.filename;\n\t\treturn (k);\n\t} catch (e) {\n\t\tif (e.name === 'KeyEncryptedError')\n\t\t\tthrow (e);\n\t\tthrow (new KeyParseError(options.filename, format, e));\n\t}\n};\n\nKey.isKey = function (obj, ver) {\n\treturn (utils.isCompatible(obj, Key, ver));\n};\n\n/*\n * API versions for Key:\n * [1,0] -- initial ver, may take Signature for createVerify or may not\n * [1,1] -- added pkcs1, pkcs8 formats\n * [1,2] -- added auto, ssh-private, openssh formats\n * [1,3] -- added defaultHashAlgorithm\n * [1,4] -- added ed support, createDH\n * [1,5] -- first explicitly tagged version\n * [1,6] -- changed ed25519 part names\n * [1,7] -- spki hash types\n */\nKey.prototype._sshpkApiVersion = [1, 7];\n\nKey._oldVersionDetect = function (obj) {\n\tassert.func(obj.toBuffer);\n\tassert.func(obj.fingerprint);\n\tif (obj.createDH)\n\t\treturn ([1, 4]);\n\tif (obj.defaultHashAlgorithm)\n\t\treturn ([1, 3]);\n\tif (obj.formats['auto'])\n\t\treturn ([1, 2]);\n\tif (obj.formats['pkcs1'])\n\t\treturn ([1, 1]);\n\treturn ([1, 0]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIva2V5LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywwRUFBYTtBQUNsQyxXQUFXLG1CQUFPLENBQUMsaUVBQVE7QUFDM0IsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFlO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFhO0FBQ3JDLG9CQUFvQixvR0FBOEI7QUFDbEQsV0FBVyxtQkFBTyxDQUFDLHFFQUFVO0FBQzdCLFlBQVksbUJBQU8sQ0FBQyxtRUFBUztBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQywrRUFBZTtBQUN4Qzs7QUFFQTtBQUNBLFlBQVksbUJBQU8sQ0FBQywyRUFBYTtBQUNqQyxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsaUZBQWdCO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLCtFQUFlO0FBQ3hDLG1CQUFtQixtQkFBTyxDQUFDLG1GQUFpQjtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBaUI7QUFDNUMscUJBQXFCLG1CQUFPLENBQUMsdUZBQW1CO0FBQ2hELGlCQUFpQixtQkFBTyxDQUFDLCtFQUFlO0FBQ3hDLHlCQUF5QixtQkFBTyxDQUFDLCtGQUF1QjtBQUN4RDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHFGQUFrQjtBQUM5QyxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBaUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2tleS5qcz85NjVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE4IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IEtleTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4vYWxncycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIEZpbmdlcnByaW50ID0gcmVxdWlyZSgnLi9maW5nZXJwcmludCcpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG52YXIgRGlmZmllSGVsbG1hbiA9IHJlcXVpcmUoJy4vZGhlJykuRGlmZmllSGVsbG1hbjtcbnZhciBlcnJzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi9wcml2YXRlLWtleScpO1xudmFyIGVkQ29tcGF0O1xuXG50cnkge1xuXHRlZENvbXBhdCA9IHJlcXVpcmUoJy4vZWQtY29tcGF0Jyk7XG59IGNhdGNoIChlKSB7XG5cdC8qIEp1c3QgY29udGludWUgdGhyb3VnaCwgYW5kIGJhaWwgb3V0IGlmIHdlIHRyeSB0byB1c2UgaXQuICovXG59XG5cbnZhciBJbnZhbGlkQWxnb3JpdGhtRXJyb3IgPSBlcnJzLkludmFsaWRBbGdvcml0aG1FcnJvcjtcbnZhciBLZXlQYXJzZUVycm9yID0gZXJycy5LZXlQYXJzZUVycm9yO1xuXG52YXIgZm9ybWF0cyA9IHt9O1xuZm9ybWF0c1snYXV0byddID0gcmVxdWlyZSgnLi9mb3JtYXRzL2F1dG8nKTtcbmZvcm1hdHNbJ3BlbSddID0gcmVxdWlyZSgnLi9mb3JtYXRzL3BlbScpO1xuZm9ybWF0c1sncGtjczEnXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9wa2NzMScpO1xuZm9ybWF0c1sncGtjczgnXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9wa2NzOCcpO1xuZm9ybWF0c1sncmZjNDI1MyddID0gcmVxdWlyZSgnLi9mb3JtYXRzL3JmYzQyNTMnKTtcbmZvcm1hdHNbJ3NzaCddID0gcmVxdWlyZSgnLi9mb3JtYXRzL3NzaCcpO1xuZm9ybWF0c1snc3NoLXByaXZhdGUnXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9zc2gtcHJpdmF0ZScpO1xuZm9ybWF0c1snb3BlbnNzaCddID0gZm9ybWF0c1snc3NoLXByaXZhdGUnXTtcbmZvcm1hdHNbJ2Ruc3NlYyddID0gcmVxdWlyZSgnLi9mb3JtYXRzL2Ruc3NlYycpO1xuZm9ybWF0c1sncHV0dHknXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9wdXR0eScpO1xuZm9ybWF0c1sncHBrJ10gPSBmb3JtYXRzWydwdXR0eSddO1xuXG5mdW5jdGlvbiBLZXkob3B0cykge1xuXHRhc3NlcnQub2JqZWN0KG9wdHMsICdvcHRpb25zJyk7XG5cdGFzc2VydC5hcnJheU9mT2JqZWN0KG9wdHMucGFydHMsICdvcHRpb25zLnBhcnRzJyk7XG5cdGFzc2VydC5zdHJpbmcob3B0cy50eXBlLCAnb3B0aW9ucy50eXBlJyk7XG5cdGFzc2VydC5vcHRpb25hbFN0cmluZyhvcHRzLmNvbW1lbnQsICdvcHRpb25zLmNvbW1lbnQnKTtcblxuXHR2YXIgYWxnSW5mbyA9IGFsZ3MuaW5mb1tvcHRzLnR5cGVdO1xuXHRpZiAodHlwZW9mIChhbGdJbmZvKSAhPT0gJ29iamVjdCcpXG5cdFx0dGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3Iob3B0cy50eXBlKSk7XG5cblx0dmFyIHBhcnRMb29rdXAgPSB7fTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvcHRzLnBhcnRzLmxlbmd0aDsgKytpKSB7XG5cdFx0dmFyIHBhcnQgPSBvcHRzLnBhcnRzW2ldO1xuXHRcdHBhcnRMb29rdXBbcGFydC5uYW1lXSA9IHBhcnQ7XG5cdH1cblxuXHR0aGlzLnR5cGUgPSBvcHRzLnR5cGU7XG5cdHRoaXMucGFydHMgPSBvcHRzLnBhcnRzO1xuXHR0aGlzLnBhcnQgPSBwYXJ0TG9va3VwO1xuXHR0aGlzLmNvbW1lbnQgPSB1bmRlZmluZWQ7XG5cdHRoaXMuc291cmNlID0gb3B0cy5zb3VyY2U7XG5cblx0LyogZm9yIHNwZWVkaW5nIHVwIGhhc2hpbmcvZmluZ2VycHJpbnQgb3BlcmF0aW9ucyAqL1xuXHR0aGlzLl9yZmM0MjUzQ2FjaGUgPSBvcHRzLl9yZmM0MjUzQ2FjaGU7XG5cdHRoaXMuX2hhc2hDYWNoZSA9IHt9O1xuXG5cdHZhciBzejtcblx0dGhpcy5jdXJ2ZSA9IHVuZGVmaW5lZDtcblx0aWYgKHRoaXMudHlwZSA9PT0gJ2VjZHNhJykge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMucGFydC5jdXJ2ZS5kYXRhLnRvU3RyaW5nKCk7XG5cdFx0dGhpcy5jdXJ2ZSA9IGN1cnZlO1xuXHRcdHN6ID0gYWxncy5jdXJ2ZXNbY3VydmVdLnNpemU7XG5cdH0gZWxzZSBpZiAodGhpcy50eXBlID09PSAnZWQyNTUxOScgfHwgdGhpcy50eXBlID09PSAnY3VydmUyNTUxOScpIHtcblx0XHRzeiA9IDI1Njtcblx0XHR0aGlzLmN1cnZlID0gJ2N1cnZlMjU1MTknO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBzelBhcnQgPSB0aGlzLnBhcnRbYWxnSW5mby5zaXplUGFydF07XG5cdFx0c3ogPSBzelBhcnQuZGF0YS5sZW5ndGg7XG5cdFx0c3ogPSBzeiAqIDggLSB1dGlscy5jb3VudFplcm9zKHN6UGFydC5kYXRhKTtcblx0fVxuXHR0aGlzLnNpemUgPSBzejtcbn1cblxuS2V5LmZvcm1hdHMgPSBmb3JtYXRzO1xuXG5LZXkucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gKGZvcm1hdCwgb3B0aW9ucykge1xuXHRpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpXG5cdFx0Zm9ybWF0ID0gJ3NzaCc7XG5cdGFzc2VydC5zdHJpbmcoZm9ybWF0LCAnZm9ybWF0Jyk7XG5cdGFzc2VydC5vYmplY3QoZm9ybWF0c1tmb3JtYXRdLCAnZm9ybWF0c1tmb3JtYXRdJyk7XG5cdGFzc2VydC5vcHRpb25hbE9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpO1xuXG5cdGlmIChmb3JtYXQgPT09ICdyZmM0MjUzJykge1xuXHRcdGlmICh0aGlzLl9yZmM0MjUzQ2FjaGUgPT09IHVuZGVmaW5lZClcblx0XHRcdHRoaXMuX3JmYzQyNTNDYWNoZSA9IGZvcm1hdHNbJ3JmYzQyNTMnXS53cml0ZSh0aGlzKTtcblx0XHRyZXR1cm4gKHRoaXMuX3JmYzQyNTNDYWNoZSk7XG5cdH1cblxuXHRyZXR1cm4gKGZvcm1hdHNbZm9ybWF0XS53cml0ZSh0aGlzLCBvcHRpb25zKSk7XG59O1xuXG5LZXkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGZvcm1hdCwgb3B0aW9ucykge1xuXHRyZXR1cm4gKHRoaXMudG9CdWZmZXIoZm9ybWF0LCBvcHRpb25zKS50b1N0cmluZygpKTtcbn07XG5cbktleS5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uIChhbGdvLCB0eXBlKSB7XG5cdGFzc2VydC5zdHJpbmcoYWxnbywgJ2FsZ29yaXRobScpO1xuXHRhc3NlcnQub3B0aW9uYWxTdHJpbmcodHlwZSwgJ3R5cGUnKTtcblx0aWYgKHR5cGUgPT09IHVuZGVmaW5lZClcblx0XHR0eXBlID0gJ3NzaCc7XG5cdGFsZ28gPSBhbGdvLnRvTG93ZXJDYXNlKCk7XG5cdGlmIChhbGdzLmhhc2hBbGdzW2FsZ29dID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3IoYWxnbykpO1xuXG5cdHZhciBjYWNoZUtleSA9IGFsZ28gKyAnfHwnICsgdHlwZTtcblx0aWYgKHRoaXMuX2hhc2hDYWNoZVtjYWNoZUtleV0pXG5cdFx0cmV0dXJuICh0aGlzLl9oYXNoQ2FjaGVbY2FjaGVLZXldKTtcblxuXHR2YXIgYnVmO1xuXHRpZiAodHlwZSA9PT0gJ3NzaCcpIHtcblx0XHRidWYgPSB0aGlzLnRvQnVmZmVyKCdyZmM0MjUzJyk7XG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3Nwa2knKSB7XG5cdFx0YnVmID0gZm9ybWF0cy5wa2NzOC5wa2NzOFRvQnVmZmVyKHRoaXMpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ0hhc2ggdHlwZSAnICsgdHlwZSArICcgbm90IHN1cHBvcnRlZCcpKTtcblx0fVxuXHR2YXIgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKGFsZ28pLnVwZGF0ZShidWYpLmRpZ2VzdCgpO1xuXHR0aGlzLl9oYXNoQ2FjaGVbY2FjaGVLZXldID0gaGFzaDtcblx0cmV0dXJuIChoYXNoKTtcbn07XG5cbktleS5wcm90b3R5cGUuZmluZ2VycHJpbnQgPSBmdW5jdGlvbiAoYWxnbywgdHlwZSkge1xuXHRpZiAoYWxnbyA9PT0gdW5kZWZpbmVkKVxuXHRcdGFsZ28gPSAnc2hhMjU2Jztcblx0aWYgKHR5cGUgPT09IHVuZGVmaW5lZClcblx0XHR0eXBlID0gJ3NzaCc7XG5cdGFzc2VydC5zdHJpbmcoYWxnbywgJ2FsZ29yaXRobScpO1xuXHRhc3NlcnQuc3RyaW5nKHR5cGUsICd0eXBlJyk7XG5cdHZhciBvcHRzID0ge1xuXHRcdHR5cGU6ICdrZXknLFxuXHRcdGhhc2g6IHRoaXMuaGFzaChhbGdvLCB0eXBlKSxcblx0XHRhbGdvcml0aG06IGFsZ28sXG5cdFx0aGFzaFR5cGU6IHR5cGVcblx0fTtcblx0cmV0dXJuIChuZXcgRmluZ2VycHJpbnQob3B0cykpO1xufTtcblxuS2V5LnByb3RvdHlwZS5kZWZhdWx0SGFzaEFsZ29yaXRobSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGhhc2hBbGdvID0gJ3NoYTEnO1xuXHRpZiAodGhpcy50eXBlID09PSAncnNhJylcblx0XHRoYXNoQWxnbyA9ICdzaGEyNTYnO1xuXHRpZiAodGhpcy50eXBlID09PSAnZHNhJyAmJiB0aGlzLnNpemUgPiAxMDI0KVxuXHRcdGhhc2hBbGdvID0gJ3NoYTI1Nic7XG5cdGlmICh0aGlzLnR5cGUgPT09ICdlZDI1NTE5Jylcblx0XHRoYXNoQWxnbyA9ICdzaGE1MTInO1xuXHRpZiAodGhpcy50eXBlID09PSAnZWNkc2EnKSB7XG5cdFx0aWYgKHRoaXMuc2l6ZSA8PSAyNTYpXG5cdFx0XHRoYXNoQWxnbyA9ICdzaGEyNTYnO1xuXHRcdGVsc2UgaWYgKHRoaXMuc2l6ZSA8PSAzODQpXG5cdFx0XHRoYXNoQWxnbyA9ICdzaGEzODQnO1xuXHRcdGVsc2Vcblx0XHRcdGhhc2hBbGdvID0gJ3NoYTUxMic7XG5cdH1cblx0cmV0dXJuIChoYXNoQWxnbyk7XG59O1xuXG5LZXkucHJvdG90eXBlLmNyZWF0ZVZlcmlmeSA9IGZ1bmN0aW9uIChoYXNoQWxnbykge1xuXHRpZiAoaGFzaEFsZ28gPT09IHVuZGVmaW5lZClcblx0XHRoYXNoQWxnbyA9IHRoaXMuZGVmYXVsdEhhc2hBbGdvcml0aG0oKTtcblx0YXNzZXJ0LnN0cmluZyhoYXNoQWxnbywgJ2hhc2ggYWxnb3JpdGhtJyk7XG5cblx0LyogRUQyNTUxOSBpcyBub3Qgc3VwcG9ydGVkIGJ5IE9wZW5TU0wsIHVzZSBhIGphdmFzY3JpcHQgaW1wbC4gKi9cblx0aWYgKHRoaXMudHlwZSA9PT0gJ2VkMjU1MTknICYmIGVkQ29tcGF0ICE9PSB1bmRlZmluZWQpXG5cdFx0cmV0dXJuIChuZXcgZWRDb21wYXQuVmVyaWZpZXIodGhpcywgaGFzaEFsZ28pKTtcblx0aWYgKHRoaXMudHlwZSA9PT0gJ2N1cnZlMjU1MTknKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0N1cnZlMjU1MTkga2V5cyBhcmUgbm90IHN1aXRhYmxlIGZvciAnICtcblx0XHQgICAgJ3NpZ25pbmcgb3IgdmVyaWZpY2F0aW9uJykpO1xuXG5cdHZhciB2LCBubSwgZXJyO1xuXHR0cnkge1xuXHRcdG5tID0gaGFzaEFsZ28udG9VcHBlckNhc2UoKTtcblx0XHR2ID0gY3J5cHRvLmNyZWF0ZVZlcmlmeShubSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRlcnIgPSBlO1xuXHR9XG5cdGlmICh2ID09PSB1bmRlZmluZWQgfHwgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmXG5cdCAgICBlcnIubWVzc2FnZS5tYXRjaCgvVW5rbm93biBtZXNzYWdlIGRpZ2VzdC8pKSkge1xuXHRcdG5tID0gJ1JTQS0nO1xuXHRcdG5tICs9IGhhc2hBbGdvLnRvVXBwZXJDYXNlKCk7XG5cdFx0diA9IGNyeXB0by5jcmVhdGVWZXJpZnkobm0pO1xuXHR9XG5cdGFzc2VydC5vayh2LCAnZmFpbGVkIHRvIGNyZWF0ZSB2ZXJpZmllcicpO1xuXHR2YXIgb2xkVmVyaWZ5ID0gdi52ZXJpZnkuYmluZCh2KTtcblx0dmFyIGtleSA9IHRoaXMudG9CdWZmZXIoJ3BrY3M4Jyk7XG5cdHZhciBjdXJ2ZSA9IHRoaXMuY3VydmU7XG5cdHZhciBzZWxmID0gdGhpcztcblx0di52ZXJpZnkgPSBmdW5jdGlvbiAoc2lnbmF0dXJlLCBmbXQpIHtcblx0XHRpZiAoU2lnbmF0dXJlLmlzU2lnbmF0dXJlKHNpZ25hdHVyZSwgWzIsIDBdKSkge1xuXHRcdFx0aWYgKHNpZ25hdHVyZS50eXBlICE9PSBzZWxmLnR5cGUpXG5cdFx0XHRcdHJldHVybiAoZmFsc2UpO1xuXHRcdFx0aWYgKHNpZ25hdHVyZS5oYXNoQWxnb3JpdGhtICYmXG5cdFx0XHQgICAgc2lnbmF0dXJlLmhhc2hBbGdvcml0aG0gIT09IGhhc2hBbGdvKVxuXHRcdFx0XHRyZXR1cm4gKGZhbHNlKTtcblx0XHRcdGlmIChzaWduYXR1cmUuY3VydmUgJiYgc2VsZi50eXBlID09PSAnZWNkc2EnICYmXG5cdFx0XHQgICAgc2lnbmF0dXJlLmN1cnZlICE9PSBjdXJ2ZSlcblx0XHRcdFx0cmV0dXJuIChmYWxzZSk7XG5cdFx0XHRyZXR1cm4gKG9sZFZlcmlmeShrZXksIHNpZ25hdHVyZS50b0J1ZmZlcignYXNuMScpKSk7XG5cblx0XHR9IGVsc2UgaWYgKHR5cGVvZiAoc2lnbmF0dXJlKSA9PT0gJ3N0cmluZycgfHxcblx0XHQgICAgQnVmZmVyLmlzQnVmZmVyKHNpZ25hdHVyZSkpIHtcblx0XHRcdHJldHVybiAob2xkVmVyaWZ5KGtleSwgc2lnbmF0dXJlLCBmbXQpKTtcblxuXHRcdC8qXG5cdFx0ICogQXZvaWQgZG9pbmcgdGhpcyBvbiB2YWxpZCBhcmd1bWVudHMsIHdhbGtpbmcgdGhlIHByb3RvdHlwZVxuXHRcdCAqIGNoYWluIGNhbiBiZSBxdWl0ZSBzbG93LlxuXHRcdCAqL1xuXHRcdH0gZWxzZSBpZiAoU2lnbmF0dXJlLmlzU2lnbmF0dXJlKHNpZ25hdHVyZSwgWzEsIDBdKSkge1xuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignc2lnbmF0dXJlIHdhcyBjcmVhdGVkIGJ5IHRvbyBvbGQgJyArXG5cdFx0XHQgICAgJ2EgdmVyc2lvbiBvZiBzc2hwayBhbmQgY2Fubm90IGJlIHZlcmlmaWVkJykpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IChuZXcgVHlwZUVycm9yKCdzaWduYXR1cmUgbXVzdCBiZSBhIHN0cmluZywgJyArXG5cdFx0XHQgICAgJ0J1ZmZlciwgb3IgU2lnbmF0dXJlIG9iamVjdCcpKTtcblx0XHR9XG5cdH07XG5cdHJldHVybiAodik7XG59O1xuXG5LZXkucHJvdG90eXBlLmNyZWF0ZURpZmZpZUhlbGxtYW4gPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0aGlzLnR5cGUgPT09ICdyc2EnKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1JTQSBrZXlzIGRvIG5vdCBzdXBwb3J0IERpZmZpZS1IZWxsbWFuJykpO1xuXG5cdHJldHVybiAobmV3IERpZmZpZUhlbGxtYW4odGhpcykpO1xufTtcbktleS5wcm90b3R5cGUuY3JlYXRlREggPSBLZXkucHJvdG90eXBlLmNyZWF0ZURpZmZpZUhlbGxtYW47XG5cbktleS5wYXJzZSA9IGZ1bmN0aW9uIChkYXRhLCBmb3JtYXQsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiAoZGF0YSkgIT09ICdzdHJpbmcnKVxuXHRcdGFzc2VydC5idWZmZXIoZGF0YSwgJ2RhdGEnKTtcblx0aWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKVxuXHRcdGZvcm1hdCA9ICdhdXRvJztcblx0YXNzZXJ0LnN0cmluZyhmb3JtYXQsICdmb3JtYXQnKTtcblx0aWYgKHR5cGVvZiAob3B0aW9ucykgPT09ICdzdHJpbmcnKVxuXHRcdG9wdGlvbnMgPSB7IGZpbGVuYW1lOiBvcHRpb25zIH07XG5cdGFzc2VydC5vcHRpb25hbE9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpO1xuXHRpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxuXHRcdG9wdGlvbnMgPSB7fTtcblx0YXNzZXJ0Lm9wdGlvbmFsU3RyaW5nKG9wdGlvbnMuZmlsZW5hbWUsICdvcHRpb25zLmZpbGVuYW1lJyk7XG5cdGlmIChvcHRpb25zLmZpbGVuYW1lID09PSB1bmRlZmluZWQpXG5cdFx0b3B0aW9ucy5maWxlbmFtZSA9ICcodW5uYW1lZCknO1xuXG5cdGFzc2VydC5vYmplY3QoZm9ybWF0c1tmb3JtYXRdLCAnZm9ybWF0c1tmb3JtYXRdJyk7XG5cblx0dHJ5IHtcblx0XHR2YXIgayA9IGZvcm1hdHNbZm9ybWF0XS5yZWFkKGRhdGEsIG9wdGlvbnMpO1xuXHRcdGlmIChrIGluc3RhbmNlb2YgUHJpdmF0ZUtleSlcblx0XHRcdGsgPSBrLnRvUHVibGljKCk7XG5cdFx0aWYgKCFrLmNvbW1lbnQpXG5cdFx0XHRrLmNvbW1lbnQgPSBvcHRpb25zLmZpbGVuYW1lO1xuXHRcdHJldHVybiAoayk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAoZS5uYW1lID09PSAnS2V5RW5jcnlwdGVkRXJyb3InKVxuXHRcdFx0dGhyb3cgKGUpO1xuXHRcdHRocm93IChuZXcgS2V5UGFyc2VFcnJvcihvcHRpb25zLmZpbGVuYW1lLCBmb3JtYXQsIGUpKTtcblx0fVxufTtcblxuS2V5LmlzS2V5ID0gZnVuY3Rpb24gKG9iaiwgdmVyKSB7XG5cdHJldHVybiAodXRpbHMuaXNDb21wYXRpYmxlKG9iaiwgS2V5LCB2ZXIpKTtcbn07XG5cbi8qXG4gKiBBUEkgdmVyc2lvbnMgZm9yIEtleTpcbiAqIFsxLDBdIC0tIGluaXRpYWwgdmVyLCBtYXkgdGFrZSBTaWduYXR1cmUgZm9yIGNyZWF0ZVZlcmlmeSBvciBtYXkgbm90XG4gKiBbMSwxXSAtLSBhZGRlZCBwa2NzMSwgcGtjczggZm9ybWF0c1xuICogWzEsMl0gLS0gYWRkZWQgYXV0bywgc3NoLXByaXZhdGUsIG9wZW5zc2ggZm9ybWF0c1xuICogWzEsM10gLS0gYWRkZWQgZGVmYXVsdEhhc2hBbGdvcml0aG1cbiAqIFsxLDRdIC0tIGFkZGVkIGVkIHN1cHBvcnQsIGNyZWF0ZURIXG4gKiBbMSw1XSAtLSBmaXJzdCBleHBsaWNpdGx5IHRhZ2dlZCB2ZXJzaW9uXG4gKiBbMSw2XSAtLSBjaGFuZ2VkIGVkMjU1MTkgcGFydCBuYW1lc1xuICogWzEsN10gLS0gc3BraSBoYXNoIHR5cGVzXG4gKi9cbktleS5wcm90b3R5cGUuX3NzaHBrQXBpVmVyc2lvbiA9IFsxLCA3XTtcblxuS2V5Ll9vbGRWZXJzaW9uRGV0ZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuXHRhc3NlcnQuZnVuYyhvYmoudG9CdWZmZXIpO1xuXHRhc3NlcnQuZnVuYyhvYmouZmluZ2VycHJpbnQpO1xuXHRpZiAob2JqLmNyZWF0ZURIKVxuXHRcdHJldHVybiAoWzEsIDRdKTtcblx0aWYgKG9iai5kZWZhdWx0SGFzaEFsZ29yaXRobSlcblx0XHRyZXR1cm4gKFsxLCAzXSk7XG5cdGlmIChvYmouZm9ybWF0c1snYXV0byddKVxuXHRcdHJldHVybiAoWzEsIDJdKTtcblx0aWYgKG9iai5mb3JtYXRzWydwa2NzMSddKVxuXHRcdHJldHVybiAoWzEsIDFdKTtcblx0cmV0dXJuIChbMSwgMF0pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/key.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/key.js":
/*!***************************************!*\
  !*** ./node_modules/sshpk/lib/key.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2018 Joyent, Inc.\n\nmodule.exports = Key;\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar algs = __webpack_require__(/*! ./algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar Fingerprint = __webpack_require__(/*! ./fingerprint */ \"(rsc)/./node_modules/sshpk/lib/fingerprint.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"(rsc)/./node_modules/sshpk/lib/signature.js\");\nvar DiffieHellman = (__webpack_require__(/*! ./dhe */ \"(rsc)/./node_modules/sshpk/lib/dhe.js\").DiffieHellman);\nvar errs = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/sshpk/lib/errors.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar PrivateKey = __webpack_require__(/*! ./private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\nvar edCompat;\n\ntry {\n\tedCompat = __webpack_require__(/*! ./ed-compat */ \"(rsc)/./node_modules/sshpk/lib/ed-compat.js\");\n} catch (e) {\n\t/* Just continue through, and bail out if we try to use it. */\n}\n\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\nvar KeyParseError = errs.KeyParseError;\n\nvar formats = {};\nformats['auto'] = __webpack_require__(/*! ./formats/auto */ \"(rsc)/./node_modules/sshpk/lib/formats/auto.js\");\nformats['pem'] = __webpack_require__(/*! ./formats/pem */ \"(rsc)/./node_modules/sshpk/lib/formats/pem.js\");\nformats['pkcs1'] = __webpack_require__(/*! ./formats/pkcs1 */ \"(rsc)/./node_modules/sshpk/lib/formats/pkcs1.js\");\nformats['pkcs8'] = __webpack_require__(/*! ./formats/pkcs8 */ \"(rsc)/./node_modules/sshpk/lib/formats/pkcs8.js\");\nformats['rfc4253'] = __webpack_require__(/*! ./formats/rfc4253 */ \"(rsc)/./node_modules/sshpk/lib/formats/rfc4253.js\");\nformats['ssh'] = __webpack_require__(/*! ./formats/ssh */ \"(rsc)/./node_modules/sshpk/lib/formats/ssh.js\");\nformats['ssh-private'] = __webpack_require__(/*! ./formats/ssh-private */ \"(rsc)/./node_modules/sshpk/lib/formats/ssh-private.js\");\nformats['openssh'] = formats['ssh-private'];\nformats['dnssec'] = __webpack_require__(/*! ./formats/dnssec */ \"(rsc)/./node_modules/sshpk/lib/formats/dnssec.js\");\nformats['putty'] = __webpack_require__(/*! ./formats/putty */ \"(rsc)/./node_modules/sshpk/lib/formats/putty.js\");\nformats['ppk'] = formats['putty'];\n\nfunction Key(opts) {\n\tassert.object(opts, 'options');\n\tassert.arrayOfObject(opts.parts, 'options.parts');\n\tassert.string(opts.type, 'options.type');\n\tassert.optionalString(opts.comment, 'options.comment');\n\n\tvar algInfo = algs.info[opts.type];\n\tif (typeof (algInfo) !== 'object')\n\t\tthrow (new InvalidAlgorithmError(opts.type));\n\n\tvar partLookup = {};\n\tfor (var i = 0; i < opts.parts.length; ++i) {\n\t\tvar part = opts.parts[i];\n\t\tpartLookup[part.name] = part;\n\t}\n\n\tthis.type = opts.type;\n\tthis.parts = opts.parts;\n\tthis.part = partLookup;\n\tthis.comment = undefined;\n\tthis.source = opts.source;\n\n\t/* for speeding up hashing/fingerprint operations */\n\tthis._rfc4253Cache = opts._rfc4253Cache;\n\tthis._hashCache = {};\n\n\tvar sz;\n\tthis.curve = undefined;\n\tif (this.type === 'ecdsa') {\n\t\tvar curve = this.part.curve.data.toString();\n\t\tthis.curve = curve;\n\t\tsz = algs.curves[curve].size;\n\t} else if (this.type === 'ed25519' || this.type === 'curve25519') {\n\t\tsz = 256;\n\t\tthis.curve = 'curve25519';\n\t} else {\n\t\tvar szPart = this.part[algInfo.sizePart];\n\t\tsz = szPart.data.length;\n\t\tsz = sz * 8 - utils.countZeros(szPart.data);\n\t}\n\tthis.size = sz;\n}\n\nKey.formats = formats;\n\nKey.prototype.toBuffer = function (format, options) {\n\tif (format === undefined)\n\t\tformat = 'ssh';\n\tassert.string(format, 'format');\n\tassert.object(formats[format], 'formats[format]');\n\tassert.optionalObject(options, 'options');\n\n\tif (format === 'rfc4253') {\n\t\tif (this._rfc4253Cache === undefined)\n\t\t\tthis._rfc4253Cache = formats['rfc4253'].write(this);\n\t\treturn (this._rfc4253Cache);\n\t}\n\n\treturn (formats[format].write(this, options));\n};\n\nKey.prototype.toString = function (format, options) {\n\treturn (this.toBuffer(format, options).toString());\n};\n\nKey.prototype.hash = function (algo, type) {\n\tassert.string(algo, 'algorithm');\n\tassert.optionalString(type, 'type');\n\tif (type === undefined)\n\t\ttype = 'ssh';\n\talgo = algo.toLowerCase();\n\tif (algs.hashAlgs[algo] === undefined)\n\t\tthrow (new InvalidAlgorithmError(algo));\n\n\tvar cacheKey = algo + '||' + type;\n\tif (this._hashCache[cacheKey])\n\t\treturn (this._hashCache[cacheKey]);\n\n\tvar buf;\n\tif (type === 'ssh') {\n\t\tbuf = this.toBuffer('rfc4253');\n\t} else if (type === 'spki') {\n\t\tbuf = formats.pkcs8.pkcs8ToBuffer(this);\n\t} else {\n\t\tthrow (new Error('Hash type ' + type + ' not supported'));\n\t}\n\tvar hash = crypto.createHash(algo).update(buf).digest();\n\tthis._hashCache[cacheKey] = hash;\n\treturn (hash);\n};\n\nKey.prototype.fingerprint = function (algo, type) {\n\tif (algo === undefined)\n\t\talgo = 'sha256';\n\tif (type === undefined)\n\t\ttype = 'ssh';\n\tassert.string(algo, 'algorithm');\n\tassert.string(type, 'type');\n\tvar opts = {\n\t\ttype: 'key',\n\t\thash: this.hash(algo, type),\n\t\talgorithm: algo,\n\t\thashType: type\n\t};\n\treturn (new Fingerprint(opts));\n};\n\nKey.prototype.defaultHashAlgorithm = function () {\n\tvar hashAlgo = 'sha1';\n\tif (this.type === 'rsa')\n\t\thashAlgo = 'sha256';\n\tif (this.type === 'dsa' && this.size > 1024)\n\t\thashAlgo = 'sha256';\n\tif (this.type === 'ed25519')\n\t\thashAlgo = 'sha512';\n\tif (this.type === 'ecdsa') {\n\t\tif (this.size <= 256)\n\t\t\thashAlgo = 'sha256';\n\t\telse if (this.size <= 384)\n\t\t\thashAlgo = 'sha384';\n\t\telse\n\t\t\thashAlgo = 'sha512';\n\t}\n\treturn (hashAlgo);\n};\n\nKey.prototype.createVerify = function (hashAlgo) {\n\tif (hashAlgo === undefined)\n\t\thashAlgo = this.defaultHashAlgorithm();\n\tassert.string(hashAlgo, 'hash algorithm');\n\n\t/* ED25519 is not supported by OpenSSL, use a javascript impl. */\n\tif (this.type === 'ed25519' && edCompat !== undefined)\n\t\treturn (new edCompat.Verifier(this, hashAlgo));\n\tif (this.type === 'curve25519')\n\t\tthrow (new Error('Curve25519 keys are not suitable for ' +\n\t\t    'signing or verification'));\n\n\tvar v, nm, err;\n\ttry {\n\t\tnm = hashAlgo.toUpperCase();\n\t\tv = crypto.createVerify(nm);\n\t} catch (e) {\n\t\terr = e;\n\t}\n\tif (v === undefined || (err instanceof Error &&\n\t    err.message.match(/Unknown message digest/))) {\n\t\tnm = 'RSA-';\n\t\tnm += hashAlgo.toUpperCase();\n\t\tv = crypto.createVerify(nm);\n\t}\n\tassert.ok(v, 'failed to create verifier');\n\tvar oldVerify = v.verify.bind(v);\n\tvar key = this.toBuffer('pkcs8');\n\tvar curve = this.curve;\n\tvar self = this;\n\tv.verify = function (signature, fmt) {\n\t\tif (Signature.isSignature(signature, [2, 0])) {\n\t\t\tif (signature.type !== self.type)\n\t\t\t\treturn (false);\n\t\t\tif (signature.hashAlgorithm &&\n\t\t\t    signature.hashAlgorithm !== hashAlgo)\n\t\t\t\treturn (false);\n\t\t\tif (signature.curve && self.type === 'ecdsa' &&\n\t\t\t    signature.curve !== curve)\n\t\t\t\treturn (false);\n\t\t\treturn (oldVerify(key, signature.toBuffer('asn1')));\n\n\t\t} else if (typeof (signature) === 'string' ||\n\t\t    Buffer.isBuffer(signature)) {\n\t\t\treturn (oldVerify(key, signature, fmt));\n\n\t\t/*\n\t\t * Avoid doing this on valid arguments, walking the prototype\n\t\t * chain can be quite slow.\n\t\t */\n\t\t} else if (Signature.isSignature(signature, [1, 0])) {\n\t\t\tthrow (new Error('signature was created by too old ' +\n\t\t\t    'a version of sshpk and cannot be verified'));\n\n\t\t} else {\n\t\t\tthrow (new TypeError('signature must be a string, ' +\n\t\t\t    'Buffer, or Signature object'));\n\t\t}\n\t};\n\treturn (v);\n};\n\nKey.prototype.createDiffieHellman = function () {\n\tif (this.type === 'rsa')\n\t\tthrow (new Error('RSA keys do not support Diffie-Hellman'));\n\n\treturn (new DiffieHellman(this));\n};\nKey.prototype.createDH = Key.prototype.createDiffieHellman;\n\nKey.parse = function (data, format, options) {\n\tif (typeof (data) !== 'string')\n\t\tassert.buffer(data, 'data');\n\tif (format === undefined)\n\t\tformat = 'auto';\n\tassert.string(format, 'format');\n\tif (typeof (options) === 'string')\n\t\toptions = { filename: options };\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.optionalString(options.filename, 'options.filename');\n\tif (options.filename === undefined)\n\t\toptions.filename = '(unnamed)';\n\n\tassert.object(formats[format], 'formats[format]');\n\n\ttry {\n\t\tvar k = formats[format].read(data, options);\n\t\tif (k instanceof PrivateKey)\n\t\t\tk = k.toPublic();\n\t\tif (!k.comment)\n\t\t\tk.comment = options.filename;\n\t\treturn (k);\n\t} catch (e) {\n\t\tif (e.name === 'KeyEncryptedError')\n\t\t\tthrow (e);\n\t\tthrow (new KeyParseError(options.filename, format, e));\n\t}\n};\n\nKey.isKey = function (obj, ver) {\n\treturn (utils.isCompatible(obj, Key, ver));\n};\n\n/*\n * API versions for Key:\n * [1,0] -- initial ver, may take Signature for createVerify or may not\n * [1,1] -- added pkcs1, pkcs8 formats\n * [1,2] -- added auto, ssh-private, openssh formats\n * [1,3] -- added defaultHashAlgorithm\n * [1,4] -- added ed support, createDH\n * [1,5] -- first explicitly tagged version\n * [1,6] -- changed ed25519 part names\n * [1,7] -- spki hash types\n */\nKey.prototype._sshpkApiVersion = [1, 7];\n\nKey._oldVersionDetect = function (obj) {\n\tassert.func(obj.toBuffer);\n\tassert.func(obj.fingerprint);\n\tif (obj.createDH)\n\t\treturn ([1, 4]);\n\tif (obj.defaultHashAlgorithm)\n\t\treturn ([1, 3]);\n\tif (obj.formats['auto'])\n\t\treturn ([1, 2]);\n\tif (obj.formats['pkcs1'])\n\t\treturn ([1, 1]);\n\treturn ([1, 0]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2tleS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsK0RBQWE7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLHNEQUFRO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixrQkFBa0IsbUJBQU8sQ0FBQyxvRUFBZTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBYTtBQUNyQyxvQkFBb0IseUZBQThCO0FBQ2xELFdBQVcsbUJBQU8sQ0FBQywwREFBVTtBQUM3QixZQUFZLG1CQUFPLENBQUMsd0RBQVM7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsb0VBQWU7QUFDeEM7O0FBRUE7QUFDQSxZQUFZLG1CQUFPLENBQUMsZ0VBQWE7QUFDakMsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHNFQUFnQjtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBZTtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWlCO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLDRFQUFtQjtBQUNoRCxpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBZTtBQUN4Qyx5QkFBeUIsbUJBQU8sQ0FBQyxvRkFBdUI7QUFDeEQ7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQywwRUFBa0I7QUFDOUMsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWlCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9rZXkuanM/NWMzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOCBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSBLZXk7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuL2FsZ3MnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBGaW5nZXJwcmludCA9IHJlcXVpcmUoJy4vZmluZ2VycHJpbnQnKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xudmFyIERpZmZpZUhlbGxtYW4gPSByZXF1aXJlKCcuL2RoZScpLkRpZmZpZUhlbGxtYW47XG52YXIgZXJycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vcHJpdmF0ZS1rZXknKTtcbnZhciBlZENvbXBhdDtcblxudHJ5IHtcblx0ZWRDb21wYXQgPSByZXF1aXJlKCcuL2VkLWNvbXBhdCcpO1xufSBjYXRjaCAoZSkge1xuXHQvKiBKdXN0IGNvbnRpbnVlIHRocm91Z2gsIGFuZCBiYWlsIG91dCBpZiB3ZSB0cnkgdG8gdXNlIGl0LiAqL1xufVxuXG52YXIgSW52YWxpZEFsZ29yaXRobUVycm9yID0gZXJycy5JbnZhbGlkQWxnb3JpdGhtRXJyb3I7XG52YXIgS2V5UGFyc2VFcnJvciA9IGVycnMuS2V5UGFyc2VFcnJvcjtcblxudmFyIGZvcm1hdHMgPSB7fTtcbmZvcm1hdHNbJ2F1dG8nXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9hdXRvJyk7XG5mb3JtYXRzWydwZW0nXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9wZW0nKTtcbmZvcm1hdHNbJ3BrY3MxJ10gPSByZXF1aXJlKCcuL2Zvcm1hdHMvcGtjczEnKTtcbmZvcm1hdHNbJ3BrY3M4J10gPSByZXF1aXJlKCcuL2Zvcm1hdHMvcGtjczgnKTtcbmZvcm1hdHNbJ3JmYzQyNTMnXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9yZmM0MjUzJyk7XG5mb3JtYXRzWydzc2gnXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9zc2gnKTtcbmZvcm1hdHNbJ3NzaC1wcml2YXRlJ10gPSByZXF1aXJlKCcuL2Zvcm1hdHMvc3NoLXByaXZhdGUnKTtcbmZvcm1hdHNbJ29wZW5zc2gnXSA9IGZvcm1hdHNbJ3NzaC1wcml2YXRlJ107XG5mb3JtYXRzWydkbnNzZWMnXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9kbnNzZWMnKTtcbmZvcm1hdHNbJ3B1dHR5J10gPSByZXF1aXJlKCcuL2Zvcm1hdHMvcHV0dHknKTtcbmZvcm1hdHNbJ3BwayddID0gZm9ybWF0c1sncHV0dHknXTtcblxuZnVuY3Rpb24gS2V5KG9wdHMpIHtcblx0YXNzZXJ0Lm9iamVjdChvcHRzLCAnb3B0aW9ucycpO1xuXHRhc3NlcnQuYXJyYXlPZk9iamVjdChvcHRzLnBhcnRzLCAnb3B0aW9ucy5wYXJ0cycpO1xuXHRhc3NlcnQuc3RyaW5nKG9wdHMudHlwZSwgJ29wdGlvbnMudHlwZScpO1xuXHRhc3NlcnQub3B0aW9uYWxTdHJpbmcob3B0cy5jb21tZW50LCAnb3B0aW9ucy5jb21tZW50Jyk7XG5cblx0dmFyIGFsZ0luZm8gPSBhbGdzLmluZm9bb3B0cy50eXBlXTtcblx0aWYgKHR5cGVvZiAoYWxnSW5mbykgIT09ICdvYmplY3QnKVxuXHRcdHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKG9wdHMudHlwZSkpO1xuXG5cdHZhciBwYXJ0TG9va3VwID0ge307XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgb3B0cy5wYXJ0cy5sZW5ndGg7ICsraSkge1xuXHRcdHZhciBwYXJ0ID0gb3B0cy5wYXJ0c1tpXTtcblx0XHRwYXJ0TG9va3VwW3BhcnQubmFtZV0gPSBwYXJ0O1xuXHR9XG5cblx0dGhpcy50eXBlID0gb3B0cy50eXBlO1xuXHR0aGlzLnBhcnRzID0gb3B0cy5wYXJ0cztcblx0dGhpcy5wYXJ0ID0gcGFydExvb2t1cDtcblx0dGhpcy5jb21tZW50ID0gdW5kZWZpbmVkO1xuXHR0aGlzLnNvdXJjZSA9IG9wdHMuc291cmNlO1xuXG5cdC8qIGZvciBzcGVlZGluZyB1cCBoYXNoaW5nL2ZpbmdlcnByaW50IG9wZXJhdGlvbnMgKi9cblx0dGhpcy5fcmZjNDI1M0NhY2hlID0gb3B0cy5fcmZjNDI1M0NhY2hlO1xuXHR0aGlzLl9oYXNoQ2FjaGUgPSB7fTtcblxuXHR2YXIgc3o7XG5cdHRoaXMuY3VydmUgPSB1bmRlZmluZWQ7XG5cdGlmICh0aGlzLnR5cGUgPT09ICdlY2RzYScpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLnBhcnQuY3VydmUuZGF0YS50b1N0cmluZygpO1xuXHRcdHRoaXMuY3VydmUgPSBjdXJ2ZTtcblx0XHRzeiA9IGFsZ3MuY3VydmVzW2N1cnZlXS5zaXplO1xuXHR9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ2VkMjU1MTknIHx8IHRoaXMudHlwZSA9PT0gJ2N1cnZlMjU1MTknKSB7XG5cdFx0c3ogPSAyNTY7XG5cdFx0dGhpcy5jdXJ2ZSA9ICdjdXJ2ZTI1NTE5Jztcblx0fSBlbHNlIHtcblx0XHR2YXIgc3pQYXJ0ID0gdGhpcy5wYXJ0W2FsZ0luZm8uc2l6ZVBhcnRdO1xuXHRcdHN6ID0gc3pQYXJ0LmRhdGEubGVuZ3RoO1xuXHRcdHN6ID0gc3ogKiA4IC0gdXRpbHMuY291bnRaZXJvcyhzelBhcnQuZGF0YSk7XG5cdH1cblx0dGhpcy5zaXplID0gc3o7XG59XG5cbktleS5mb3JtYXRzID0gZm9ybWF0cztcblxuS2V5LnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIChmb3JtYXQsIG9wdGlvbnMpIHtcblx0aWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKVxuXHRcdGZvcm1hdCA9ICdzc2gnO1xuXHRhc3NlcnQuc3RyaW5nKGZvcm1hdCwgJ2Zvcm1hdCcpO1xuXHRhc3NlcnQub2JqZWN0KGZvcm1hdHNbZm9ybWF0XSwgJ2Zvcm1hdHNbZm9ybWF0XScpO1xuXHRhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcblxuXHRpZiAoZm9ybWF0ID09PSAncmZjNDI1MycpIHtcblx0XHRpZiAodGhpcy5fcmZjNDI1M0NhY2hlID09PSB1bmRlZmluZWQpXG5cdFx0XHR0aGlzLl9yZmM0MjUzQ2FjaGUgPSBmb3JtYXRzWydyZmM0MjUzJ10ud3JpdGUodGhpcyk7XG5cdFx0cmV0dXJuICh0aGlzLl9yZmM0MjUzQ2FjaGUpO1xuXHR9XG5cblx0cmV0dXJuIChmb3JtYXRzW2Zvcm1hdF0ud3JpdGUodGhpcywgb3B0aW9ucykpO1xufTtcblxuS2V5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChmb3JtYXQsIG9wdGlvbnMpIHtcblx0cmV0dXJuICh0aGlzLnRvQnVmZmVyKGZvcm1hdCwgb3B0aW9ucykudG9TdHJpbmcoKSk7XG59O1xuXG5LZXkucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoYWxnbywgdHlwZSkge1xuXHRhc3NlcnQuc3RyaW5nKGFsZ28sICdhbGdvcml0aG0nKTtcblx0YXNzZXJ0Lm9wdGlvbmFsU3RyaW5nKHR5cGUsICd0eXBlJyk7XG5cdGlmICh0eXBlID09PSB1bmRlZmluZWQpXG5cdFx0dHlwZSA9ICdzc2gnO1xuXHRhbGdvID0gYWxnby50b0xvd2VyQ2FzZSgpO1xuXHRpZiAoYWxncy5oYXNoQWxnc1thbGdvXSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKGFsZ28pKTtcblxuXHR2YXIgY2FjaGVLZXkgPSBhbGdvICsgJ3x8JyArIHR5cGU7XG5cdGlmICh0aGlzLl9oYXNoQ2FjaGVbY2FjaGVLZXldKVxuXHRcdHJldHVybiAodGhpcy5faGFzaENhY2hlW2NhY2hlS2V5XSk7XG5cblx0dmFyIGJ1Zjtcblx0aWYgKHR5cGUgPT09ICdzc2gnKSB7XG5cdFx0YnVmID0gdGhpcy50b0J1ZmZlcigncmZjNDI1MycpO1xuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICdzcGtpJykge1xuXHRcdGJ1ZiA9IGZvcm1hdHMucGtjczgucGtjczhUb0J1ZmZlcih0aGlzKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdIYXNoIHR5cGUgJyArIHR5cGUgKyAnIG5vdCBzdXBwb3J0ZWQnKSk7XG5cdH1cblx0dmFyIGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvKS51cGRhdGUoYnVmKS5kaWdlc3QoKTtcblx0dGhpcy5faGFzaENhY2hlW2NhY2hlS2V5XSA9IGhhc2g7XG5cdHJldHVybiAoaGFzaCk7XG59O1xuXG5LZXkucHJvdG90eXBlLmZpbmdlcnByaW50ID0gZnVuY3Rpb24gKGFsZ28sIHR5cGUpIHtcblx0aWYgKGFsZ28gPT09IHVuZGVmaW5lZClcblx0XHRhbGdvID0gJ3NoYTI1Nic7XG5cdGlmICh0eXBlID09PSB1bmRlZmluZWQpXG5cdFx0dHlwZSA9ICdzc2gnO1xuXHRhc3NlcnQuc3RyaW5nKGFsZ28sICdhbGdvcml0aG0nKTtcblx0YXNzZXJ0LnN0cmluZyh0eXBlLCAndHlwZScpO1xuXHR2YXIgb3B0cyA9IHtcblx0XHR0eXBlOiAna2V5Jyxcblx0XHRoYXNoOiB0aGlzLmhhc2goYWxnbywgdHlwZSksXG5cdFx0YWxnb3JpdGhtOiBhbGdvLFxuXHRcdGhhc2hUeXBlOiB0eXBlXG5cdH07XG5cdHJldHVybiAobmV3IEZpbmdlcnByaW50KG9wdHMpKTtcbn07XG5cbktleS5wcm90b3R5cGUuZGVmYXVsdEhhc2hBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBoYXNoQWxnbyA9ICdzaGExJztcblx0aWYgKHRoaXMudHlwZSA9PT0gJ3JzYScpXG5cdFx0aGFzaEFsZ28gPSAnc2hhMjU2Jztcblx0aWYgKHRoaXMudHlwZSA9PT0gJ2RzYScgJiYgdGhpcy5zaXplID4gMTAyNClcblx0XHRoYXNoQWxnbyA9ICdzaGEyNTYnO1xuXHRpZiAodGhpcy50eXBlID09PSAnZWQyNTUxOScpXG5cdFx0aGFzaEFsZ28gPSAnc2hhNTEyJztcblx0aWYgKHRoaXMudHlwZSA9PT0gJ2VjZHNhJykge1xuXHRcdGlmICh0aGlzLnNpemUgPD0gMjU2KVxuXHRcdFx0aGFzaEFsZ28gPSAnc2hhMjU2Jztcblx0XHRlbHNlIGlmICh0aGlzLnNpemUgPD0gMzg0KVxuXHRcdFx0aGFzaEFsZ28gPSAnc2hhMzg0Jztcblx0XHRlbHNlXG5cdFx0XHRoYXNoQWxnbyA9ICdzaGE1MTInO1xuXHR9XG5cdHJldHVybiAoaGFzaEFsZ28pO1xufTtcblxuS2V5LnByb3RvdHlwZS5jcmVhdGVWZXJpZnkgPSBmdW5jdGlvbiAoaGFzaEFsZ28pIHtcblx0aWYgKGhhc2hBbGdvID09PSB1bmRlZmluZWQpXG5cdFx0aGFzaEFsZ28gPSB0aGlzLmRlZmF1bHRIYXNoQWxnb3JpdGhtKCk7XG5cdGFzc2VydC5zdHJpbmcoaGFzaEFsZ28sICdoYXNoIGFsZ29yaXRobScpO1xuXG5cdC8qIEVEMjU1MTkgaXMgbm90IHN1cHBvcnRlZCBieSBPcGVuU1NMLCB1c2UgYSBqYXZhc2NyaXB0IGltcGwuICovXG5cdGlmICh0aGlzLnR5cGUgPT09ICdlZDI1NTE5JyAmJiBlZENvbXBhdCAhPT0gdW5kZWZpbmVkKVxuXHRcdHJldHVybiAobmV3IGVkQ29tcGF0LlZlcmlmaWVyKHRoaXMsIGhhc2hBbGdvKSk7XG5cdGlmICh0aGlzLnR5cGUgPT09ICdjdXJ2ZTI1NTE5Jylcblx0XHR0aHJvdyAobmV3IEVycm9yKCdDdXJ2ZTI1NTE5IGtleXMgYXJlIG5vdCBzdWl0YWJsZSBmb3IgJyArXG5cdFx0ICAgICdzaWduaW5nIG9yIHZlcmlmaWNhdGlvbicpKTtcblxuXHR2YXIgdiwgbm0sIGVycjtcblx0dHJ5IHtcblx0XHRubSA9IGhhc2hBbGdvLnRvVXBwZXJDYXNlKCk7XG5cdFx0diA9IGNyeXB0by5jcmVhdGVWZXJpZnkobm0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0ZXJyID0gZTtcblx0fVxuXHRpZiAodiA9PT0gdW5kZWZpbmVkIHx8IChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJlxuXHQgICAgZXJyLm1lc3NhZ2UubWF0Y2goL1Vua25vd24gbWVzc2FnZSBkaWdlc3QvKSkpIHtcblx0XHRubSA9ICdSU0EtJztcblx0XHRubSArPSBoYXNoQWxnby50b1VwcGVyQ2FzZSgpO1xuXHRcdHYgPSBjcnlwdG8uY3JlYXRlVmVyaWZ5KG5tKTtcblx0fVxuXHRhc3NlcnQub2sodiwgJ2ZhaWxlZCB0byBjcmVhdGUgdmVyaWZpZXInKTtcblx0dmFyIG9sZFZlcmlmeSA9IHYudmVyaWZ5LmJpbmQodik7XG5cdHZhciBrZXkgPSB0aGlzLnRvQnVmZmVyKCdwa2NzOCcpO1xuXHR2YXIgY3VydmUgPSB0aGlzLmN1cnZlO1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHYudmVyaWZ5ID0gZnVuY3Rpb24gKHNpZ25hdHVyZSwgZm10KSB7XG5cdFx0aWYgKFNpZ25hdHVyZS5pc1NpZ25hdHVyZShzaWduYXR1cmUsIFsyLCAwXSkpIHtcblx0XHRcdGlmIChzaWduYXR1cmUudHlwZSAhPT0gc2VsZi50eXBlKVxuXHRcdFx0XHRyZXR1cm4gKGZhbHNlKTtcblx0XHRcdGlmIChzaWduYXR1cmUuaGFzaEFsZ29yaXRobSAmJlxuXHRcdFx0ICAgIHNpZ25hdHVyZS5oYXNoQWxnb3JpdGhtICE9PSBoYXNoQWxnbylcblx0XHRcdFx0cmV0dXJuIChmYWxzZSk7XG5cdFx0XHRpZiAoc2lnbmF0dXJlLmN1cnZlICYmIHNlbGYudHlwZSA9PT0gJ2VjZHNhJyAmJlxuXHRcdFx0ICAgIHNpZ25hdHVyZS5jdXJ2ZSAhPT0gY3VydmUpXG5cdFx0XHRcdHJldHVybiAoZmFsc2UpO1xuXHRcdFx0cmV0dXJuIChvbGRWZXJpZnkoa2V5LCBzaWduYXR1cmUudG9CdWZmZXIoJ2FzbjEnKSkpO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgKHNpZ25hdHVyZSkgPT09ICdzdHJpbmcnIHx8XG5cdFx0ICAgIEJ1ZmZlci5pc0J1ZmZlcihzaWduYXR1cmUpKSB7XG5cdFx0XHRyZXR1cm4gKG9sZFZlcmlmeShrZXksIHNpZ25hdHVyZSwgZm10KSk7XG5cblx0XHQvKlxuXHRcdCAqIEF2b2lkIGRvaW5nIHRoaXMgb24gdmFsaWQgYXJndW1lbnRzLCB3YWxraW5nIHRoZSBwcm90b3R5cGVcblx0XHQgKiBjaGFpbiBjYW4gYmUgcXVpdGUgc2xvdy5cblx0XHQgKi9cblx0XHR9IGVsc2UgaWYgKFNpZ25hdHVyZS5pc1NpZ25hdHVyZShzaWduYXR1cmUsIFsxLCAwXSkpIHtcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ3NpZ25hdHVyZSB3YXMgY3JlYXRlZCBieSB0b28gb2xkICcgK1xuXHRcdFx0ICAgICdhIHZlcnNpb24gb2Ygc3NocGsgYW5kIGNhbm5vdCBiZSB2ZXJpZmllZCcpKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyAobmV3IFR5cGVFcnJvcignc2lnbmF0dXJlIG11c3QgYmUgYSBzdHJpbmcsICcgK1xuXHRcdFx0ICAgICdCdWZmZXIsIG9yIFNpZ25hdHVyZSBvYmplY3QnKSk7XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gKHYpO1xufTtcblxuS2V5LnByb3RvdHlwZS5jcmVhdGVEaWZmaWVIZWxsbWFuID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodGhpcy50eXBlID09PSAncnNhJylcblx0XHR0aHJvdyAobmV3IEVycm9yKCdSU0Ega2V5cyBkbyBub3Qgc3VwcG9ydCBEaWZmaWUtSGVsbG1hbicpKTtcblxuXHRyZXR1cm4gKG5ldyBEaWZmaWVIZWxsbWFuKHRoaXMpKTtcbn07XG5LZXkucHJvdG90eXBlLmNyZWF0ZURIID0gS2V5LnByb3RvdHlwZS5jcmVhdGVEaWZmaWVIZWxsbWFuO1xuXG5LZXkucGFyc2UgPSBmdW5jdGlvbiAoZGF0YSwgZm9ybWF0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgKGRhdGEpICE9PSAnc3RyaW5nJylcblx0XHRhc3NlcnQuYnVmZmVyKGRhdGEsICdkYXRhJyk7XG5cdGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZClcblx0XHRmb3JtYXQgPSAnYXV0byc7XG5cdGFzc2VydC5zdHJpbmcoZm9ybWF0LCAnZm9ybWF0Jyk7XG5cdGlmICh0eXBlb2YgKG9wdGlvbnMpID09PSAnc3RyaW5nJylcblx0XHRvcHRpb25zID0geyBmaWxlbmFtZTogb3B0aW9ucyB9O1xuXHRhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcblx0aWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZClcblx0XHRvcHRpb25zID0ge307XG5cdGFzc2VydC5vcHRpb25hbFN0cmluZyhvcHRpb25zLmZpbGVuYW1lLCAnb3B0aW9ucy5maWxlbmFtZScpO1xuXHRpZiAob3B0aW9ucy5maWxlbmFtZSA9PT0gdW5kZWZpbmVkKVxuXHRcdG9wdGlvbnMuZmlsZW5hbWUgPSAnKHVubmFtZWQpJztcblxuXHRhc3NlcnQub2JqZWN0KGZvcm1hdHNbZm9ybWF0XSwgJ2Zvcm1hdHNbZm9ybWF0XScpO1xuXG5cdHRyeSB7XG5cdFx0dmFyIGsgPSBmb3JtYXRzW2Zvcm1hdF0ucmVhZChkYXRhLCBvcHRpb25zKTtcblx0XHRpZiAoayBpbnN0YW5jZW9mIFByaXZhdGVLZXkpXG5cdFx0XHRrID0gay50b1B1YmxpYygpO1xuXHRcdGlmICghay5jb21tZW50KVxuXHRcdFx0ay5jb21tZW50ID0gb3B0aW9ucy5maWxlbmFtZTtcblx0XHRyZXR1cm4gKGspO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKGUubmFtZSA9PT0gJ0tleUVuY3J5cHRlZEVycm9yJylcblx0XHRcdHRocm93IChlKTtcblx0XHR0aHJvdyAobmV3IEtleVBhcnNlRXJyb3Iob3B0aW9ucy5maWxlbmFtZSwgZm9ybWF0LCBlKSk7XG5cdH1cbn07XG5cbktleS5pc0tleSA9IGZ1bmN0aW9uIChvYmosIHZlcikge1xuXHRyZXR1cm4gKHV0aWxzLmlzQ29tcGF0aWJsZShvYmosIEtleSwgdmVyKSk7XG59O1xuXG4vKlxuICogQVBJIHZlcnNpb25zIGZvciBLZXk6XG4gKiBbMSwwXSAtLSBpbml0aWFsIHZlciwgbWF5IHRha2UgU2lnbmF0dXJlIGZvciBjcmVhdGVWZXJpZnkgb3IgbWF5IG5vdFxuICogWzEsMV0gLS0gYWRkZWQgcGtjczEsIHBrY3M4IGZvcm1hdHNcbiAqIFsxLDJdIC0tIGFkZGVkIGF1dG8sIHNzaC1wcml2YXRlLCBvcGVuc3NoIGZvcm1hdHNcbiAqIFsxLDNdIC0tIGFkZGVkIGRlZmF1bHRIYXNoQWxnb3JpdGhtXG4gKiBbMSw0XSAtLSBhZGRlZCBlZCBzdXBwb3J0LCBjcmVhdGVESFxuICogWzEsNV0gLS0gZmlyc3QgZXhwbGljaXRseSB0YWdnZWQgdmVyc2lvblxuICogWzEsNl0gLS0gY2hhbmdlZCBlZDI1NTE5IHBhcnQgbmFtZXNcbiAqIFsxLDddIC0tIHNwa2kgaGFzaCB0eXBlc1xuICovXG5LZXkucHJvdG90eXBlLl9zc2hwa0FwaVZlcnNpb24gPSBbMSwgN107XG5cbktleS5fb2xkVmVyc2lvbkRldGVjdCA9IGZ1bmN0aW9uIChvYmopIHtcblx0YXNzZXJ0LmZ1bmMob2JqLnRvQnVmZmVyKTtcblx0YXNzZXJ0LmZ1bmMob2JqLmZpbmdlcnByaW50KTtcblx0aWYgKG9iai5jcmVhdGVESClcblx0XHRyZXR1cm4gKFsxLCA0XSk7XG5cdGlmIChvYmouZGVmYXVsdEhhc2hBbGdvcml0aG0pXG5cdFx0cmV0dXJuIChbMSwgM10pO1xuXHRpZiAob2JqLmZvcm1hdHNbJ2F1dG8nXSlcblx0XHRyZXR1cm4gKFsxLCAyXSk7XG5cdGlmIChvYmouZm9ybWF0c1sncGtjczEnXSlcblx0XHRyZXR1cm4gKFsxLCAxXSk7XG5cdHJldHVybiAoWzEsIDBdKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/key.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/private-key.js":
/*!***********************************************!*\
  !*** ./node_modules/sshpk/lib/private-key.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2017 Joyent, Inc.\n\nmodule.exports = PrivateKey;\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ./algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar Fingerprint = __webpack_require__(/*! ./fingerprint */ \"(action-browser)/./node_modules/sshpk/lib/fingerprint.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"(action-browser)/./node_modules/sshpk/lib/signature.js\");\nvar errs = __webpack_require__(/*! ./errors */ \"(action-browser)/./node_modules/sshpk/lib/errors.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar utils = __webpack_require__(/*! ./utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar dhe = __webpack_require__(/*! ./dhe */ \"(action-browser)/./node_modules/sshpk/lib/dhe.js\");\nvar generateECDSA = dhe.generateECDSA;\nvar generateED25519 = dhe.generateED25519;\nvar edCompat = __webpack_require__(/*! ./ed-compat */ \"(action-browser)/./node_modules/sshpk/lib/ed-compat.js\");\nvar nacl = __webpack_require__(/*! tweetnacl */ \"(action-browser)/./node_modules/tweetnacl/nacl-fast.js\");\n\nvar Key = __webpack_require__(/*! ./key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\n\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\nvar KeyParseError = errs.KeyParseError;\nvar KeyEncryptedError = errs.KeyEncryptedError;\n\nvar formats = {};\nformats['auto'] = __webpack_require__(/*! ./formats/auto */ \"(action-browser)/./node_modules/sshpk/lib/formats/auto.js\");\nformats['pem'] = __webpack_require__(/*! ./formats/pem */ \"(action-browser)/./node_modules/sshpk/lib/formats/pem.js\");\nformats['pkcs1'] = __webpack_require__(/*! ./formats/pkcs1 */ \"(action-browser)/./node_modules/sshpk/lib/formats/pkcs1.js\");\nformats['pkcs8'] = __webpack_require__(/*! ./formats/pkcs8 */ \"(action-browser)/./node_modules/sshpk/lib/formats/pkcs8.js\");\nformats['rfc4253'] = __webpack_require__(/*! ./formats/rfc4253 */ \"(action-browser)/./node_modules/sshpk/lib/formats/rfc4253.js\");\nformats['ssh-private'] = __webpack_require__(/*! ./formats/ssh-private */ \"(action-browser)/./node_modules/sshpk/lib/formats/ssh-private.js\");\nformats['openssh'] = formats['ssh-private'];\nformats['ssh'] = formats['ssh-private'];\nformats['dnssec'] = __webpack_require__(/*! ./formats/dnssec */ \"(action-browser)/./node_modules/sshpk/lib/formats/dnssec.js\");\nformats['putty'] = __webpack_require__(/*! ./formats/putty */ \"(action-browser)/./node_modules/sshpk/lib/formats/putty.js\");\n\nfunction PrivateKey(opts) {\n\tassert.object(opts, 'options');\n\tKey.call(this, opts);\n\n\tthis._pubCache = undefined;\n}\nutil.inherits(PrivateKey, Key);\n\nPrivateKey.formats = formats;\n\nPrivateKey.prototype.toBuffer = function (format, options) {\n\tif (format === undefined)\n\t\tformat = 'pkcs1';\n\tassert.string(format, 'format');\n\tassert.object(formats[format], 'formats[format]');\n\tassert.optionalObject(options, 'options');\n\n\treturn (formats[format].write(this, options));\n};\n\nPrivateKey.prototype.hash = function (algo, type) {\n\treturn (this.toPublic().hash(algo, type));\n};\n\nPrivateKey.prototype.fingerprint = function (algo, type) {\n\treturn (this.toPublic().fingerprint(algo, type));\n};\n\nPrivateKey.prototype.toPublic = function () {\n\tif (this._pubCache)\n\t\treturn (this._pubCache);\n\n\tvar algInfo = algs.info[this.type];\n\tvar pubParts = [];\n\tfor (var i = 0; i < algInfo.parts.length; ++i) {\n\t\tvar p = algInfo.parts[i];\n\t\tpubParts.push(this.part[p]);\n\t}\n\n\tthis._pubCache = new Key({\n\t\ttype: this.type,\n\t\tsource: this,\n\t\tparts: pubParts\n\t});\n\tif (this.comment)\n\t\tthis._pubCache.comment = this.comment;\n\treturn (this._pubCache);\n};\n\nPrivateKey.prototype.derive = function (newType) {\n\tassert.string(newType, 'type');\n\tvar priv, pub, pair;\n\n\tif (this.type === 'ed25519' && newType === 'curve25519') {\n\t\tpriv = this.part.k.data;\n\t\tif (priv[0] === 0x00)\n\t\t\tpriv = priv.slice(1);\n\n\t\tpair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));\n\t\tpub = Buffer.from(pair.publicKey);\n\n\t\treturn (new PrivateKey({\n\t\t\ttype: 'curve25519',\n\t\t\tparts: [\n\t\t\t\t{ name: 'A', data: utils.mpNormalize(pub) },\n\t\t\t\t{ name: 'k', data: utils.mpNormalize(priv) }\n\t\t\t]\n\t\t}));\n\t} else if (this.type === 'curve25519' && newType === 'ed25519') {\n\t\tpriv = this.part.k.data;\n\t\tif (priv[0] === 0x00)\n\t\t\tpriv = priv.slice(1);\n\n\t\tpair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));\n\t\tpub = Buffer.from(pair.publicKey);\n\n\t\treturn (new PrivateKey({\n\t\t\ttype: 'ed25519',\n\t\t\tparts: [\n\t\t\t\t{ name: 'A', data: utils.mpNormalize(pub) },\n\t\t\t\t{ name: 'k', data: utils.mpNormalize(priv) }\n\t\t\t]\n\t\t}));\n\t}\n\tthrow (new Error('Key derivation not supported from ' + this.type +\n\t    ' to ' + newType));\n};\n\nPrivateKey.prototype.createVerify = function (hashAlgo) {\n\treturn (this.toPublic().createVerify(hashAlgo));\n};\n\nPrivateKey.prototype.createSign = function (hashAlgo) {\n\tif (hashAlgo === undefined)\n\t\thashAlgo = this.defaultHashAlgorithm();\n\tassert.string(hashAlgo, 'hash algorithm');\n\n\t/* ED25519 is not supported by OpenSSL, use a javascript impl. */\n\tif (this.type === 'ed25519' && edCompat !== undefined)\n\t\treturn (new edCompat.Signer(this, hashAlgo));\n\tif (this.type === 'curve25519')\n\t\tthrow (new Error('Curve25519 keys are not suitable for ' +\n\t\t    'signing or verification'));\n\n\tvar v, nm, err;\n\ttry {\n\t\tnm = hashAlgo.toUpperCase();\n\t\tv = crypto.createSign(nm);\n\t} catch (e) {\n\t\terr = e;\n\t}\n\tif (v === undefined || (err instanceof Error &&\n\t    err.message.match(/Unknown message digest/))) {\n\t\tnm = 'RSA-';\n\t\tnm += hashAlgo.toUpperCase();\n\t\tv = crypto.createSign(nm);\n\t}\n\tassert.ok(v, 'failed to create verifier');\n\tvar oldSign = v.sign.bind(v);\n\tvar key = this.toBuffer('pkcs1');\n\tvar type = this.type;\n\tvar curve = this.curve;\n\tv.sign = function () {\n\t\tvar sig = oldSign(key);\n\t\tif (typeof (sig) === 'string')\n\t\t\tsig = Buffer.from(sig, 'binary');\n\t\tsig = Signature.parse(sig, type, 'asn1');\n\t\tsig.hashAlgorithm = hashAlgo;\n\t\tsig.curve = curve;\n\t\treturn (sig);\n\t};\n\treturn (v);\n};\n\nPrivateKey.parse = function (data, format, options) {\n\tif (typeof (data) !== 'string')\n\t\tassert.buffer(data, 'data');\n\tif (format === undefined)\n\t\tformat = 'auto';\n\tassert.string(format, 'format');\n\tif (typeof (options) === 'string')\n\t\toptions = { filename: options };\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.optionalString(options.filename, 'options.filename');\n\tif (options.filename === undefined)\n\t\toptions.filename = '(unnamed)';\n\n\tassert.object(formats[format], 'formats[format]');\n\n\ttry {\n\t\tvar k = formats[format].read(data, options);\n\t\tassert.ok(k instanceof PrivateKey, 'key is not a private key');\n\t\tif (!k.comment)\n\t\t\tk.comment = options.filename;\n\t\treturn (k);\n\t} catch (e) {\n\t\tif (e.name === 'KeyEncryptedError')\n\t\t\tthrow (e);\n\t\tthrow (new KeyParseError(options.filename, format, e));\n\t}\n};\n\nPrivateKey.isPrivateKey = function (obj, ver) {\n\treturn (utils.isCompatible(obj, PrivateKey, ver));\n};\n\nPrivateKey.generate = function (type, options) {\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.object(options, 'options');\n\n\tswitch (type) {\n\tcase 'ecdsa':\n\t\tif (options.curve === undefined)\n\t\t\toptions.curve = 'nistp256';\n\t\tassert.string(options.curve, 'options.curve');\n\t\treturn (generateECDSA(options.curve));\n\tcase 'ed25519':\n\t\treturn (generateED25519());\n\tdefault:\n\t\tthrow (new Error('Key generation not supported with key ' +\n\t\t    'type \"' + type + '\"'));\n\t}\n};\n\n/*\n * API versions for PrivateKey:\n * [1,0] -- initial ver\n * [1,1] -- added auto, pkcs[18], openssh/ssh-private formats\n * [1,2] -- added defaultHashAlgorithm\n * [1,3] -- added derive, ed, createDH\n * [1,4] -- first tagged version\n * [1,5] -- changed ed25519 part names and format\n * [1,6] -- type arguments for hash() and fingerprint()\n */\nPrivateKey.prototype._sshpkApiVersion = [1, 6];\n\nPrivateKey._oldVersionDetect = function (obj) {\n\tassert.func(obj.toPublic);\n\tassert.func(obj.createSign);\n\tif (obj.derive)\n\t\treturn ([1, 3]);\n\tif (obj.defaultHashAlgorithm)\n\t\treturn ([1, 2]);\n\tif (obj.formats['auto'])\n\t\treturn ([1, 1]);\n\treturn ([1, 0]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvcHJpdmF0ZS1rZXkuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDBFQUFhO0FBQ2xDLGFBQWEseUdBQThCO0FBQzNDLFdBQVcsbUJBQU8sQ0FBQyxpRUFBUTtBQUMzQixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMsK0VBQWU7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsMkVBQWE7QUFDckMsV0FBVyxtQkFBTyxDQUFDLHFFQUFVO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsbUVBQVM7QUFDN0IsVUFBVSxtQkFBTyxDQUFDLCtEQUFPO0FBQ3pCO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsMkVBQWE7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLHlFQUFXOztBQUU5QixVQUFVLG1CQUFPLENBQUMsK0RBQU87O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFnQjtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBZTtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBaUI7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsbUZBQWlCO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLHVGQUFtQjtBQUNoRCx5QkFBeUIsbUJBQU8sQ0FBQywrRkFBdUI7QUFDeEQ7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHFGQUFrQjtBQUM5QyxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBaUI7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seUNBQXlDO0FBQy9DLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvcHJpdmF0ZS1rZXkuanM/YWM5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNyBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSBQcml2YXRlS2V5O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4vYWxncycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIEZpbmdlcnByaW50ID0gcmVxdWlyZSgnLi9maW5nZXJwcmludCcpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG52YXIgZXJycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBkaGUgPSByZXF1aXJlKCcuL2RoZScpO1xudmFyIGdlbmVyYXRlRUNEU0EgPSBkaGUuZ2VuZXJhdGVFQ0RTQTtcbnZhciBnZW5lcmF0ZUVEMjU1MTkgPSBkaGUuZ2VuZXJhdGVFRDI1NTE5O1xudmFyIGVkQ29tcGF0ID0gcmVxdWlyZSgnLi9lZC1jb21wYXQnKTtcbnZhciBuYWNsID0gcmVxdWlyZSgndHdlZXRuYWNsJyk7XG5cbnZhciBLZXkgPSByZXF1aXJlKCcuL2tleScpO1xuXG52YXIgSW52YWxpZEFsZ29yaXRobUVycm9yID0gZXJycy5JbnZhbGlkQWxnb3JpdGhtRXJyb3I7XG52YXIgS2V5UGFyc2VFcnJvciA9IGVycnMuS2V5UGFyc2VFcnJvcjtcbnZhciBLZXlFbmNyeXB0ZWRFcnJvciA9IGVycnMuS2V5RW5jcnlwdGVkRXJyb3I7XG5cbnZhciBmb3JtYXRzID0ge307XG5mb3JtYXRzWydhdXRvJ10gPSByZXF1aXJlKCcuL2Zvcm1hdHMvYXV0bycpO1xuZm9ybWF0c1sncGVtJ10gPSByZXF1aXJlKCcuL2Zvcm1hdHMvcGVtJyk7XG5mb3JtYXRzWydwa2NzMSddID0gcmVxdWlyZSgnLi9mb3JtYXRzL3BrY3MxJyk7XG5mb3JtYXRzWydwa2NzOCddID0gcmVxdWlyZSgnLi9mb3JtYXRzL3BrY3M4Jyk7XG5mb3JtYXRzWydyZmM0MjUzJ10gPSByZXF1aXJlKCcuL2Zvcm1hdHMvcmZjNDI1MycpO1xuZm9ybWF0c1snc3NoLXByaXZhdGUnXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9zc2gtcHJpdmF0ZScpO1xuZm9ybWF0c1snb3BlbnNzaCddID0gZm9ybWF0c1snc3NoLXByaXZhdGUnXTtcbmZvcm1hdHNbJ3NzaCddID0gZm9ybWF0c1snc3NoLXByaXZhdGUnXTtcbmZvcm1hdHNbJ2Ruc3NlYyddID0gcmVxdWlyZSgnLi9mb3JtYXRzL2Ruc3NlYycpO1xuZm9ybWF0c1sncHV0dHknXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9wdXR0eScpO1xuXG5mdW5jdGlvbiBQcml2YXRlS2V5KG9wdHMpIHtcblx0YXNzZXJ0Lm9iamVjdChvcHRzLCAnb3B0aW9ucycpO1xuXHRLZXkuY2FsbCh0aGlzLCBvcHRzKTtcblxuXHR0aGlzLl9wdWJDYWNoZSA9IHVuZGVmaW5lZDtcbn1cbnV0aWwuaW5oZXJpdHMoUHJpdmF0ZUtleSwgS2V5KTtcblxuUHJpdmF0ZUtleS5mb3JtYXRzID0gZm9ybWF0cztcblxuUHJpdmF0ZUtleS5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiAoZm9ybWF0LCBvcHRpb25zKSB7XG5cdGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZClcblx0XHRmb3JtYXQgPSAncGtjczEnO1xuXHRhc3NlcnQuc3RyaW5nKGZvcm1hdCwgJ2Zvcm1hdCcpO1xuXHRhc3NlcnQub2JqZWN0KGZvcm1hdHNbZm9ybWF0XSwgJ2Zvcm1hdHNbZm9ybWF0XScpO1xuXHRhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcblxuXHRyZXR1cm4gKGZvcm1hdHNbZm9ybWF0XS53cml0ZSh0aGlzLCBvcHRpb25zKSk7XG59O1xuXG5Qcml2YXRlS2V5LnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKGFsZ28sIHR5cGUpIHtcblx0cmV0dXJuICh0aGlzLnRvUHVibGljKCkuaGFzaChhbGdvLCB0eXBlKSk7XG59O1xuXG5Qcml2YXRlS2V5LnByb3RvdHlwZS5maW5nZXJwcmludCA9IGZ1bmN0aW9uIChhbGdvLCB0eXBlKSB7XG5cdHJldHVybiAodGhpcy50b1B1YmxpYygpLmZpbmdlcnByaW50KGFsZ28sIHR5cGUpKTtcbn07XG5cblByaXZhdGVLZXkucHJvdG90eXBlLnRvUHVibGljID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodGhpcy5fcHViQ2FjaGUpXG5cdFx0cmV0dXJuICh0aGlzLl9wdWJDYWNoZSk7XG5cblx0dmFyIGFsZ0luZm8gPSBhbGdzLmluZm9bdGhpcy50eXBlXTtcblx0dmFyIHB1YlBhcnRzID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYWxnSW5mby5wYXJ0cy5sZW5ndGg7ICsraSkge1xuXHRcdHZhciBwID0gYWxnSW5mby5wYXJ0c1tpXTtcblx0XHRwdWJQYXJ0cy5wdXNoKHRoaXMucGFydFtwXSk7XG5cdH1cblxuXHR0aGlzLl9wdWJDYWNoZSA9IG5ldyBLZXkoe1xuXHRcdHR5cGU6IHRoaXMudHlwZSxcblx0XHRzb3VyY2U6IHRoaXMsXG5cdFx0cGFydHM6IHB1YlBhcnRzXG5cdH0pO1xuXHRpZiAodGhpcy5jb21tZW50KVxuXHRcdHRoaXMuX3B1YkNhY2hlLmNvbW1lbnQgPSB0aGlzLmNvbW1lbnQ7XG5cdHJldHVybiAodGhpcy5fcHViQ2FjaGUpO1xufTtcblxuUHJpdmF0ZUtleS5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24gKG5ld1R5cGUpIHtcblx0YXNzZXJ0LnN0cmluZyhuZXdUeXBlLCAndHlwZScpO1xuXHR2YXIgcHJpdiwgcHViLCBwYWlyO1xuXG5cdGlmICh0aGlzLnR5cGUgPT09ICdlZDI1NTE5JyAmJiBuZXdUeXBlID09PSAnY3VydmUyNTUxOScpIHtcblx0XHRwcml2ID0gdGhpcy5wYXJ0LmsuZGF0YTtcblx0XHRpZiAocHJpdlswXSA9PT0gMHgwMClcblx0XHRcdHByaXYgPSBwcml2LnNsaWNlKDEpO1xuXG5cdFx0cGFpciA9IG5hY2wuYm94LmtleVBhaXIuZnJvbVNlY3JldEtleShuZXcgVWludDhBcnJheShwcml2KSk7XG5cdFx0cHViID0gQnVmZmVyLmZyb20ocGFpci5wdWJsaWNLZXkpO1xuXG5cdFx0cmV0dXJuIChuZXcgUHJpdmF0ZUtleSh7XG5cdFx0XHR0eXBlOiAnY3VydmUyNTUxOScsXG5cdFx0XHRwYXJ0czogW1xuXHRcdFx0XHR7IG5hbWU6ICdBJywgZGF0YTogdXRpbHMubXBOb3JtYWxpemUocHViKSB9LFxuXHRcdFx0XHR7IG5hbWU6ICdrJywgZGF0YTogdXRpbHMubXBOb3JtYWxpemUocHJpdikgfVxuXHRcdFx0XVxuXHRcdH0pKTtcblx0fSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdjdXJ2ZTI1NTE5JyAmJiBuZXdUeXBlID09PSAnZWQyNTUxOScpIHtcblx0XHRwcml2ID0gdGhpcy5wYXJ0LmsuZGF0YTtcblx0XHRpZiAocHJpdlswXSA9PT0gMHgwMClcblx0XHRcdHByaXYgPSBwcml2LnNsaWNlKDEpO1xuXG5cdFx0cGFpciA9IG5hY2wuc2lnbi5rZXlQYWlyLmZyb21TZWVkKG5ldyBVaW50OEFycmF5KHByaXYpKTtcblx0XHRwdWIgPSBCdWZmZXIuZnJvbShwYWlyLnB1YmxpY0tleSk7XG5cblx0XHRyZXR1cm4gKG5ldyBQcml2YXRlS2V5KHtcblx0XHRcdHR5cGU6ICdlZDI1NTE5Jyxcblx0XHRcdHBhcnRzOiBbXG5cdFx0XHRcdHsgbmFtZTogJ0EnLCBkYXRhOiB1dGlscy5tcE5vcm1hbGl6ZShwdWIpIH0sXG5cdFx0XHRcdHsgbmFtZTogJ2snLCBkYXRhOiB1dGlscy5tcE5vcm1hbGl6ZShwcml2KSB9XG5cdFx0XHRdXG5cdFx0fSkpO1xuXHR9XG5cdHRocm93IChuZXcgRXJyb3IoJ0tleSBkZXJpdmF0aW9uIG5vdCBzdXBwb3J0ZWQgZnJvbSAnICsgdGhpcy50eXBlICtcblx0ICAgICcgdG8gJyArIG5ld1R5cGUpKTtcbn07XG5cblByaXZhdGVLZXkucHJvdG90eXBlLmNyZWF0ZVZlcmlmeSA9IGZ1bmN0aW9uIChoYXNoQWxnbykge1xuXHRyZXR1cm4gKHRoaXMudG9QdWJsaWMoKS5jcmVhdGVWZXJpZnkoaGFzaEFsZ28pKTtcbn07XG5cblByaXZhdGVLZXkucHJvdG90eXBlLmNyZWF0ZVNpZ24gPSBmdW5jdGlvbiAoaGFzaEFsZ28pIHtcblx0aWYgKGhhc2hBbGdvID09PSB1bmRlZmluZWQpXG5cdFx0aGFzaEFsZ28gPSB0aGlzLmRlZmF1bHRIYXNoQWxnb3JpdGhtKCk7XG5cdGFzc2VydC5zdHJpbmcoaGFzaEFsZ28sICdoYXNoIGFsZ29yaXRobScpO1xuXG5cdC8qIEVEMjU1MTkgaXMgbm90IHN1cHBvcnRlZCBieSBPcGVuU1NMLCB1c2UgYSBqYXZhc2NyaXB0IGltcGwuICovXG5cdGlmICh0aGlzLnR5cGUgPT09ICdlZDI1NTE5JyAmJiBlZENvbXBhdCAhPT0gdW5kZWZpbmVkKVxuXHRcdHJldHVybiAobmV3IGVkQ29tcGF0LlNpZ25lcih0aGlzLCBoYXNoQWxnbykpO1xuXHRpZiAodGhpcy50eXBlID09PSAnY3VydmUyNTUxOScpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignQ3VydmUyNTUxOSBrZXlzIGFyZSBub3Qgc3VpdGFibGUgZm9yICcgK1xuXHRcdCAgICAnc2lnbmluZyBvciB2ZXJpZmljYXRpb24nKSk7XG5cblx0dmFyIHYsIG5tLCBlcnI7XG5cdHRyeSB7XG5cdFx0bm0gPSBoYXNoQWxnby50b1VwcGVyQ2FzZSgpO1xuXHRcdHYgPSBjcnlwdG8uY3JlYXRlU2lnbihubSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRlcnIgPSBlO1xuXHR9XG5cdGlmICh2ID09PSB1bmRlZmluZWQgfHwgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmXG5cdCAgICBlcnIubWVzc2FnZS5tYXRjaCgvVW5rbm93biBtZXNzYWdlIGRpZ2VzdC8pKSkge1xuXHRcdG5tID0gJ1JTQS0nO1xuXHRcdG5tICs9IGhhc2hBbGdvLnRvVXBwZXJDYXNlKCk7XG5cdFx0diA9IGNyeXB0by5jcmVhdGVTaWduKG5tKTtcblx0fVxuXHRhc3NlcnQub2sodiwgJ2ZhaWxlZCB0byBjcmVhdGUgdmVyaWZpZXInKTtcblx0dmFyIG9sZFNpZ24gPSB2LnNpZ24uYmluZCh2KTtcblx0dmFyIGtleSA9IHRoaXMudG9CdWZmZXIoJ3BrY3MxJyk7XG5cdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXHR2YXIgY3VydmUgPSB0aGlzLmN1cnZlO1xuXHR2LnNpZ24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNpZyA9IG9sZFNpZ24oa2V5KTtcblx0XHRpZiAodHlwZW9mIChzaWcpID09PSAnc3RyaW5nJylcblx0XHRcdHNpZyA9IEJ1ZmZlci5mcm9tKHNpZywgJ2JpbmFyeScpO1xuXHRcdHNpZyA9IFNpZ25hdHVyZS5wYXJzZShzaWcsIHR5cGUsICdhc24xJyk7XG5cdFx0c2lnLmhhc2hBbGdvcml0aG0gPSBoYXNoQWxnbztcblx0XHRzaWcuY3VydmUgPSBjdXJ2ZTtcblx0XHRyZXR1cm4gKHNpZyk7XG5cdH07XG5cdHJldHVybiAodik7XG59O1xuXG5Qcml2YXRlS2V5LnBhcnNlID0gZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIChkYXRhKSAhPT0gJ3N0cmluZycpXG5cdFx0YXNzZXJ0LmJ1ZmZlcihkYXRhLCAnZGF0YScpO1xuXHRpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpXG5cdFx0Zm9ybWF0ID0gJ2F1dG8nO1xuXHRhc3NlcnQuc3RyaW5nKGZvcm1hdCwgJ2Zvcm1hdCcpO1xuXHRpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gJ3N0cmluZycpXG5cdFx0b3B0aW9ucyA9IHsgZmlsZW5hbWU6IG9wdGlvbnMgfTtcblx0YXNzZXJ0Lm9wdGlvbmFsT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG5cdGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpXG5cdFx0b3B0aW9ucyA9IHt9O1xuXHRhc3NlcnQub3B0aW9uYWxTdHJpbmcob3B0aW9ucy5maWxlbmFtZSwgJ29wdGlvbnMuZmlsZW5hbWUnKTtcblx0aWYgKG9wdGlvbnMuZmlsZW5hbWUgPT09IHVuZGVmaW5lZClcblx0XHRvcHRpb25zLmZpbGVuYW1lID0gJyh1bm5hbWVkKSc7XG5cblx0YXNzZXJ0Lm9iamVjdChmb3JtYXRzW2Zvcm1hdF0sICdmb3JtYXRzW2Zvcm1hdF0nKTtcblxuXHR0cnkge1xuXHRcdHZhciBrID0gZm9ybWF0c1tmb3JtYXRdLnJlYWQoZGF0YSwgb3B0aW9ucyk7XG5cdFx0YXNzZXJ0Lm9rKGsgaW5zdGFuY2VvZiBQcml2YXRlS2V5LCAna2V5IGlzIG5vdCBhIHByaXZhdGUga2V5Jyk7XG5cdFx0aWYgKCFrLmNvbW1lbnQpXG5cdFx0XHRrLmNvbW1lbnQgPSBvcHRpb25zLmZpbGVuYW1lO1xuXHRcdHJldHVybiAoayk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAoZS5uYW1lID09PSAnS2V5RW5jcnlwdGVkRXJyb3InKVxuXHRcdFx0dGhyb3cgKGUpO1xuXHRcdHRocm93IChuZXcgS2V5UGFyc2VFcnJvcihvcHRpb25zLmZpbGVuYW1lLCBmb3JtYXQsIGUpKTtcblx0fVxufTtcblxuUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkgPSBmdW5jdGlvbiAob2JqLCB2ZXIpIHtcblx0cmV0dXJuICh1dGlscy5pc0NvbXBhdGlibGUob2JqLCBQcml2YXRlS2V5LCB2ZXIpKTtcbn07XG5cblByaXZhdGVLZXkuZ2VuZXJhdGUgPSBmdW5jdGlvbiAodHlwZSwgb3B0aW9ucykge1xuXHRpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxuXHRcdG9wdGlvbnMgPSB7fTtcblx0YXNzZXJ0Lm9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpO1xuXG5cdHN3aXRjaCAodHlwZSkge1xuXHRjYXNlICdlY2RzYSc6XG5cdFx0aWYgKG9wdGlvbnMuY3VydmUgPT09IHVuZGVmaW5lZClcblx0XHRcdG9wdGlvbnMuY3VydmUgPSAnbmlzdHAyNTYnO1xuXHRcdGFzc2VydC5zdHJpbmcob3B0aW9ucy5jdXJ2ZSwgJ29wdGlvbnMuY3VydmUnKTtcblx0XHRyZXR1cm4gKGdlbmVyYXRlRUNEU0Eob3B0aW9ucy5jdXJ2ZSkpO1xuXHRjYXNlICdlZDI1NTE5Jzpcblx0XHRyZXR1cm4gKGdlbmVyYXRlRUQyNTUxOSgpKTtcblx0ZGVmYXVsdDpcblx0XHR0aHJvdyAobmV3IEVycm9yKCdLZXkgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkIHdpdGgga2V5ICcgK1xuXHRcdCAgICAndHlwZSBcIicgKyB0eXBlICsgJ1wiJykpO1xuXHR9XG59O1xuXG4vKlxuICogQVBJIHZlcnNpb25zIGZvciBQcml2YXRlS2V5OlxuICogWzEsMF0gLS0gaW5pdGlhbCB2ZXJcbiAqIFsxLDFdIC0tIGFkZGVkIGF1dG8sIHBrY3NbMThdLCBvcGVuc3NoL3NzaC1wcml2YXRlIGZvcm1hdHNcbiAqIFsxLDJdIC0tIGFkZGVkIGRlZmF1bHRIYXNoQWxnb3JpdGhtXG4gKiBbMSwzXSAtLSBhZGRlZCBkZXJpdmUsIGVkLCBjcmVhdGVESFxuICogWzEsNF0gLS0gZmlyc3QgdGFnZ2VkIHZlcnNpb25cbiAqIFsxLDVdIC0tIGNoYW5nZWQgZWQyNTUxOSBwYXJ0IG5hbWVzIGFuZCBmb3JtYXRcbiAqIFsxLDZdIC0tIHR5cGUgYXJndW1lbnRzIGZvciBoYXNoKCkgYW5kIGZpbmdlcnByaW50KClcbiAqL1xuUHJpdmF0ZUtleS5wcm90b3R5cGUuX3NzaHBrQXBpVmVyc2lvbiA9IFsxLCA2XTtcblxuUHJpdmF0ZUtleS5fb2xkVmVyc2lvbkRldGVjdCA9IGZ1bmN0aW9uIChvYmopIHtcblx0YXNzZXJ0LmZ1bmMob2JqLnRvUHVibGljKTtcblx0YXNzZXJ0LmZ1bmMob2JqLmNyZWF0ZVNpZ24pO1xuXHRpZiAob2JqLmRlcml2ZSlcblx0XHRyZXR1cm4gKFsxLCAzXSk7XG5cdGlmIChvYmouZGVmYXVsdEhhc2hBbGdvcml0aG0pXG5cdFx0cmV0dXJuIChbMSwgMl0pO1xuXHRpZiAob2JqLmZvcm1hdHNbJ2F1dG8nXSlcblx0XHRyZXR1cm4gKFsxLCAxXSk7XG5cdHJldHVybiAoWzEsIDBdKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/private-key.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/private-key.js":
/*!***********************************************!*\
  !*** ./node_modules/sshpk/lib/private-key.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2017 Joyent, Inc.\n\nmodule.exports = PrivateKey;\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ./algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar Fingerprint = __webpack_require__(/*! ./fingerprint */ \"(rsc)/./node_modules/sshpk/lib/fingerprint.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"(rsc)/./node_modules/sshpk/lib/signature.js\");\nvar errs = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/sshpk/lib/errors.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar dhe = __webpack_require__(/*! ./dhe */ \"(rsc)/./node_modules/sshpk/lib/dhe.js\");\nvar generateECDSA = dhe.generateECDSA;\nvar generateED25519 = dhe.generateED25519;\nvar edCompat = __webpack_require__(/*! ./ed-compat */ \"(rsc)/./node_modules/sshpk/lib/ed-compat.js\");\nvar nacl = __webpack_require__(/*! tweetnacl */ \"(rsc)/./node_modules/tweetnacl/nacl-fast.js\");\n\nvar Key = __webpack_require__(/*! ./key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\n\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\nvar KeyParseError = errs.KeyParseError;\nvar KeyEncryptedError = errs.KeyEncryptedError;\n\nvar formats = {};\nformats['auto'] = __webpack_require__(/*! ./formats/auto */ \"(rsc)/./node_modules/sshpk/lib/formats/auto.js\");\nformats['pem'] = __webpack_require__(/*! ./formats/pem */ \"(rsc)/./node_modules/sshpk/lib/formats/pem.js\");\nformats['pkcs1'] = __webpack_require__(/*! ./formats/pkcs1 */ \"(rsc)/./node_modules/sshpk/lib/formats/pkcs1.js\");\nformats['pkcs8'] = __webpack_require__(/*! ./formats/pkcs8 */ \"(rsc)/./node_modules/sshpk/lib/formats/pkcs8.js\");\nformats['rfc4253'] = __webpack_require__(/*! ./formats/rfc4253 */ \"(rsc)/./node_modules/sshpk/lib/formats/rfc4253.js\");\nformats['ssh-private'] = __webpack_require__(/*! ./formats/ssh-private */ \"(rsc)/./node_modules/sshpk/lib/formats/ssh-private.js\");\nformats['openssh'] = formats['ssh-private'];\nformats['ssh'] = formats['ssh-private'];\nformats['dnssec'] = __webpack_require__(/*! ./formats/dnssec */ \"(rsc)/./node_modules/sshpk/lib/formats/dnssec.js\");\nformats['putty'] = __webpack_require__(/*! ./formats/putty */ \"(rsc)/./node_modules/sshpk/lib/formats/putty.js\");\n\nfunction PrivateKey(opts) {\n\tassert.object(opts, 'options');\n\tKey.call(this, opts);\n\n\tthis._pubCache = undefined;\n}\nutil.inherits(PrivateKey, Key);\n\nPrivateKey.formats = formats;\n\nPrivateKey.prototype.toBuffer = function (format, options) {\n\tif (format === undefined)\n\t\tformat = 'pkcs1';\n\tassert.string(format, 'format');\n\tassert.object(formats[format], 'formats[format]');\n\tassert.optionalObject(options, 'options');\n\n\treturn (formats[format].write(this, options));\n};\n\nPrivateKey.prototype.hash = function (algo, type) {\n\treturn (this.toPublic().hash(algo, type));\n};\n\nPrivateKey.prototype.fingerprint = function (algo, type) {\n\treturn (this.toPublic().fingerprint(algo, type));\n};\n\nPrivateKey.prototype.toPublic = function () {\n\tif (this._pubCache)\n\t\treturn (this._pubCache);\n\n\tvar algInfo = algs.info[this.type];\n\tvar pubParts = [];\n\tfor (var i = 0; i < algInfo.parts.length; ++i) {\n\t\tvar p = algInfo.parts[i];\n\t\tpubParts.push(this.part[p]);\n\t}\n\n\tthis._pubCache = new Key({\n\t\ttype: this.type,\n\t\tsource: this,\n\t\tparts: pubParts\n\t});\n\tif (this.comment)\n\t\tthis._pubCache.comment = this.comment;\n\treturn (this._pubCache);\n};\n\nPrivateKey.prototype.derive = function (newType) {\n\tassert.string(newType, 'type');\n\tvar priv, pub, pair;\n\n\tif (this.type === 'ed25519' && newType === 'curve25519') {\n\t\tpriv = this.part.k.data;\n\t\tif (priv[0] === 0x00)\n\t\t\tpriv = priv.slice(1);\n\n\t\tpair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));\n\t\tpub = Buffer.from(pair.publicKey);\n\n\t\treturn (new PrivateKey({\n\t\t\ttype: 'curve25519',\n\t\t\tparts: [\n\t\t\t\t{ name: 'A', data: utils.mpNormalize(pub) },\n\t\t\t\t{ name: 'k', data: utils.mpNormalize(priv) }\n\t\t\t]\n\t\t}));\n\t} else if (this.type === 'curve25519' && newType === 'ed25519') {\n\t\tpriv = this.part.k.data;\n\t\tif (priv[0] === 0x00)\n\t\t\tpriv = priv.slice(1);\n\n\t\tpair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));\n\t\tpub = Buffer.from(pair.publicKey);\n\n\t\treturn (new PrivateKey({\n\t\t\ttype: 'ed25519',\n\t\t\tparts: [\n\t\t\t\t{ name: 'A', data: utils.mpNormalize(pub) },\n\t\t\t\t{ name: 'k', data: utils.mpNormalize(priv) }\n\t\t\t]\n\t\t}));\n\t}\n\tthrow (new Error('Key derivation not supported from ' + this.type +\n\t    ' to ' + newType));\n};\n\nPrivateKey.prototype.createVerify = function (hashAlgo) {\n\treturn (this.toPublic().createVerify(hashAlgo));\n};\n\nPrivateKey.prototype.createSign = function (hashAlgo) {\n\tif (hashAlgo === undefined)\n\t\thashAlgo = this.defaultHashAlgorithm();\n\tassert.string(hashAlgo, 'hash algorithm');\n\n\t/* ED25519 is not supported by OpenSSL, use a javascript impl. */\n\tif (this.type === 'ed25519' && edCompat !== undefined)\n\t\treturn (new edCompat.Signer(this, hashAlgo));\n\tif (this.type === 'curve25519')\n\t\tthrow (new Error('Curve25519 keys are not suitable for ' +\n\t\t    'signing or verification'));\n\n\tvar v, nm, err;\n\ttry {\n\t\tnm = hashAlgo.toUpperCase();\n\t\tv = crypto.createSign(nm);\n\t} catch (e) {\n\t\terr = e;\n\t}\n\tif (v === undefined || (err instanceof Error &&\n\t    err.message.match(/Unknown message digest/))) {\n\t\tnm = 'RSA-';\n\t\tnm += hashAlgo.toUpperCase();\n\t\tv = crypto.createSign(nm);\n\t}\n\tassert.ok(v, 'failed to create verifier');\n\tvar oldSign = v.sign.bind(v);\n\tvar key = this.toBuffer('pkcs1');\n\tvar type = this.type;\n\tvar curve = this.curve;\n\tv.sign = function () {\n\t\tvar sig = oldSign(key);\n\t\tif (typeof (sig) === 'string')\n\t\t\tsig = Buffer.from(sig, 'binary');\n\t\tsig = Signature.parse(sig, type, 'asn1');\n\t\tsig.hashAlgorithm = hashAlgo;\n\t\tsig.curve = curve;\n\t\treturn (sig);\n\t};\n\treturn (v);\n};\n\nPrivateKey.parse = function (data, format, options) {\n\tif (typeof (data) !== 'string')\n\t\tassert.buffer(data, 'data');\n\tif (format === undefined)\n\t\tformat = 'auto';\n\tassert.string(format, 'format');\n\tif (typeof (options) === 'string')\n\t\toptions = { filename: options };\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.optionalString(options.filename, 'options.filename');\n\tif (options.filename === undefined)\n\t\toptions.filename = '(unnamed)';\n\n\tassert.object(formats[format], 'formats[format]');\n\n\ttry {\n\t\tvar k = formats[format].read(data, options);\n\t\tassert.ok(k instanceof PrivateKey, 'key is not a private key');\n\t\tif (!k.comment)\n\t\t\tk.comment = options.filename;\n\t\treturn (k);\n\t} catch (e) {\n\t\tif (e.name === 'KeyEncryptedError')\n\t\t\tthrow (e);\n\t\tthrow (new KeyParseError(options.filename, format, e));\n\t}\n};\n\nPrivateKey.isPrivateKey = function (obj, ver) {\n\treturn (utils.isCompatible(obj, PrivateKey, ver));\n};\n\nPrivateKey.generate = function (type, options) {\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.object(options, 'options');\n\n\tswitch (type) {\n\tcase 'ecdsa':\n\t\tif (options.curve === undefined)\n\t\t\toptions.curve = 'nistp256';\n\t\tassert.string(options.curve, 'options.curve');\n\t\treturn (generateECDSA(options.curve));\n\tcase 'ed25519':\n\t\treturn (generateED25519());\n\tdefault:\n\t\tthrow (new Error('Key generation not supported with key ' +\n\t\t    'type \"' + type + '\"'));\n\t}\n};\n\n/*\n * API versions for PrivateKey:\n * [1,0] -- initial ver\n * [1,1] -- added auto, pkcs[18], openssh/ssh-private formats\n * [1,2] -- added defaultHashAlgorithm\n * [1,3] -- added derive, ed, createDH\n * [1,4] -- first tagged version\n * [1,5] -- changed ed25519 part names and format\n * [1,6] -- type arguments for hash() and fingerprint()\n */\nPrivateKey.prototype._sshpkApiVersion = [1, 6];\n\nPrivateKey._oldVersionDetect = function (obj) {\n\tassert.func(obj.toPublic);\n\tassert.func(obj.createSign);\n\tif (obj.derive)\n\t\treturn ([1, 3]);\n\tif (obj.defaultHashAlgorithm)\n\t\treturn ([1, 2]);\n\tif (obj.formats['auto'])\n\t\treturn ([1, 1]);\n\treturn ([1, 0]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL3ByaXZhdGUta2V5LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrREFBYTtBQUNsQyxhQUFhLDhGQUE4QjtBQUMzQyxXQUFXLG1CQUFPLENBQUMsc0RBQVE7QUFDM0IsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGtCQUFrQixtQkFBTyxDQUFDLG9FQUFlO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFhO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQywwREFBVTtBQUM3QixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLHdEQUFTO0FBQzdCLFVBQVUsbUJBQU8sQ0FBQyxvREFBTztBQUN6QjtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLGdFQUFhO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyw4REFBVzs7QUFFOUIsVUFBVSxtQkFBTyxDQUFDLG9EQUFPOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsb0VBQWU7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWlCO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFpQjtBQUM1QyxxQkFBcUIsbUJBQU8sQ0FBQyw0RUFBbUI7QUFDaEQseUJBQXlCLG1CQUFPLENBQUMsb0ZBQXVCO0FBQ3hEO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQywwRUFBa0I7QUFDOUMsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWlCOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlDQUF5QztBQUMvQyxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seUNBQXlDO0FBQy9DLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL3ByaXZhdGUta2V5LmpzPzUzNzIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTcgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0gUHJpdmF0ZUtleTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuL2FsZ3MnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBGaW5nZXJwcmludCA9IHJlcXVpcmUoJy4vZmluZ2VycHJpbnQnKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xudmFyIGVycnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZGhlID0gcmVxdWlyZSgnLi9kaGUnKTtcbnZhciBnZW5lcmF0ZUVDRFNBID0gZGhlLmdlbmVyYXRlRUNEU0E7XG52YXIgZ2VuZXJhdGVFRDI1NTE5ID0gZGhlLmdlbmVyYXRlRUQyNTUxOTtcbnZhciBlZENvbXBhdCA9IHJlcXVpcmUoJy4vZWQtY29tcGF0Jyk7XG52YXIgbmFjbCA9IHJlcXVpcmUoJ3R3ZWV0bmFjbCcpO1xuXG52YXIgS2V5ID0gcmVxdWlyZSgnLi9rZXknKTtcblxudmFyIEludmFsaWRBbGdvcml0aG1FcnJvciA9IGVycnMuSW52YWxpZEFsZ29yaXRobUVycm9yO1xudmFyIEtleVBhcnNlRXJyb3IgPSBlcnJzLktleVBhcnNlRXJyb3I7XG52YXIgS2V5RW5jcnlwdGVkRXJyb3IgPSBlcnJzLktleUVuY3J5cHRlZEVycm9yO1xuXG52YXIgZm9ybWF0cyA9IHt9O1xuZm9ybWF0c1snYXV0byddID0gcmVxdWlyZSgnLi9mb3JtYXRzL2F1dG8nKTtcbmZvcm1hdHNbJ3BlbSddID0gcmVxdWlyZSgnLi9mb3JtYXRzL3BlbScpO1xuZm9ybWF0c1sncGtjczEnXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9wa2NzMScpO1xuZm9ybWF0c1sncGtjczgnXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9wa2NzOCcpO1xuZm9ybWF0c1sncmZjNDI1MyddID0gcmVxdWlyZSgnLi9mb3JtYXRzL3JmYzQyNTMnKTtcbmZvcm1hdHNbJ3NzaC1wcml2YXRlJ10gPSByZXF1aXJlKCcuL2Zvcm1hdHMvc3NoLXByaXZhdGUnKTtcbmZvcm1hdHNbJ29wZW5zc2gnXSA9IGZvcm1hdHNbJ3NzaC1wcml2YXRlJ107XG5mb3JtYXRzWydzc2gnXSA9IGZvcm1hdHNbJ3NzaC1wcml2YXRlJ107XG5mb3JtYXRzWydkbnNzZWMnXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9kbnNzZWMnKTtcbmZvcm1hdHNbJ3B1dHR5J10gPSByZXF1aXJlKCcuL2Zvcm1hdHMvcHV0dHknKTtcblxuZnVuY3Rpb24gUHJpdmF0ZUtleShvcHRzKSB7XG5cdGFzc2VydC5vYmplY3Qob3B0cywgJ29wdGlvbnMnKTtcblx0S2V5LmNhbGwodGhpcywgb3B0cyk7XG5cblx0dGhpcy5fcHViQ2FjaGUgPSB1bmRlZmluZWQ7XG59XG51dGlsLmluaGVyaXRzKFByaXZhdGVLZXksIEtleSk7XG5cblByaXZhdGVLZXkuZm9ybWF0cyA9IGZvcm1hdHM7XG5cblByaXZhdGVLZXkucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gKGZvcm1hdCwgb3B0aW9ucykge1xuXHRpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpXG5cdFx0Zm9ybWF0ID0gJ3BrY3MxJztcblx0YXNzZXJ0LnN0cmluZyhmb3JtYXQsICdmb3JtYXQnKTtcblx0YXNzZXJ0Lm9iamVjdChmb3JtYXRzW2Zvcm1hdF0sICdmb3JtYXRzW2Zvcm1hdF0nKTtcblx0YXNzZXJ0Lm9wdGlvbmFsT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG5cblx0cmV0dXJuIChmb3JtYXRzW2Zvcm1hdF0ud3JpdGUodGhpcywgb3B0aW9ucykpO1xufTtcblxuUHJpdmF0ZUtleS5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uIChhbGdvLCB0eXBlKSB7XG5cdHJldHVybiAodGhpcy50b1B1YmxpYygpLmhhc2goYWxnbywgdHlwZSkpO1xufTtcblxuUHJpdmF0ZUtleS5wcm90b3R5cGUuZmluZ2VycHJpbnQgPSBmdW5jdGlvbiAoYWxnbywgdHlwZSkge1xuXHRyZXR1cm4gKHRoaXMudG9QdWJsaWMoKS5maW5nZXJwcmludChhbGdvLCB0eXBlKSk7XG59O1xuXG5Qcml2YXRlS2V5LnByb3RvdHlwZS50b1B1YmxpYyA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKHRoaXMuX3B1YkNhY2hlKVxuXHRcdHJldHVybiAodGhpcy5fcHViQ2FjaGUpO1xuXG5cdHZhciBhbGdJbmZvID0gYWxncy5pbmZvW3RoaXMudHlwZV07XG5cdHZhciBwdWJQYXJ0cyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFsZ0luZm8ucGFydHMubGVuZ3RoOyArK2kpIHtcblx0XHR2YXIgcCA9IGFsZ0luZm8ucGFydHNbaV07XG5cdFx0cHViUGFydHMucHVzaCh0aGlzLnBhcnRbcF0pO1xuXHR9XG5cblx0dGhpcy5fcHViQ2FjaGUgPSBuZXcgS2V5KHtcblx0XHR0eXBlOiB0aGlzLnR5cGUsXG5cdFx0c291cmNlOiB0aGlzLFxuXHRcdHBhcnRzOiBwdWJQYXJ0c1xuXHR9KTtcblx0aWYgKHRoaXMuY29tbWVudClcblx0XHR0aGlzLl9wdWJDYWNoZS5jb21tZW50ID0gdGhpcy5jb21tZW50O1xuXHRyZXR1cm4gKHRoaXMuX3B1YkNhY2hlKTtcbn07XG5cblByaXZhdGVLZXkucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uIChuZXdUeXBlKSB7XG5cdGFzc2VydC5zdHJpbmcobmV3VHlwZSwgJ3R5cGUnKTtcblx0dmFyIHByaXYsIHB1YiwgcGFpcjtcblxuXHRpZiAodGhpcy50eXBlID09PSAnZWQyNTUxOScgJiYgbmV3VHlwZSA9PT0gJ2N1cnZlMjU1MTknKSB7XG5cdFx0cHJpdiA9IHRoaXMucGFydC5rLmRhdGE7XG5cdFx0aWYgKHByaXZbMF0gPT09IDB4MDApXG5cdFx0XHRwcml2ID0gcHJpdi5zbGljZSgxKTtcblxuXHRcdHBhaXIgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkobmV3IFVpbnQ4QXJyYXkocHJpdikpO1xuXHRcdHB1YiA9IEJ1ZmZlci5mcm9tKHBhaXIucHVibGljS2V5KTtcblxuXHRcdHJldHVybiAobmV3IFByaXZhdGVLZXkoe1xuXHRcdFx0dHlwZTogJ2N1cnZlMjU1MTknLFxuXHRcdFx0cGFydHM6IFtcblx0XHRcdFx0eyBuYW1lOiAnQScsIGRhdGE6IHV0aWxzLm1wTm9ybWFsaXplKHB1YikgfSxcblx0XHRcdFx0eyBuYW1lOiAnaycsIGRhdGE6IHV0aWxzLm1wTm9ybWFsaXplKHByaXYpIH1cblx0XHRcdF1cblx0XHR9KSk7XG5cdH0gZWxzZSBpZiAodGhpcy50eXBlID09PSAnY3VydmUyNTUxOScgJiYgbmV3VHlwZSA9PT0gJ2VkMjU1MTknKSB7XG5cdFx0cHJpdiA9IHRoaXMucGFydC5rLmRhdGE7XG5cdFx0aWYgKHByaXZbMF0gPT09IDB4MDApXG5cdFx0XHRwcml2ID0gcHJpdi5zbGljZSgxKTtcblxuXHRcdHBhaXIgPSBuYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZChuZXcgVWludDhBcnJheShwcml2KSk7XG5cdFx0cHViID0gQnVmZmVyLmZyb20ocGFpci5wdWJsaWNLZXkpO1xuXG5cdFx0cmV0dXJuIChuZXcgUHJpdmF0ZUtleSh7XG5cdFx0XHR0eXBlOiAnZWQyNTUxOScsXG5cdFx0XHRwYXJ0czogW1xuXHRcdFx0XHR7IG5hbWU6ICdBJywgZGF0YTogdXRpbHMubXBOb3JtYWxpemUocHViKSB9LFxuXHRcdFx0XHR7IG5hbWU6ICdrJywgZGF0YTogdXRpbHMubXBOb3JtYWxpemUocHJpdikgfVxuXHRcdFx0XVxuXHRcdH0pKTtcblx0fVxuXHR0aHJvdyAobmV3IEVycm9yKCdLZXkgZGVyaXZhdGlvbiBub3Qgc3VwcG9ydGVkIGZyb20gJyArIHRoaXMudHlwZSArXG5cdCAgICAnIHRvICcgKyBuZXdUeXBlKSk7XG59O1xuXG5Qcml2YXRlS2V5LnByb3RvdHlwZS5jcmVhdGVWZXJpZnkgPSBmdW5jdGlvbiAoaGFzaEFsZ28pIHtcblx0cmV0dXJuICh0aGlzLnRvUHVibGljKCkuY3JlYXRlVmVyaWZ5KGhhc2hBbGdvKSk7XG59O1xuXG5Qcml2YXRlS2V5LnByb3RvdHlwZS5jcmVhdGVTaWduID0gZnVuY3Rpb24gKGhhc2hBbGdvKSB7XG5cdGlmIChoYXNoQWxnbyA9PT0gdW5kZWZpbmVkKVxuXHRcdGhhc2hBbGdvID0gdGhpcy5kZWZhdWx0SGFzaEFsZ29yaXRobSgpO1xuXHRhc3NlcnQuc3RyaW5nKGhhc2hBbGdvLCAnaGFzaCBhbGdvcml0aG0nKTtcblxuXHQvKiBFRDI1NTE5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgT3BlblNTTCwgdXNlIGEgamF2YXNjcmlwdCBpbXBsLiAqL1xuXHRpZiAodGhpcy50eXBlID09PSAnZWQyNTUxOScgJiYgZWRDb21wYXQgIT09IHVuZGVmaW5lZClcblx0XHRyZXR1cm4gKG5ldyBlZENvbXBhdC5TaWduZXIodGhpcywgaGFzaEFsZ28pKTtcblx0aWYgKHRoaXMudHlwZSA9PT0gJ2N1cnZlMjU1MTknKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0N1cnZlMjU1MTkga2V5cyBhcmUgbm90IHN1aXRhYmxlIGZvciAnICtcblx0XHQgICAgJ3NpZ25pbmcgb3IgdmVyaWZpY2F0aW9uJykpO1xuXG5cdHZhciB2LCBubSwgZXJyO1xuXHR0cnkge1xuXHRcdG5tID0gaGFzaEFsZ28udG9VcHBlckNhc2UoKTtcblx0XHR2ID0gY3J5cHRvLmNyZWF0ZVNpZ24obm0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0ZXJyID0gZTtcblx0fVxuXHRpZiAodiA9PT0gdW5kZWZpbmVkIHx8IChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJlxuXHQgICAgZXJyLm1lc3NhZ2UubWF0Y2goL1Vua25vd24gbWVzc2FnZSBkaWdlc3QvKSkpIHtcblx0XHRubSA9ICdSU0EtJztcblx0XHRubSArPSBoYXNoQWxnby50b1VwcGVyQ2FzZSgpO1xuXHRcdHYgPSBjcnlwdG8uY3JlYXRlU2lnbihubSk7XG5cdH1cblx0YXNzZXJ0Lm9rKHYsICdmYWlsZWQgdG8gY3JlYXRlIHZlcmlmaWVyJyk7XG5cdHZhciBvbGRTaWduID0gdi5zaWduLmJpbmQodik7XG5cdHZhciBrZXkgPSB0aGlzLnRvQnVmZmVyKCdwa2NzMScpO1xuXHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblx0dmFyIGN1cnZlID0gdGhpcy5jdXJ2ZTtcblx0di5zaWduID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzaWcgPSBvbGRTaWduKGtleSk7XG5cdFx0aWYgKHR5cGVvZiAoc2lnKSA9PT0gJ3N0cmluZycpXG5cdFx0XHRzaWcgPSBCdWZmZXIuZnJvbShzaWcsICdiaW5hcnknKTtcblx0XHRzaWcgPSBTaWduYXR1cmUucGFyc2Uoc2lnLCB0eXBlLCAnYXNuMScpO1xuXHRcdHNpZy5oYXNoQWxnb3JpdGhtID0gaGFzaEFsZ287XG5cdFx0c2lnLmN1cnZlID0gY3VydmU7XG5cdFx0cmV0dXJuIChzaWcpO1xuXHR9O1xuXHRyZXR1cm4gKHYpO1xufTtcblxuUHJpdmF0ZUtleS5wYXJzZSA9IGZ1bmN0aW9uIChkYXRhLCBmb3JtYXQsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiAoZGF0YSkgIT09ICdzdHJpbmcnKVxuXHRcdGFzc2VydC5idWZmZXIoZGF0YSwgJ2RhdGEnKTtcblx0aWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKVxuXHRcdGZvcm1hdCA9ICdhdXRvJztcblx0YXNzZXJ0LnN0cmluZyhmb3JtYXQsICdmb3JtYXQnKTtcblx0aWYgKHR5cGVvZiAob3B0aW9ucykgPT09ICdzdHJpbmcnKVxuXHRcdG9wdGlvbnMgPSB7IGZpbGVuYW1lOiBvcHRpb25zIH07XG5cdGFzc2VydC5vcHRpb25hbE9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpO1xuXHRpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxuXHRcdG9wdGlvbnMgPSB7fTtcblx0YXNzZXJ0Lm9wdGlvbmFsU3RyaW5nKG9wdGlvbnMuZmlsZW5hbWUsICdvcHRpb25zLmZpbGVuYW1lJyk7XG5cdGlmIChvcHRpb25zLmZpbGVuYW1lID09PSB1bmRlZmluZWQpXG5cdFx0b3B0aW9ucy5maWxlbmFtZSA9ICcodW5uYW1lZCknO1xuXG5cdGFzc2VydC5vYmplY3QoZm9ybWF0c1tmb3JtYXRdLCAnZm9ybWF0c1tmb3JtYXRdJyk7XG5cblx0dHJ5IHtcblx0XHR2YXIgayA9IGZvcm1hdHNbZm9ybWF0XS5yZWFkKGRhdGEsIG9wdGlvbnMpO1xuXHRcdGFzc2VydC5vayhrIGluc3RhbmNlb2YgUHJpdmF0ZUtleSwgJ2tleSBpcyBub3QgYSBwcml2YXRlIGtleScpO1xuXHRcdGlmICghay5jb21tZW50KVxuXHRcdFx0ay5jb21tZW50ID0gb3B0aW9ucy5maWxlbmFtZTtcblx0XHRyZXR1cm4gKGspO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKGUubmFtZSA9PT0gJ0tleUVuY3J5cHRlZEVycm9yJylcblx0XHRcdHRocm93IChlKTtcblx0XHR0aHJvdyAobmV3IEtleVBhcnNlRXJyb3Iob3B0aW9ucy5maWxlbmFtZSwgZm9ybWF0LCBlKSk7XG5cdH1cbn07XG5cblByaXZhdGVLZXkuaXNQcml2YXRlS2V5ID0gZnVuY3Rpb24gKG9iaiwgdmVyKSB7XG5cdHJldHVybiAodXRpbHMuaXNDb21wYXRpYmxlKG9iaiwgUHJpdmF0ZUtleSwgdmVyKSk7XG59O1xuXG5Qcml2YXRlS2V5LmdlbmVyYXRlID0gZnVuY3Rpb24gKHR5cGUsIG9wdGlvbnMpIHtcblx0aWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZClcblx0XHRvcHRpb25zID0ge307XG5cdGFzc2VydC5vYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcblxuXHRzd2l0Y2ggKHR5cGUpIHtcblx0Y2FzZSAnZWNkc2EnOlxuXHRcdGlmIChvcHRpb25zLmN1cnZlID09PSB1bmRlZmluZWQpXG5cdFx0XHRvcHRpb25zLmN1cnZlID0gJ25pc3RwMjU2Jztcblx0XHRhc3NlcnQuc3RyaW5nKG9wdGlvbnMuY3VydmUsICdvcHRpb25zLmN1cnZlJyk7XG5cdFx0cmV0dXJuIChnZW5lcmF0ZUVDRFNBKG9wdGlvbnMuY3VydmUpKTtcblx0Y2FzZSAnZWQyNTUxOSc6XG5cdFx0cmV0dXJuIChnZW5lcmF0ZUVEMjU1MTkoKSk7XG5cdGRlZmF1bHQ6XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignS2V5IGdlbmVyYXRpb24gbm90IHN1cHBvcnRlZCB3aXRoIGtleSAnICtcblx0XHQgICAgJ3R5cGUgXCInICsgdHlwZSArICdcIicpKTtcblx0fVxufTtcblxuLypcbiAqIEFQSSB2ZXJzaW9ucyBmb3IgUHJpdmF0ZUtleTpcbiAqIFsxLDBdIC0tIGluaXRpYWwgdmVyXG4gKiBbMSwxXSAtLSBhZGRlZCBhdXRvLCBwa2NzWzE4XSwgb3BlbnNzaC9zc2gtcHJpdmF0ZSBmb3JtYXRzXG4gKiBbMSwyXSAtLSBhZGRlZCBkZWZhdWx0SGFzaEFsZ29yaXRobVxuICogWzEsM10gLS0gYWRkZWQgZGVyaXZlLCBlZCwgY3JlYXRlREhcbiAqIFsxLDRdIC0tIGZpcnN0IHRhZ2dlZCB2ZXJzaW9uXG4gKiBbMSw1XSAtLSBjaGFuZ2VkIGVkMjU1MTkgcGFydCBuYW1lcyBhbmQgZm9ybWF0XG4gKiBbMSw2XSAtLSB0eXBlIGFyZ3VtZW50cyBmb3IgaGFzaCgpIGFuZCBmaW5nZXJwcmludCgpXG4gKi9cblByaXZhdGVLZXkucHJvdG90eXBlLl9zc2hwa0FwaVZlcnNpb24gPSBbMSwgNl07XG5cblByaXZhdGVLZXkuX29sZFZlcnNpb25EZXRlY3QgPSBmdW5jdGlvbiAob2JqKSB7XG5cdGFzc2VydC5mdW5jKG9iai50b1B1YmxpYyk7XG5cdGFzc2VydC5mdW5jKG9iai5jcmVhdGVTaWduKTtcblx0aWYgKG9iai5kZXJpdmUpXG5cdFx0cmV0dXJuIChbMSwgM10pO1xuXHRpZiAob2JqLmRlZmF1bHRIYXNoQWxnb3JpdGhtKVxuXHRcdHJldHVybiAoWzEsIDJdKTtcblx0aWYgKG9iai5mb3JtYXRzWydhdXRvJ10pXG5cdFx0cmV0dXJuIChbMSwgMV0pO1xuXHRyZXR1cm4gKFsxLCAwXSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/private-key.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/signature.js":
/*!*********************************************!*\
  !*** ./node_modules/sshpk/lib/signature.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = Signature;\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ./algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar errs = __webpack_require__(/*! ./errors */ \"(action-browser)/./node_modules/sshpk/lib/errors.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(action-browser)/./node_modules/sshpk/lib/utils.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(action-browser)/./node_modules/asn1/lib/index.js\");\nvar SSHBuffer = __webpack_require__(/*! ./ssh-buffer */ \"(action-browser)/./node_modules/sshpk/lib/ssh-buffer.js\");\n\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\nvar SignatureParseError = errs.SignatureParseError;\n\nfunction Signature(opts) {\n\tassert.object(opts, 'options');\n\tassert.arrayOfObject(opts.parts, 'options.parts');\n\tassert.string(opts.type, 'options.type');\n\n\tvar partLookup = {};\n\tfor (var i = 0; i < opts.parts.length; ++i) {\n\t\tvar part = opts.parts[i];\n\t\tpartLookup[part.name] = part;\n\t}\n\n\tthis.type = opts.type;\n\tthis.hashAlgorithm = opts.hashAlgo;\n\tthis.curve = opts.curve;\n\tthis.parts = opts.parts;\n\tthis.part = partLookup;\n}\n\nSignature.prototype.toBuffer = function (format) {\n\tif (format === undefined)\n\t\tformat = 'asn1';\n\tassert.string(format, 'format');\n\n\tvar buf;\n\tvar stype = 'ssh-' + this.type;\n\n\tswitch (this.type) {\n\tcase 'rsa':\n\t\tswitch (this.hashAlgorithm) {\n\t\tcase 'sha256':\n\t\t\tstype = 'rsa-sha2-256';\n\t\t\tbreak;\n\t\tcase 'sha512':\n\t\t\tstype = 'rsa-sha2-512';\n\t\t\tbreak;\n\t\tcase 'sha1':\n\t\tcase undefined:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new Error('SSH signature ' +\n\t\t\t    'format does not support hash ' +\n\t\t\t    'algorithm ' + this.hashAlgorithm));\n\t\t}\n\t\tif (format === 'ssh') {\n\t\t\tbuf = new SSHBuffer({});\n\t\t\tbuf.writeString(stype);\n\t\t\tbuf.writePart(this.part.sig);\n\t\t\treturn (buf.toBuffer());\n\t\t} else {\n\t\t\treturn (this.part.sig.data);\n\t\t}\n\t\tbreak;\n\n\tcase 'ed25519':\n\t\tif (format === 'ssh') {\n\t\t\tbuf = new SSHBuffer({});\n\t\t\tbuf.writeString(stype);\n\t\t\tbuf.writePart(this.part.sig);\n\t\t\treturn (buf.toBuffer());\n\t\t} else {\n\t\t\treturn (this.part.sig.data);\n\t\t}\n\t\tbreak;\n\n\tcase 'dsa':\n\tcase 'ecdsa':\n\t\tvar r, s;\n\t\tif (format === 'asn1') {\n\t\t\tvar der = new asn1.BerWriter();\n\t\t\tder.startSequence();\n\t\t\tr = utils.mpNormalize(this.part.r.data);\n\t\t\ts = utils.mpNormalize(this.part.s.data);\n\t\t\tder.writeBuffer(r, asn1.Ber.Integer);\n\t\t\tder.writeBuffer(s, asn1.Ber.Integer);\n\t\t\tder.endSequence();\n\t\t\treturn (der.buffer);\n\t\t} else if (format === 'ssh' && this.type === 'dsa') {\n\t\t\tbuf = new SSHBuffer({});\n\t\t\tbuf.writeString('ssh-dss');\n\t\t\tr = this.part.r.data;\n\t\t\tif (r.length > 20 && r[0] === 0x00)\n\t\t\t\tr = r.slice(1);\n\t\t\ts = this.part.s.data;\n\t\t\tif (s.length > 20 && s[0] === 0x00)\n\t\t\t\ts = s.slice(1);\n\t\t\tif ((this.hashAlgorithm &&\n\t\t\t    this.hashAlgorithm !== 'sha1') ||\n\t\t\t    r.length + s.length !== 40) {\n\t\t\t\tthrow (new Error('OpenSSH only supports ' +\n\t\t\t\t    'DSA signatures with SHA1 hash'));\n\t\t\t}\n\t\t\tbuf.writeBuffer(Buffer.concat([r, s]));\n\t\t\treturn (buf.toBuffer());\n\t\t} else if (format === 'ssh' && this.type === 'ecdsa') {\n\t\t\tvar inner = new SSHBuffer({});\n\t\t\tr = this.part.r.data;\n\t\t\tinner.writeBuffer(r);\n\t\t\tinner.writePart(this.part.s);\n\n\t\t\tbuf = new SSHBuffer({});\n\t\t\t/* XXX: find a more proper way to do this? */\n\t\t\tvar curve;\n\t\t\tif (r[0] === 0x00)\n\t\t\t\tr = r.slice(1);\n\t\t\tvar sz = r.length * 8;\n\t\t\tif (sz === 256)\n\t\t\t\tcurve = 'nistp256';\n\t\t\telse if (sz === 384)\n\t\t\t\tcurve = 'nistp384';\n\t\t\telse if (sz === 528)\n\t\t\t\tcurve = 'nistp521';\n\t\t\tbuf.writeString('ecdsa-sha2-' + curve);\n\t\t\tbuf.writeBuffer(inner.toBuffer());\n\t\t\treturn (buf.toBuffer());\n\t\t}\n\t\tthrow (new Error('Invalid signature format'));\n\tdefault:\n\t\tthrow (new Error('Invalid signature data'));\n\t}\n};\n\nSignature.prototype.toString = function (format) {\n\tassert.optionalString(format, 'format');\n\treturn (this.toBuffer(format).toString('base64'));\n};\n\nSignature.parse = function (data, type, format) {\n\tif (typeof (data) === 'string')\n\t\tdata = Buffer.from(data, 'base64');\n\tassert.buffer(data, 'data');\n\tassert.string(format, 'format');\n\tassert.string(type, 'type');\n\n\tvar opts = {};\n\topts.type = type.toLowerCase();\n\topts.parts = [];\n\n\ttry {\n\t\tassert.ok(data.length > 0, 'signature must not be empty');\n\t\tswitch (opts.type) {\n\t\tcase 'rsa':\n\t\t\treturn (parseOneNum(data, type, format, opts));\n\t\tcase 'ed25519':\n\t\t\treturn (parseOneNum(data, type, format, opts));\n\n\t\tcase 'dsa':\n\t\tcase 'ecdsa':\n\t\t\tif (format === 'asn1')\n\t\t\t\treturn (parseDSAasn1(data, type, format, opts));\n\t\t\telse if (opts.type === 'dsa')\n\t\t\t\treturn (parseDSA(data, type, format, opts));\n\t\t\telse\n\t\t\t\treturn (parseECDSA(data, type, format, opts));\n\n\t\tdefault:\n\t\t\tthrow (new InvalidAlgorithmError(type));\n\t\t}\n\n\t} catch (e) {\n\t\tif (e instanceof InvalidAlgorithmError)\n\t\t\tthrow (e);\n\t\tthrow (new SignatureParseError(type, format, e));\n\t}\n};\n\nfunction parseOneNum(data, type, format, opts) {\n\tif (format === 'ssh') {\n\t\ttry {\n\t\t\tvar buf = new SSHBuffer({buffer: data});\n\t\t\tvar head = buf.readString();\n\t\t} catch (e) {\n\t\t\t/* fall through */\n\t\t}\n\t\tif (buf !== undefined) {\n\t\t\tvar msg = 'SSH signature does not match expected ' +\n\t\t\t    'type (expected ' + type + ', got ' + head + ')';\n\t\t\tswitch (head) {\n\t\t\tcase 'ssh-rsa':\n\t\t\t\tassert.strictEqual(type, 'rsa', msg);\n\t\t\t\topts.hashAlgo = 'sha1';\n\t\t\t\tbreak;\n\t\t\tcase 'rsa-sha2-256':\n\t\t\t\tassert.strictEqual(type, 'rsa', msg);\n\t\t\t\topts.hashAlgo = 'sha256';\n\t\t\t\tbreak;\n\t\t\tcase 'rsa-sha2-512':\n\t\t\t\tassert.strictEqual(type, 'rsa', msg);\n\t\t\t\topts.hashAlgo = 'sha512';\n\t\t\t\tbreak;\n\t\t\tcase 'ssh-ed25519':\n\t\t\t\tassert.strictEqual(type, 'ed25519', msg);\n\t\t\t\topts.hashAlgo = 'sha512';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow (new Error('Unknown SSH signature ' +\n\t\t\t\t    'type: ' + head));\n\t\t\t}\n\t\t\tvar sig = buf.readPart();\n\t\t\tassert.ok(buf.atEnd(), 'extra trailing bytes');\n\t\t\tsig.name = 'sig';\n\t\t\topts.parts.push(sig);\n\t\t\treturn (new Signature(opts));\n\t\t}\n\t}\n\topts.parts.push({name: 'sig', data: data});\n\treturn (new Signature(opts));\n}\n\nfunction parseDSAasn1(data, type, format, opts) {\n\tvar der = new asn1.BerReader(data);\n\tder.readSequence();\n\tvar r = der.readString(asn1.Ber.Integer, true);\n\tvar s = der.readString(asn1.Ber.Integer, true);\n\n\topts.parts.push({name: 'r', data: utils.mpNormalize(r)});\n\topts.parts.push({name: 's', data: utils.mpNormalize(s)});\n\n\treturn (new Signature(opts));\n}\n\nfunction parseDSA(data, type, format, opts) {\n\tif (data.length != 40) {\n\t\tvar buf = new SSHBuffer({buffer: data});\n\t\tvar d = buf.readBuffer();\n\t\tif (d.toString('ascii') === 'ssh-dss')\n\t\t\td = buf.readBuffer();\n\t\tassert.ok(buf.atEnd(), 'extra trailing bytes');\n\t\tassert.strictEqual(d.length, 40, 'invalid inner length');\n\t\tdata = d;\n\t}\n\topts.parts.push({name: 'r', data: data.slice(0, 20)});\n\topts.parts.push({name: 's', data: data.slice(20, 40)});\n\treturn (new Signature(opts));\n}\n\nfunction parseECDSA(data, type, format, opts) {\n\tvar buf = new SSHBuffer({buffer: data});\n\n\tvar r, s;\n\tvar inner = buf.readBuffer();\n\tvar stype = inner.toString('ascii');\n\tif (stype.slice(0, 6) === 'ecdsa-') {\n\t\tvar parts = stype.split('-');\n\t\tassert.strictEqual(parts[0], 'ecdsa');\n\t\tassert.strictEqual(parts[1], 'sha2');\n\t\topts.curve = parts[2];\n\t\tswitch (opts.curve) {\n\t\tcase 'nistp256':\n\t\t\topts.hashAlgo = 'sha256';\n\t\t\tbreak;\n\t\tcase 'nistp384':\n\t\t\topts.hashAlgo = 'sha384';\n\t\t\tbreak;\n\t\tcase 'nistp521':\n\t\t\topts.hashAlgo = 'sha512';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new Error('Unsupported ECDSA curve: ' +\n\t\t\t    opts.curve));\n\t\t}\n\t\tinner = buf.readBuffer();\n\t\tassert.ok(buf.atEnd(), 'extra trailing bytes on outer');\n\t\tbuf = new SSHBuffer({buffer: inner});\n\t\tr = buf.readPart();\n\t} else {\n\t\tr = {data: inner};\n\t}\n\n\ts = buf.readPart();\n\tassert.ok(buf.atEnd(), 'extra trailing bytes');\n\n\tr.name = 'r';\n\ts.name = 's';\n\n\topts.parts.push(r);\n\topts.parts.push(s);\n\treturn (new Signature(opts));\n}\n\nSignature.isSignature = function (obj, ver) {\n\treturn (utils.isCompatible(obj, Signature, ver));\n};\n\n/*\n * API versions for Signature:\n * [1,0] -- initial ver\n * [2,0] -- support for rsa in full ssh format, compat with sshpk-agent\n *          hashAlgorithm property\n * [2,1] -- first tagged version\n */\nSignature.prototype._sshpkApiVersion = [2, 1];\n\nSignature._oldVersionDetect = function (obj) {\n\tassert.func(obj.toBuffer);\n\tif (obj.hasOwnProperty('hashAlgorithm'))\n\t\treturn ([2, 0]);\n\treturn ([1, 0]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvc2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywwRUFBYTtBQUNsQyxhQUFhLHlHQUE4QjtBQUMzQyxXQUFXLG1CQUFPLENBQUMsaUVBQVE7QUFDM0IsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxxRUFBVTtBQUM3QixZQUFZLG1CQUFPLENBQUMsbUVBQVM7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLCtEQUFNO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLDZFQUFjOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0NBQXNDO0FBQ3hELGtCQUFrQixzQ0FBc0M7O0FBRXhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1DQUFtQztBQUNyRCxrQkFBa0Isb0NBQW9DO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsYUFBYTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQSxHQUFHO0FBQ0gsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9zaWduYXR1cmUuanM/MTlkOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNSBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSBTaWduYXR1cmU7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBhbGdzID0gcmVxdWlyZSgnLi9hbGdzJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgZXJycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYXNuMSA9IHJlcXVpcmUoJ2FzbjEnKTtcbnZhciBTU0hCdWZmZXIgPSByZXF1aXJlKCcuL3NzaC1idWZmZXInKTtcblxudmFyIEludmFsaWRBbGdvcml0aG1FcnJvciA9IGVycnMuSW52YWxpZEFsZ29yaXRobUVycm9yO1xudmFyIFNpZ25hdHVyZVBhcnNlRXJyb3IgPSBlcnJzLlNpZ25hdHVyZVBhcnNlRXJyb3I7XG5cbmZ1bmN0aW9uIFNpZ25hdHVyZShvcHRzKSB7XG5cdGFzc2VydC5vYmplY3Qob3B0cywgJ29wdGlvbnMnKTtcblx0YXNzZXJ0LmFycmF5T2ZPYmplY3Qob3B0cy5wYXJ0cywgJ29wdGlvbnMucGFydHMnKTtcblx0YXNzZXJ0LnN0cmluZyhvcHRzLnR5cGUsICdvcHRpb25zLnR5cGUnKTtcblxuXHR2YXIgcGFydExvb2t1cCA9IHt9O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG9wdHMucGFydHMubGVuZ3RoOyArK2kpIHtcblx0XHR2YXIgcGFydCA9IG9wdHMucGFydHNbaV07XG5cdFx0cGFydExvb2t1cFtwYXJ0Lm5hbWVdID0gcGFydDtcblx0fVxuXG5cdHRoaXMudHlwZSA9IG9wdHMudHlwZTtcblx0dGhpcy5oYXNoQWxnb3JpdGhtID0gb3B0cy5oYXNoQWxnbztcblx0dGhpcy5jdXJ2ZSA9IG9wdHMuY3VydmU7XG5cdHRoaXMucGFydHMgPSBvcHRzLnBhcnRzO1xuXHR0aGlzLnBhcnQgPSBwYXJ0TG9va3VwO1xufVxuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuXHRpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpXG5cdFx0Zm9ybWF0ID0gJ2FzbjEnO1xuXHRhc3NlcnQuc3RyaW5nKGZvcm1hdCwgJ2Zvcm1hdCcpO1xuXG5cdHZhciBidWY7XG5cdHZhciBzdHlwZSA9ICdzc2gtJyArIHRoaXMudHlwZTtcblxuXHRzd2l0Y2ggKHRoaXMudHlwZSkge1xuXHRjYXNlICdyc2EnOlxuXHRcdHN3aXRjaCAodGhpcy5oYXNoQWxnb3JpdGhtKSB7XG5cdFx0Y2FzZSAnc2hhMjU2Jzpcblx0XHRcdHN0eXBlID0gJ3JzYS1zaGEyLTI1Nic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdzaGE1MTInOlxuXHRcdFx0c3R5cGUgPSAncnNhLXNoYTItNTEyJztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3NoYTEnOlxuXHRcdGNhc2UgdW5kZWZpbmVkOlxuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ1NTSCBzaWduYXR1cmUgJyArXG5cdFx0XHQgICAgJ2Zvcm1hdCBkb2VzIG5vdCBzdXBwb3J0IGhhc2ggJyArXG5cdFx0XHQgICAgJ2FsZ29yaXRobSAnICsgdGhpcy5oYXNoQWxnb3JpdGhtKSk7XG5cdFx0fVxuXHRcdGlmIChmb3JtYXQgPT09ICdzc2gnKSB7XG5cdFx0XHRidWYgPSBuZXcgU1NIQnVmZmVyKHt9KTtcblx0XHRcdGJ1Zi53cml0ZVN0cmluZyhzdHlwZSk7XG5cdFx0XHRidWYud3JpdGVQYXJ0KHRoaXMucGFydC5zaWcpO1xuXHRcdFx0cmV0dXJuIChidWYudG9CdWZmZXIoKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAodGhpcy5wYXJ0LnNpZy5kYXRhKTtcblx0XHR9XG5cdFx0YnJlYWs7XG5cblx0Y2FzZSAnZWQyNTUxOSc6XG5cdFx0aWYgKGZvcm1hdCA9PT0gJ3NzaCcpIHtcblx0XHRcdGJ1ZiA9IG5ldyBTU0hCdWZmZXIoe30pO1xuXHRcdFx0YnVmLndyaXRlU3RyaW5nKHN0eXBlKTtcblx0XHRcdGJ1Zi53cml0ZVBhcnQodGhpcy5wYXJ0LnNpZyk7XG5cdFx0XHRyZXR1cm4gKGJ1Zi50b0J1ZmZlcigpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuICh0aGlzLnBhcnQuc2lnLmRhdGEpO1xuXHRcdH1cblx0XHRicmVhaztcblxuXHRjYXNlICdkc2EnOlxuXHRjYXNlICdlY2RzYSc6XG5cdFx0dmFyIHIsIHM7XG5cdFx0aWYgKGZvcm1hdCA9PT0gJ2FzbjEnKSB7XG5cdFx0XHR2YXIgZGVyID0gbmV3IGFzbjEuQmVyV3JpdGVyKCk7XG5cdFx0XHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRcdFx0ciA9IHV0aWxzLm1wTm9ybWFsaXplKHRoaXMucGFydC5yLmRhdGEpO1xuXHRcdFx0cyA9IHV0aWxzLm1wTm9ybWFsaXplKHRoaXMucGFydC5zLmRhdGEpO1xuXHRcdFx0ZGVyLndyaXRlQnVmZmVyKHIsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRcdFx0ZGVyLndyaXRlQnVmZmVyKHMsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRcdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdFx0XHRyZXR1cm4gKGRlci5idWZmZXIpO1xuXHRcdH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnc3NoJyAmJiB0aGlzLnR5cGUgPT09ICdkc2EnKSB7XG5cdFx0XHRidWYgPSBuZXcgU1NIQnVmZmVyKHt9KTtcblx0XHRcdGJ1Zi53cml0ZVN0cmluZygnc3NoLWRzcycpO1xuXHRcdFx0ciA9IHRoaXMucGFydC5yLmRhdGE7XG5cdFx0XHRpZiAoci5sZW5ndGggPiAyMCAmJiByWzBdID09PSAweDAwKVxuXHRcdFx0XHRyID0gci5zbGljZSgxKTtcblx0XHRcdHMgPSB0aGlzLnBhcnQucy5kYXRhO1xuXHRcdFx0aWYgKHMubGVuZ3RoID4gMjAgJiYgc1swXSA9PT0gMHgwMClcblx0XHRcdFx0cyA9IHMuc2xpY2UoMSk7XG5cdFx0XHRpZiAoKHRoaXMuaGFzaEFsZ29yaXRobSAmJlxuXHRcdFx0ICAgIHRoaXMuaGFzaEFsZ29yaXRobSAhPT0gJ3NoYTEnKSB8fFxuXHRcdFx0ICAgIHIubGVuZ3RoICsgcy5sZW5ndGggIT09IDQwKSB7XG5cdFx0XHRcdHRocm93IChuZXcgRXJyb3IoJ09wZW5TU0ggb25seSBzdXBwb3J0cyAnICtcblx0XHRcdFx0ICAgICdEU0Egc2lnbmF0dXJlcyB3aXRoIFNIQTEgaGFzaCcpKTtcblx0XHRcdH1cblx0XHRcdGJ1Zi53cml0ZUJ1ZmZlcihCdWZmZXIuY29uY2F0KFtyLCBzXSkpO1xuXHRcdFx0cmV0dXJuIChidWYudG9CdWZmZXIoKSk7XG5cdFx0fSBlbHNlIGlmIChmb3JtYXQgPT09ICdzc2gnICYmIHRoaXMudHlwZSA9PT0gJ2VjZHNhJykge1xuXHRcdFx0dmFyIGlubmVyID0gbmV3IFNTSEJ1ZmZlcih7fSk7XG5cdFx0XHRyID0gdGhpcy5wYXJ0LnIuZGF0YTtcblx0XHRcdGlubmVyLndyaXRlQnVmZmVyKHIpO1xuXHRcdFx0aW5uZXIud3JpdGVQYXJ0KHRoaXMucGFydC5zKTtcblxuXHRcdFx0YnVmID0gbmV3IFNTSEJ1ZmZlcih7fSk7XG5cdFx0XHQvKiBYWFg6IGZpbmQgYSBtb3JlIHByb3BlciB3YXkgdG8gZG8gdGhpcz8gKi9cblx0XHRcdHZhciBjdXJ2ZTtcblx0XHRcdGlmIChyWzBdID09PSAweDAwKVxuXHRcdFx0XHRyID0gci5zbGljZSgxKTtcblx0XHRcdHZhciBzeiA9IHIubGVuZ3RoICogODtcblx0XHRcdGlmIChzeiA9PT0gMjU2KVxuXHRcdFx0XHRjdXJ2ZSA9ICduaXN0cDI1Nic7XG5cdFx0XHRlbHNlIGlmIChzeiA9PT0gMzg0KVxuXHRcdFx0XHRjdXJ2ZSA9ICduaXN0cDM4NCc7XG5cdFx0XHRlbHNlIGlmIChzeiA9PT0gNTI4KVxuXHRcdFx0XHRjdXJ2ZSA9ICduaXN0cDUyMSc7XG5cdFx0XHRidWYud3JpdGVTdHJpbmcoJ2VjZHNhLXNoYTItJyArIGN1cnZlKTtcblx0XHRcdGJ1Zi53cml0ZUJ1ZmZlcihpbm5lci50b0J1ZmZlcigpKTtcblx0XHRcdHJldHVybiAoYnVmLnRvQnVmZmVyKCkpO1xuXHRcdH1cblx0XHR0aHJvdyAobmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBmb3JtYXQnKSk7XG5cdGRlZmF1bHQ6XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgZGF0YScpKTtcblx0fVxufTtcblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcblx0YXNzZXJ0Lm9wdGlvbmFsU3RyaW5nKGZvcm1hdCwgJ2Zvcm1hdCcpO1xuXHRyZXR1cm4gKHRoaXMudG9CdWZmZXIoZm9ybWF0KS50b1N0cmluZygnYmFzZTY0JykpO1xufTtcblxuU2lnbmF0dXJlLnBhcnNlID0gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIGZvcm1hdCkge1xuXHRpZiAodHlwZW9mIChkYXRhKSA9PT0gJ3N0cmluZycpXG5cdFx0ZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiYXNlNjQnKTtcblx0YXNzZXJ0LmJ1ZmZlcihkYXRhLCAnZGF0YScpO1xuXHRhc3NlcnQuc3RyaW5nKGZvcm1hdCwgJ2Zvcm1hdCcpO1xuXHRhc3NlcnQuc3RyaW5nKHR5cGUsICd0eXBlJyk7XG5cblx0dmFyIG9wdHMgPSB7fTtcblx0b3B0cy50eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXHRvcHRzLnBhcnRzID0gW107XG5cblx0dHJ5IHtcblx0XHRhc3NlcnQub2soZGF0YS5sZW5ndGggPiAwLCAnc2lnbmF0dXJlIG11c3Qgbm90IGJlIGVtcHR5Jyk7XG5cdFx0c3dpdGNoIChvcHRzLnR5cGUpIHtcblx0XHRjYXNlICdyc2EnOlxuXHRcdFx0cmV0dXJuIChwYXJzZU9uZU51bShkYXRhLCB0eXBlLCBmb3JtYXQsIG9wdHMpKTtcblx0XHRjYXNlICdlZDI1NTE5Jzpcblx0XHRcdHJldHVybiAocGFyc2VPbmVOdW0oZGF0YSwgdHlwZSwgZm9ybWF0LCBvcHRzKSk7XG5cblx0XHRjYXNlICdkc2EnOlxuXHRcdGNhc2UgJ2VjZHNhJzpcblx0XHRcdGlmIChmb3JtYXQgPT09ICdhc24xJylcblx0XHRcdFx0cmV0dXJuIChwYXJzZURTQWFzbjEoZGF0YSwgdHlwZSwgZm9ybWF0LCBvcHRzKSk7XG5cdFx0XHRlbHNlIGlmIChvcHRzLnR5cGUgPT09ICdkc2EnKVxuXHRcdFx0XHRyZXR1cm4gKHBhcnNlRFNBKGRhdGEsIHR5cGUsIGZvcm1hdCwgb3B0cykpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXR1cm4gKHBhcnNlRUNEU0EoZGF0YSwgdHlwZSwgZm9ybWF0LCBvcHRzKSk7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3IodHlwZSkpO1xuXHRcdH1cblxuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKGUgaW5zdGFuY2VvZiBJbnZhbGlkQWxnb3JpdGhtRXJyb3IpXG5cdFx0XHR0aHJvdyAoZSk7XG5cdFx0dGhyb3cgKG5ldyBTaWduYXR1cmVQYXJzZUVycm9yKHR5cGUsIGZvcm1hdCwgZSkpO1xuXHR9XG59O1xuXG5mdW5jdGlvbiBwYXJzZU9uZU51bShkYXRhLCB0eXBlLCBmb3JtYXQsIG9wdHMpIHtcblx0aWYgKGZvcm1hdCA9PT0gJ3NzaCcpIHtcblx0XHR0cnkge1xuXHRcdFx0dmFyIGJ1ZiA9IG5ldyBTU0hCdWZmZXIoe2J1ZmZlcjogZGF0YX0pO1xuXHRcdFx0dmFyIGhlYWQgPSBidWYucmVhZFN0cmluZygpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8qIGZhbGwgdGhyb3VnaCAqL1xuXHRcdH1cblx0XHRpZiAoYnVmICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHZhciBtc2cgPSAnU1NIIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCAnICtcblx0XHRcdCAgICAndHlwZSAoZXhwZWN0ZWQgJyArIHR5cGUgKyAnLCBnb3QgJyArIGhlYWQgKyAnKSc7XG5cdFx0XHRzd2l0Y2ggKGhlYWQpIHtcblx0XHRcdGNhc2UgJ3NzaC1yc2EnOlxuXHRcdFx0XHRhc3NlcnQuc3RyaWN0RXF1YWwodHlwZSwgJ3JzYScsIG1zZyk7XG5cdFx0XHRcdG9wdHMuaGFzaEFsZ28gPSAnc2hhMSc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncnNhLXNoYTItMjU2Jzpcblx0XHRcdFx0YXNzZXJ0LnN0cmljdEVxdWFsKHR5cGUsICdyc2EnLCBtc2cpO1xuXHRcdFx0XHRvcHRzLmhhc2hBbGdvID0gJ3NoYTI1Nic7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncnNhLXNoYTItNTEyJzpcblx0XHRcdFx0YXNzZXJ0LnN0cmljdEVxdWFsKHR5cGUsICdyc2EnLCBtc2cpO1xuXHRcdFx0XHRvcHRzLmhhc2hBbGdvID0gJ3NoYTUxMic7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc3NoLWVkMjU1MTknOlxuXHRcdFx0XHRhc3NlcnQuc3RyaWN0RXF1YWwodHlwZSwgJ2VkMjU1MTknLCBtc2cpO1xuXHRcdFx0XHRvcHRzLmhhc2hBbGdvID0gJ3NoYTUxMic7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biBTU0ggc2lnbmF0dXJlICcgK1xuXHRcdFx0XHQgICAgJ3R5cGU6ICcgKyBoZWFkKSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc2lnID0gYnVmLnJlYWRQYXJ0KCk7XG5cdFx0XHRhc3NlcnQub2soYnVmLmF0RW5kKCksICdleHRyYSB0cmFpbGluZyBieXRlcycpO1xuXHRcdFx0c2lnLm5hbWUgPSAnc2lnJztcblx0XHRcdG9wdHMucGFydHMucHVzaChzaWcpO1xuXHRcdFx0cmV0dXJuIChuZXcgU2lnbmF0dXJlKG9wdHMpKTtcblx0XHR9XG5cdH1cblx0b3B0cy5wYXJ0cy5wdXNoKHtuYW1lOiAnc2lnJywgZGF0YTogZGF0YX0pO1xuXHRyZXR1cm4gKG5ldyBTaWduYXR1cmUob3B0cykpO1xufVxuXG5mdW5jdGlvbiBwYXJzZURTQWFzbjEoZGF0YSwgdHlwZSwgZm9ybWF0LCBvcHRzKSB7XG5cdHZhciBkZXIgPSBuZXcgYXNuMS5CZXJSZWFkZXIoZGF0YSk7XG5cdGRlci5yZWFkU2VxdWVuY2UoKTtcblx0dmFyIHIgPSBkZXIucmVhZFN0cmluZyhhc24xLkJlci5JbnRlZ2VyLCB0cnVlKTtcblx0dmFyIHMgPSBkZXIucmVhZFN0cmluZyhhc24xLkJlci5JbnRlZ2VyLCB0cnVlKTtcblxuXHRvcHRzLnBhcnRzLnB1c2goe25hbWU6ICdyJywgZGF0YTogdXRpbHMubXBOb3JtYWxpemUocil9KTtcblx0b3B0cy5wYXJ0cy5wdXNoKHtuYW1lOiAncycsIGRhdGE6IHV0aWxzLm1wTm9ybWFsaXplKHMpfSk7XG5cblx0cmV0dXJuIChuZXcgU2lnbmF0dXJlKG9wdHMpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEU0EoZGF0YSwgdHlwZSwgZm9ybWF0LCBvcHRzKSB7XG5cdGlmIChkYXRhLmxlbmd0aCAhPSA0MCkge1xuXHRcdHZhciBidWYgPSBuZXcgU1NIQnVmZmVyKHtidWZmZXI6IGRhdGF9KTtcblx0XHR2YXIgZCA9IGJ1Zi5yZWFkQnVmZmVyKCk7XG5cdFx0aWYgKGQudG9TdHJpbmcoJ2FzY2lpJykgPT09ICdzc2gtZHNzJylcblx0XHRcdGQgPSBidWYucmVhZEJ1ZmZlcigpO1xuXHRcdGFzc2VydC5vayhidWYuYXRFbmQoKSwgJ2V4dHJhIHRyYWlsaW5nIGJ5dGVzJyk7XG5cdFx0YXNzZXJ0LnN0cmljdEVxdWFsKGQubGVuZ3RoLCA0MCwgJ2ludmFsaWQgaW5uZXIgbGVuZ3RoJyk7XG5cdFx0ZGF0YSA9IGQ7XG5cdH1cblx0b3B0cy5wYXJ0cy5wdXNoKHtuYW1lOiAncicsIGRhdGE6IGRhdGEuc2xpY2UoMCwgMjApfSk7XG5cdG9wdHMucGFydHMucHVzaCh7bmFtZTogJ3MnLCBkYXRhOiBkYXRhLnNsaWNlKDIwLCA0MCl9KTtcblx0cmV0dXJuIChuZXcgU2lnbmF0dXJlKG9wdHMpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VFQ0RTQShkYXRhLCB0eXBlLCBmb3JtYXQsIG9wdHMpIHtcblx0dmFyIGJ1ZiA9IG5ldyBTU0hCdWZmZXIoe2J1ZmZlcjogZGF0YX0pO1xuXG5cdHZhciByLCBzO1xuXHR2YXIgaW5uZXIgPSBidWYucmVhZEJ1ZmZlcigpO1xuXHR2YXIgc3R5cGUgPSBpbm5lci50b1N0cmluZygnYXNjaWknKTtcblx0aWYgKHN0eXBlLnNsaWNlKDAsIDYpID09PSAnZWNkc2EtJykge1xuXHRcdHZhciBwYXJ0cyA9IHN0eXBlLnNwbGl0KCctJyk7XG5cdFx0YXNzZXJ0LnN0cmljdEVxdWFsKHBhcnRzWzBdLCAnZWNkc2EnKTtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwocGFydHNbMV0sICdzaGEyJyk7XG5cdFx0b3B0cy5jdXJ2ZSA9IHBhcnRzWzJdO1xuXHRcdHN3aXRjaCAob3B0cy5jdXJ2ZSkge1xuXHRcdGNhc2UgJ25pc3RwMjU2Jzpcblx0XHRcdG9wdHMuaGFzaEFsZ28gPSAnc2hhMjU2Jztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ25pc3RwMzg0Jzpcblx0XHRcdG9wdHMuaGFzaEFsZ28gPSAnc2hhMzg0Jztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ25pc3RwNTIxJzpcblx0XHRcdG9wdHMuaGFzaEFsZ28gPSAnc2hhNTEyJztcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBFQ0RTQSBjdXJ2ZTogJyArXG5cdFx0XHQgICAgb3B0cy5jdXJ2ZSkpO1xuXHRcdH1cblx0XHRpbm5lciA9IGJ1Zi5yZWFkQnVmZmVyKCk7XG5cdFx0YXNzZXJ0Lm9rKGJ1Zi5hdEVuZCgpLCAnZXh0cmEgdHJhaWxpbmcgYnl0ZXMgb24gb3V0ZXInKTtcblx0XHRidWYgPSBuZXcgU1NIQnVmZmVyKHtidWZmZXI6IGlubmVyfSk7XG5cdFx0ciA9IGJ1Zi5yZWFkUGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdHIgPSB7ZGF0YTogaW5uZXJ9O1xuXHR9XG5cblx0cyA9IGJ1Zi5yZWFkUGFydCgpO1xuXHRhc3NlcnQub2soYnVmLmF0RW5kKCksICdleHRyYSB0cmFpbGluZyBieXRlcycpO1xuXG5cdHIubmFtZSA9ICdyJztcblx0cy5uYW1lID0gJ3MnO1xuXG5cdG9wdHMucGFydHMucHVzaChyKTtcblx0b3B0cy5wYXJ0cy5wdXNoKHMpO1xuXHRyZXR1cm4gKG5ldyBTaWduYXR1cmUob3B0cykpO1xufVxuXG5TaWduYXR1cmUuaXNTaWduYXR1cmUgPSBmdW5jdGlvbiAob2JqLCB2ZXIpIHtcblx0cmV0dXJuICh1dGlscy5pc0NvbXBhdGlibGUob2JqLCBTaWduYXR1cmUsIHZlcikpO1xufTtcblxuLypcbiAqIEFQSSB2ZXJzaW9ucyBmb3IgU2lnbmF0dXJlOlxuICogWzEsMF0gLS0gaW5pdGlhbCB2ZXJcbiAqIFsyLDBdIC0tIHN1cHBvcnQgZm9yIHJzYSBpbiBmdWxsIHNzaCBmb3JtYXQsIGNvbXBhdCB3aXRoIHNzaHBrLWFnZW50XG4gKiAgICAgICAgICBoYXNoQWxnb3JpdGhtIHByb3BlcnR5XG4gKiBbMiwxXSAtLSBmaXJzdCB0YWdnZWQgdmVyc2lvblxuICovXG5TaWduYXR1cmUucHJvdG90eXBlLl9zc2hwa0FwaVZlcnNpb24gPSBbMiwgMV07XG5cblNpZ25hdHVyZS5fb2xkVmVyc2lvbkRldGVjdCA9IGZ1bmN0aW9uIChvYmopIHtcblx0YXNzZXJ0LmZ1bmMob2JqLnRvQnVmZmVyKTtcblx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eSgnaGFzaEFsZ29yaXRobScpKVxuXHRcdHJldHVybiAoWzIsIDBdKTtcblx0cmV0dXJuIChbMSwgMF0pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/signature.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/signature.js":
/*!*********************************************!*\
  !*** ./node_modules/sshpk/lib/signature.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = Signature;\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar algs = __webpack_require__(/*! ./algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar errs = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/sshpk/lib/errors.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/sshpk/lib/utils.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(rsc)/./node_modules/asn1/lib/index.js\");\nvar SSHBuffer = __webpack_require__(/*! ./ssh-buffer */ \"(rsc)/./node_modules/sshpk/lib/ssh-buffer.js\");\n\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\nvar SignatureParseError = errs.SignatureParseError;\n\nfunction Signature(opts) {\n\tassert.object(opts, 'options');\n\tassert.arrayOfObject(opts.parts, 'options.parts');\n\tassert.string(opts.type, 'options.type');\n\n\tvar partLookup = {};\n\tfor (var i = 0; i < opts.parts.length; ++i) {\n\t\tvar part = opts.parts[i];\n\t\tpartLookup[part.name] = part;\n\t}\n\n\tthis.type = opts.type;\n\tthis.hashAlgorithm = opts.hashAlgo;\n\tthis.curve = opts.curve;\n\tthis.parts = opts.parts;\n\tthis.part = partLookup;\n}\n\nSignature.prototype.toBuffer = function (format) {\n\tif (format === undefined)\n\t\tformat = 'asn1';\n\tassert.string(format, 'format');\n\n\tvar buf;\n\tvar stype = 'ssh-' + this.type;\n\n\tswitch (this.type) {\n\tcase 'rsa':\n\t\tswitch (this.hashAlgorithm) {\n\t\tcase 'sha256':\n\t\t\tstype = 'rsa-sha2-256';\n\t\t\tbreak;\n\t\tcase 'sha512':\n\t\t\tstype = 'rsa-sha2-512';\n\t\t\tbreak;\n\t\tcase 'sha1':\n\t\tcase undefined:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new Error('SSH signature ' +\n\t\t\t    'format does not support hash ' +\n\t\t\t    'algorithm ' + this.hashAlgorithm));\n\t\t}\n\t\tif (format === 'ssh') {\n\t\t\tbuf = new SSHBuffer({});\n\t\t\tbuf.writeString(stype);\n\t\t\tbuf.writePart(this.part.sig);\n\t\t\treturn (buf.toBuffer());\n\t\t} else {\n\t\t\treturn (this.part.sig.data);\n\t\t}\n\t\tbreak;\n\n\tcase 'ed25519':\n\t\tif (format === 'ssh') {\n\t\t\tbuf = new SSHBuffer({});\n\t\t\tbuf.writeString(stype);\n\t\t\tbuf.writePart(this.part.sig);\n\t\t\treturn (buf.toBuffer());\n\t\t} else {\n\t\t\treturn (this.part.sig.data);\n\t\t}\n\t\tbreak;\n\n\tcase 'dsa':\n\tcase 'ecdsa':\n\t\tvar r, s;\n\t\tif (format === 'asn1') {\n\t\t\tvar der = new asn1.BerWriter();\n\t\t\tder.startSequence();\n\t\t\tr = utils.mpNormalize(this.part.r.data);\n\t\t\ts = utils.mpNormalize(this.part.s.data);\n\t\t\tder.writeBuffer(r, asn1.Ber.Integer);\n\t\t\tder.writeBuffer(s, asn1.Ber.Integer);\n\t\t\tder.endSequence();\n\t\t\treturn (der.buffer);\n\t\t} else if (format === 'ssh' && this.type === 'dsa') {\n\t\t\tbuf = new SSHBuffer({});\n\t\t\tbuf.writeString('ssh-dss');\n\t\t\tr = this.part.r.data;\n\t\t\tif (r.length > 20 && r[0] === 0x00)\n\t\t\t\tr = r.slice(1);\n\t\t\ts = this.part.s.data;\n\t\t\tif (s.length > 20 && s[0] === 0x00)\n\t\t\t\ts = s.slice(1);\n\t\t\tif ((this.hashAlgorithm &&\n\t\t\t    this.hashAlgorithm !== 'sha1') ||\n\t\t\t    r.length + s.length !== 40) {\n\t\t\t\tthrow (new Error('OpenSSH only supports ' +\n\t\t\t\t    'DSA signatures with SHA1 hash'));\n\t\t\t}\n\t\t\tbuf.writeBuffer(Buffer.concat([r, s]));\n\t\t\treturn (buf.toBuffer());\n\t\t} else if (format === 'ssh' && this.type === 'ecdsa') {\n\t\t\tvar inner = new SSHBuffer({});\n\t\t\tr = this.part.r.data;\n\t\t\tinner.writeBuffer(r);\n\t\t\tinner.writePart(this.part.s);\n\n\t\t\tbuf = new SSHBuffer({});\n\t\t\t/* XXX: find a more proper way to do this? */\n\t\t\tvar curve;\n\t\t\tif (r[0] === 0x00)\n\t\t\t\tr = r.slice(1);\n\t\t\tvar sz = r.length * 8;\n\t\t\tif (sz === 256)\n\t\t\t\tcurve = 'nistp256';\n\t\t\telse if (sz === 384)\n\t\t\t\tcurve = 'nistp384';\n\t\t\telse if (sz === 528)\n\t\t\t\tcurve = 'nistp521';\n\t\t\tbuf.writeString('ecdsa-sha2-' + curve);\n\t\t\tbuf.writeBuffer(inner.toBuffer());\n\t\t\treturn (buf.toBuffer());\n\t\t}\n\t\tthrow (new Error('Invalid signature format'));\n\tdefault:\n\t\tthrow (new Error('Invalid signature data'));\n\t}\n};\n\nSignature.prototype.toString = function (format) {\n\tassert.optionalString(format, 'format');\n\treturn (this.toBuffer(format).toString('base64'));\n};\n\nSignature.parse = function (data, type, format) {\n\tif (typeof (data) === 'string')\n\t\tdata = Buffer.from(data, 'base64');\n\tassert.buffer(data, 'data');\n\tassert.string(format, 'format');\n\tassert.string(type, 'type');\n\n\tvar opts = {};\n\topts.type = type.toLowerCase();\n\topts.parts = [];\n\n\ttry {\n\t\tassert.ok(data.length > 0, 'signature must not be empty');\n\t\tswitch (opts.type) {\n\t\tcase 'rsa':\n\t\t\treturn (parseOneNum(data, type, format, opts));\n\t\tcase 'ed25519':\n\t\t\treturn (parseOneNum(data, type, format, opts));\n\n\t\tcase 'dsa':\n\t\tcase 'ecdsa':\n\t\t\tif (format === 'asn1')\n\t\t\t\treturn (parseDSAasn1(data, type, format, opts));\n\t\t\telse if (opts.type === 'dsa')\n\t\t\t\treturn (parseDSA(data, type, format, opts));\n\t\t\telse\n\t\t\t\treturn (parseECDSA(data, type, format, opts));\n\n\t\tdefault:\n\t\t\tthrow (new InvalidAlgorithmError(type));\n\t\t}\n\n\t} catch (e) {\n\t\tif (e instanceof InvalidAlgorithmError)\n\t\t\tthrow (e);\n\t\tthrow (new SignatureParseError(type, format, e));\n\t}\n};\n\nfunction parseOneNum(data, type, format, opts) {\n\tif (format === 'ssh') {\n\t\ttry {\n\t\t\tvar buf = new SSHBuffer({buffer: data});\n\t\t\tvar head = buf.readString();\n\t\t} catch (e) {\n\t\t\t/* fall through */\n\t\t}\n\t\tif (buf !== undefined) {\n\t\t\tvar msg = 'SSH signature does not match expected ' +\n\t\t\t    'type (expected ' + type + ', got ' + head + ')';\n\t\t\tswitch (head) {\n\t\t\tcase 'ssh-rsa':\n\t\t\t\tassert.strictEqual(type, 'rsa', msg);\n\t\t\t\topts.hashAlgo = 'sha1';\n\t\t\t\tbreak;\n\t\t\tcase 'rsa-sha2-256':\n\t\t\t\tassert.strictEqual(type, 'rsa', msg);\n\t\t\t\topts.hashAlgo = 'sha256';\n\t\t\t\tbreak;\n\t\t\tcase 'rsa-sha2-512':\n\t\t\t\tassert.strictEqual(type, 'rsa', msg);\n\t\t\t\topts.hashAlgo = 'sha512';\n\t\t\t\tbreak;\n\t\t\tcase 'ssh-ed25519':\n\t\t\t\tassert.strictEqual(type, 'ed25519', msg);\n\t\t\t\topts.hashAlgo = 'sha512';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow (new Error('Unknown SSH signature ' +\n\t\t\t\t    'type: ' + head));\n\t\t\t}\n\t\t\tvar sig = buf.readPart();\n\t\t\tassert.ok(buf.atEnd(), 'extra trailing bytes');\n\t\t\tsig.name = 'sig';\n\t\t\topts.parts.push(sig);\n\t\t\treturn (new Signature(opts));\n\t\t}\n\t}\n\topts.parts.push({name: 'sig', data: data});\n\treturn (new Signature(opts));\n}\n\nfunction parseDSAasn1(data, type, format, opts) {\n\tvar der = new asn1.BerReader(data);\n\tder.readSequence();\n\tvar r = der.readString(asn1.Ber.Integer, true);\n\tvar s = der.readString(asn1.Ber.Integer, true);\n\n\topts.parts.push({name: 'r', data: utils.mpNormalize(r)});\n\topts.parts.push({name: 's', data: utils.mpNormalize(s)});\n\n\treturn (new Signature(opts));\n}\n\nfunction parseDSA(data, type, format, opts) {\n\tif (data.length != 40) {\n\t\tvar buf = new SSHBuffer({buffer: data});\n\t\tvar d = buf.readBuffer();\n\t\tif (d.toString('ascii') === 'ssh-dss')\n\t\t\td = buf.readBuffer();\n\t\tassert.ok(buf.atEnd(), 'extra trailing bytes');\n\t\tassert.strictEqual(d.length, 40, 'invalid inner length');\n\t\tdata = d;\n\t}\n\topts.parts.push({name: 'r', data: data.slice(0, 20)});\n\topts.parts.push({name: 's', data: data.slice(20, 40)});\n\treturn (new Signature(opts));\n}\n\nfunction parseECDSA(data, type, format, opts) {\n\tvar buf = new SSHBuffer({buffer: data});\n\n\tvar r, s;\n\tvar inner = buf.readBuffer();\n\tvar stype = inner.toString('ascii');\n\tif (stype.slice(0, 6) === 'ecdsa-') {\n\t\tvar parts = stype.split('-');\n\t\tassert.strictEqual(parts[0], 'ecdsa');\n\t\tassert.strictEqual(parts[1], 'sha2');\n\t\topts.curve = parts[2];\n\t\tswitch (opts.curve) {\n\t\tcase 'nistp256':\n\t\t\topts.hashAlgo = 'sha256';\n\t\t\tbreak;\n\t\tcase 'nistp384':\n\t\t\topts.hashAlgo = 'sha384';\n\t\t\tbreak;\n\t\tcase 'nistp521':\n\t\t\topts.hashAlgo = 'sha512';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new Error('Unsupported ECDSA curve: ' +\n\t\t\t    opts.curve));\n\t\t}\n\t\tinner = buf.readBuffer();\n\t\tassert.ok(buf.atEnd(), 'extra trailing bytes on outer');\n\t\tbuf = new SSHBuffer({buffer: inner});\n\t\tr = buf.readPart();\n\t} else {\n\t\tr = {data: inner};\n\t}\n\n\ts = buf.readPart();\n\tassert.ok(buf.atEnd(), 'extra trailing bytes');\n\n\tr.name = 'r';\n\ts.name = 's';\n\n\topts.parts.push(r);\n\topts.parts.push(s);\n\treturn (new Signature(opts));\n}\n\nSignature.isSignature = function (obj, ver) {\n\treturn (utils.isCompatible(obj, Signature, ver));\n};\n\n/*\n * API versions for Signature:\n * [1,0] -- initial ver\n * [2,0] -- support for rsa in full ssh format, compat with sshpk-agent\n *          hashAlgorithm property\n * [2,1] -- first tagged version\n */\nSignature.prototype._sshpkApiVersion = [2, 1];\n\nSignature._oldVersionDetect = function (obj) {\n\tassert.func(obj.toBuffer);\n\tif (obj.hasOwnProperty('hashAlgorithm'))\n\t\treturn ([2, 0]);\n\treturn ([1, 0]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsK0RBQWE7QUFDbEMsYUFBYSw4RkFBOEI7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLHNEQUFRO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixXQUFXLG1CQUFPLENBQUMsMERBQVU7QUFDN0IsWUFBWSxtQkFBTyxDQUFDLHdEQUFTO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxvREFBTTtBQUN6QixnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBYzs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNDQUFzQztBQUN4RCxrQkFBa0Isc0NBQXNDOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQ0FBbUM7QUFDckQsa0JBQWtCLG9DQUFvQztBQUN0RDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGFBQWE7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0EsR0FBRztBQUNILE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvc2lnbmF0dXJlLmpzPzU0NDYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0gU2lnbmF0dXJlO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4vYWxncycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIGVycnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGFzbjEgPSByZXF1aXJlKCdhc24xJyk7XG52YXIgU1NIQnVmZmVyID0gcmVxdWlyZSgnLi9zc2gtYnVmZmVyJyk7XG5cbnZhciBJbnZhbGlkQWxnb3JpdGhtRXJyb3IgPSBlcnJzLkludmFsaWRBbGdvcml0aG1FcnJvcjtcbnZhciBTaWduYXR1cmVQYXJzZUVycm9yID0gZXJycy5TaWduYXR1cmVQYXJzZUVycm9yO1xuXG5mdW5jdGlvbiBTaWduYXR1cmUob3B0cykge1xuXHRhc3NlcnQub2JqZWN0KG9wdHMsICdvcHRpb25zJyk7XG5cdGFzc2VydC5hcnJheU9mT2JqZWN0KG9wdHMucGFydHMsICdvcHRpb25zLnBhcnRzJyk7XG5cdGFzc2VydC5zdHJpbmcob3B0cy50eXBlLCAnb3B0aW9ucy50eXBlJyk7XG5cblx0dmFyIHBhcnRMb29rdXAgPSB7fTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvcHRzLnBhcnRzLmxlbmd0aDsgKytpKSB7XG5cdFx0dmFyIHBhcnQgPSBvcHRzLnBhcnRzW2ldO1xuXHRcdHBhcnRMb29rdXBbcGFydC5uYW1lXSA9IHBhcnQ7XG5cdH1cblxuXHR0aGlzLnR5cGUgPSBvcHRzLnR5cGU7XG5cdHRoaXMuaGFzaEFsZ29yaXRobSA9IG9wdHMuaGFzaEFsZ287XG5cdHRoaXMuY3VydmUgPSBvcHRzLmN1cnZlO1xuXHR0aGlzLnBhcnRzID0gb3B0cy5wYXJ0cztcblx0dGhpcy5wYXJ0ID0gcGFydExvb2t1cDtcbn1cblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcblx0aWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKVxuXHRcdGZvcm1hdCA9ICdhc24xJztcblx0YXNzZXJ0LnN0cmluZyhmb3JtYXQsICdmb3JtYXQnKTtcblxuXHR2YXIgYnVmO1xuXHR2YXIgc3R5cGUgPSAnc3NoLScgKyB0aGlzLnR5cGU7XG5cblx0c3dpdGNoICh0aGlzLnR5cGUpIHtcblx0Y2FzZSAncnNhJzpcblx0XHRzd2l0Y2ggKHRoaXMuaGFzaEFsZ29yaXRobSkge1xuXHRcdGNhc2UgJ3NoYTI1Nic6XG5cdFx0XHRzdHlwZSA9ICdyc2Etc2hhMi0yNTYnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnc2hhNTEyJzpcblx0XHRcdHN0eXBlID0gJ3JzYS1zaGEyLTUxMic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdzaGExJzpcblx0XHRjYXNlIHVuZGVmaW5lZDpcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdTU0ggc2lnbmF0dXJlICcgK1xuXHRcdFx0ICAgICdmb3JtYXQgZG9lcyBub3Qgc3VwcG9ydCBoYXNoICcgK1xuXHRcdFx0ICAgICdhbGdvcml0aG0gJyArIHRoaXMuaGFzaEFsZ29yaXRobSkpO1xuXHRcdH1cblx0XHRpZiAoZm9ybWF0ID09PSAnc3NoJykge1xuXHRcdFx0YnVmID0gbmV3IFNTSEJ1ZmZlcih7fSk7XG5cdFx0XHRidWYud3JpdGVTdHJpbmcoc3R5cGUpO1xuXHRcdFx0YnVmLndyaXRlUGFydCh0aGlzLnBhcnQuc2lnKTtcblx0XHRcdHJldHVybiAoYnVmLnRvQnVmZmVyKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKHRoaXMucGFydC5zaWcuZGF0YSk7XG5cdFx0fVxuXHRcdGJyZWFrO1xuXG5cdGNhc2UgJ2VkMjU1MTknOlxuXHRcdGlmIChmb3JtYXQgPT09ICdzc2gnKSB7XG5cdFx0XHRidWYgPSBuZXcgU1NIQnVmZmVyKHt9KTtcblx0XHRcdGJ1Zi53cml0ZVN0cmluZyhzdHlwZSk7XG5cdFx0XHRidWYud3JpdGVQYXJ0KHRoaXMucGFydC5zaWcpO1xuXHRcdFx0cmV0dXJuIChidWYudG9CdWZmZXIoKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAodGhpcy5wYXJ0LnNpZy5kYXRhKTtcblx0XHR9XG5cdFx0YnJlYWs7XG5cblx0Y2FzZSAnZHNhJzpcblx0Y2FzZSAnZWNkc2EnOlxuXHRcdHZhciByLCBzO1xuXHRcdGlmIChmb3JtYXQgPT09ICdhc24xJykge1xuXHRcdFx0dmFyIGRlciA9IG5ldyBhc24xLkJlcldyaXRlcigpO1xuXHRcdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblx0XHRcdHIgPSB1dGlscy5tcE5vcm1hbGl6ZSh0aGlzLnBhcnQuci5kYXRhKTtcblx0XHRcdHMgPSB1dGlscy5tcE5vcm1hbGl6ZSh0aGlzLnBhcnQucy5kYXRhKTtcblx0XHRcdGRlci53cml0ZUJ1ZmZlcihyLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0XHRcdGRlci53cml0ZUJ1ZmZlcihzLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0XHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRcdFx0cmV0dXJuIChkZXIuYnVmZmVyKTtcblx0XHR9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ3NzaCcgJiYgdGhpcy50eXBlID09PSAnZHNhJykge1xuXHRcdFx0YnVmID0gbmV3IFNTSEJ1ZmZlcih7fSk7XG5cdFx0XHRidWYud3JpdGVTdHJpbmcoJ3NzaC1kc3MnKTtcblx0XHRcdHIgPSB0aGlzLnBhcnQuci5kYXRhO1xuXHRcdFx0aWYgKHIubGVuZ3RoID4gMjAgJiYgclswXSA9PT0gMHgwMClcblx0XHRcdFx0ciA9IHIuc2xpY2UoMSk7XG5cdFx0XHRzID0gdGhpcy5wYXJ0LnMuZGF0YTtcblx0XHRcdGlmIChzLmxlbmd0aCA+IDIwICYmIHNbMF0gPT09IDB4MDApXG5cdFx0XHRcdHMgPSBzLnNsaWNlKDEpO1xuXHRcdFx0aWYgKCh0aGlzLmhhc2hBbGdvcml0aG0gJiZcblx0XHRcdCAgICB0aGlzLmhhc2hBbGdvcml0aG0gIT09ICdzaGExJykgfHxcblx0XHRcdCAgICByLmxlbmd0aCArIHMubGVuZ3RoICE9PSA0MCkge1xuXHRcdFx0XHR0aHJvdyAobmV3IEVycm9yKCdPcGVuU1NIIG9ubHkgc3VwcG9ydHMgJyArXG5cdFx0XHRcdCAgICAnRFNBIHNpZ25hdHVyZXMgd2l0aCBTSEExIGhhc2gnKSk7XG5cdFx0XHR9XG5cdFx0XHRidWYud3JpdGVCdWZmZXIoQnVmZmVyLmNvbmNhdChbciwgc10pKTtcblx0XHRcdHJldHVybiAoYnVmLnRvQnVmZmVyKCkpO1xuXHRcdH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnc3NoJyAmJiB0aGlzLnR5cGUgPT09ICdlY2RzYScpIHtcblx0XHRcdHZhciBpbm5lciA9IG5ldyBTU0hCdWZmZXIoe30pO1xuXHRcdFx0ciA9IHRoaXMucGFydC5yLmRhdGE7XG5cdFx0XHRpbm5lci53cml0ZUJ1ZmZlcihyKTtcblx0XHRcdGlubmVyLndyaXRlUGFydCh0aGlzLnBhcnQucyk7XG5cblx0XHRcdGJ1ZiA9IG5ldyBTU0hCdWZmZXIoe30pO1xuXHRcdFx0LyogWFhYOiBmaW5kIGEgbW9yZSBwcm9wZXIgd2F5IHRvIGRvIHRoaXM/ICovXG5cdFx0XHR2YXIgY3VydmU7XG5cdFx0XHRpZiAoclswXSA9PT0gMHgwMClcblx0XHRcdFx0ciA9IHIuc2xpY2UoMSk7XG5cdFx0XHR2YXIgc3ogPSByLmxlbmd0aCAqIDg7XG5cdFx0XHRpZiAoc3ogPT09IDI1Nilcblx0XHRcdFx0Y3VydmUgPSAnbmlzdHAyNTYnO1xuXHRcdFx0ZWxzZSBpZiAoc3ogPT09IDM4NClcblx0XHRcdFx0Y3VydmUgPSAnbmlzdHAzODQnO1xuXHRcdFx0ZWxzZSBpZiAoc3ogPT09IDUyOClcblx0XHRcdFx0Y3VydmUgPSAnbmlzdHA1MjEnO1xuXHRcdFx0YnVmLndyaXRlU3RyaW5nKCdlY2RzYS1zaGEyLScgKyBjdXJ2ZSk7XG5cdFx0XHRidWYud3JpdGVCdWZmZXIoaW5uZXIudG9CdWZmZXIoKSk7XG5cdFx0XHRyZXR1cm4gKGJ1Zi50b0J1ZmZlcigpKTtcblx0XHR9XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgZm9ybWF0JykpO1xuXHRkZWZhdWx0OlxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGRhdGEnKSk7XG5cdH1cbn07XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdGFzc2VydC5vcHRpb25hbFN0cmluZyhmb3JtYXQsICdmb3JtYXQnKTtcblx0cmV0dXJuICh0aGlzLnRvQnVmZmVyKGZvcm1hdCkudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbn07XG5cblNpZ25hdHVyZS5wYXJzZSA9IGZ1bmN0aW9uIChkYXRhLCB0eXBlLCBmb3JtYXQpIHtcblx0aWYgKHR5cGVvZiAoZGF0YSkgPT09ICdzdHJpbmcnKVxuXHRcdGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCAnYmFzZTY0Jyk7XG5cdGFzc2VydC5idWZmZXIoZGF0YSwgJ2RhdGEnKTtcblx0YXNzZXJ0LnN0cmluZyhmb3JtYXQsICdmb3JtYXQnKTtcblx0YXNzZXJ0LnN0cmluZyh0eXBlLCAndHlwZScpO1xuXG5cdHZhciBvcHRzID0ge307XG5cdG9wdHMudHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblx0b3B0cy5wYXJ0cyA9IFtdO1xuXG5cdHRyeSB7XG5cdFx0YXNzZXJ0Lm9rKGRhdGEubGVuZ3RoID4gMCwgJ3NpZ25hdHVyZSBtdXN0IG5vdCBiZSBlbXB0eScpO1xuXHRcdHN3aXRjaCAob3B0cy50eXBlKSB7XG5cdFx0Y2FzZSAncnNhJzpcblx0XHRcdHJldHVybiAocGFyc2VPbmVOdW0oZGF0YSwgdHlwZSwgZm9ybWF0LCBvcHRzKSk7XG5cdFx0Y2FzZSAnZWQyNTUxOSc6XG5cdFx0XHRyZXR1cm4gKHBhcnNlT25lTnVtKGRhdGEsIHR5cGUsIGZvcm1hdCwgb3B0cykpO1xuXG5cdFx0Y2FzZSAnZHNhJzpcblx0XHRjYXNlICdlY2RzYSc6XG5cdFx0XHRpZiAoZm9ybWF0ID09PSAnYXNuMScpXG5cdFx0XHRcdHJldHVybiAocGFyc2VEU0Fhc24xKGRhdGEsIHR5cGUsIGZvcm1hdCwgb3B0cykpO1xuXHRcdFx0ZWxzZSBpZiAob3B0cy50eXBlID09PSAnZHNhJylcblx0XHRcdFx0cmV0dXJuIChwYXJzZURTQShkYXRhLCB0eXBlLCBmb3JtYXQsIG9wdHMpKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0cmV0dXJuIChwYXJzZUVDRFNBKGRhdGEsIHR5cGUsIGZvcm1hdCwgb3B0cykpO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKHR5cGUpKTtcblx0XHR9XG5cblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmIChlIGluc3RhbmNlb2YgSW52YWxpZEFsZ29yaXRobUVycm9yKVxuXHRcdFx0dGhyb3cgKGUpO1xuXHRcdHRocm93IChuZXcgU2lnbmF0dXJlUGFyc2VFcnJvcih0eXBlLCBmb3JtYXQsIGUpKTtcblx0fVxufTtcblxuZnVuY3Rpb24gcGFyc2VPbmVOdW0oZGF0YSwgdHlwZSwgZm9ybWF0LCBvcHRzKSB7XG5cdGlmIChmb3JtYXQgPT09ICdzc2gnKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHZhciBidWYgPSBuZXcgU1NIQnVmZmVyKHtidWZmZXI6IGRhdGF9KTtcblx0XHRcdHZhciBoZWFkID0gYnVmLnJlYWRTdHJpbmcoKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvKiBmYWxsIHRocm91Z2ggKi9cblx0XHR9XG5cdFx0aWYgKGJ1ZiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR2YXIgbXNnID0gJ1NTSCBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgJyArXG5cdFx0XHQgICAgJ3R5cGUgKGV4cGVjdGVkICcgKyB0eXBlICsgJywgZ290ICcgKyBoZWFkICsgJyknO1xuXHRcdFx0c3dpdGNoIChoZWFkKSB7XG5cdFx0XHRjYXNlICdzc2gtcnNhJzpcblx0XHRcdFx0YXNzZXJ0LnN0cmljdEVxdWFsKHR5cGUsICdyc2EnLCBtc2cpO1xuXHRcdFx0XHRvcHRzLmhhc2hBbGdvID0gJ3NoYTEnO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3JzYS1zaGEyLTI1Nic6XG5cdFx0XHRcdGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlLCAncnNhJywgbXNnKTtcblx0XHRcdFx0b3B0cy5oYXNoQWxnbyA9ICdzaGEyNTYnO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3JzYS1zaGEyLTUxMic6XG5cdFx0XHRcdGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlLCAncnNhJywgbXNnKTtcblx0XHRcdFx0b3B0cy5oYXNoQWxnbyA9ICdzaGE1MTInO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3NzaC1lZDI1NTE5Jzpcblx0XHRcdFx0YXNzZXJ0LnN0cmljdEVxdWFsKHR5cGUsICdlZDI1NTE5JywgbXNnKTtcblx0XHRcdFx0b3B0cy5oYXNoQWxnbyA9ICdzaGE1MTInO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IChuZXcgRXJyb3IoJ1Vua25vd24gU1NIIHNpZ25hdHVyZSAnICtcblx0XHRcdFx0ICAgICd0eXBlOiAnICsgaGVhZCkpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHNpZyA9IGJ1Zi5yZWFkUGFydCgpO1xuXHRcdFx0YXNzZXJ0Lm9rKGJ1Zi5hdEVuZCgpLCAnZXh0cmEgdHJhaWxpbmcgYnl0ZXMnKTtcblx0XHRcdHNpZy5uYW1lID0gJ3NpZyc7XG5cdFx0XHRvcHRzLnBhcnRzLnB1c2goc2lnKTtcblx0XHRcdHJldHVybiAobmV3IFNpZ25hdHVyZShvcHRzKSk7XG5cdFx0fVxuXHR9XG5cdG9wdHMucGFydHMucHVzaCh7bmFtZTogJ3NpZycsIGRhdGE6IGRhdGF9KTtcblx0cmV0dXJuIChuZXcgU2lnbmF0dXJlKG9wdHMpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEU0Fhc24xKGRhdGEsIHR5cGUsIGZvcm1hdCwgb3B0cykge1xuXHR2YXIgZGVyID0gbmV3IGFzbjEuQmVyUmVhZGVyKGRhdGEpO1xuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdHZhciByID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuSW50ZWdlciwgdHJ1ZSk7XG5cdHZhciBzID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuSW50ZWdlciwgdHJ1ZSk7XG5cblx0b3B0cy5wYXJ0cy5wdXNoKHtuYW1lOiAncicsIGRhdGE6IHV0aWxzLm1wTm9ybWFsaXplKHIpfSk7XG5cdG9wdHMucGFydHMucHVzaCh7bmFtZTogJ3MnLCBkYXRhOiB1dGlscy5tcE5vcm1hbGl6ZShzKX0pO1xuXG5cdHJldHVybiAobmV3IFNpZ25hdHVyZShvcHRzKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRFNBKGRhdGEsIHR5cGUsIGZvcm1hdCwgb3B0cykge1xuXHRpZiAoZGF0YS5sZW5ndGggIT0gNDApIHtcblx0XHR2YXIgYnVmID0gbmV3IFNTSEJ1ZmZlcih7YnVmZmVyOiBkYXRhfSk7XG5cdFx0dmFyIGQgPSBidWYucmVhZEJ1ZmZlcigpO1xuXHRcdGlmIChkLnRvU3RyaW5nKCdhc2NpaScpID09PSAnc3NoLWRzcycpXG5cdFx0XHRkID0gYnVmLnJlYWRCdWZmZXIoKTtcblx0XHRhc3NlcnQub2soYnVmLmF0RW5kKCksICdleHRyYSB0cmFpbGluZyBieXRlcycpO1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChkLmxlbmd0aCwgNDAsICdpbnZhbGlkIGlubmVyIGxlbmd0aCcpO1xuXHRcdGRhdGEgPSBkO1xuXHR9XG5cdG9wdHMucGFydHMucHVzaCh7bmFtZTogJ3InLCBkYXRhOiBkYXRhLnNsaWNlKDAsIDIwKX0pO1xuXHRvcHRzLnBhcnRzLnB1c2goe25hbWU6ICdzJywgZGF0YTogZGF0YS5zbGljZSgyMCwgNDApfSk7XG5cdHJldHVybiAobmV3IFNpZ25hdHVyZShvcHRzKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRUNEU0EoZGF0YSwgdHlwZSwgZm9ybWF0LCBvcHRzKSB7XG5cdHZhciBidWYgPSBuZXcgU1NIQnVmZmVyKHtidWZmZXI6IGRhdGF9KTtcblxuXHR2YXIgciwgcztcblx0dmFyIGlubmVyID0gYnVmLnJlYWRCdWZmZXIoKTtcblx0dmFyIHN0eXBlID0gaW5uZXIudG9TdHJpbmcoJ2FzY2lpJyk7XG5cdGlmIChzdHlwZS5zbGljZSgwLCA2KSA9PT0gJ2VjZHNhLScpIHtcblx0XHR2YXIgcGFydHMgPSBzdHlwZS5zcGxpdCgnLScpO1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChwYXJ0c1swXSwgJ2VjZHNhJyk7XG5cdFx0YXNzZXJ0LnN0cmljdEVxdWFsKHBhcnRzWzFdLCAnc2hhMicpO1xuXHRcdG9wdHMuY3VydmUgPSBwYXJ0c1syXTtcblx0XHRzd2l0Y2ggKG9wdHMuY3VydmUpIHtcblx0XHRjYXNlICduaXN0cDI1Nic6XG5cdFx0XHRvcHRzLmhhc2hBbGdvID0gJ3NoYTI1Nic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICduaXN0cDM4NCc6XG5cdFx0XHRvcHRzLmhhc2hBbGdvID0gJ3NoYTM4NCc7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICduaXN0cDUyMSc6XG5cdFx0XHRvcHRzLmhhc2hBbGdvID0gJ3NoYTUxMic7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgRUNEU0EgY3VydmU6ICcgK1xuXHRcdFx0ICAgIG9wdHMuY3VydmUpKTtcblx0XHR9XG5cdFx0aW5uZXIgPSBidWYucmVhZEJ1ZmZlcigpO1xuXHRcdGFzc2VydC5vayhidWYuYXRFbmQoKSwgJ2V4dHJhIHRyYWlsaW5nIGJ5dGVzIG9uIG91dGVyJyk7XG5cdFx0YnVmID0gbmV3IFNTSEJ1ZmZlcih7YnVmZmVyOiBpbm5lcn0pO1xuXHRcdHIgPSBidWYucmVhZFBhcnQoKTtcblx0fSBlbHNlIHtcblx0XHRyID0ge2RhdGE6IGlubmVyfTtcblx0fVxuXG5cdHMgPSBidWYucmVhZFBhcnQoKTtcblx0YXNzZXJ0Lm9rKGJ1Zi5hdEVuZCgpLCAnZXh0cmEgdHJhaWxpbmcgYnl0ZXMnKTtcblxuXHRyLm5hbWUgPSAncic7XG5cdHMubmFtZSA9ICdzJztcblxuXHRvcHRzLnBhcnRzLnB1c2gocik7XG5cdG9wdHMucGFydHMucHVzaChzKTtcblx0cmV0dXJuIChuZXcgU2lnbmF0dXJlKG9wdHMpKTtcbn1cblxuU2lnbmF0dXJlLmlzU2lnbmF0dXJlID0gZnVuY3Rpb24gKG9iaiwgdmVyKSB7XG5cdHJldHVybiAodXRpbHMuaXNDb21wYXRpYmxlKG9iaiwgU2lnbmF0dXJlLCB2ZXIpKTtcbn07XG5cbi8qXG4gKiBBUEkgdmVyc2lvbnMgZm9yIFNpZ25hdHVyZTpcbiAqIFsxLDBdIC0tIGluaXRpYWwgdmVyXG4gKiBbMiwwXSAtLSBzdXBwb3J0IGZvciByc2EgaW4gZnVsbCBzc2ggZm9ybWF0LCBjb21wYXQgd2l0aCBzc2hway1hZ2VudFxuICogICAgICAgICAgaGFzaEFsZ29yaXRobSBwcm9wZXJ0eVxuICogWzIsMV0gLS0gZmlyc3QgdGFnZ2VkIHZlcnNpb25cbiAqL1xuU2lnbmF0dXJlLnByb3RvdHlwZS5fc3NocGtBcGlWZXJzaW9uID0gWzIsIDFdO1xuXG5TaWduYXR1cmUuX29sZFZlcnNpb25EZXRlY3QgPSBmdW5jdGlvbiAob2JqKSB7XG5cdGFzc2VydC5mdW5jKG9iai50b0J1ZmZlcik7XG5cdGlmIChvYmouaGFzT3duUHJvcGVydHkoJ2hhc2hBbGdvcml0aG0nKSlcblx0XHRyZXR1cm4gKFsyLCAwXSk7XG5cdHJldHVybiAoWzEsIDBdKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/signature.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/ssh-buffer.js":
/*!**********************************************!*\
  !*** ./node_modules/sshpk/lib/ssh-buffer.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = SSHBuffer;\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\n\nfunction SSHBuffer(opts) {\n\tassert.object(opts, 'options');\n\tif (opts.buffer !== undefined)\n\t\tassert.buffer(opts.buffer, 'options.buffer');\n\n\tthis._size = opts.buffer ? opts.buffer.length : 1024;\n\tthis._buffer = opts.buffer || Buffer.alloc(this._size);\n\tthis._offset = 0;\n}\n\nSSHBuffer.prototype.toBuffer = function () {\n\treturn (this._buffer.slice(0, this._offset));\n};\n\nSSHBuffer.prototype.atEnd = function () {\n\treturn (this._offset >= this._buffer.length);\n};\n\nSSHBuffer.prototype.remainder = function () {\n\treturn (this._buffer.slice(this._offset));\n};\n\nSSHBuffer.prototype.skip = function (n) {\n\tthis._offset += n;\n};\n\nSSHBuffer.prototype.expand = function () {\n\tthis._size *= 2;\n\tvar buf = Buffer.alloc(this._size);\n\tthis._buffer.copy(buf, 0);\n\tthis._buffer = buf;\n};\n\nSSHBuffer.prototype.readPart = function () {\n\treturn ({data: this.readBuffer()});\n};\n\nSSHBuffer.prototype.readBuffer = function () {\n\tvar len = this._buffer.readUInt32BE(this._offset);\n\tthis._offset += 4;\n\tassert.ok(this._offset + len <= this._buffer.length,\n\t    'length out of bounds at +0x' + this._offset.toString(16) +\n\t    ' (data truncated?)');\n\tvar buf = this._buffer.slice(this._offset, this._offset + len);\n\tthis._offset += len;\n\treturn (buf);\n};\n\nSSHBuffer.prototype.readString = function () {\n\treturn (this.readBuffer().toString());\n};\n\nSSHBuffer.prototype.readCString = function () {\n\tvar offset = this._offset;\n\twhile (offset < this._buffer.length &&\n\t    this._buffer[offset] !== 0x00)\n\t\toffset++;\n\tassert.ok(offset < this._buffer.length, 'c string does not terminate');\n\tvar str = this._buffer.slice(this._offset, offset).toString();\n\tthis._offset = offset + 1;\n\treturn (str);\n};\n\nSSHBuffer.prototype.readInt = function () {\n\tvar v = this._buffer.readUInt32BE(this._offset);\n\tthis._offset += 4;\n\treturn (v);\n};\n\nSSHBuffer.prototype.readInt64 = function () {\n\tassert.ok(this._offset + 8 < this._buffer.length,\n\t    'buffer not long enough to read Int64');\n\tvar v = this._buffer.slice(this._offset, this._offset + 8);\n\tthis._offset += 8;\n\treturn (v);\n};\n\nSSHBuffer.prototype.readChar = function () {\n\tvar v = this._buffer[this._offset++];\n\treturn (v);\n};\n\nSSHBuffer.prototype.writeBuffer = function (buf) {\n\twhile (this._offset + 4 + buf.length > this._size)\n\t\tthis.expand();\n\tthis._buffer.writeUInt32BE(buf.length, this._offset);\n\tthis._offset += 4;\n\tbuf.copy(this._buffer, this._offset);\n\tthis._offset += buf.length;\n};\n\nSSHBuffer.prototype.writeString = function (str) {\n\tthis.writeBuffer(Buffer.from(str, 'utf8'));\n};\n\nSSHBuffer.prototype.writeCString = function (str) {\n\twhile (this._offset + 1 + str.length > this._size)\n\t\tthis.expand();\n\tthis._buffer.write(str, this._offset);\n\tthis._offset += str.length;\n\tthis._buffer[this._offset++] = 0;\n};\n\nSSHBuffer.prototype.writeInt = function (v) {\n\twhile (this._offset + 4 > this._size)\n\t\tthis.expand();\n\tthis._buffer.writeUInt32BE(v, this._offset);\n\tthis._offset += 4;\n};\n\nSSHBuffer.prototype.writeInt64 = function (v) {\n\tassert.buffer(v, 'value');\n\tif (v.length > 8) {\n\t\tvar lead = v.slice(0, v.length - 8);\n\t\tfor (var i = 0; i < lead.length; ++i) {\n\t\t\tassert.strictEqual(lead[i], 0,\n\t\t\t    'must fit in 64 bits of precision');\n\t\t}\n\t\tv = v.slice(v.length - 8, v.length);\n\t}\n\twhile (this._offset + 8 > this._size)\n\t\tthis.expand();\n\tv.copy(this._buffer, this._offset);\n\tthis._offset += 8;\n};\n\nSSHBuffer.prototype.writeChar = function (v) {\n\twhile (this._offset + 1 > this._size)\n\t\tthis.expand();\n\tthis._buffer[this._offset++] = v;\n};\n\nSSHBuffer.prototype.writePart = function (p) {\n\tthis.writeBuffer(p.data);\n};\n\nSSHBuffer.prototype.write = function (buf) {\n\twhile (this._offset + buf.length > this._size)\n\t\tthis.expand();\n\tbuf.copy(this._buffer, this._offset);\n\tthis._offset += buf.length;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvc3NoLWJ1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsMEVBQWE7QUFDbEMsYUFBYSx5R0FBOEI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL3NzaC1idWZmZXIuanM/ZTE5MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNSBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSBTU0hCdWZmZXI7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcblxuZnVuY3Rpb24gU1NIQnVmZmVyKG9wdHMpIHtcblx0YXNzZXJ0Lm9iamVjdChvcHRzLCAnb3B0aW9ucycpO1xuXHRpZiAob3B0cy5idWZmZXIgIT09IHVuZGVmaW5lZClcblx0XHRhc3NlcnQuYnVmZmVyKG9wdHMuYnVmZmVyLCAnb3B0aW9ucy5idWZmZXInKTtcblxuXHR0aGlzLl9zaXplID0gb3B0cy5idWZmZXIgPyBvcHRzLmJ1ZmZlci5sZW5ndGggOiAxMDI0O1xuXHR0aGlzLl9idWZmZXIgPSBvcHRzLmJ1ZmZlciB8fCBCdWZmZXIuYWxsb2ModGhpcy5fc2l6ZSk7XG5cdHRoaXMuX29mZnNldCA9IDA7XG59XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAodGhpcy5fYnVmZmVyLnNsaWNlKDAsIHRoaXMuX29mZnNldCkpO1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS5hdEVuZCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICh0aGlzLl9vZmZzZXQgPj0gdGhpcy5fYnVmZmVyLmxlbmd0aCk7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICh0aGlzLl9idWZmZXIuc2xpY2UodGhpcy5fb2Zmc2V0KSk7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAobikge1xuXHR0aGlzLl9vZmZzZXQgKz0gbjtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLl9zaXplICo9IDI7XG5cdHZhciBidWYgPSBCdWZmZXIuYWxsb2ModGhpcy5fc2l6ZSk7XG5cdHRoaXMuX2J1ZmZlci5jb3B5KGJ1ZiwgMCk7XG5cdHRoaXMuX2J1ZmZlciA9IGJ1Zjtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUucmVhZFBhcnQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAoe2RhdGE6IHRoaXMucmVhZEJ1ZmZlcigpfSk7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLnJlYWRCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBsZW4gPSB0aGlzLl9idWZmZXIucmVhZFVJbnQzMkJFKHRoaXMuX29mZnNldCk7XG5cdHRoaXMuX29mZnNldCArPSA0O1xuXHRhc3NlcnQub2sodGhpcy5fb2Zmc2V0ICsgbGVuIDw9IHRoaXMuX2J1ZmZlci5sZW5ndGgsXG5cdCAgICAnbGVuZ3RoIG91dCBvZiBib3VuZHMgYXQgKzB4JyArIHRoaXMuX29mZnNldC50b1N0cmluZygxNikgK1xuXHQgICAgJyAoZGF0YSB0cnVuY2F0ZWQ/KScpO1xuXHR2YXIgYnVmID0gdGhpcy5fYnVmZmVyLnNsaWNlKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgbGVuKTtcblx0dGhpcy5fb2Zmc2V0ICs9IGxlbjtcblx0cmV0dXJuIChidWYpO1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS5yZWFkU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gKHRoaXMucmVhZEJ1ZmZlcigpLnRvU3RyaW5nKCkpO1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS5yZWFkQ1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIG9mZnNldCA9IHRoaXMuX29mZnNldDtcblx0d2hpbGUgKG9mZnNldCA8IHRoaXMuX2J1ZmZlci5sZW5ndGggJiZcblx0ICAgIHRoaXMuX2J1ZmZlcltvZmZzZXRdICE9PSAweDAwKVxuXHRcdG9mZnNldCsrO1xuXHRhc3NlcnQub2sob2Zmc2V0IDwgdGhpcy5fYnVmZmVyLmxlbmd0aCwgJ2Mgc3RyaW5nIGRvZXMgbm90IHRlcm1pbmF0ZScpO1xuXHR2YXIgc3RyID0gdGhpcy5fYnVmZmVyLnNsaWNlKHRoaXMuX29mZnNldCwgb2Zmc2V0KS50b1N0cmluZygpO1xuXHR0aGlzLl9vZmZzZXQgPSBvZmZzZXQgKyAxO1xuXHRyZXR1cm4gKHN0cik7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciB2ID0gdGhpcy5fYnVmZmVyLnJlYWRVSW50MzJCRSh0aGlzLl9vZmZzZXQpO1xuXHR0aGlzLl9vZmZzZXQgKz0gNDtcblx0cmV0dXJuICh2KTtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDY0ID0gZnVuY3Rpb24gKCkge1xuXHRhc3NlcnQub2sodGhpcy5fb2Zmc2V0ICsgOCA8IHRoaXMuX2J1ZmZlci5sZW5ndGgsXG5cdCAgICAnYnVmZmVyIG5vdCBsb25nIGVub3VnaCB0byByZWFkIEludDY0Jyk7XG5cdHZhciB2ID0gdGhpcy5fYnVmZmVyLnNsaWNlKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgOCk7XG5cdHRoaXMuX29mZnNldCArPSA4O1xuXHRyZXR1cm4gKHYpO1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS5yZWFkQ2hhciA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHYgPSB0aGlzLl9idWZmZXJbdGhpcy5fb2Zmc2V0KytdO1xuXHRyZXR1cm4gKHYpO1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS53cml0ZUJ1ZmZlciA9IGZ1bmN0aW9uIChidWYpIHtcblx0d2hpbGUgKHRoaXMuX29mZnNldCArIDQgKyBidWYubGVuZ3RoID4gdGhpcy5fc2l6ZSlcblx0XHR0aGlzLmV4cGFuZCgpO1xuXHR0aGlzLl9idWZmZXIud3JpdGVVSW50MzJCRShidWYubGVuZ3RoLCB0aGlzLl9vZmZzZXQpO1xuXHR0aGlzLl9vZmZzZXQgKz0gNDtcblx0YnVmLmNvcHkodGhpcy5fYnVmZmVyLCB0aGlzLl9vZmZzZXQpO1xuXHR0aGlzLl9vZmZzZXQgKz0gYnVmLmxlbmd0aDtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUud3JpdGVTdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpKTtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUud3JpdGVDU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuXHR3aGlsZSAodGhpcy5fb2Zmc2V0ICsgMSArIHN0ci5sZW5ndGggPiB0aGlzLl9zaXplKVxuXHRcdHRoaXMuZXhwYW5kKCk7XG5cdHRoaXMuX2J1ZmZlci53cml0ZShzdHIsIHRoaXMuX29mZnNldCk7XG5cdHRoaXMuX29mZnNldCArPSBzdHIubGVuZ3RoO1xuXHR0aGlzLl9idWZmZXJbdGhpcy5fb2Zmc2V0KytdID0gMDtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQgPSBmdW5jdGlvbiAodikge1xuXHR3aGlsZSAodGhpcy5fb2Zmc2V0ICsgNCA+IHRoaXMuX3NpemUpXG5cdFx0dGhpcy5leHBhbmQoKTtcblx0dGhpcy5fYnVmZmVyLndyaXRlVUludDMyQkUodiwgdGhpcy5fb2Zmc2V0KTtcblx0dGhpcy5fb2Zmc2V0ICs9IDQ7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLndyaXRlSW50NjQgPSBmdW5jdGlvbiAodikge1xuXHRhc3NlcnQuYnVmZmVyKHYsICd2YWx1ZScpO1xuXHRpZiAodi5sZW5ndGggPiA4KSB7XG5cdFx0dmFyIGxlYWQgPSB2LnNsaWNlKDAsIHYubGVuZ3RoIC0gOCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZWFkLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRhc3NlcnQuc3RyaWN0RXF1YWwobGVhZFtpXSwgMCxcblx0XHRcdCAgICAnbXVzdCBmaXQgaW4gNjQgYml0cyBvZiBwcmVjaXNpb24nKTtcblx0XHR9XG5cdFx0diA9IHYuc2xpY2Uodi5sZW5ndGggLSA4LCB2Lmxlbmd0aCk7XG5cdH1cblx0d2hpbGUgKHRoaXMuX29mZnNldCArIDggPiB0aGlzLl9zaXplKVxuXHRcdHRoaXMuZXhwYW5kKCk7XG5cdHYuY29weSh0aGlzLl9idWZmZXIsIHRoaXMuX29mZnNldCk7XG5cdHRoaXMuX29mZnNldCArPSA4O1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS53cml0ZUNoYXIgPSBmdW5jdGlvbiAodikge1xuXHR3aGlsZSAodGhpcy5fb2Zmc2V0ICsgMSA+IHRoaXMuX3NpemUpXG5cdFx0dGhpcy5leHBhbmQoKTtcblx0dGhpcy5fYnVmZmVyW3RoaXMuX29mZnNldCsrXSA9IHY7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLndyaXRlUGFydCA9IGZ1bmN0aW9uIChwKSB7XG5cdHRoaXMud3JpdGVCdWZmZXIocC5kYXRhKTtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG5cdHdoaWxlICh0aGlzLl9vZmZzZXQgKyBidWYubGVuZ3RoID4gdGhpcy5fc2l6ZSlcblx0XHR0aGlzLmV4cGFuZCgpO1xuXHRidWYuY29weSh0aGlzLl9idWZmZXIsIHRoaXMuX29mZnNldCk7XG5cdHRoaXMuX29mZnNldCArPSBidWYubGVuZ3RoO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/ssh-buffer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/ssh-buffer.js":
/*!**********************************************!*\
  !*** ./node_modules/sshpk/lib/ssh-buffer.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = SSHBuffer;\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\n\nfunction SSHBuffer(opts) {\n\tassert.object(opts, 'options');\n\tif (opts.buffer !== undefined)\n\t\tassert.buffer(opts.buffer, 'options.buffer');\n\n\tthis._size = opts.buffer ? opts.buffer.length : 1024;\n\tthis._buffer = opts.buffer || Buffer.alloc(this._size);\n\tthis._offset = 0;\n}\n\nSSHBuffer.prototype.toBuffer = function () {\n\treturn (this._buffer.slice(0, this._offset));\n};\n\nSSHBuffer.prototype.atEnd = function () {\n\treturn (this._offset >= this._buffer.length);\n};\n\nSSHBuffer.prototype.remainder = function () {\n\treturn (this._buffer.slice(this._offset));\n};\n\nSSHBuffer.prototype.skip = function (n) {\n\tthis._offset += n;\n};\n\nSSHBuffer.prototype.expand = function () {\n\tthis._size *= 2;\n\tvar buf = Buffer.alloc(this._size);\n\tthis._buffer.copy(buf, 0);\n\tthis._buffer = buf;\n};\n\nSSHBuffer.prototype.readPart = function () {\n\treturn ({data: this.readBuffer()});\n};\n\nSSHBuffer.prototype.readBuffer = function () {\n\tvar len = this._buffer.readUInt32BE(this._offset);\n\tthis._offset += 4;\n\tassert.ok(this._offset + len <= this._buffer.length,\n\t    'length out of bounds at +0x' + this._offset.toString(16) +\n\t    ' (data truncated?)');\n\tvar buf = this._buffer.slice(this._offset, this._offset + len);\n\tthis._offset += len;\n\treturn (buf);\n};\n\nSSHBuffer.prototype.readString = function () {\n\treturn (this.readBuffer().toString());\n};\n\nSSHBuffer.prototype.readCString = function () {\n\tvar offset = this._offset;\n\twhile (offset < this._buffer.length &&\n\t    this._buffer[offset] !== 0x00)\n\t\toffset++;\n\tassert.ok(offset < this._buffer.length, 'c string does not terminate');\n\tvar str = this._buffer.slice(this._offset, offset).toString();\n\tthis._offset = offset + 1;\n\treturn (str);\n};\n\nSSHBuffer.prototype.readInt = function () {\n\tvar v = this._buffer.readUInt32BE(this._offset);\n\tthis._offset += 4;\n\treturn (v);\n};\n\nSSHBuffer.prototype.readInt64 = function () {\n\tassert.ok(this._offset + 8 < this._buffer.length,\n\t    'buffer not long enough to read Int64');\n\tvar v = this._buffer.slice(this._offset, this._offset + 8);\n\tthis._offset += 8;\n\treturn (v);\n};\n\nSSHBuffer.prototype.readChar = function () {\n\tvar v = this._buffer[this._offset++];\n\treturn (v);\n};\n\nSSHBuffer.prototype.writeBuffer = function (buf) {\n\twhile (this._offset + 4 + buf.length > this._size)\n\t\tthis.expand();\n\tthis._buffer.writeUInt32BE(buf.length, this._offset);\n\tthis._offset += 4;\n\tbuf.copy(this._buffer, this._offset);\n\tthis._offset += buf.length;\n};\n\nSSHBuffer.prototype.writeString = function (str) {\n\tthis.writeBuffer(Buffer.from(str, 'utf8'));\n};\n\nSSHBuffer.prototype.writeCString = function (str) {\n\twhile (this._offset + 1 + str.length > this._size)\n\t\tthis.expand();\n\tthis._buffer.write(str, this._offset);\n\tthis._offset += str.length;\n\tthis._buffer[this._offset++] = 0;\n};\n\nSSHBuffer.prototype.writeInt = function (v) {\n\twhile (this._offset + 4 > this._size)\n\t\tthis.expand();\n\tthis._buffer.writeUInt32BE(v, this._offset);\n\tthis._offset += 4;\n};\n\nSSHBuffer.prototype.writeInt64 = function (v) {\n\tassert.buffer(v, 'value');\n\tif (v.length > 8) {\n\t\tvar lead = v.slice(0, v.length - 8);\n\t\tfor (var i = 0; i < lead.length; ++i) {\n\t\t\tassert.strictEqual(lead[i], 0,\n\t\t\t    'must fit in 64 bits of precision');\n\t\t}\n\t\tv = v.slice(v.length - 8, v.length);\n\t}\n\twhile (this._offset + 8 > this._size)\n\t\tthis.expand();\n\tv.copy(this._buffer, this._offset);\n\tthis._offset += 8;\n};\n\nSSHBuffer.prototype.writeChar = function (v) {\n\twhile (this._offset + 1 > this._size)\n\t\tthis.expand();\n\tthis._buffer[this._offset++] = v;\n};\n\nSSHBuffer.prototype.writePart = function (p) {\n\tthis.writeBuffer(p.data);\n};\n\nSSHBuffer.prototype.write = function (buf) {\n\twhile (this._offset + buf.length > this._size)\n\t\tthis.expand();\n\tbuf.copy(this._buffer, this._offset);\n\tthis._offset += buf.length;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL3NzaC1idWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLCtEQUFhO0FBQ2xDLGFBQWEsOEZBQThCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9zc2gtYnVmZmVyLmpzP2FhNzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0gU1NIQnVmZmVyO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG5cbmZ1bmN0aW9uIFNTSEJ1ZmZlcihvcHRzKSB7XG5cdGFzc2VydC5vYmplY3Qob3B0cywgJ29wdGlvbnMnKTtcblx0aWYgKG9wdHMuYnVmZmVyICE9PSB1bmRlZmluZWQpXG5cdFx0YXNzZXJ0LmJ1ZmZlcihvcHRzLmJ1ZmZlciwgJ29wdGlvbnMuYnVmZmVyJyk7XG5cblx0dGhpcy5fc2l6ZSA9IG9wdHMuYnVmZmVyID8gb3B0cy5idWZmZXIubGVuZ3RoIDogMTAyNDtcblx0dGhpcy5fYnVmZmVyID0gb3B0cy5idWZmZXIgfHwgQnVmZmVyLmFsbG9jKHRoaXMuX3NpemUpO1xuXHR0aGlzLl9vZmZzZXQgPSAwO1xufVxuXG5TU0hCdWZmZXIucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gKHRoaXMuX2J1ZmZlci5zbGljZSgwLCB0aGlzLl9vZmZzZXQpKTtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUuYXRFbmQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAodGhpcy5fb2Zmc2V0ID49IHRoaXMuX2J1ZmZlci5sZW5ndGgpO1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS5yZW1haW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAodGhpcy5fYnVmZmVyLnNsaWNlKHRoaXMuX29mZnNldCkpO1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKG4pIHtcblx0dGhpcy5fb2Zmc2V0ICs9IG47XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5fc2l6ZSAqPSAyO1xuXHR2YXIgYnVmID0gQnVmZmVyLmFsbG9jKHRoaXMuX3NpemUpO1xuXHR0aGlzLl9idWZmZXIuY29weShidWYsIDApO1xuXHR0aGlzLl9idWZmZXIgPSBidWY7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLnJlYWRQYXJ0ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gKHtkYXRhOiB0aGlzLnJlYWRCdWZmZXIoKX0pO1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS5yZWFkQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgbGVuID0gdGhpcy5fYnVmZmVyLnJlYWRVSW50MzJCRSh0aGlzLl9vZmZzZXQpO1xuXHR0aGlzLl9vZmZzZXQgKz0gNDtcblx0YXNzZXJ0Lm9rKHRoaXMuX29mZnNldCArIGxlbiA8PSB0aGlzLl9idWZmZXIubGVuZ3RoLFxuXHQgICAgJ2xlbmd0aCBvdXQgb2YgYm91bmRzIGF0ICsweCcgKyB0aGlzLl9vZmZzZXQudG9TdHJpbmcoMTYpICtcblx0ICAgICcgKGRhdGEgdHJ1bmNhdGVkPyknKTtcblx0dmFyIGJ1ZiA9IHRoaXMuX2J1ZmZlci5zbGljZSh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIGxlbik7XG5cdHRoaXMuX29mZnNldCArPSBsZW47XG5cdHJldHVybiAoYnVmKTtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUucmVhZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICh0aGlzLnJlYWRCdWZmZXIoKS50b1N0cmluZygpKTtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUucmVhZENTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG5cdHdoaWxlIChvZmZzZXQgPCB0aGlzLl9idWZmZXIubGVuZ3RoICYmXG5cdCAgICB0aGlzLl9idWZmZXJbb2Zmc2V0XSAhPT0gMHgwMClcblx0XHRvZmZzZXQrKztcblx0YXNzZXJ0Lm9rKG9mZnNldCA8IHRoaXMuX2J1ZmZlci5sZW5ndGgsICdjIHN0cmluZyBkb2VzIG5vdCB0ZXJtaW5hdGUnKTtcblx0dmFyIHN0ciA9IHRoaXMuX2J1ZmZlci5zbGljZSh0aGlzLl9vZmZzZXQsIG9mZnNldCkudG9TdHJpbmcoKTtcblx0dGhpcy5fb2Zmc2V0ID0gb2Zmc2V0ICsgMTtcblx0cmV0dXJuIChzdHIpO1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgdiA9IHRoaXMuX2J1ZmZlci5yZWFkVUludDMyQkUodGhpcy5fb2Zmc2V0KTtcblx0dGhpcy5fb2Zmc2V0ICs9IDQ7XG5cdHJldHVybiAodik7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ2NCA9IGZ1bmN0aW9uICgpIHtcblx0YXNzZXJ0Lm9rKHRoaXMuX29mZnNldCArIDggPCB0aGlzLl9idWZmZXIubGVuZ3RoLFxuXHQgICAgJ2J1ZmZlciBub3QgbG9uZyBlbm91Z2ggdG8gcmVhZCBJbnQ2NCcpO1xuXHR2YXIgdiA9IHRoaXMuX2J1ZmZlci5zbGljZSh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIDgpO1xuXHR0aGlzLl9vZmZzZXQgKz0gODtcblx0cmV0dXJuICh2KTtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUucmVhZENoYXIgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciB2ID0gdGhpcy5fYnVmZmVyW3RoaXMuX29mZnNldCsrXTtcblx0cmV0dXJuICh2KTtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCdWZmZXIgPSBmdW5jdGlvbiAoYnVmKSB7XG5cdHdoaWxlICh0aGlzLl9vZmZzZXQgKyA0ICsgYnVmLmxlbmd0aCA+IHRoaXMuX3NpemUpXG5cdFx0dGhpcy5leHBhbmQoKTtcblx0dGhpcy5fYnVmZmVyLndyaXRlVUludDMyQkUoYnVmLmxlbmd0aCwgdGhpcy5fb2Zmc2V0KTtcblx0dGhpcy5fb2Zmc2V0ICs9IDQ7XG5cdGJ1Zi5jb3B5KHRoaXMuX2J1ZmZlciwgdGhpcy5fb2Zmc2V0KTtcblx0dGhpcy5fb2Zmc2V0ICs9IGJ1Zi5sZW5ndGg7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuXHR0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjgnKSk7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLndyaXRlQ1N0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0d2hpbGUgKHRoaXMuX29mZnNldCArIDEgKyBzdHIubGVuZ3RoID4gdGhpcy5fc2l6ZSlcblx0XHR0aGlzLmV4cGFuZCgpO1xuXHR0aGlzLl9idWZmZXIud3JpdGUoc3RyLCB0aGlzLl9vZmZzZXQpO1xuXHR0aGlzLl9vZmZzZXQgKz0gc3RyLmxlbmd0aDtcblx0dGhpcy5fYnVmZmVyW3RoaXMuX29mZnNldCsrXSA9IDA7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLndyaXRlSW50ID0gZnVuY3Rpb24gKHYpIHtcblx0d2hpbGUgKHRoaXMuX29mZnNldCArIDQgPiB0aGlzLl9zaXplKVxuXHRcdHRoaXMuZXhwYW5kKCk7XG5cdHRoaXMuX2J1ZmZlci53cml0ZVVJbnQzMkJFKHYsIHRoaXMuX29mZnNldCk7XG5cdHRoaXMuX29mZnNldCArPSA0O1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDY0ID0gZnVuY3Rpb24gKHYpIHtcblx0YXNzZXJ0LmJ1ZmZlcih2LCAndmFsdWUnKTtcblx0aWYgKHYubGVuZ3RoID4gOCkge1xuXHRcdHZhciBsZWFkID0gdi5zbGljZSgwLCB2Lmxlbmd0aCAtIDgpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVhZC5sZW5ndGg7ICsraSkge1xuXHRcdFx0YXNzZXJ0LnN0cmljdEVxdWFsKGxlYWRbaV0sIDAsXG5cdFx0XHQgICAgJ211c3QgZml0IGluIDY0IGJpdHMgb2YgcHJlY2lzaW9uJyk7XG5cdFx0fVxuXHRcdHYgPSB2LnNsaWNlKHYubGVuZ3RoIC0gOCwgdi5sZW5ndGgpO1xuXHR9XG5cdHdoaWxlICh0aGlzLl9vZmZzZXQgKyA4ID4gdGhpcy5fc2l6ZSlcblx0XHR0aGlzLmV4cGFuZCgpO1xuXHR2LmNvcHkodGhpcy5fYnVmZmVyLCB0aGlzLl9vZmZzZXQpO1xuXHR0aGlzLl9vZmZzZXQgKz0gODtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUud3JpdGVDaGFyID0gZnVuY3Rpb24gKHYpIHtcblx0d2hpbGUgKHRoaXMuX29mZnNldCArIDEgPiB0aGlzLl9zaXplKVxuXHRcdHRoaXMuZXhwYW5kKCk7XG5cdHRoaXMuX2J1ZmZlclt0aGlzLl9vZmZzZXQrK10gPSB2O1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS53cml0ZVBhcnQgPSBmdW5jdGlvbiAocCkge1xuXHR0aGlzLndyaXRlQnVmZmVyKHAuZGF0YSk7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuXHR3aGlsZSAodGhpcy5fb2Zmc2V0ICsgYnVmLmxlbmd0aCA+IHRoaXMuX3NpemUpXG5cdFx0dGhpcy5leHBhbmQoKTtcblx0YnVmLmNvcHkodGhpcy5fYnVmZmVyLCB0aGlzLl9vZmZzZXQpO1xuXHR0aGlzLl9vZmZzZXQgKz0gYnVmLmxlbmd0aDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/ssh-buffer.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/sshpk/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tbufferSplit: bufferSplit,\n\taddRSAMissing: addRSAMissing,\n\tcalculateDSAPublic: calculateDSAPublic,\n\tcalculateED25519Public: calculateED25519Public,\n\tcalculateX25519Public: calculateX25519Public,\n\tmpNormalize: mpNormalize,\n\tmpDenormalize: mpDenormalize,\n\tecNormalize: ecNormalize,\n\tcountZeros: countZeros,\n\tassertCompatible: assertCompatible,\n\tisCompatible: isCompatible,\n\topensslKeyDeriv: opensslKeyDeriv,\n\topensshCipherInfo: opensshCipherInfo,\n\tpublicFromPrivateECDSA: publicFromPrivateECDSA,\n\tzeroPadToLength: zeroPadToLength,\n\twriteBitString: writeBitString,\n\treadBitString: readBitString,\n\tpbkdf2: pbkdf2\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(action-browser)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar PrivateKey = __webpack_require__(/*! ./private-key */ \"(action-browser)/./node_modules/sshpk/lib/private-key.js\");\nvar Key = __webpack_require__(/*! ./key */ \"(action-browser)/./node_modules/sshpk/lib/key.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar algs = __webpack_require__(/*! ./algs */ \"(action-browser)/./node_modules/sshpk/lib/algs.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(action-browser)/./node_modules/asn1/lib/index.js\");\n\nvar ec = __webpack_require__(/*! ecc-jsbn/lib/ec */ \"(action-browser)/./node_modules/ecc-jsbn/lib/ec.js\");\nvar jsbn = (__webpack_require__(/*! jsbn */ \"(action-browser)/./node_modules/sshpk/node_modules/jsbn/index.js\").BigInteger);\nvar nacl = __webpack_require__(/*! tweetnacl */ \"(action-browser)/./node_modules/tweetnacl/nacl-fast.js\");\n\nvar MAX_CLASS_DEPTH = 3;\n\nfunction isCompatible(obj, klass, needVer) {\n\tif (obj === null || typeof (obj) !== 'object')\n\t\treturn (false);\n\tif (needVer === undefined)\n\t\tneedVer = klass.prototype._sshpkApiVersion;\n\tif (obj instanceof klass &&\n\t    klass.prototype._sshpkApiVersion[0] == needVer[0])\n\t\treturn (true);\n\tvar proto = Object.getPrototypeOf(obj);\n\tvar depth = 0;\n\twhile (proto.constructor.name !== klass.name) {\n\t\tproto = Object.getPrototypeOf(proto);\n\t\tif (!proto || ++depth > MAX_CLASS_DEPTH)\n\t\t\treturn (false);\n\t}\n\tif (proto.constructor.name !== klass.name)\n\t\treturn (false);\n\tvar ver = proto._sshpkApiVersion;\n\tif (ver === undefined)\n\t\tver = klass._oldVersionDetect(obj);\n\tif (ver[0] != needVer[0] || ver[1] < needVer[1])\n\t\treturn (false);\n\treturn (true);\n}\n\nfunction assertCompatible(obj, klass, needVer, name) {\n\tif (name === undefined)\n\t\tname = 'object';\n\tassert.ok(obj, name + ' must not be null');\n\tassert.object(obj, name + ' must be an object');\n\tif (needVer === undefined)\n\t\tneedVer = klass.prototype._sshpkApiVersion;\n\tif (obj instanceof klass &&\n\t    klass.prototype._sshpkApiVersion[0] == needVer[0])\n\t\treturn;\n\tvar proto = Object.getPrototypeOf(obj);\n\tvar depth = 0;\n\twhile (proto.constructor.name !== klass.name) {\n\t\tproto = Object.getPrototypeOf(proto);\n\t\tassert.ok(proto && ++depth <= MAX_CLASS_DEPTH,\n\t\t    name + ' must be a ' + klass.name + ' instance');\n\t}\n\tassert.strictEqual(proto.constructor.name, klass.name,\n\t    name + ' must be a ' + klass.name + ' instance');\n\tvar ver = proto._sshpkApiVersion;\n\tif (ver === undefined)\n\t\tver = klass._oldVersionDetect(obj);\n\tassert.ok(ver[0] == needVer[0] && ver[1] >= needVer[1],\n\t    name + ' must be compatible with ' + klass.name + ' klass ' +\n\t    'version ' + needVer[0] + '.' + needVer[1]);\n}\n\nvar CIPHER_LEN = {\n\t'des-ede3-cbc': { key: 24, iv: 8 },\n\t'aes-128-cbc': { key: 16, iv: 16 },\n\t'aes-256-cbc': { key: 32, iv: 16 }\n};\nvar PKCS5_SALT_LEN = 8;\n\nfunction opensslKeyDeriv(cipher, salt, passphrase, count) {\n\tassert.buffer(salt, 'salt');\n\tassert.buffer(passphrase, 'passphrase');\n\tassert.number(count, 'iteration count');\n\n\tvar clen = CIPHER_LEN[cipher];\n\tassert.object(clen, 'supported cipher');\n\n\tsalt = salt.slice(0, PKCS5_SALT_LEN);\n\n\tvar D, D_prev, bufs;\n\tvar material = Buffer.alloc(0);\n\twhile (material.length < clen.key + clen.iv) {\n\t\tbufs = [];\n\t\tif (D_prev)\n\t\t\tbufs.push(D_prev);\n\t\tbufs.push(passphrase);\n\t\tbufs.push(salt);\n\t\tD = Buffer.concat(bufs);\n\t\tfor (var j = 0; j < count; ++j)\n\t\t\tD = crypto.createHash('md5').update(D).digest();\n\t\tmaterial = Buffer.concat([material, D]);\n\t\tD_prev = D;\n\t}\n\n\treturn ({\n\t    key: material.slice(0, clen.key),\n\t    iv: material.slice(clen.key, clen.key + clen.iv)\n\t});\n}\n\n/* See: RFC2898 */\nfunction pbkdf2(hashAlg, salt, iterations, size, passphrase) {\n\tvar hkey = Buffer.alloc(salt.length + 4);\n\tsalt.copy(hkey);\n\n\tvar gen = 0, ts = [];\n\tvar i = 1;\n\twhile (gen < size) {\n\t\tvar t = T(i++);\n\t\tgen += t.length;\n\t\tts.push(t);\n\t}\n\treturn (Buffer.concat(ts).slice(0, size));\n\n\tfunction T(I) {\n\t\thkey.writeUInt32BE(I, hkey.length - 4);\n\n\t\tvar hmac = crypto.createHmac(hashAlg, passphrase);\n\t\thmac.update(hkey);\n\n\t\tvar Ti = hmac.digest();\n\t\tvar Uc = Ti;\n\t\tvar c = 1;\n\t\twhile (c++ < iterations) {\n\t\t\thmac = crypto.createHmac(hashAlg, passphrase);\n\t\t\thmac.update(Uc);\n\t\t\tUc = hmac.digest();\n\t\t\tfor (var x = 0; x < Ti.length; ++x)\n\t\t\t\tTi[x] ^= Uc[x];\n\t\t}\n\t\treturn (Ti);\n\t}\n}\n\n/* Count leading zero bits on a buffer */\nfunction countZeros(buf) {\n\tvar o = 0, obit = 8;\n\twhile (o < buf.length) {\n\t\tvar mask = (1 << obit);\n\t\tif ((buf[o] & mask) === mask)\n\t\t\tbreak;\n\t\tobit--;\n\t\tif (obit < 0) {\n\t\t\to++;\n\t\t\tobit = 8;\n\t\t}\n\t}\n\treturn (o*8 + (8 - obit) - 1);\n}\n\nfunction bufferSplit(buf, chr) {\n\tassert.buffer(buf);\n\tassert.string(chr);\n\n\tvar parts = [];\n\tvar lastPart = 0;\n\tvar matches = 0;\n\tfor (var i = 0; i < buf.length; ++i) {\n\t\tif (buf[i] === chr.charCodeAt(matches))\n\t\t\t++matches;\n\t\telse if (buf[i] === chr.charCodeAt(0))\n\t\t\tmatches = 1;\n\t\telse\n\t\t\tmatches = 0;\n\n\t\tif (matches >= chr.length) {\n\t\t\tvar newPart = i + 1;\n\t\t\tparts.push(buf.slice(lastPart, newPart - matches));\n\t\t\tlastPart = newPart;\n\t\t\tmatches = 0;\n\t\t}\n\t}\n\tif (lastPart <= buf.length)\n\t\tparts.push(buf.slice(lastPart, buf.length));\n\n\treturn (parts);\n}\n\nfunction ecNormalize(buf, addZero) {\n\tassert.buffer(buf);\n\tif (buf[0] === 0x00 && buf[1] === 0x04) {\n\t\tif (addZero)\n\t\t\treturn (buf);\n\t\treturn (buf.slice(1));\n\t} else if (buf[0] === 0x04) {\n\t\tif (!addZero)\n\t\t\treturn (buf);\n\t} else {\n\t\twhile (buf[0] === 0x00)\n\t\t\tbuf = buf.slice(1);\n\t\tif (buf[0] === 0x02 || buf[0] === 0x03)\n\t\t\tthrow (new Error('Compressed elliptic curve points ' +\n\t\t\t    'are not supported'));\n\t\tif (buf[0] !== 0x04)\n\t\t\tthrow (new Error('Not a valid elliptic curve point'));\n\t\tif (!addZero)\n\t\t\treturn (buf);\n\t}\n\tvar b = Buffer.alloc(buf.length + 1);\n\tb[0] = 0x0;\n\tbuf.copy(b, 1);\n\treturn (b);\n}\n\nfunction readBitString(der, tag) {\n\tif (tag === undefined)\n\t\ttag = asn1.Ber.BitString;\n\tvar buf = der.readString(tag, true);\n\tassert.strictEqual(buf[0], 0x00, 'bit strings with unused bits are ' +\n\t    'not supported (0x' + buf[0].toString(16) + ')');\n\treturn (buf.slice(1));\n}\n\nfunction writeBitString(der, buf, tag) {\n\tif (tag === undefined)\n\t\ttag = asn1.Ber.BitString;\n\tvar b = Buffer.alloc(buf.length + 1);\n\tb[0] = 0x00;\n\tbuf.copy(b, 1);\n\tder.writeBuffer(b, tag);\n}\n\nfunction mpNormalize(buf) {\n\tassert.buffer(buf);\n\twhile (buf.length > 1 && buf[0] === 0x00 && (buf[1] & 0x80) === 0x00)\n\t\tbuf = buf.slice(1);\n\tif ((buf[0] & 0x80) === 0x80) {\n\t\tvar b = Buffer.alloc(buf.length + 1);\n\t\tb[0] = 0x00;\n\t\tbuf.copy(b, 1);\n\t\tbuf = b;\n\t}\n\treturn (buf);\n}\n\nfunction mpDenormalize(buf) {\n\tassert.buffer(buf);\n\twhile (buf.length > 1 && buf[0] === 0x00)\n\t\tbuf = buf.slice(1);\n\treturn (buf);\n}\n\nfunction zeroPadToLength(buf, len) {\n\tassert.buffer(buf);\n\tassert.number(len);\n\twhile (buf.length > len) {\n\t\tassert.equal(buf[0], 0x00);\n\t\tbuf = buf.slice(1);\n\t}\n\twhile (buf.length < len) {\n\t\tvar b = Buffer.alloc(buf.length + 1);\n\t\tb[0] = 0x00;\n\t\tbuf.copy(b, 1);\n\t\tbuf = b;\n\t}\n\treturn (buf);\n}\n\nfunction bigintToMpBuf(bigint) {\n\tvar buf = Buffer.from(bigint.toByteArray());\n\tbuf = mpNormalize(buf);\n\treturn (buf);\n}\n\nfunction calculateDSAPublic(g, p, x) {\n\tassert.buffer(g);\n\tassert.buffer(p);\n\tassert.buffer(x);\n\tg = new jsbn(g);\n\tp = new jsbn(p);\n\tx = new jsbn(x);\n\tvar y = g.modPow(x, p);\n\tvar ybuf = bigintToMpBuf(y);\n\treturn (ybuf);\n}\n\nfunction calculateED25519Public(k) {\n\tassert.buffer(k);\n\n\tvar kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));\n\treturn (Buffer.from(kp.publicKey));\n}\n\nfunction calculateX25519Public(k) {\n\tassert.buffer(k);\n\n\tvar kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));\n\treturn (Buffer.from(kp.publicKey));\n}\n\nfunction addRSAMissing(key) {\n\tassert.object(key);\n\tassertCompatible(key, PrivateKey, [1, 1]);\n\n\tvar d = new jsbn(key.part.d.data);\n\tvar buf;\n\n\tif (!key.part.dmodp) {\n\t\tvar p = new jsbn(key.part.p.data);\n\t\tvar dmodp = d.mod(p.subtract(1));\n\n\t\tbuf = bigintToMpBuf(dmodp);\n\t\tkey.part.dmodp = {name: 'dmodp', data: buf};\n\t\tkey.parts.push(key.part.dmodp);\n\t}\n\tif (!key.part.dmodq) {\n\t\tvar q = new jsbn(key.part.q.data);\n\t\tvar dmodq = d.mod(q.subtract(1));\n\n\t\tbuf = bigintToMpBuf(dmodq);\n\t\tkey.part.dmodq = {name: 'dmodq', data: buf};\n\t\tkey.parts.push(key.part.dmodq);\n\t}\n}\n\nfunction publicFromPrivateECDSA(curveName, priv) {\n\tassert.string(curveName, 'curveName');\n\tassert.buffer(priv);\n\tvar params = algs.curves[curveName];\n\tvar p = new jsbn(params.p);\n\tvar a = new jsbn(params.a);\n\tvar b = new jsbn(params.b);\n\tvar curve = new ec.ECCurveFp(p, a, b);\n\tvar G = curve.decodePointHex(params.G.toString('hex'));\n\n\tvar d = new jsbn(mpNormalize(priv));\n\tvar pub = G.multiply(d);\n\tpub = Buffer.from(curve.encodePointHex(pub), 'hex');\n\n\tvar parts = [];\n\tparts.push({name: 'curve', data: Buffer.from(curveName)});\n\tparts.push({name: 'Q', data: pub});\n\n\tvar key = new Key({type: 'ecdsa', curve: curve, parts: parts});\n\treturn (key);\n}\n\nfunction opensshCipherInfo(cipher) {\n\tvar inf = {};\n\tswitch (cipher) {\n\tcase '3des-cbc':\n\t\tinf.keySize = 24;\n\t\tinf.blockSize = 8;\n\t\tinf.opensslName = 'des-ede3-cbc';\n\t\tbreak;\n\tcase 'blowfish-cbc':\n\t\tinf.keySize = 16;\n\t\tinf.blockSize = 8;\n\t\tinf.opensslName = 'bf-cbc';\n\t\tbreak;\n\tcase 'aes128-cbc':\n\tcase 'aes128-ctr':\n\tcase 'aes128-gcm@openssh.com':\n\t\tinf.keySize = 16;\n\t\tinf.blockSize = 16;\n\t\tinf.opensslName = 'aes-128-' + cipher.slice(7, 10);\n\t\tbreak;\n\tcase 'aes192-cbc':\n\tcase 'aes192-ctr':\n\tcase 'aes192-gcm@openssh.com':\n\t\tinf.keySize = 24;\n\t\tinf.blockSize = 16;\n\t\tinf.opensslName = 'aes-192-' + cipher.slice(7, 10);\n\t\tbreak;\n\tcase 'aes256-cbc':\n\tcase 'aes256-ctr':\n\tcase 'aes256-gcm@openssh.com':\n\t\tinf.keySize = 32;\n\t\tinf.blockSize = 16;\n\t\tinf.opensslName = 'aes-256-' + cipher.slice(7, 10);\n\t\tbreak;\n\tdefault:\n\t\tthrow (new Error(\n\t\t    'Unsupported openssl cipher \"' + cipher + '\"'));\n\t}\n\treturn (inf);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsMEVBQWE7QUFDbEMsYUFBYSx5R0FBOEI7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsK0VBQWU7QUFDeEMsVUFBVSxtQkFBTyxDQUFDLCtEQUFPO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixXQUFXLG1CQUFPLENBQUMsaUVBQVE7QUFDM0IsV0FBVyxtQkFBTyxDQUFDLCtEQUFNOztBQUV6QixTQUFTLG1CQUFPLENBQUMsMkVBQWlCO0FBQ2xDLFdBQVcsZ0hBQTBCO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQyx5RUFBVzs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DLGtCQUFrQixpQkFBaUI7QUFDbkMsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDRDQUE0QztBQUN6RCxhQUFhLHFCQUFxQjs7QUFFbEMsb0JBQW9CLDBDQUEwQztBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvdXRpbHMuanM/NTBlNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNSBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGJ1ZmZlclNwbGl0OiBidWZmZXJTcGxpdCxcblx0YWRkUlNBTWlzc2luZzogYWRkUlNBTWlzc2luZyxcblx0Y2FsY3VsYXRlRFNBUHVibGljOiBjYWxjdWxhdGVEU0FQdWJsaWMsXG5cdGNhbGN1bGF0ZUVEMjU1MTlQdWJsaWM6IGNhbGN1bGF0ZUVEMjU1MTlQdWJsaWMsXG5cdGNhbGN1bGF0ZVgyNTUxOVB1YmxpYzogY2FsY3VsYXRlWDI1NTE5UHVibGljLFxuXHRtcE5vcm1hbGl6ZTogbXBOb3JtYWxpemUsXG5cdG1wRGVub3JtYWxpemU6IG1wRGVub3JtYWxpemUsXG5cdGVjTm9ybWFsaXplOiBlY05vcm1hbGl6ZSxcblx0Y291bnRaZXJvczogY291bnRaZXJvcyxcblx0YXNzZXJ0Q29tcGF0aWJsZTogYXNzZXJ0Q29tcGF0aWJsZSxcblx0aXNDb21wYXRpYmxlOiBpc0NvbXBhdGlibGUsXG5cdG9wZW5zc2xLZXlEZXJpdjogb3BlbnNzbEtleURlcml2LFxuXHRvcGVuc3NoQ2lwaGVySW5mbzogb3BlbnNzaENpcGhlckluZm8sXG5cdHB1YmxpY0Zyb21Qcml2YXRlRUNEU0E6IHB1YmxpY0Zyb21Qcml2YXRlRUNEU0EsXG5cdHplcm9QYWRUb0xlbmd0aDogemVyb1BhZFRvTGVuZ3RoLFxuXHR3cml0ZUJpdFN0cmluZzogd3JpdGVCaXRTdHJpbmcsXG5cdHJlYWRCaXRTdHJpbmc6IHJlYWRCaXRTdHJpbmcsXG5cdHBia2RmMjogcGJrZGYyXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vcHJpdmF0ZS1rZXknKTtcbnZhciBLZXkgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuL2FsZ3MnKTtcbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMScpO1xuXG52YXIgZWMgPSByZXF1aXJlKCdlY2MtanNibi9saWIvZWMnKTtcbnZhciBqc2JuID0gcmVxdWlyZSgnanNibicpLkJpZ0ludGVnZXI7XG52YXIgbmFjbCA9IHJlcXVpcmUoJ3R3ZWV0bmFjbCcpO1xuXG52YXIgTUFYX0NMQVNTX0RFUFRIID0gMztcblxuZnVuY3Rpb24gaXNDb21wYXRpYmxlKG9iaiwga2xhc3MsIG5lZWRWZXIpIHtcblx0aWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2YgKG9iaikgIT09ICdvYmplY3QnKVxuXHRcdHJldHVybiAoZmFsc2UpO1xuXHRpZiAobmVlZFZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdG5lZWRWZXIgPSBrbGFzcy5wcm90b3R5cGUuX3NzaHBrQXBpVmVyc2lvbjtcblx0aWYgKG9iaiBpbnN0YW5jZW9mIGtsYXNzICYmXG5cdCAgICBrbGFzcy5wcm90b3R5cGUuX3NzaHBrQXBpVmVyc2lvblswXSA9PSBuZWVkVmVyWzBdKVxuXHRcdHJldHVybiAodHJ1ZSk7XG5cdHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuXHR2YXIgZGVwdGggPSAwO1xuXHR3aGlsZSAocHJvdG8uY29uc3RydWN0b3IubmFtZSAhPT0ga2xhc3MubmFtZSkge1xuXHRcdHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRpZiAoIXByb3RvIHx8ICsrZGVwdGggPiBNQVhfQ0xBU1NfREVQVEgpXG5cdFx0XHRyZXR1cm4gKGZhbHNlKTtcblx0fVxuXHRpZiAocHJvdG8uY29uc3RydWN0b3IubmFtZSAhPT0ga2xhc3MubmFtZSlcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0dmFyIHZlciA9IHByb3RvLl9zc2hwa0FwaVZlcnNpb247XG5cdGlmICh2ZXIgPT09IHVuZGVmaW5lZClcblx0XHR2ZXIgPSBrbGFzcy5fb2xkVmVyc2lvbkRldGVjdChvYmopO1xuXHRpZiAodmVyWzBdICE9IG5lZWRWZXJbMF0gfHwgdmVyWzFdIDwgbmVlZFZlclsxXSlcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0cmV0dXJuICh0cnVlKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q29tcGF0aWJsZShvYmosIGtsYXNzLCBuZWVkVmVyLCBuYW1lKSB7XG5cdGlmIChuYW1lID09PSB1bmRlZmluZWQpXG5cdFx0bmFtZSA9ICdvYmplY3QnO1xuXHRhc3NlcnQub2sob2JqLCBuYW1lICsgJyBtdXN0IG5vdCBiZSBudWxsJyk7XG5cdGFzc2VydC5vYmplY3Qob2JqLCBuYW1lICsgJyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuXHRpZiAobmVlZFZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdG5lZWRWZXIgPSBrbGFzcy5wcm90b3R5cGUuX3NzaHBrQXBpVmVyc2lvbjtcblx0aWYgKG9iaiBpbnN0YW5jZW9mIGtsYXNzICYmXG5cdCAgICBrbGFzcy5wcm90b3R5cGUuX3NzaHBrQXBpVmVyc2lvblswXSA9PSBuZWVkVmVyWzBdKVxuXHRcdHJldHVybjtcblx0dmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG5cdHZhciBkZXB0aCA9IDA7XG5cdHdoaWxlIChwcm90by5jb25zdHJ1Y3Rvci5uYW1lICE9PSBrbGFzcy5uYW1lKSB7XG5cdFx0cHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdGFzc2VydC5vayhwcm90byAmJiArK2RlcHRoIDw9IE1BWF9DTEFTU19ERVBUSCxcblx0XHQgICAgbmFtZSArICcgbXVzdCBiZSBhICcgKyBrbGFzcy5uYW1lICsgJyBpbnN0YW5jZScpO1xuXHR9XG5cdGFzc2VydC5zdHJpY3RFcXVhbChwcm90by5jb25zdHJ1Y3Rvci5uYW1lLCBrbGFzcy5uYW1lLFxuXHQgICAgbmFtZSArICcgbXVzdCBiZSBhICcgKyBrbGFzcy5uYW1lICsgJyBpbnN0YW5jZScpO1xuXHR2YXIgdmVyID0gcHJvdG8uX3NzaHBrQXBpVmVyc2lvbjtcblx0aWYgKHZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHZlciA9IGtsYXNzLl9vbGRWZXJzaW9uRGV0ZWN0KG9iaik7XG5cdGFzc2VydC5vayh2ZXJbMF0gPT0gbmVlZFZlclswXSAmJiB2ZXJbMV0gPj0gbmVlZFZlclsxXSxcblx0ICAgIG5hbWUgKyAnIG11c3QgYmUgY29tcGF0aWJsZSB3aXRoICcgKyBrbGFzcy5uYW1lICsgJyBrbGFzcyAnICtcblx0ICAgICd2ZXJzaW9uICcgKyBuZWVkVmVyWzBdICsgJy4nICsgbmVlZFZlclsxXSk7XG59XG5cbnZhciBDSVBIRVJfTEVOID0ge1xuXHQnZGVzLWVkZTMtY2JjJzogeyBrZXk6IDI0LCBpdjogOCB9LFxuXHQnYWVzLTEyOC1jYmMnOiB7IGtleTogMTYsIGl2OiAxNiB9LFxuXHQnYWVzLTI1Ni1jYmMnOiB7IGtleTogMzIsIGl2OiAxNiB9XG59O1xudmFyIFBLQ1M1X1NBTFRfTEVOID0gODtcblxuZnVuY3Rpb24gb3BlbnNzbEtleURlcml2KGNpcGhlciwgc2FsdCwgcGFzc3BocmFzZSwgY291bnQpIHtcblx0YXNzZXJ0LmJ1ZmZlcihzYWx0LCAnc2FsdCcpO1xuXHRhc3NlcnQuYnVmZmVyKHBhc3NwaHJhc2UsICdwYXNzcGhyYXNlJyk7XG5cdGFzc2VydC5udW1iZXIoY291bnQsICdpdGVyYXRpb24gY291bnQnKTtcblxuXHR2YXIgY2xlbiA9IENJUEhFUl9MRU5bY2lwaGVyXTtcblx0YXNzZXJ0Lm9iamVjdChjbGVuLCAnc3VwcG9ydGVkIGNpcGhlcicpO1xuXG5cdHNhbHQgPSBzYWx0LnNsaWNlKDAsIFBLQ1M1X1NBTFRfTEVOKTtcblxuXHR2YXIgRCwgRF9wcmV2LCBidWZzO1xuXHR2YXIgbWF0ZXJpYWwgPSBCdWZmZXIuYWxsb2MoMCk7XG5cdHdoaWxlIChtYXRlcmlhbC5sZW5ndGggPCBjbGVuLmtleSArIGNsZW4uaXYpIHtcblx0XHRidWZzID0gW107XG5cdFx0aWYgKERfcHJldilcblx0XHRcdGJ1ZnMucHVzaChEX3ByZXYpO1xuXHRcdGJ1ZnMucHVzaChwYXNzcGhyYXNlKTtcblx0XHRidWZzLnB1c2goc2FsdCk7XG5cdFx0RCA9IEJ1ZmZlci5jb25jYXQoYnVmcyk7XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgKytqKVxuXHRcdFx0RCA9IGNyeXB0by5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUoRCkuZGlnZXN0KCk7XG5cdFx0bWF0ZXJpYWwgPSBCdWZmZXIuY29uY2F0KFttYXRlcmlhbCwgRF0pO1xuXHRcdERfcHJldiA9IEQ7XG5cdH1cblxuXHRyZXR1cm4gKHtcblx0ICAgIGtleTogbWF0ZXJpYWwuc2xpY2UoMCwgY2xlbi5rZXkpLFxuXHQgICAgaXY6IG1hdGVyaWFsLnNsaWNlKGNsZW4ua2V5LCBjbGVuLmtleSArIGNsZW4uaXYpXG5cdH0pO1xufVxuXG4vKiBTZWU6IFJGQzI4OTggKi9cbmZ1bmN0aW9uIHBia2RmMihoYXNoQWxnLCBzYWx0LCBpdGVyYXRpb25zLCBzaXplLCBwYXNzcGhyYXNlKSB7XG5cdHZhciBoa2V5ID0gQnVmZmVyLmFsbG9jKHNhbHQubGVuZ3RoICsgNCk7XG5cdHNhbHQuY29weShoa2V5KTtcblxuXHR2YXIgZ2VuID0gMCwgdHMgPSBbXTtcblx0dmFyIGkgPSAxO1xuXHR3aGlsZSAoZ2VuIDwgc2l6ZSkge1xuXHRcdHZhciB0ID0gVChpKyspO1xuXHRcdGdlbiArPSB0Lmxlbmd0aDtcblx0XHR0cy5wdXNoKHQpO1xuXHR9XG5cdHJldHVybiAoQnVmZmVyLmNvbmNhdCh0cykuc2xpY2UoMCwgc2l6ZSkpO1xuXG5cdGZ1bmN0aW9uIFQoSSkge1xuXHRcdGhrZXkud3JpdGVVSW50MzJCRShJLCBoa2V5Lmxlbmd0aCAtIDQpO1xuXG5cdFx0dmFyIGhtYWMgPSBjcnlwdG8uY3JlYXRlSG1hYyhoYXNoQWxnLCBwYXNzcGhyYXNlKTtcblx0XHRobWFjLnVwZGF0ZShoa2V5KTtcblxuXHRcdHZhciBUaSA9IGhtYWMuZGlnZXN0KCk7XG5cdFx0dmFyIFVjID0gVGk7XG5cdFx0dmFyIGMgPSAxO1xuXHRcdHdoaWxlIChjKysgPCBpdGVyYXRpb25zKSB7XG5cdFx0XHRobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoaGFzaEFsZywgcGFzc3BocmFzZSk7XG5cdFx0XHRobWFjLnVwZGF0ZShVYyk7XG5cdFx0XHRVYyA9IGhtYWMuZGlnZXN0KCk7XG5cdFx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IFRpLmxlbmd0aDsgKyt4KVxuXHRcdFx0XHRUaVt4XSBePSBVY1t4XTtcblx0XHR9XG5cdFx0cmV0dXJuIChUaSk7XG5cdH1cbn1cblxuLyogQ291bnQgbGVhZGluZyB6ZXJvIGJpdHMgb24gYSBidWZmZXIgKi9cbmZ1bmN0aW9uIGNvdW50WmVyb3MoYnVmKSB7XG5cdHZhciBvID0gMCwgb2JpdCA9IDg7XG5cdHdoaWxlIChvIDwgYnVmLmxlbmd0aCkge1xuXHRcdHZhciBtYXNrID0gKDEgPDwgb2JpdCk7XG5cdFx0aWYgKChidWZbb10gJiBtYXNrKSA9PT0gbWFzaylcblx0XHRcdGJyZWFrO1xuXHRcdG9iaXQtLTtcblx0XHRpZiAob2JpdCA8IDApIHtcblx0XHRcdG8rKztcblx0XHRcdG9iaXQgPSA4O1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gKG8qOCArICg4IC0gb2JpdCkgLSAxKTtcbn1cblxuZnVuY3Rpb24gYnVmZmVyU3BsaXQoYnVmLCBjaHIpIHtcblx0YXNzZXJ0LmJ1ZmZlcihidWYpO1xuXHRhc3NlcnQuc3RyaW5nKGNocik7XG5cblx0dmFyIHBhcnRzID0gW107XG5cdHZhciBsYXN0UGFydCA9IDA7XG5cdHZhciBtYXRjaGVzID0gMDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyArK2kpIHtcblx0XHRpZiAoYnVmW2ldID09PSBjaHIuY2hhckNvZGVBdChtYXRjaGVzKSlcblx0XHRcdCsrbWF0Y2hlcztcblx0XHRlbHNlIGlmIChidWZbaV0gPT09IGNoci5jaGFyQ29kZUF0KDApKVxuXHRcdFx0bWF0Y2hlcyA9IDE7XG5cdFx0ZWxzZVxuXHRcdFx0bWF0Y2hlcyA9IDA7XG5cblx0XHRpZiAobWF0Y2hlcyA+PSBjaHIubGVuZ3RoKSB7XG5cdFx0XHR2YXIgbmV3UGFydCA9IGkgKyAxO1xuXHRcdFx0cGFydHMucHVzaChidWYuc2xpY2UobGFzdFBhcnQsIG5ld1BhcnQgLSBtYXRjaGVzKSk7XG5cdFx0XHRsYXN0UGFydCA9IG5ld1BhcnQ7XG5cdFx0XHRtYXRjaGVzID0gMDtcblx0XHR9XG5cdH1cblx0aWYgKGxhc3RQYXJ0IDw9IGJ1Zi5sZW5ndGgpXG5cdFx0cGFydHMucHVzaChidWYuc2xpY2UobGFzdFBhcnQsIGJ1Zi5sZW5ndGgpKTtcblxuXHRyZXR1cm4gKHBhcnRzKTtcbn1cblxuZnVuY3Rpb24gZWNOb3JtYWxpemUoYnVmLCBhZGRaZXJvKSB7XG5cdGFzc2VydC5idWZmZXIoYnVmKTtcblx0aWYgKGJ1ZlswXSA9PT0gMHgwMCAmJiBidWZbMV0gPT09IDB4MDQpIHtcblx0XHRpZiAoYWRkWmVybylcblx0XHRcdHJldHVybiAoYnVmKTtcblx0XHRyZXR1cm4gKGJ1Zi5zbGljZSgxKSk7XG5cdH0gZWxzZSBpZiAoYnVmWzBdID09PSAweDA0KSB7XG5cdFx0aWYgKCFhZGRaZXJvKVxuXHRcdFx0cmV0dXJuIChidWYpO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlIChidWZbMF0gPT09IDB4MDApXG5cdFx0XHRidWYgPSBidWYuc2xpY2UoMSk7XG5cdFx0aWYgKGJ1ZlswXSA9PT0gMHgwMiB8fCBidWZbMF0gPT09IDB4MDMpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdDb21wcmVzc2VkIGVsbGlwdGljIGN1cnZlIHBvaW50cyAnICtcblx0XHRcdCAgICAnYXJlIG5vdCBzdXBwb3J0ZWQnKSk7XG5cdFx0aWYgKGJ1ZlswXSAhPT0gMHgwNClcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIGVsbGlwdGljIGN1cnZlIHBvaW50JykpO1xuXHRcdGlmICghYWRkWmVybylcblx0XHRcdHJldHVybiAoYnVmKTtcblx0fVxuXHR2YXIgYiA9IEJ1ZmZlci5hbGxvYyhidWYubGVuZ3RoICsgMSk7XG5cdGJbMF0gPSAweDA7XG5cdGJ1Zi5jb3B5KGIsIDEpO1xuXHRyZXR1cm4gKGIpO1xufVxuXG5mdW5jdGlvbiByZWFkQml0U3RyaW5nKGRlciwgdGFnKSB7XG5cdGlmICh0YWcgPT09IHVuZGVmaW5lZClcblx0XHR0YWcgPSBhc24xLkJlci5CaXRTdHJpbmc7XG5cdHZhciBidWYgPSBkZXIucmVhZFN0cmluZyh0YWcsIHRydWUpO1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwoYnVmWzBdLCAweDAwLCAnYml0IHN0cmluZ3Mgd2l0aCB1bnVzZWQgYml0cyBhcmUgJyArXG5cdCAgICAnbm90IHN1cHBvcnRlZCAoMHgnICsgYnVmWzBdLnRvU3RyaW5nKDE2KSArICcpJyk7XG5cdHJldHVybiAoYnVmLnNsaWNlKDEpKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVCaXRTdHJpbmcoZGVyLCBidWYsIHRhZykge1xuXHRpZiAodGFnID09PSB1bmRlZmluZWQpXG5cdFx0dGFnID0gYXNuMS5CZXIuQml0U3RyaW5nO1xuXHR2YXIgYiA9IEJ1ZmZlci5hbGxvYyhidWYubGVuZ3RoICsgMSk7XG5cdGJbMF0gPSAweDAwO1xuXHRidWYuY29weShiLCAxKTtcblx0ZGVyLndyaXRlQnVmZmVyKGIsIHRhZyk7XG59XG5cbmZ1bmN0aW9uIG1wTm9ybWFsaXplKGJ1Zikge1xuXHRhc3NlcnQuYnVmZmVyKGJ1Zik7XG5cdHdoaWxlIChidWYubGVuZ3RoID4gMSAmJiBidWZbMF0gPT09IDB4MDAgJiYgKGJ1ZlsxXSAmIDB4ODApID09PSAweDAwKVxuXHRcdGJ1ZiA9IGJ1Zi5zbGljZSgxKTtcblx0aWYgKChidWZbMF0gJiAweDgwKSA9PT0gMHg4MCkge1xuXHRcdHZhciBiID0gQnVmZmVyLmFsbG9jKGJ1Zi5sZW5ndGggKyAxKTtcblx0XHRiWzBdID0gMHgwMDtcblx0XHRidWYuY29weShiLCAxKTtcblx0XHRidWYgPSBiO1xuXHR9XG5cdHJldHVybiAoYnVmKTtcbn1cblxuZnVuY3Rpb24gbXBEZW5vcm1hbGl6ZShidWYpIHtcblx0YXNzZXJ0LmJ1ZmZlcihidWYpO1xuXHR3aGlsZSAoYnVmLmxlbmd0aCA+IDEgJiYgYnVmWzBdID09PSAweDAwKVxuXHRcdGJ1ZiA9IGJ1Zi5zbGljZSgxKTtcblx0cmV0dXJuIChidWYpO1xufVxuXG5mdW5jdGlvbiB6ZXJvUGFkVG9MZW5ndGgoYnVmLCBsZW4pIHtcblx0YXNzZXJ0LmJ1ZmZlcihidWYpO1xuXHRhc3NlcnQubnVtYmVyKGxlbik7XG5cdHdoaWxlIChidWYubGVuZ3RoID4gbGVuKSB7XG5cdFx0YXNzZXJ0LmVxdWFsKGJ1ZlswXSwgMHgwMCk7XG5cdFx0YnVmID0gYnVmLnNsaWNlKDEpO1xuXHR9XG5cdHdoaWxlIChidWYubGVuZ3RoIDwgbGVuKSB7XG5cdFx0dmFyIGIgPSBCdWZmZXIuYWxsb2MoYnVmLmxlbmd0aCArIDEpO1xuXHRcdGJbMF0gPSAweDAwO1xuXHRcdGJ1Zi5jb3B5KGIsIDEpO1xuXHRcdGJ1ZiA9IGI7XG5cdH1cblx0cmV0dXJuIChidWYpO1xufVxuXG5mdW5jdGlvbiBiaWdpbnRUb01wQnVmKGJpZ2ludCkge1xuXHR2YXIgYnVmID0gQnVmZmVyLmZyb20oYmlnaW50LnRvQnl0ZUFycmF5KCkpO1xuXHRidWYgPSBtcE5vcm1hbGl6ZShidWYpO1xuXHRyZXR1cm4gKGJ1Zik7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZURTQVB1YmxpYyhnLCBwLCB4KSB7XG5cdGFzc2VydC5idWZmZXIoZyk7XG5cdGFzc2VydC5idWZmZXIocCk7XG5cdGFzc2VydC5idWZmZXIoeCk7XG5cdGcgPSBuZXcganNibihnKTtcblx0cCA9IG5ldyBqc2JuKHApO1xuXHR4ID0gbmV3IGpzYm4oeCk7XG5cdHZhciB5ID0gZy5tb2RQb3coeCwgcCk7XG5cdHZhciB5YnVmID0gYmlnaW50VG9NcEJ1Zih5KTtcblx0cmV0dXJuICh5YnVmKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlRUQyNTUxOVB1YmxpYyhrKSB7XG5cdGFzc2VydC5idWZmZXIoayk7XG5cblx0dmFyIGtwID0gbmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQobmV3IFVpbnQ4QXJyYXkoaykpO1xuXHRyZXR1cm4gKEJ1ZmZlci5mcm9tKGtwLnB1YmxpY0tleSkpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVYMjU1MTlQdWJsaWMoaykge1xuXHRhc3NlcnQuYnVmZmVyKGspO1xuXG5cdHZhciBrcCA9IG5hY2wuYm94LmtleVBhaXIuZnJvbVNlZWQobmV3IFVpbnQ4QXJyYXkoaykpO1xuXHRyZXR1cm4gKEJ1ZmZlci5mcm9tKGtwLnB1YmxpY0tleSkpO1xufVxuXG5mdW5jdGlvbiBhZGRSU0FNaXNzaW5nKGtleSkge1xuXHRhc3NlcnQub2JqZWN0KGtleSk7XG5cdGFzc2VydENvbXBhdGlibGUoa2V5LCBQcml2YXRlS2V5LCBbMSwgMV0pO1xuXG5cdHZhciBkID0gbmV3IGpzYm4oa2V5LnBhcnQuZC5kYXRhKTtcblx0dmFyIGJ1ZjtcblxuXHRpZiAoIWtleS5wYXJ0LmRtb2RwKSB7XG5cdFx0dmFyIHAgPSBuZXcganNibihrZXkucGFydC5wLmRhdGEpO1xuXHRcdHZhciBkbW9kcCA9IGQubW9kKHAuc3VidHJhY3QoMSkpO1xuXG5cdFx0YnVmID0gYmlnaW50VG9NcEJ1ZihkbW9kcCk7XG5cdFx0a2V5LnBhcnQuZG1vZHAgPSB7bmFtZTogJ2Rtb2RwJywgZGF0YTogYnVmfTtcblx0XHRrZXkucGFydHMucHVzaChrZXkucGFydC5kbW9kcCk7XG5cdH1cblx0aWYgKCFrZXkucGFydC5kbW9kcSkge1xuXHRcdHZhciBxID0gbmV3IGpzYm4oa2V5LnBhcnQucS5kYXRhKTtcblx0XHR2YXIgZG1vZHEgPSBkLm1vZChxLnN1YnRyYWN0KDEpKTtcblxuXHRcdGJ1ZiA9IGJpZ2ludFRvTXBCdWYoZG1vZHEpO1xuXHRcdGtleS5wYXJ0LmRtb2RxID0ge25hbWU6ICdkbW9kcScsIGRhdGE6IGJ1Zn07XG5cdFx0a2V5LnBhcnRzLnB1c2goa2V5LnBhcnQuZG1vZHEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHB1YmxpY0Zyb21Qcml2YXRlRUNEU0EoY3VydmVOYW1lLCBwcml2KSB7XG5cdGFzc2VydC5zdHJpbmcoY3VydmVOYW1lLCAnY3VydmVOYW1lJyk7XG5cdGFzc2VydC5idWZmZXIocHJpdik7XG5cdHZhciBwYXJhbXMgPSBhbGdzLmN1cnZlc1tjdXJ2ZU5hbWVdO1xuXHR2YXIgcCA9IG5ldyBqc2JuKHBhcmFtcy5wKTtcblx0dmFyIGEgPSBuZXcganNibihwYXJhbXMuYSk7XG5cdHZhciBiID0gbmV3IGpzYm4ocGFyYW1zLmIpO1xuXHR2YXIgY3VydmUgPSBuZXcgZWMuRUNDdXJ2ZUZwKHAsIGEsIGIpO1xuXHR2YXIgRyA9IGN1cnZlLmRlY29kZVBvaW50SGV4KHBhcmFtcy5HLnRvU3RyaW5nKCdoZXgnKSk7XG5cblx0dmFyIGQgPSBuZXcganNibihtcE5vcm1hbGl6ZShwcml2KSk7XG5cdHZhciBwdWIgPSBHLm11bHRpcGx5KGQpO1xuXHRwdWIgPSBCdWZmZXIuZnJvbShjdXJ2ZS5lbmNvZGVQb2ludEhleChwdWIpLCAnaGV4Jyk7XG5cblx0dmFyIHBhcnRzID0gW107XG5cdHBhcnRzLnB1c2goe25hbWU6ICdjdXJ2ZScsIGRhdGE6IEJ1ZmZlci5mcm9tKGN1cnZlTmFtZSl9KTtcblx0cGFydHMucHVzaCh7bmFtZTogJ1EnLCBkYXRhOiBwdWJ9KTtcblxuXHR2YXIga2V5ID0gbmV3IEtleSh7dHlwZTogJ2VjZHNhJywgY3VydmU6IGN1cnZlLCBwYXJ0czogcGFydHN9KTtcblx0cmV0dXJuIChrZXkpO1xufVxuXG5mdW5jdGlvbiBvcGVuc3NoQ2lwaGVySW5mbyhjaXBoZXIpIHtcblx0dmFyIGluZiA9IHt9O1xuXHRzd2l0Y2ggKGNpcGhlcikge1xuXHRjYXNlICczZGVzLWNiYyc6XG5cdFx0aW5mLmtleVNpemUgPSAyNDtcblx0XHRpbmYuYmxvY2tTaXplID0gODtcblx0XHRpbmYub3BlbnNzbE5hbWUgPSAnZGVzLWVkZTMtY2JjJztcblx0XHRicmVhaztcblx0Y2FzZSAnYmxvd2Zpc2gtY2JjJzpcblx0XHRpbmYua2V5U2l6ZSA9IDE2O1xuXHRcdGluZi5ibG9ja1NpemUgPSA4O1xuXHRcdGluZi5vcGVuc3NsTmFtZSA9ICdiZi1jYmMnO1xuXHRcdGJyZWFrO1xuXHRjYXNlICdhZXMxMjgtY2JjJzpcblx0Y2FzZSAnYWVzMTI4LWN0cic6XG5cdGNhc2UgJ2FlczEyOC1nY21Ab3BlbnNzaC5jb20nOlxuXHRcdGluZi5rZXlTaXplID0gMTY7XG5cdFx0aW5mLmJsb2NrU2l6ZSA9IDE2O1xuXHRcdGluZi5vcGVuc3NsTmFtZSA9ICdhZXMtMTI4LScgKyBjaXBoZXIuc2xpY2UoNywgMTApO1xuXHRcdGJyZWFrO1xuXHRjYXNlICdhZXMxOTItY2JjJzpcblx0Y2FzZSAnYWVzMTkyLWN0cic6XG5cdGNhc2UgJ2FlczE5Mi1nY21Ab3BlbnNzaC5jb20nOlxuXHRcdGluZi5rZXlTaXplID0gMjQ7XG5cdFx0aW5mLmJsb2NrU2l6ZSA9IDE2O1xuXHRcdGluZi5vcGVuc3NsTmFtZSA9ICdhZXMtMTkyLScgKyBjaXBoZXIuc2xpY2UoNywgMTApO1xuXHRcdGJyZWFrO1xuXHRjYXNlICdhZXMyNTYtY2JjJzpcblx0Y2FzZSAnYWVzMjU2LWN0cic6XG5cdGNhc2UgJ2FlczI1Ni1nY21Ab3BlbnNzaC5jb20nOlxuXHRcdGluZi5rZXlTaXplID0gMzI7XG5cdFx0aW5mLmJsb2NrU2l6ZSA9IDE2O1xuXHRcdGluZi5vcGVuc3NsTmFtZSA9ICdhZXMtMjU2LScgKyBjaXBoZXIuc2xpY2UoNywgMTApO1xuXHRcdGJyZWFrO1xuXHRkZWZhdWx0OlxuXHRcdHRocm93IChuZXcgRXJyb3IoXG5cdFx0ICAgICdVbnN1cHBvcnRlZCBvcGVuc3NsIGNpcGhlciBcIicgKyBjaXBoZXIgKyAnXCInKSk7XG5cdH1cblx0cmV0dXJuIChpbmYpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/sshpk/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tbufferSplit: bufferSplit,\n\taddRSAMissing: addRSAMissing,\n\tcalculateDSAPublic: calculateDSAPublic,\n\tcalculateED25519Public: calculateED25519Public,\n\tcalculateX25519Public: calculateX25519Public,\n\tmpNormalize: mpNormalize,\n\tmpDenormalize: mpDenormalize,\n\tecNormalize: ecNormalize,\n\tcountZeros: countZeros,\n\tassertCompatible: assertCompatible,\n\tisCompatible: isCompatible,\n\topensslKeyDeriv: opensslKeyDeriv,\n\topensshCipherInfo: opensshCipherInfo,\n\tpublicFromPrivateECDSA: publicFromPrivateECDSA,\n\tzeroPadToLength: zeroPadToLength,\n\twriteBitString: writeBitString,\n\treadBitString: readBitString,\n\tpbkdf2: pbkdf2\n};\n\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/./node_modules/safer-buffer/safer.js\").Buffer);\nvar PrivateKey = __webpack_require__(/*! ./private-key */ \"(rsc)/./node_modules/sshpk/lib/private-key.js\");\nvar Key = __webpack_require__(/*! ./key */ \"(rsc)/./node_modules/sshpk/lib/key.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar algs = __webpack_require__(/*! ./algs */ \"(rsc)/./node_modules/sshpk/lib/algs.js\");\nvar asn1 = __webpack_require__(/*! asn1 */ \"(rsc)/./node_modules/asn1/lib/index.js\");\n\nvar ec = __webpack_require__(/*! ecc-jsbn/lib/ec */ \"(rsc)/./node_modules/ecc-jsbn/lib/ec.js\");\nvar jsbn = (__webpack_require__(/*! jsbn */ \"(rsc)/./node_modules/sshpk/node_modules/jsbn/index.js\").BigInteger);\nvar nacl = __webpack_require__(/*! tweetnacl */ \"(rsc)/./node_modules/tweetnacl/nacl-fast.js\");\n\nvar MAX_CLASS_DEPTH = 3;\n\nfunction isCompatible(obj, klass, needVer) {\n\tif (obj === null || typeof (obj) !== 'object')\n\t\treturn (false);\n\tif (needVer === undefined)\n\t\tneedVer = klass.prototype._sshpkApiVersion;\n\tif (obj instanceof klass &&\n\t    klass.prototype._sshpkApiVersion[0] == needVer[0])\n\t\treturn (true);\n\tvar proto = Object.getPrototypeOf(obj);\n\tvar depth = 0;\n\twhile (proto.constructor.name !== klass.name) {\n\t\tproto = Object.getPrototypeOf(proto);\n\t\tif (!proto || ++depth > MAX_CLASS_DEPTH)\n\t\t\treturn (false);\n\t}\n\tif (proto.constructor.name !== klass.name)\n\t\treturn (false);\n\tvar ver = proto._sshpkApiVersion;\n\tif (ver === undefined)\n\t\tver = klass._oldVersionDetect(obj);\n\tif (ver[0] != needVer[0] || ver[1] < needVer[1])\n\t\treturn (false);\n\treturn (true);\n}\n\nfunction assertCompatible(obj, klass, needVer, name) {\n\tif (name === undefined)\n\t\tname = 'object';\n\tassert.ok(obj, name + ' must not be null');\n\tassert.object(obj, name + ' must be an object');\n\tif (needVer === undefined)\n\t\tneedVer = klass.prototype._sshpkApiVersion;\n\tif (obj instanceof klass &&\n\t    klass.prototype._sshpkApiVersion[0] == needVer[0])\n\t\treturn;\n\tvar proto = Object.getPrototypeOf(obj);\n\tvar depth = 0;\n\twhile (proto.constructor.name !== klass.name) {\n\t\tproto = Object.getPrototypeOf(proto);\n\t\tassert.ok(proto && ++depth <= MAX_CLASS_DEPTH,\n\t\t    name + ' must be a ' + klass.name + ' instance');\n\t}\n\tassert.strictEqual(proto.constructor.name, klass.name,\n\t    name + ' must be a ' + klass.name + ' instance');\n\tvar ver = proto._sshpkApiVersion;\n\tif (ver === undefined)\n\t\tver = klass._oldVersionDetect(obj);\n\tassert.ok(ver[0] == needVer[0] && ver[1] >= needVer[1],\n\t    name + ' must be compatible with ' + klass.name + ' klass ' +\n\t    'version ' + needVer[0] + '.' + needVer[1]);\n}\n\nvar CIPHER_LEN = {\n\t'des-ede3-cbc': { key: 24, iv: 8 },\n\t'aes-128-cbc': { key: 16, iv: 16 },\n\t'aes-256-cbc': { key: 32, iv: 16 }\n};\nvar PKCS5_SALT_LEN = 8;\n\nfunction opensslKeyDeriv(cipher, salt, passphrase, count) {\n\tassert.buffer(salt, 'salt');\n\tassert.buffer(passphrase, 'passphrase');\n\tassert.number(count, 'iteration count');\n\n\tvar clen = CIPHER_LEN[cipher];\n\tassert.object(clen, 'supported cipher');\n\n\tsalt = salt.slice(0, PKCS5_SALT_LEN);\n\n\tvar D, D_prev, bufs;\n\tvar material = Buffer.alloc(0);\n\twhile (material.length < clen.key + clen.iv) {\n\t\tbufs = [];\n\t\tif (D_prev)\n\t\t\tbufs.push(D_prev);\n\t\tbufs.push(passphrase);\n\t\tbufs.push(salt);\n\t\tD = Buffer.concat(bufs);\n\t\tfor (var j = 0; j < count; ++j)\n\t\t\tD = crypto.createHash('md5').update(D).digest();\n\t\tmaterial = Buffer.concat([material, D]);\n\t\tD_prev = D;\n\t}\n\n\treturn ({\n\t    key: material.slice(0, clen.key),\n\t    iv: material.slice(clen.key, clen.key + clen.iv)\n\t});\n}\n\n/* See: RFC2898 */\nfunction pbkdf2(hashAlg, salt, iterations, size, passphrase) {\n\tvar hkey = Buffer.alloc(salt.length + 4);\n\tsalt.copy(hkey);\n\n\tvar gen = 0, ts = [];\n\tvar i = 1;\n\twhile (gen < size) {\n\t\tvar t = T(i++);\n\t\tgen += t.length;\n\t\tts.push(t);\n\t}\n\treturn (Buffer.concat(ts).slice(0, size));\n\n\tfunction T(I) {\n\t\thkey.writeUInt32BE(I, hkey.length - 4);\n\n\t\tvar hmac = crypto.createHmac(hashAlg, passphrase);\n\t\thmac.update(hkey);\n\n\t\tvar Ti = hmac.digest();\n\t\tvar Uc = Ti;\n\t\tvar c = 1;\n\t\twhile (c++ < iterations) {\n\t\t\thmac = crypto.createHmac(hashAlg, passphrase);\n\t\t\thmac.update(Uc);\n\t\t\tUc = hmac.digest();\n\t\t\tfor (var x = 0; x < Ti.length; ++x)\n\t\t\t\tTi[x] ^= Uc[x];\n\t\t}\n\t\treturn (Ti);\n\t}\n}\n\n/* Count leading zero bits on a buffer */\nfunction countZeros(buf) {\n\tvar o = 0, obit = 8;\n\twhile (o < buf.length) {\n\t\tvar mask = (1 << obit);\n\t\tif ((buf[o] & mask) === mask)\n\t\t\tbreak;\n\t\tobit--;\n\t\tif (obit < 0) {\n\t\t\to++;\n\t\t\tobit = 8;\n\t\t}\n\t}\n\treturn (o*8 + (8 - obit) - 1);\n}\n\nfunction bufferSplit(buf, chr) {\n\tassert.buffer(buf);\n\tassert.string(chr);\n\n\tvar parts = [];\n\tvar lastPart = 0;\n\tvar matches = 0;\n\tfor (var i = 0; i < buf.length; ++i) {\n\t\tif (buf[i] === chr.charCodeAt(matches))\n\t\t\t++matches;\n\t\telse if (buf[i] === chr.charCodeAt(0))\n\t\t\tmatches = 1;\n\t\telse\n\t\t\tmatches = 0;\n\n\t\tif (matches >= chr.length) {\n\t\t\tvar newPart = i + 1;\n\t\t\tparts.push(buf.slice(lastPart, newPart - matches));\n\t\t\tlastPart = newPart;\n\t\t\tmatches = 0;\n\t\t}\n\t}\n\tif (lastPart <= buf.length)\n\t\tparts.push(buf.slice(lastPart, buf.length));\n\n\treturn (parts);\n}\n\nfunction ecNormalize(buf, addZero) {\n\tassert.buffer(buf);\n\tif (buf[0] === 0x00 && buf[1] === 0x04) {\n\t\tif (addZero)\n\t\t\treturn (buf);\n\t\treturn (buf.slice(1));\n\t} else if (buf[0] === 0x04) {\n\t\tif (!addZero)\n\t\t\treturn (buf);\n\t} else {\n\t\twhile (buf[0] === 0x00)\n\t\t\tbuf = buf.slice(1);\n\t\tif (buf[0] === 0x02 || buf[0] === 0x03)\n\t\t\tthrow (new Error('Compressed elliptic curve points ' +\n\t\t\t    'are not supported'));\n\t\tif (buf[0] !== 0x04)\n\t\t\tthrow (new Error('Not a valid elliptic curve point'));\n\t\tif (!addZero)\n\t\t\treturn (buf);\n\t}\n\tvar b = Buffer.alloc(buf.length + 1);\n\tb[0] = 0x0;\n\tbuf.copy(b, 1);\n\treturn (b);\n}\n\nfunction readBitString(der, tag) {\n\tif (tag === undefined)\n\t\ttag = asn1.Ber.BitString;\n\tvar buf = der.readString(tag, true);\n\tassert.strictEqual(buf[0], 0x00, 'bit strings with unused bits are ' +\n\t    'not supported (0x' + buf[0].toString(16) + ')');\n\treturn (buf.slice(1));\n}\n\nfunction writeBitString(der, buf, tag) {\n\tif (tag === undefined)\n\t\ttag = asn1.Ber.BitString;\n\tvar b = Buffer.alloc(buf.length + 1);\n\tb[0] = 0x00;\n\tbuf.copy(b, 1);\n\tder.writeBuffer(b, tag);\n}\n\nfunction mpNormalize(buf) {\n\tassert.buffer(buf);\n\twhile (buf.length > 1 && buf[0] === 0x00 && (buf[1] & 0x80) === 0x00)\n\t\tbuf = buf.slice(1);\n\tif ((buf[0] & 0x80) === 0x80) {\n\t\tvar b = Buffer.alloc(buf.length + 1);\n\t\tb[0] = 0x00;\n\t\tbuf.copy(b, 1);\n\t\tbuf = b;\n\t}\n\treturn (buf);\n}\n\nfunction mpDenormalize(buf) {\n\tassert.buffer(buf);\n\twhile (buf.length > 1 && buf[0] === 0x00)\n\t\tbuf = buf.slice(1);\n\treturn (buf);\n}\n\nfunction zeroPadToLength(buf, len) {\n\tassert.buffer(buf);\n\tassert.number(len);\n\twhile (buf.length > len) {\n\t\tassert.equal(buf[0], 0x00);\n\t\tbuf = buf.slice(1);\n\t}\n\twhile (buf.length < len) {\n\t\tvar b = Buffer.alloc(buf.length + 1);\n\t\tb[0] = 0x00;\n\t\tbuf.copy(b, 1);\n\t\tbuf = b;\n\t}\n\treturn (buf);\n}\n\nfunction bigintToMpBuf(bigint) {\n\tvar buf = Buffer.from(bigint.toByteArray());\n\tbuf = mpNormalize(buf);\n\treturn (buf);\n}\n\nfunction calculateDSAPublic(g, p, x) {\n\tassert.buffer(g);\n\tassert.buffer(p);\n\tassert.buffer(x);\n\tg = new jsbn(g);\n\tp = new jsbn(p);\n\tx = new jsbn(x);\n\tvar y = g.modPow(x, p);\n\tvar ybuf = bigintToMpBuf(y);\n\treturn (ybuf);\n}\n\nfunction calculateED25519Public(k) {\n\tassert.buffer(k);\n\n\tvar kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));\n\treturn (Buffer.from(kp.publicKey));\n}\n\nfunction calculateX25519Public(k) {\n\tassert.buffer(k);\n\n\tvar kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));\n\treturn (Buffer.from(kp.publicKey));\n}\n\nfunction addRSAMissing(key) {\n\tassert.object(key);\n\tassertCompatible(key, PrivateKey, [1, 1]);\n\n\tvar d = new jsbn(key.part.d.data);\n\tvar buf;\n\n\tif (!key.part.dmodp) {\n\t\tvar p = new jsbn(key.part.p.data);\n\t\tvar dmodp = d.mod(p.subtract(1));\n\n\t\tbuf = bigintToMpBuf(dmodp);\n\t\tkey.part.dmodp = {name: 'dmodp', data: buf};\n\t\tkey.parts.push(key.part.dmodp);\n\t}\n\tif (!key.part.dmodq) {\n\t\tvar q = new jsbn(key.part.q.data);\n\t\tvar dmodq = d.mod(q.subtract(1));\n\n\t\tbuf = bigintToMpBuf(dmodq);\n\t\tkey.part.dmodq = {name: 'dmodq', data: buf};\n\t\tkey.parts.push(key.part.dmodq);\n\t}\n}\n\nfunction publicFromPrivateECDSA(curveName, priv) {\n\tassert.string(curveName, 'curveName');\n\tassert.buffer(priv);\n\tvar params = algs.curves[curveName];\n\tvar p = new jsbn(params.p);\n\tvar a = new jsbn(params.a);\n\tvar b = new jsbn(params.b);\n\tvar curve = new ec.ECCurveFp(p, a, b);\n\tvar G = curve.decodePointHex(params.G.toString('hex'));\n\n\tvar d = new jsbn(mpNormalize(priv));\n\tvar pub = G.multiply(d);\n\tpub = Buffer.from(curve.encodePointHex(pub), 'hex');\n\n\tvar parts = [];\n\tparts.push({name: 'curve', data: Buffer.from(curveName)});\n\tparts.push({name: 'Q', data: pub});\n\n\tvar key = new Key({type: 'ecdsa', curve: curve, parts: parts});\n\treturn (key);\n}\n\nfunction opensshCipherInfo(cipher) {\n\tvar inf = {};\n\tswitch (cipher) {\n\tcase '3des-cbc':\n\t\tinf.keySize = 24;\n\t\tinf.blockSize = 8;\n\t\tinf.opensslName = 'des-ede3-cbc';\n\t\tbreak;\n\tcase 'blowfish-cbc':\n\t\tinf.keySize = 16;\n\t\tinf.blockSize = 8;\n\t\tinf.opensslName = 'bf-cbc';\n\t\tbreak;\n\tcase 'aes128-cbc':\n\tcase 'aes128-ctr':\n\tcase 'aes128-gcm@openssh.com':\n\t\tinf.keySize = 16;\n\t\tinf.blockSize = 16;\n\t\tinf.opensslName = 'aes-128-' + cipher.slice(7, 10);\n\t\tbreak;\n\tcase 'aes192-cbc':\n\tcase 'aes192-ctr':\n\tcase 'aes192-gcm@openssh.com':\n\t\tinf.keySize = 24;\n\t\tinf.blockSize = 16;\n\t\tinf.opensslName = 'aes-192-' + cipher.slice(7, 10);\n\t\tbreak;\n\tcase 'aes256-cbc':\n\tcase 'aes256-ctr':\n\tcase 'aes256-gcm@openssh.com':\n\t\tinf.keySize = 32;\n\t\tinf.blockSize = 16;\n\t\tinf.opensslName = 'aes-256-' + cipher.slice(7, 10);\n\t\tbreak;\n\tdefault:\n\t\tthrow (new Error(\n\t\t    'Unsupported openssl cipher \"' + cipher + '\"'));\n\t}\n\treturn (inf);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLCtEQUFhO0FBQ2xDLGFBQWEsOEZBQThCO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLG9FQUFlO0FBQ3hDLFVBQVUsbUJBQU8sQ0FBQyxvREFBTztBQUN6QixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLHNEQUFRO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxvREFBTTs7QUFFekIsU0FBUyxtQkFBTyxDQUFDLGdFQUFpQjtBQUNsQyxXQUFXLHFHQUEwQjtBQUNyQyxXQUFXLG1CQUFPLENBQUMsOERBQVc7O0FBRTlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQyxrQkFBa0IsaUJBQWlCO0FBQ25DLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSw0Q0FBNEM7QUFDekQsYUFBYSxxQkFBcUI7O0FBRWxDLG9CQUFvQiwwQ0FBMEM7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL3V0aWxzLmpzPzIwODAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRidWZmZXJTcGxpdDogYnVmZmVyU3BsaXQsXG5cdGFkZFJTQU1pc3Npbmc6IGFkZFJTQU1pc3NpbmcsXG5cdGNhbGN1bGF0ZURTQVB1YmxpYzogY2FsY3VsYXRlRFNBUHVibGljLFxuXHRjYWxjdWxhdGVFRDI1NTE5UHVibGljOiBjYWxjdWxhdGVFRDI1NTE5UHVibGljLFxuXHRjYWxjdWxhdGVYMjU1MTlQdWJsaWM6IGNhbGN1bGF0ZVgyNTUxOVB1YmxpYyxcblx0bXBOb3JtYWxpemU6IG1wTm9ybWFsaXplLFxuXHRtcERlbm9ybWFsaXplOiBtcERlbm9ybWFsaXplLFxuXHRlY05vcm1hbGl6ZTogZWNOb3JtYWxpemUsXG5cdGNvdW50WmVyb3M6IGNvdW50WmVyb3MsXG5cdGFzc2VydENvbXBhdGlibGU6IGFzc2VydENvbXBhdGlibGUsXG5cdGlzQ29tcGF0aWJsZTogaXNDb21wYXRpYmxlLFxuXHRvcGVuc3NsS2V5RGVyaXY6IG9wZW5zc2xLZXlEZXJpdixcblx0b3BlbnNzaENpcGhlckluZm86IG9wZW5zc2hDaXBoZXJJbmZvLFxuXHRwdWJsaWNGcm9tUHJpdmF0ZUVDRFNBOiBwdWJsaWNGcm9tUHJpdmF0ZUVDRFNBLFxuXHR6ZXJvUGFkVG9MZW5ndGg6IHplcm9QYWRUb0xlbmd0aCxcblx0d3JpdGVCaXRTdHJpbmc6IHdyaXRlQml0U3RyaW5nLFxuXHRyZWFkQml0U3RyaW5nOiByZWFkQml0U3RyaW5nLFxuXHRwYmtkZjI6IHBia2RmMlxufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xudmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuL3ByaXZhdGUta2V5Jyk7XG52YXIgS2V5ID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBhbGdzID0gcmVxdWlyZSgnLi9hbGdzJyk7XG52YXIgYXNuMSA9IHJlcXVpcmUoJ2FzbjEnKTtcblxudmFyIGVjID0gcmVxdWlyZSgnZWNjLWpzYm4vbGliL2VjJyk7XG52YXIganNibiA9IHJlcXVpcmUoJ2pzYm4nKS5CaWdJbnRlZ2VyO1xudmFyIG5hY2wgPSByZXF1aXJlKCd0d2VldG5hY2wnKTtcblxudmFyIE1BWF9DTEFTU19ERVBUSCA9IDM7XG5cbmZ1bmN0aW9uIGlzQ29tcGF0aWJsZShvYmosIGtsYXNzLCBuZWVkVmVyKSB7XG5cdGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIChvYmopICE9PSAnb2JqZWN0Jylcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0aWYgKG5lZWRWZXIgPT09IHVuZGVmaW5lZClcblx0XHRuZWVkVmVyID0ga2xhc3MucHJvdG90eXBlLl9zc2hwa0FwaVZlcnNpb247XG5cdGlmIChvYmogaW5zdGFuY2VvZiBrbGFzcyAmJlxuXHQgICAga2xhc3MucHJvdG90eXBlLl9zc2hwa0FwaVZlcnNpb25bMF0gPT0gbmVlZFZlclswXSlcblx0XHRyZXR1cm4gKHRydWUpO1xuXHR2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcblx0dmFyIGRlcHRoID0gMDtcblx0d2hpbGUgKHByb3RvLmNvbnN0cnVjdG9yLm5hbWUgIT09IGtsYXNzLm5hbWUpIHtcblx0XHRwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0aWYgKCFwcm90byB8fCArK2RlcHRoID4gTUFYX0NMQVNTX0RFUFRIKVxuXHRcdFx0cmV0dXJuIChmYWxzZSk7XG5cdH1cblx0aWYgKHByb3RvLmNvbnN0cnVjdG9yLm5hbWUgIT09IGtsYXNzLm5hbWUpXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cdHZhciB2ZXIgPSBwcm90by5fc3NocGtBcGlWZXJzaW9uO1xuXHRpZiAodmVyID09PSB1bmRlZmluZWQpXG5cdFx0dmVyID0ga2xhc3MuX29sZFZlcnNpb25EZXRlY3Qob2JqKTtcblx0aWYgKHZlclswXSAhPSBuZWVkVmVyWzBdIHx8IHZlclsxXSA8IG5lZWRWZXJbMV0pXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cdHJldHVybiAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENvbXBhdGlibGUob2JqLCBrbGFzcywgbmVlZFZlciwgbmFtZSkge1xuXHRpZiAobmFtZSA9PT0gdW5kZWZpbmVkKVxuXHRcdG5hbWUgPSAnb2JqZWN0Jztcblx0YXNzZXJ0Lm9rKG9iaiwgbmFtZSArICcgbXVzdCBub3QgYmUgbnVsbCcpO1xuXHRhc3NlcnQub2JqZWN0KG9iaiwgbmFtZSArICcgbXVzdCBiZSBhbiBvYmplY3QnKTtcblx0aWYgKG5lZWRWZXIgPT09IHVuZGVmaW5lZClcblx0XHRuZWVkVmVyID0ga2xhc3MucHJvdG90eXBlLl9zc2hwa0FwaVZlcnNpb247XG5cdGlmIChvYmogaW5zdGFuY2VvZiBrbGFzcyAmJlxuXHQgICAga2xhc3MucHJvdG90eXBlLl9zc2hwa0FwaVZlcnNpb25bMF0gPT0gbmVlZFZlclswXSlcblx0XHRyZXR1cm47XG5cdHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuXHR2YXIgZGVwdGggPSAwO1xuXHR3aGlsZSAocHJvdG8uY29uc3RydWN0b3IubmFtZSAhPT0ga2xhc3MubmFtZSkge1xuXHRcdHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRhc3NlcnQub2socHJvdG8gJiYgKytkZXB0aCA8PSBNQVhfQ0xBU1NfREVQVEgsXG5cdFx0ICAgIG5hbWUgKyAnIG11c3QgYmUgYSAnICsga2xhc3MubmFtZSArICcgaW5zdGFuY2UnKTtcblx0fVxuXHRhc3NlcnQuc3RyaWN0RXF1YWwocHJvdG8uY29uc3RydWN0b3IubmFtZSwga2xhc3MubmFtZSxcblx0ICAgIG5hbWUgKyAnIG11c3QgYmUgYSAnICsga2xhc3MubmFtZSArICcgaW5zdGFuY2UnKTtcblx0dmFyIHZlciA9IHByb3RvLl9zc2hwa0FwaVZlcnNpb247XG5cdGlmICh2ZXIgPT09IHVuZGVmaW5lZClcblx0XHR2ZXIgPSBrbGFzcy5fb2xkVmVyc2lvbkRldGVjdChvYmopO1xuXHRhc3NlcnQub2sodmVyWzBdID09IG5lZWRWZXJbMF0gJiYgdmVyWzFdID49IG5lZWRWZXJbMV0sXG5cdCAgICBuYW1lICsgJyBtdXN0IGJlIGNvbXBhdGlibGUgd2l0aCAnICsga2xhc3MubmFtZSArICcga2xhc3MgJyArXG5cdCAgICAndmVyc2lvbiAnICsgbmVlZFZlclswXSArICcuJyArIG5lZWRWZXJbMV0pO1xufVxuXG52YXIgQ0lQSEVSX0xFTiA9IHtcblx0J2Rlcy1lZGUzLWNiYyc6IHsga2V5OiAyNCwgaXY6IDggfSxcblx0J2Flcy0xMjgtY2JjJzogeyBrZXk6IDE2LCBpdjogMTYgfSxcblx0J2Flcy0yNTYtY2JjJzogeyBrZXk6IDMyLCBpdjogMTYgfVxufTtcbnZhciBQS0NTNV9TQUxUX0xFTiA9IDg7XG5cbmZ1bmN0aW9uIG9wZW5zc2xLZXlEZXJpdihjaXBoZXIsIHNhbHQsIHBhc3NwaHJhc2UsIGNvdW50KSB7XG5cdGFzc2VydC5idWZmZXIoc2FsdCwgJ3NhbHQnKTtcblx0YXNzZXJ0LmJ1ZmZlcihwYXNzcGhyYXNlLCAncGFzc3BocmFzZScpO1xuXHRhc3NlcnQubnVtYmVyKGNvdW50LCAnaXRlcmF0aW9uIGNvdW50Jyk7XG5cblx0dmFyIGNsZW4gPSBDSVBIRVJfTEVOW2NpcGhlcl07XG5cdGFzc2VydC5vYmplY3QoY2xlbiwgJ3N1cHBvcnRlZCBjaXBoZXInKTtcblxuXHRzYWx0ID0gc2FsdC5zbGljZSgwLCBQS0NTNV9TQUxUX0xFTik7XG5cblx0dmFyIEQsIERfcHJldiwgYnVmcztcblx0dmFyIG1hdGVyaWFsID0gQnVmZmVyLmFsbG9jKDApO1xuXHR3aGlsZSAobWF0ZXJpYWwubGVuZ3RoIDwgY2xlbi5rZXkgKyBjbGVuLml2KSB7XG5cdFx0YnVmcyA9IFtdO1xuXHRcdGlmIChEX3ByZXYpXG5cdFx0XHRidWZzLnB1c2goRF9wcmV2KTtcblx0XHRidWZzLnB1c2gocGFzc3BocmFzZSk7XG5cdFx0YnVmcy5wdXNoKHNhbHQpO1xuXHRcdEQgPSBCdWZmZXIuY29uY2F0KGJ1ZnMpO1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgY291bnQ7ICsrailcblx0XHRcdEQgPSBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKEQpLmRpZ2VzdCgpO1xuXHRcdG1hdGVyaWFsID0gQnVmZmVyLmNvbmNhdChbbWF0ZXJpYWwsIERdKTtcblx0XHREX3ByZXYgPSBEO1xuXHR9XG5cblx0cmV0dXJuICh7XG5cdCAgICBrZXk6IG1hdGVyaWFsLnNsaWNlKDAsIGNsZW4ua2V5KSxcblx0ICAgIGl2OiBtYXRlcmlhbC5zbGljZShjbGVuLmtleSwgY2xlbi5rZXkgKyBjbGVuLml2KVxuXHR9KTtcbn1cblxuLyogU2VlOiBSRkMyODk4ICovXG5mdW5jdGlvbiBwYmtkZjIoaGFzaEFsZywgc2FsdCwgaXRlcmF0aW9ucywgc2l6ZSwgcGFzc3BocmFzZSkge1xuXHR2YXIgaGtleSA9IEJ1ZmZlci5hbGxvYyhzYWx0Lmxlbmd0aCArIDQpO1xuXHRzYWx0LmNvcHkoaGtleSk7XG5cblx0dmFyIGdlbiA9IDAsIHRzID0gW107XG5cdHZhciBpID0gMTtcblx0d2hpbGUgKGdlbiA8IHNpemUpIHtcblx0XHR2YXIgdCA9IFQoaSsrKTtcblx0XHRnZW4gKz0gdC5sZW5ndGg7XG5cdFx0dHMucHVzaCh0KTtcblx0fVxuXHRyZXR1cm4gKEJ1ZmZlci5jb25jYXQodHMpLnNsaWNlKDAsIHNpemUpKTtcblxuXHRmdW5jdGlvbiBUKEkpIHtcblx0XHRoa2V5LndyaXRlVUludDMyQkUoSSwgaGtleS5sZW5ndGggLSA0KTtcblxuXHRcdHZhciBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoaGFzaEFsZywgcGFzc3BocmFzZSk7XG5cdFx0aG1hYy51cGRhdGUoaGtleSk7XG5cblx0XHR2YXIgVGkgPSBobWFjLmRpZ2VzdCgpO1xuXHRcdHZhciBVYyA9IFRpO1xuXHRcdHZhciBjID0gMTtcblx0XHR3aGlsZSAoYysrIDwgaXRlcmF0aW9ucykge1xuXHRcdFx0aG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKGhhc2hBbGcsIHBhc3NwaHJhc2UpO1xuXHRcdFx0aG1hYy51cGRhdGUoVWMpO1xuXHRcdFx0VWMgPSBobWFjLmRpZ2VzdCgpO1xuXHRcdFx0Zm9yICh2YXIgeCA9IDA7IHggPCBUaS5sZW5ndGg7ICsreClcblx0XHRcdFx0VGlbeF0gXj0gVWNbeF07XG5cdFx0fVxuXHRcdHJldHVybiAoVGkpO1xuXHR9XG59XG5cbi8qIENvdW50IGxlYWRpbmcgemVybyBiaXRzIG9uIGEgYnVmZmVyICovXG5mdW5jdGlvbiBjb3VudFplcm9zKGJ1Zikge1xuXHR2YXIgbyA9IDAsIG9iaXQgPSA4O1xuXHR3aGlsZSAobyA8IGJ1Zi5sZW5ndGgpIHtcblx0XHR2YXIgbWFzayA9ICgxIDw8IG9iaXQpO1xuXHRcdGlmICgoYnVmW29dICYgbWFzaykgPT09IG1hc2spXG5cdFx0XHRicmVhaztcblx0XHRvYml0LS07XG5cdFx0aWYgKG9iaXQgPCAwKSB7XG5cdFx0XHRvKys7XG5cdFx0XHRvYml0ID0gODtcblx0XHR9XG5cdH1cblx0cmV0dXJuIChvKjggKyAoOCAtIG9iaXQpIC0gMSk7XG59XG5cbmZ1bmN0aW9uIGJ1ZmZlclNwbGl0KGJ1ZiwgY2hyKSB7XG5cdGFzc2VydC5idWZmZXIoYnVmKTtcblx0YXNzZXJ0LnN0cmluZyhjaHIpO1xuXG5cdHZhciBwYXJ0cyA9IFtdO1xuXHR2YXIgbGFzdFBhcnQgPSAwO1xuXHR2YXIgbWF0Y2hlcyA9IDA7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgKytpKSB7XG5cdFx0aWYgKGJ1ZltpXSA9PT0gY2hyLmNoYXJDb2RlQXQobWF0Y2hlcykpXG5cdFx0XHQrK21hdGNoZXM7XG5cdFx0ZWxzZSBpZiAoYnVmW2ldID09PSBjaHIuY2hhckNvZGVBdCgwKSlcblx0XHRcdG1hdGNoZXMgPSAxO1xuXHRcdGVsc2Vcblx0XHRcdG1hdGNoZXMgPSAwO1xuXG5cdFx0aWYgKG1hdGNoZXMgPj0gY2hyLmxlbmd0aCkge1xuXHRcdFx0dmFyIG5ld1BhcnQgPSBpICsgMTtcblx0XHRcdHBhcnRzLnB1c2goYnVmLnNsaWNlKGxhc3RQYXJ0LCBuZXdQYXJ0IC0gbWF0Y2hlcykpO1xuXHRcdFx0bGFzdFBhcnQgPSBuZXdQYXJ0O1xuXHRcdFx0bWF0Y2hlcyA9IDA7XG5cdFx0fVxuXHR9XG5cdGlmIChsYXN0UGFydCA8PSBidWYubGVuZ3RoKVxuXHRcdHBhcnRzLnB1c2goYnVmLnNsaWNlKGxhc3RQYXJ0LCBidWYubGVuZ3RoKSk7XG5cblx0cmV0dXJuIChwYXJ0cyk7XG59XG5cbmZ1bmN0aW9uIGVjTm9ybWFsaXplKGJ1ZiwgYWRkWmVybykge1xuXHRhc3NlcnQuYnVmZmVyKGJ1Zik7XG5cdGlmIChidWZbMF0gPT09IDB4MDAgJiYgYnVmWzFdID09PSAweDA0KSB7XG5cdFx0aWYgKGFkZFplcm8pXG5cdFx0XHRyZXR1cm4gKGJ1Zik7XG5cdFx0cmV0dXJuIChidWYuc2xpY2UoMSkpO1xuXHR9IGVsc2UgaWYgKGJ1ZlswXSA9PT0gMHgwNCkge1xuXHRcdGlmICghYWRkWmVybylcblx0XHRcdHJldHVybiAoYnVmKTtcblx0fSBlbHNlIHtcblx0XHR3aGlsZSAoYnVmWzBdID09PSAweDAwKVxuXHRcdFx0YnVmID0gYnVmLnNsaWNlKDEpO1xuXHRcdGlmIChidWZbMF0gPT09IDB4MDIgfHwgYnVmWzBdID09PSAweDAzKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignQ29tcHJlc3NlZCBlbGxpcHRpYyBjdXJ2ZSBwb2ludHMgJyArXG5cdFx0XHQgICAgJ2FyZSBub3Qgc3VwcG9ydGVkJykpO1xuXHRcdGlmIChidWZbMF0gIT09IDB4MDQpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdOb3QgYSB2YWxpZCBlbGxpcHRpYyBjdXJ2ZSBwb2ludCcpKTtcblx0XHRpZiAoIWFkZFplcm8pXG5cdFx0XHRyZXR1cm4gKGJ1Zik7XG5cdH1cblx0dmFyIGIgPSBCdWZmZXIuYWxsb2MoYnVmLmxlbmd0aCArIDEpO1xuXHRiWzBdID0gMHgwO1xuXHRidWYuY29weShiLCAxKTtcblx0cmV0dXJuIChiKTtcbn1cblxuZnVuY3Rpb24gcmVhZEJpdFN0cmluZyhkZXIsIHRhZykge1xuXHRpZiAodGFnID09PSB1bmRlZmluZWQpXG5cdFx0dGFnID0gYXNuMS5CZXIuQml0U3RyaW5nO1xuXHR2YXIgYnVmID0gZGVyLnJlYWRTdHJpbmcodGFnLCB0cnVlKTtcblx0YXNzZXJ0LnN0cmljdEVxdWFsKGJ1ZlswXSwgMHgwMCwgJ2JpdCBzdHJpbmdzIHdpdGggdW51c2VkIGJpdHMgYXJlICcgK1xuXHQgICAgJ25vdCBzdXBwb3J0ZWQgKDB4JyArIGJ1ZlswXS50b1N0cmluZygxNikgKyAnKScpO1xuXHRyZXR1cm4gKGJ1Zi5zbGljZSgxKSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQml0U3RyaW5nKGRlciwgYnVmLCB0YWcpIHtcblx0aWYgKHRhZyA9PT0gdW5kZWZpbmVkKVxuXHRcdHRhZyA9IGFzbjEuQmVyLkJpdFN0cmluZztcblx0dmFyIGIgPSBCdWZmZXIuYWxsb2MoYnVmLmxlbmd0aCArIDEpO1xuXHRiWzBdID0gMHgwMDtcblx0YnVmLmNvcHkoYiwgMSk7XG5cdGRlci53cml0ZUJ1ZmZlcihiLCB0YWcpO1xufVxuXG5mdW5jdGlvbiBtcE5vcm1hbGl6ZShidWYpIHtcblx0YXNzZXJ0LmJ1ZmZlcihidWYpO1xuXHR3aGlsZSAoYnVmLmxlbmd0aCA+IDEgJiYgYnVmWzBdID09PSAweDAwICYmIChidWZbMV0gJiAweDgwKSA9PT0gMHgwMClcblx0XHRidWYgPSBidWYuc2xpY2UoMSk7XG5cdGlmICgoYnVmWzBdICYgMHg4MCkgPT09IDB4ODApIHtcblx0XHR2YXIgYiA9IEJ1ZmZlci5hbGxvYyhidWYubGVuZ3RoICsgMSk7XG5cdFx0YlswXSA9IDB4MDA7XG5cdFx0YnVmLmNvcHkoYiwgMSk7XG5cdFx0YnVmID0gYjtcblx0fVxuXHRyZXR1cm4gKGJ1Zik7XG59XG5cbmZ1bmN0aW9uIG1wRGVub3JtYWxpemUoYnVmKSB7XG5cdGFzc2VydC5idWZmZXIoYnVmKTtcblx0d2hpbGUgKGJ1Zi5sZW5ndGggPiAxICYmIGJ1ZlswXSA9PT0gMHgwMClcblx0XHRidWYgPSBidWYuc2xpY2UoMSk7XG5cdHJldHVybiAoYnVmKTtcbn1cblxuZnVuY3Rpb24gemVyb1BhZFRvTGVuZ3RoKGJ1ZiwgbGVuKSB7XG5cdGFzc2VydC5idWZmZXIoYnVmKTtcblx0YXNzZXJ0Lm51bWJlcihsZW4pO1xuXHR3aGlsZSAoYnVmLmxlbmd0aCA+IGxlbikge1xuXHRcdGFzc2VydC5lcXVhbChidWZbMF0sIDB4MDApO1xuXHRcdGJ1ZiA9IGJ1Zi5zbGljZSgxKTtcblx0fVxuXHR3aGlsZSAoYnVmLmxlbmd0aCA8IGxlbikge1xuXHRcdHZhciBiID0gQnVmZmVyLmFsbG9jKGJ1Zi5sZW5ndGggKyAxKTtcblx0XHRiWzBdID0gMHgwMDtcblx0XHRidWYuY29weShiLCAxKTtcblx0XHRidWYgPSBiO1xuXHR9XG5cdHJldHVybiAoYnVmKTtcbn1cblxuZnVuY3Rpb24gYmlnaW50VG9NcEJ1ZihiaWdpbnQpIHtcblx0dmFyIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJpZ2ludC50b0J5dGVBcnJheSgpKTtcblx0YnVmID0gbXBOb3JtYWxpemUoYnVmKTtcblx0cmV0dXJuIChidWYpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVEU0FQdWJsaWMoZywgcCwgeCkge1xuXHRhc3NlcnQuYnVmZmVyKGcpO1xuXHRhc3NlcnQuYnVmZmVyKHApO1xuXHRhc3NlcnQuYnVmZmVyKHgpO1xuXHRnID0gbmV3IGpzYm4oZyk7XG5cdHAgPSBuZXcganNibihwKTtcblx0eCA9IG5ldyBqc2JuKHgpO1xuXHR2YXIgeSA9IGcubW9kUG93KHgsIHApO1xuXHR2YXIgeWJ1ZiA9IGJpZ2ludFRvTXBCdWYoeSk7XG5cdHJldHVybiAoeWJ1Zik7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUVEMjU1MTlQdWJsaWMoaykge1xuXHRhc3NlcnQuYnVmZmVyKGspO1xuXG5cdHZhciBrcCA9IG5hY2wuc2lnbi5rZXlQYWlyLmZyb21TZWVkKG5ldyBVaW50OEFycmF5KGspKTtcblx0cmV0dXJuIChCdWZmZXIuZnJvbShrcC5wdWJsaWNLZXkpKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlWDI1NTE5UHVibGljKGspIHtcblx0YXNzZXJ0LmJ1ZmZlcihrKTtcblxuXHR2YXIga3AgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWVkKG5ldyBVaW50OEFycmF5KGspKTtcblx0cmV0dXJuIChCdWZmZXIuZnJvbShrcC5wdWJsaWNLZXkpKTtcbn1cblxuZnVuY3Rpb24gYWRkUlNBTWlzc2luZyhrZXkpIHtcblx0YXNzZXJ0Lm9iamVjdChrZXkpO1xuXHRhc3NlcnRDb21wYXRpYmxlKGtleSwgUHJpdmF0ZUtleSwgWzEsIDFdKTtcblxuXHR2YXIgZCA9IG5ldyBqc2JuKGtleS5wYXJ0LmQuZGF0YSk7XG5cdHZhciBidWY7XG5cblx0aWYgKCFrZXkucGFydC5kbW9kcCkge1xuXHRcdHZhciBwID0gbmV3IGpzYm4oa2V5LnBhcnQucC5kYXRhKTtcblx0XHR2YXIgZG1vZHAgPSBkLm1vZChwLnN1YnRyYWN0KDEpKTtcblxuXHRcdGJ1ZiA9IGJpZ2ludFRvTXBCdWYoZG1vZHApO1xuXHRcdGtleS5wYXJ0LmRtb2RwID0ge25hbWU6ICdkbW9kcCcsIGRhdGE6IGJ1Zn07XG5cdFx0a2V5LnBhcnRzLnB1c2goa2V5LnBhcnQuZG1vZHApO1xuXHR9XG5cdGlmICgha2V5LnBhcnQuZG1vZHEpIHtcblx0XHR2YXIgcSA9IG5ldyBqc2JuKGtleS5wYXJ0LnEuZGF0YSk7XG5cdFx0dmFyIGRtb2RxID0gZC5tb2QocS5zdWJ0cmFjdCgxKSk7XG5cblx0XHRidWYgPSBiaWdpbnRUb01wQnVmKGRtb2RxKTtcblx0XHRrZXkucGFydC5kbW9kcSA9IHtuYW1lOiAnZG1vZHEnLCBkYXRhOiBidWZ9O1xuXHRcdGtleS5wYXJ0cy5wdXNoKGtleS5wYXJ0LmRtb2RxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBwdWJsaWNGcm9tUHJpdmF0ZUVDRFNBKGN1cnZlTmFtZSwgcHJpdikge1xuXHRhc3NlcnQuc3RyaW5nKGN1cnZlTmFtZSwgJ2N1cnZlTmFtZScpO1xuXHRhc3NlcnQuYnVmZmVyKHByaXYpO1xuXHR2YXIgcGFyYW1zID0gYWxncy5jdXJ2ZXNbY3VydmVOYW1lXTtcblx0dmFyIHAgPSBuZXcganNibihwYXJhbXMucCk7XG5cdHZhciBhID0gbmV3IGpzYm4ocGFyYW1zLmEpO1xuXHR2YXIgYiA9IG5ldyBqc2JuKHBhcmFtcy5iKTtcblx0dmFyIGN1cnZlID0gbmV3IGVjLkVDQ3VydmVGcChwLCBhLCBiKTtcblx0dmFyIEcgPSBjdXJ2ZS5kZWNvZGVQb2ludEhleChwYXJhbXMuRy50b1N0cmluZygnaGV4JykpO1xuXG5cdHZhciBkID0gbmV3IGpzYm4obXBOb3JtYWxpemUocHJpdikpO1xuXHR2YXIgcHViID0gRy5tdWx0aXBseShkKTtcblx0cHViID0gQnVmZmVyLmZyb20oY3VydmUuZW5jb2RlUG9pbnRIZXgocHViKSwgJ2hleCcpO1xuXG5cdHZhciBwYXJ0cyA9IFtdO1xuXHRwYXJ0cy5wdXNoKHtuYW1lOiAnY3VydmUnLCBkYXRhOiBCdWZmZXIuZnJvbShjdXJ2ZU5hbWUpfSk7XG5cdHBhcnRzLnB1c2goe25hbWU6ICdRJywgZGF0YTogcHVifSk7XG5cblx0dmFyIGtleSA9IG5ldyBLZXkoe3R5cGU6ICdlY2RzYScsIGN1cnZlOiBjdXJ2ZSwgcGFydHM6IHBhcnRzfSk7XG5cdHJldHVybiAoa2V5KTtcbn1cblxuZnVuY3Rpb24gb3BlbnNzaENpcGhlckluZm8oY2lwaGVyKSB7XG5cdHZhciBpbmYgPSB7fTtcblx0c3dpdGNoIChjaXBoZXIpIHtcblx0Y2FzZSAnM2Rlcy1jYmMnOlxuXHRcdGluZi5rZXlTaXplID0gMjQ7XG5cdFx0aW5mLmJsb2NrU2l6ZSA9IDg7XG5cdFx0aW5mLm9wZW5zc2xOYW1lID0gJ2Rlcy1lZGUzLWNiYyc7XG5cdFx0YnJlYWs7XG5cdGNhc2UgJ2Jsb3dmaXNoLWNiYyc6XG5cdFx0aW5mLmtleVNpemUgPSAxNjtcblx0XHRpbmYuYmxvY2tTaXplID0gODtcblx0XHRpbmYub3BlbnNzbE5hbWUgPSAnYmYtY2JjJztcblx0XHRicmVhaztcblx0Y2FzZSAnYWVzMTI4LWNiYyc6XG5cdGNhc2UgJ2FlczEyOC1jdHInOlxuXHRjYXNlICdhZXMxMjgtZ2NtQG9wZW5zc2guY29tJzpcblx0XHRpbmYua2V5U2l6ZSA9IDE2O1xuXHRcdGluZi5ibG9ja1NpemUgPSAxNjtcblx0XHRpbmYub3BlbnNzbE5hbWUgPSAnYWVzLTEyOC0nICsgY2lwaGVyLnNsaWNlKDcsIDEwKTtcblx0XHRicmVhaztcblx0Y2FzZSAnYWVzMTkyLWNiYyc6XG5cdGNhc2UgJ2FlczE5Mi1jdHInOlxuXHRjYXNlICdhZXMxOTItZ2NtQG9wZW5zc2guY29tJzpcblx0XHRpbmYua2V5U2l6ZSA9IDI0O1xuXHRcdGluZi5ibG9ja1NpemUgPSAxNjtcblx0XHRpbmYub3BlbnNzbE5hbWUgPSAnYWVzLTE5Mi0nICsgY2lwaGVyLnNsaWNlKDcsIDEwKTtcblx0XHRicmVhaztcblx0Y2FzZSAnYWVzMjU2LWNiYyc6XG5cdGNhc2UgJ2FlczI1Ni1jdHInOlxuXHRjYXNlICdhZXMyNTYtZ2NtQG9wZW5zc2guY29tJzpcblx0XHRpbmYua2V5U2l6ZSA9IDMyO1xuXHRcdGluZi5ibG9ja1NpemUgPSAxNjtcblx0XHRpbmYub3BlbnNzbE5hbWUgPSAnYWVzLTI1Ni0nICsgY2lwaGVyLnNsaWNlKDcsIDEwKTtcblx0XHRicmVhaztcblx0ZGVmYXVsdDpcblx0XHR0aHJvdyAobmV3IEVycm9yKFxuXHRcdCAgICAnVW5zdXBwb3J0ZWQgb3BlbnNzbCBjaXBoZXIgXCInICsgY2lwaGVyICsgJ1wiJykpO1xuXHR9XG5cdHJldHVybiAoaW5mKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/lib/utils.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/sshpk/node_modules/jsbn/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/sshpk/node_modules/jsbn/index.js ***!
  \*******************************************************/
/***/ (function(module, exports) {

eval("(function(){\n\n    // Copyright (c) 2005  Tom Wu\n    // All Rights Reserved.\n    // See \"LICENSE\" for details.\n\n    // Basic JavaScript BN library - subset useful for RSA encryption.\n\n    // Bits per digit\n    var dbits;\n\n    // JavaScript engine analysis\n    var canary = 0xdeadbeefcafe;\n    var j_lm = ((canary&0xffffff)==0xefcafe);\n\n    // (public) Constructor\n    function BigInteger(a,b,c) {\n      if(a != null)\n        if(\"number\" == typeof a) this.fromNumber(a,b,c);\n        else if(b == null && \"string\" != typeof a) this.fromString(a,256);\n        else this.fromString(a,b);\n    }\n\n    // return new, unset BigInteger\n    function nbi() { return new BigInteger(null); }\n\n    // am: Compute w_j += (x*this_i), propagate carries,\n    // c is initial carry, returns final carry.\n    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n    // We need to select the fastest one that works in this environment.\n\n    // am1: use a single mult and divide to get the high bits,\n    // max digit bits should be 26 because\n    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n    function am1(i,x,w,j,c,n) {\n      while(--n >= 0) {\n        var v = x*this[i++]+w[j]+c;\n        c = Math.floor(v/0x4000000);\n        w[j++] = v&0x3ffffff;\n      }\n      return c;\n    }\n    // am2 avoids a big mult-and-extract completely.\n    // Max digit bits should be <= 30 because we do bitwise ops\n    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n    function am2(i,x,w,j,c,n) {\n      var xl = x&0x7fff, xh = x>>15;\n      while(--n >= 0) {\n        var l = this[i]&0x7fff;\n        var h = this[i++]>>15;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n        w[j++] = l&0x3fffffff;\n      }\n      return c;\n    }\n    // Alternately, set max digit bits to 28 since some\n    // browsers slow down when dealing with 32-bit numbers.\n    function am3(i,x,w,j,c,n) {\n      var xl = x&0x3fff, xh = x>>14;\n      while(--n >= 0) {\n        var l = this[i]&0x3fff;\n        var h = this[i++]>>14;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n        c = (l>>28)+(m>>14)+xh*h;\n        w[j++] = l&0xfffffff;\n      }\n      return c;\n    }\n    var inBrowser = typeof navigator !== \"undefined\";\n    if(inBrowser && j_lm && (navigator.appName == \"Microsoft Internet Explorer\")) {\n      BigInteger.prototype.am = am2;\n      dbits = 30;\n    }\n    else if(inBrowser && j_lm && (navigator.appName != \"Netscape\")) {\n      BigInteger.prototype.am = am1;\n      dbits = 26;\n    }\n    else { // Mozilla/Netscape seems to prefer am3\n      BigInteger.prototype.am = am3;\n      dbits = 28;\n    }\n\n    BigInteger.prototype.DB = dbits;\n    BigInteger.prototype.DM = ((1<<dbits)-1);\n    BigInteger.prototype.DV = (1<<dbits);\n\n    var BI_FP = 52;\n    BigInteger.prototype.FV = Math.pow(2,BI_FP);\n    BigInteger.prototype.F1 = BI_FP-dbits;\n    BigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n    // Digit conversions\n    var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n    var BI_RC = new Array();\n    var rr,vv;\n    rr = \"0\".charCodeAt(0);\n    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n    rr = \"a\".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n    rr = \"A\".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n    function int2char(n) { return BI_RM.charAt(n); }\n    function intAt(s,i) {\n      var c = BI_RC[s.charCodeAt(i)];\n      return (c==null)?-1:c;\n    }\n\n    // (protected) copy this to r\n    function bnpCopyTo(r) {\n      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n      r.t = this.t;\n      r.s = this.s;\n    }\n\n    // (protected) set from integer value x, -DV <= x < DV\n    function bnpFromInt(x) {\n      this.t = 1;\n      this.s = (x<0)?-1:0;\n      if(x > 0) this[0] = x;\n      else if(x < -1) this[0] = x+this.DV;\n      else this.t = 0;\n    }\n\n    // return bigint initialized to value\n    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n    // (protected) set from string and radix\n    function bnpFromString(s,b) {\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 256) k = 8; // byte array\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else { this.fromRadix(s,b); return; }\n      this.t = 0;\n      this.s = 0;\n      var i = s.length, mi = false, sh = 0;\n      while(--i >= 0) {\n        var x = (k==8)?s[i]&0xff:intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == \"-\") mi = true;\n          continue;\n        }\n        mi = false;\n        if(sh == 0)\n          this[this.t++] = x;\n        else if(sh+k > this.DB) {\n          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n          this[this.t++] = (x>>(this.DB-sh));\n        }\n        else\n          this[this.t-1] |= x<<sh;\n        sh += k;\n        if(sh >= this.DB) sh -= this.DB;\n      }\n      if(k == 8 && (s[0]&0x80) != 0) {\n        this.s = -1;\n        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n      }\n      this.clamp();\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) clamp off excess high words\n    function bnpClamp() {\n      var c = this.s&this.DM;\n      while(this.t > 0 && this[this.t-1] == c) --this.t;\n    }\n\n    // (public) return string representation in given radix\n    function bnToString(b) {\n      if(this.s < 0) return \"-\"+this.negate().toString(b);\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else return this.toRadix(b);\n      var km = (1<<k)-1, d, m = false, r = \"\", i = this.t;\n      var p = this.DB-(i*this.DB)%k;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n        while(i >= 0) {\n          if(p < k) {\n            d = (this[i]&((1<<p)-1))<<(k-p);\n            d |= this[--i]>>(p+=this.DB-k);\n          }\n          else {\n            d = (this[i]>>(p-=k))&km;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if(d > 0) m = true;\n          if(m) r += int2char(d);\n        }\n      }\n      return m?r:\"0\";\n    }\n\n    // (public) -this\n    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n    // (public) |this|\n    function bnAbs() { return (this.s<0)?this.negate():this; }\n\n    // (public) return + if this > a, - if this < a, 0 if equal\n    function bnCompareTo(a) {\n      var r = this.s-a.s;\n      if(r != 0) return r;\n      var i = this.t;\n      r = i-a.t;\n      if(r != 0) return (this.s<0)?-r:r;\n      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n      return 0;\n    }\n\n    // returns bit length of the integer x\n    function nbits(x) {\n      var r = 1, t;\n      if((t=x>>>16) != 0) { x = t; r += 16; }\n      if((t=x>>8) != 0) { x = t; r += 8; }\n      if((t=x>>4) != 0) { x = t; r += 4; }\n      if((t=x>>2) != 0) { x = t; r += 2; }\n      if((t=x>>1) != 0) { x = t; r += 1; }\n      return r;\n    }\n\n    // (public) return the number of bits in \"this\"\n    function bnBitLength() {\n      if(this.t <= 0) return 0;\n      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n    }\n\n    // (protected) r = this << n*DB\n    function bnpDLShiftTo(n,r) {\n      var i;\n      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n      for(i = n-1; i >= 0; --i) r[i] = 0;\n      r.t = this.t+n;\n      r.s = this.s;\n    }\n\n    // (protected) r = this >> n*DB\n    function bnpDRShiftTo(n,r) {\n      for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n      r.t = Math.max(this.t-n,0);\n      r.s = this.s;\n    }\n\n    // (protected) r = this << n\n    function bnpLShiftTo(n,r) {\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<cbs)-1;\n      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n      for(i = this.t-1; i >= 0; --i) {\n        r[i+ds+1] = (this[i]>>cbs)|c;\n        c = (this[i]&bm)<<bs;\n      }\n      for(i = ds-1; i >= 0; --i) r[i] = 0;\n      r[ds] = c;\n      r.t = this.t+ds+1;\n      r.s = this.s;\n      r.clamp();\n    }\n\n    // (protected) r = this >> n\n    function bnpRShiftTo(n,r) {\n      r.s = this.s;\n      var ds = Math.floor(n/this.DB);\n      if(ds >= this.t) { r.t = 0; return; }\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<bs)-1;\n      r[0] = this[ds]>>bs;\n      for(var i = ds+1; i < this.t; ++i) {\n        r[i-ds-1] |= (this[i]&bm)<<cbs;\n        r[i-ds] = this[i]>>bs;\n      }\n      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n      r.t = this.t-ds;\n      r.clamp();\n    }\n\n    // (protected) r = this - a\n    function bnpSubTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]-a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c -= a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c -= a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c -= a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c < -1) r[i++] = this.DV+c;\n      else if(c > 0) r[i++] = c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (protected) r = this * a, r != this,a (HAC 14.12)\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyTo(a,r) {\n      var x = this.abs(), y = a.abs();\n      var i = x.t;\n      r.t = i+y.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n      r.s = 0;\n      r.clamp();\n      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (protected) r = this^2, r != this (HAC 14.16)\n    function bnpSquareTo(r) {\n      var x = this.abs();\n      var i = r.t = 2*x.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < x.t-1; ++i) {\n        var c = x.am(i,x[i],r,2*i,0,1);\n        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n          r[i+x.t] -= x.DV;\n          r[i+x.t+1] = 1;\n        }\n      }\n      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n      r.s = 0;\n      r.clamp();\n    }\n\n    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n    // r != q, this != m.  q or r may be null.\n    function bnpDivRemTo(m,q,r) {\n      var pm = m.abs();\n      if(pm.t <= 0) return;\n      var pt = this.abs();\n      if(pt.t < pm.t) {\n        if(q != null) q.fromInt(0);\n        if(r != null) this.copyTo(r);\n        return;\n      }\n      if(r == null) r = nbi();\n      var y = nbi(), ts = this.s, ms = m.s;\n      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus\n      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n      else { pm.copyTo(y); pt.copyTo(r); }\n      var ys = y.t;\n      var y0 = y[ys-1];\n      if(y0 == 0) return;\n      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n      var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n      y.dlShiftTo(j,t);\n      if(r.compareTo(t) >= 0) {\n        r[r.t++] = 1;\n        r.subTo(t,r);\n      }\n      BigInteger.ONE.dlShiftTo(ys,t);\n      t.subTo(y,y);  // \"negative\" y so we can replace sub with am later\n      while(y.t < ys) y[y.t++] = 0;\n      while(--j >= 0) {\n        // Estimate quotient digit\n        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out\n          y.dlShiftTo(j,t);\n          r.subTo(t,r);\n          while(r[i] < --qd) r.subTo(t,r);\n        }\n      }\n      if(q != null) {\n        r.drShiftTo(ys,q);\n        if(ts != ms) BigInteger.ZERO.subTo(q,q);\n      }\n      r.t = ys;\n      r.clamp();\n      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder\n      if(ts < 0) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (public) this mod a\n    function bnMod(a) {\n      var r = nbi();\n      this.abs().divRemTo(a,null,r);\n      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n      return r;\n    }\n\n    // Modular reduction using \"classic\" algorithm\n    function Classic(m) { this.m = m; }\n    function cConvert(x) {\n      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n      else return x;\n    }\n    function cRevert(x) { return x; }\n    function cReduce(x) { x.divRemTo(this.m,null,x); }\n    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    Classic.prototype.convert = cConvert;\n    Classic.prototype.revert = cRevert;\n    Classic.prototype.reduce = cReduce;\n    Classic.prototype.mulTo = cMulTo;\n    Classic.prototype.sqrTo = cSqrTo;\n\n    // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n    // justification:\n    //         xy == 1 (mod m)\n    //         xy =  1+km\n    //   xy(2-xy) = (1+km)(1-km)\n    // x[y(2-xy)] = 1-k^2m^2\n    // x[y(2-xy)] == 1 (mod m^2)\n    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n    // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n    function bnpInvDigit() {\n      if(this.t < 1) return 0;\n      var x = this[0];\n      if((x&1) == 0) return 0;\n      var y = x&3;       // y == 1/x mod 2^2\n      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4\n      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8\n      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16\n      // last step - calculate inverse mod DV directly;\n      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits\n      // we really want the negative inverse, and -DV < y < DV\n      return (y>0)?this.DV-y:-y;\n    }\n\n    // Montgomery reduction\n    function Montgomery(m) {\n      this.m = m;\n      this.mp = m.invDigit();\n      this.mpl = this.mp&0x7fff;\n      this.mph = this.mp>>15;\n      this.um = (1<<(m.DB-15))-1;\n      this.mt2 = 2*m.t;\n    }\n\n    // xR mod m\n    function montConvert(x) {\n      var r = nbi();\n      x.abs().dlShiftTo(this.m.t,r);\n      r.divRemTo(this.m,null,r);\n      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n      return r;\n    }\n\n    // x/R mod m\n    function montRevert(x) {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n\n    // x = x/R mod m (HAC 14.32)\n    function montReduce(x) {\n      while(x.t <= this.mt2) // pad x so am has enough room later\n        x[x.t++] = 0;\n      for(var i = 0; i < this.m.t; ++i) {\n        // faster way of calculating u0 = x[i]*mp mod DV\n        var j = x[i]&0x7fff;\n        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n        // use am to combine the multiply-shift-add into one call\n        j = i+this.m.t;\n        x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n        // propagate carry\n        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n      }\n      x.clamp();\n      x.drShiftTo(this.m.t,x);\n      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = \"x^2/R mod m\"; x != r\n    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = \"xy/R mod m\"; x,y != r\n    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Montgomery.prototype.convert = montConvert;\n    Montgomery.prototype.revert = montRevert;\n    Montgomery.prototype.reduce = montReduce;\n    Montgomery.prototype.mulTo = montMulTo;\n    Montgomery.prototype.sqrTo = montSqrTo;\n\n    // (protected) true iff this is even\n    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n    // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n    function bnpExp(e,z) {\n      if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n      g.copyTo(r);\n      while(--i >= 0) {\n        z.sqrTo(r,r2);\n        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n        else { var t = r; r = r2; r2 = t; }\n      }\n      return z.revert(r);\n    }\n\n    // (public) this^e % m, 0 <= e < 2^32\n    function bnModPowInt(e,m) {\n      var z;\n      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n      return this.exp(e,z);\n    }\n\n    // protected\n    BigInteger.prototype.copyTo = bnpCopyTo;\n    BigInteger.prototype.fromInt = bnpFromInt;\n    BigInteger.prototype.fromString = bnpFromString;\n    BigInteger.prototype.clamp = bnpClamp;\n    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n    BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n    BigInteger.prototype.lShiftTo = bnpLShiftTo;\n    BigInteger.prototype.rShiftTo = bnpRShiftTo;\n    BigInteger.prototype.subTo = bnpSubTo;\n    BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n    BigInteger.prototype.squareTo = bnpSquareTo;\n    BigInteger.prototype.divRemTo = bnpDivRemTo;\n    BigInteger.prototype.invDigit = bnpInvDigit;\n    BigInteger.prototype.isEven = bnpIsEven;\n    BigInteger.prototype.exp = bnpExp;\n\n    // public\n    BigInteger.prototype.toString = bnToString;\n    BigInteger.prototype.negate = bnNegate;\n    BigInteger.prototype.abs = bnAbs;\n    BigInteger.prototype.compareTo = bnCompareTo;\n    BigInteger.prototype.bitLength = bnBitLength;\n    BigInteger.prototype.mod = bnMod;\n    BigInteger.prototype.modPowInt = bnModPowInt;\n\n    // \"constants\"\n    BigInteger.ZERO = nbv(0);\n    BigInteger.ONE = nbv(1);\n\n    // Copyright (c) 2005-2009  Tom Wu\n    // All Rights Reserved.\n    // See \"LICENSE\" for details.\n\n    // Extended JavaScript BN functions, required for RSA private ops.\n\n    // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n    // Version 1.2: square() API, isProbablePrime fix\n\n    // (public)\n    function bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n    // (public) return value as integer\n    function bnIntValue() {\n      if(this.s < 0) {\n        if(this.t == 1) return this[0]-this.DV;\n        else if(this.t == 0) return -1;\n      }\n      else if(this.t == 1) return this[0];\n      else if(this.t == 0) return 0;\n      // assumes 16 < DB < 32\n      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n    }\n\n    // (public) return value as byte\n    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n    // (public) return value as short (assumes DB>=16)\n    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n    // (protected) return x s.t. r^x < DV\n    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n    // (public) 0 if this == 0, 1 if this > 0\n    function bnSigNum() {\n      if(this.s < 0) return -1;\n      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n      else return 1;\n    }\n\n    // (protected) convert to radix string\n    function bnpToRadix(b) {\n      if(b == null) b = 10;\n      if(this.signum() == 0 || b < 2 || b > 36) return \"0\";\n      var cs = this.chunkSize(b);\n      var a = Math.pow(b,cs);\n      var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\n      this.divRemTo(d,y,z);\n      while(y.signum() > 0) {\n        r = (a+z.intValue()).toString(b).substr(1) + r;\n        y.divRemTo(d,y,z);\n      }\n      return z.intValue().toString(b) + r;\n    }\n\n    // (protected) convert from radix string\n    function bnpFromRadix(s,b) {\n      this.fromInt(0);\n      if(b == null) b = 10;\n      var cs = this.chunkSize(b);\n      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n      for(var i = 0; i < s.length; ++i) {\n        var x = intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n          continue;\n        }\n        w = b*w+x;\n        if(++j >= cs) {\n          this.dMultiply(d);\n          this.dAddOffset(w,0);\n          j = 0;\n          w = 0;\n        }\n      }\n      if(j > 0) {\n        this.dMultiply(Math.pow(b,j));\n        this.dAddOffset(w,0);\n      }\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) alternate constructor\n    function bnpFromNumber(a,b,c) {\n      if(\"number\" == typeof b) {\n        // new BigInteger(int,int,RNG)\n        if(a < 2) this.fromInt(1);\n        else {\n          this.fromNumber(a,c);\n          if(!this.testBit(a-1))\t// force MSB set\n            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n          if(this.isEven()) this.dAddOffset(1,0); // force odd\n          while(!this.isProbablePrime(b)) {\n            this.dAddOffset(2,0);\n            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n          }\n        }\n      }\n      else {\n        // new BigInteger(int,RNG)\n        var x = new Array(), t = a&7;\n        x.length = (a>>3)+1;\n        b.nextBytes(x);\n        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n        this.fromString(x,256);\n      }\n    }\n\n    // (public) convert to bigendian byte array\n    function bnToByteArray() {\n      var i = this.t, r = new Array();\n      r[0] = this.s;\n      var p = this.DB-(i*this.DB)%8, d, k = 0;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n          r[k++] = d|(this.s<<(this.DB-p));\n        while(i >= 0) {\n          if(p < 8) {\n            d = (this[i]&((1<<p)-1))<<(8-p);\n            d |= this[--i]>>(p+=this.DB-8);\n          }\n          else {\n            d = (this[i]>>(p-=8))&0xff;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if((d&0x80) != 0) d |= -256;\n          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n          if(k > 0 || d != this.s) r[k++] = d;\n        }\n      }\n      return r;\n    }\n\n    function bnEquals(a) { return(this.compareTo(a)==0); }\n    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }\n    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n    // (protected) r = this op a (bitwise)\n    function bnpBitwiseTo(a,op,r) {\n      var i, f, m = Math.min(a.t,this.t);\n      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n      if(a.t < this.t) {\n        f = a.s&this.DM;\n        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n        r.t = this.t;\n      }\n      else {\n        f = this.s&this.DM;\n        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n        r.t = a.t;\n      }\n      r.s = op(this.s,a.s);\n      r.clamp();\n    }\n\n    // (public) this & a\n    function op_and(x,y) { return x&y; }\n    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n    // (public) this | a\n    function op_or(x,y) { return x|y; }\n    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n    // (public) this ^ a\n    function op_xor(x,y) { return x^y; }\n    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n    // (public) this & ~a\n    function op_andnot(x,y) { return x&~y; }\n    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n    // (public) ~this\n    function bnNot() {\n      var r = nbi();\n      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n      r.t = this.t;\n      r.s = ~this.s;\n      return r;\n    }\n\n    // (public) this << n\n    function bnShiftLeft(n) {\n      var r = nbi();\n      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n      return r;\n    }\n\n    // (public) this >> n\n    function bnShiftRight(n) {\n      var r = nbi();\n      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n      return r;\n    }\n\n    // return index of lowest 1-bit in x, x < 2^31\n    function lbit(x) {\n      if(x == 0) return -1;\n      var r = 0;\n      if((x&0xffff) == 0) { x >>= 16; r += 16; }\n      if((x&0xff) == 0) { x >>= 8; r += 8; }\n      if((x&0xf) == 0) { x >>= 4; r += 4; }\n      if((x&3) == 0) { x >>= 2; r += 2; }\n      if((x&1) == 0) ++r;\n      return r;\n    }\n\n    // (public) returns index of lowest 1-bit (or -1 if none)\n    function bnGetLowestSetBit() {\n      for(var i = 0; i < this.t; ++i)\n        if(this[i] != 0) return i*this.DB+lbit(this[i]);\n      if(this.s < 0) return this.t*this.DB;\n      return -1;\n    }\n\n    // return number of 1 bits in x\n    function cbit(x) {\n      var r = 0;\n      while(x != 0) { x &= x-1; ++r; }\n      return r;\n    }\n\n    // (public) return number of set bits\n    function bnBitCount() {\n      var r = 0, x = this.s&this.DM;\n      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n      return r;\n    }\n\n    // (public) true iff nth bit is set\n    function bnTestBit(n) {\n      var j = Math.floor(n/this.DB);\n      if(j >= this.t) return(this.s!=0);\n      return((this[j]&(1<<(n%this.DB)))!=0);\n    }\n\n    // (protected) this op (1<<n)\n    function bnpChangeBit(n,op) {\n      var r = BigInteger.ONE.shiftLeft(n);\n      this.bitwiseTo(r,op,r);\n      return r;\n    }\n\n    // (public) this | (1<<n)\n    function bnSetBit(n) { return this.changeBit(n,op_or); }\n\n    // (public) this & ~(1<<n)\n    function bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n    // (public) this ^ (1<<n)\n    function bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n    // (protected) r = this + a\n    function bnpAddTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]+a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c += a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c += a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c > 0) r[i++] = c;\n      else if(c < -1) r[i++] = this.DV+c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (public) this + a\n    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n    // (public) this - a\n    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n    // (public) this * a\n    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n    // (public) this^2\n    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n    // (public) this / a\n    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n    // (public) this % a\n    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n    // (public) [this/a,this%a]\n    function bnDivideAndRemainder(a) {\n      var q = nbi(), r = nbi();\n      this.divRemTo(a,q,r);\n      return new Array(q,r);\n    }\n\n    // (protected) this *= n, this >= 0, 1 < n < DV\n    function bnpDMultiply(n) {\n      this[this.t] = this.am(0,n-1,this,0,0,this.t);\n      ++this.t;\n      this.clamp();\n    }\n\n    // (protected) this += n << w words, this >= 0\n    function bnpDAddOffset(n,w) {\n      if(n == 0) return;\n      while(this.t <= w) this[this.t++] = 0;\n      this[w] += n;\n      while(this[w] >= this.DV) {\n        this[w] -= this.DV;\n        if(++w >= this.t) this[this.t++] = 0;\n        ++this[w];\n      }\n    }\n\n    // A \"null\" reducer\n    function NullExp() {}\n    function nNop(x) { return x; }\n    function nMulTo(x,y,r) { x.multiplyTo(y,r); }\n    function nSqrTo(x,r) { x.squareTo(r); }\n\n    NullExp.prototype.convert = nNop;\n    NullExp.prototype.revert = nNop;\n    NullExp.prototype.mulTo = nMulTo;\n    NullExp.prototype.sqrTo = nSqrTo;\n\n    // (public) this^e\n    function bnPow(e) { return this.exp(e,new NullExp()); }\n\n    // (protected) r = lower n words of \"this * a\", a.t <= n\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyLowerTo(a,n,r) {\n      var i = Math.min(this.t+a.t,n);\n      r.s = 0; // assumes a,this >= 0\n      r.t = i;\n      while(i > 0) r[--i] = 0;\n      var j;\n      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n      r.clamp();\n    }\n\n    // (protected) r = \"this * a\" without lower n words, n > 0\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyUpperTo(a,n,r) {\n      --n;\n      var i = r.t = this.t+a.t-n;\n      r.s = 0; // assumes a,this >= 0\n      while(--i >= 0) r[i] = 0;\n      for(i = Math.max(n-this.t,0); i < a.t; ++i)\n        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n      r.clamp();\n      r.drShiftTo(1,r);\n    }\n\n    // Barrett modular reduction\n    function Barrett(m) {\n      // setup Barrett\n      this.r2 = nbi();\n      this.q3 = nbi();\n      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n      this.mu = this.r2.divide(m);\n      this.m = m;\n    }\n\n    function barrettConvert(x) {\n      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n      else if(x.compareTo(this.m) < 0) return x;\n      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n    }\n\n    function barrettRevert(x) { return x; }\n\n    // x = x mod m (HAC 14.42)\n    function barrettReduce(x) {\n      x.drShiftTo(this.m.t-1,this.r2);\n      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n      x.subTo(this.r2,x);\n      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = x^2 mod m; x != r\n    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = x*y mod m; x,y != r\n    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Barrett.prototype.convert = barrettConvert;\n    Barrett.prototype.revert = barrettRevert;\n    Barrett.prototype.reduce = barrettReduce;\n    Barrett.prototype.mulTo = barrettMulTo;\n    Barrett.prototype.sqrTo = barrettSqrTo;\n\n    // (public) this^e % m (HAC 14.85)\n    function bnModPow(e,m) {\n      var i = e.bitLength(), k, r = nbv(1), z;\n      if(i <= 0) return r;\n      else if(i < 18) k = 1;\n      else if(i < 48) k = 3;\n      else if(i < 144) k = 4;\n      else if(i < 768) k = 5;\n      else k = 6;\n      if(i < 8)\n        z = new Classic(m);\n      else if(m.isEven())\n        z = new Barrett(m);\n      else\n        z = new Montgomery(m);\n\n      // precomputation\n      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n      g[1] = z.convert(this);\n      if(k > 1) {\n        var g2 = nbi();\n        z.sqrTo(g[1],g2);\n        while(n <= km) {\n          g[n] = nbi();\n          z.mulTo(g2,g[n-2],g[n]);\n          n += 2;\n        }\n      }\n\n      var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n      i = nbits(e[j])-1;\n      while(j >= 0) {\n        if(i >= k1) w = (e[j]>>(i-k1))&km;\n        else {\n          w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n        }\n\n        n = k;\n        while((w&1) == 0) { w >>= 1; --n; }\n        if((i -= n) < 0) { i += this.DB; --j; }\n        if(is1) {\t// ret == 1, don't bother squaring or multiplying it\n          g[w].copyTo(r);\n          is1 = false;\n        }\n        else {\n          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n          z.mulTo(r2,g[w],r);\n        }\n\n        while(j >= 0 && (e[j]&(1<<i)) == 0) {\n          z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n          if(--i < 0) { i = this.DB-1; --j; }\n        }\n      }\n      return z.revert(r);\n    }\n\n    // (public) gcd(this,a) (HAC 14.54)\n    function bnGCD(a) {\n      var x = (this.s<0)?this.negate():this.clone();\n      var y = (a.s<0)?a.negate():a.clone();\n      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n      var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n      if(g < 0) return x;\n      if(i < g) g = i;\n      if(g > 0) {\n        x.rShiftTo(g,x);\n        y.rShiftTo(g,y);\n      }\n      while(x.signum() > 0) {\n        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n        if(x.compareTo(y) >= 0) {\n          x.subTo(y,x);\n          x.rShiftTo(1,x);\n        }\n        else {\n          y.subTo(x,y);\n          y.rShiftTo(1,y);\n        }\n      }\n      if(g > 0) y.lShiftTo(g,y);\n      return y;\n    }\n\n    // (protected) this % n, n < 2^26\n    function bnpModInt(n) {\n      if(n <= 0) return 0;\n      var d = this.DV%n, r = (this.s<0)?n-1:0;\n      if(this.t > 0)\n        if(d == 0) r = this[0]%n;\n        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n      return r;\n    }\n\n    // (public) 1/this % m (HAC 14.61)\n    function bnModInverse(m) {\n      var ac = m.isEven();\n      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n      var u = m.clone(), v = this.clone();\n      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n      while(u.signum() != 0) {\n        while(u.isEven()) {\n          u.rShiftTo(1,u);\n          if(ac) {\n            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n            a.rShiftTo(1,a);\n          }\n          else if(!b.isEven()) b.subTo(m,b);\n          b.rShiftTo(1,b);\n        }\n        while(v.isEven()) {\n          v.rShiftTo(1,v);\n          if(ac) {\n            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n            c.rShiftTo(1,c);\n          }\n          else if(!d.isEven()) d.subTo(m,d);\n          d.rShiftTo(1,d);\n        }\n        if(u.compareTo(v) >= 0) {\n          u.subTo(v,u);\n          if(ac) a.subTo(c,a);\n          b.subTo(d,b);\n        }\n        else {\n          v.subTo(u,v);\n          if(ac) c.subTo(a,c);\n          d.subTo(b,d);\n        }\n      }\n      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n      if(d.compareTo(m) >= 0) return d.subtract(m);\n      if(d.signum() < 0) d.addTo(m,d); else return d;\n      if(d.signum() < 0) return d.add(m); else return d;\n    }\n\n    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\n    var lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n    // (public) test primality with certainty >= 1-.5^t\n    function bnIsProbablePrime(t) {\n      var i, x = this.abs();\n      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n        for(i = 0; i < lowprimes.length; ++i)\n          if(x[0] == lowprimes[i]) return true;\n        return false;\n      }\n      if(x.isEven()) return false;\n      i = 1;\n      while(i < lowprimes.length) {\n        var m = lowprimes[i], j = i+1;\n        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n        m = x.modInt(m);\n        while(i < j) if(m%lowprimes[i++] == 0) return false;\n      }\n      return x.millerRabin(t);\n    }\n\n    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n    function bnpMillerRabin(t) {\n      var n1 = this.subtract(BigInteger.ONE);\n      var k = n1.getLowestSetBit();\n      if(k <= 0) return false;\n      var r = n1.shiftRight(k);\n      t = (t+1)>>1;\n      if(t > lowprimes.length) t = lowprimes.length;\n      var a = nbi();\n      for(var i = 0; i < t; ++i) {\n        //Pick bases at random, instead of starting at 2\n        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n        var y = a.modPow(r,this);\n        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n          var j = 1;\n          while(j++ < k && y.compareTo(n1) != 0) {\n            y = y.modPowInt(2,this);\n            if(y.compareTo(BigInteger.ONE) == 0) return false;\n          }\n          if(y.compareTo(n1) != 0) return false;\n        }\n      }\n      return true;\n    }\n\n    // protected\n    BigInteger.prototype.chunkSize = bnpChunkSize;\n    BigInteger.prototype.toRadix = bnpToRadix;\n    BigInteger.prototype.fromRadix = bnpFromRadix;\n    BigInteger.prototype.fromNumber = bnpFromNumber;\n    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n    BigInteger.prototype.changeBit = bnpChangeBit;\n    BigInteger.prototype.addTo = bnpAddTo;\n    BigInteger.prototype.dMultiply = bnpDMultiply;\n    BigInteger.prototype.dAddOffset = bnpDAddOffset;\n    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n    BigInteger.prototype.modInt = bnpModInt;\n    BigInteger.prototype.millerRabin = bnpMillerRabin;\n\n    // public\n    BigInteger.prototype.clone = bnClone;\n    BigInteger.prototype.intValue = bnIntValue;\n    BigInteger.prototype.byteValue = bnByteValue;\n    BigInteger.prototype.shortValue = bnShortValue;\n    BigInteger.prototype.signum = bnSigNum;\n    BigInteger.prototype.toByteArray = bnToByteArray;\n    BigInteger.prototype.equals = bnEquals;\n    BigInteger.prototype.min = bnMin;\n    BigInteger.prototype.max = bnMax;\n    BigInteger.prototype.and = bnAnd;\n    BigInteger.prototype.or = bnOr;\n    BigInteger.prototype.xor = bnXor;\n    BigInteger.prototype.andNot = bnAndNot;\n    BigInteger.prototype.not = bnNot;\n    BigInteger.prototype.shiftLeft = bnShiftLeft;\n    BigInteger.prototype.shiftRight = bnShiftRight;\n    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n    BigInteger.prototype.bitCount = bnBitCount;\n    BigInteger.prototype.testBit = bnTestBit;\n    BigInteger.prototype.setBit = bnSetBit;\n    BigInteger.prototype.clearBit = bnClearBit;\n    BigInteger.prototype.flipBit = bnFlipBit;\n    BigInteger.prototype.add = bnAdd;\n    BigInteger.prototype.subtract = bnSubtract;\n    BigInteger.prototype.multiply = bnMultiply;\n    BigInteger.prototype.divide = bnDivide;\n    BigInteger.prototype.remainder = bnRemainder;\n    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n    BigInteger.prototype.modPow = bnModPow;\n    BigInteger.prototype.modInverse = bnModInverse;\n    BigInteger.prototype.pow = bnPow;\n    BigInteger.prototype.gcd = bnGCD;\n    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n    // JSBN-specific extension\n    BigInteger.prototype.square = bnSquare;\n\n    // Expose the Barrett function\n    BigInteger.prototype.Barrett = Barrett\n\n    // BigInteger interfaces not implemented in jsbn:\n\n    // BigInteger(int signum, byte[] magnitude)\n    // double doubleValue()\n    // float floatValue()\n    // int hashCode()\n    // long longValue()\n    // static BigInteger valueOf(long val)\n\n\t// Random number generator - requires a PRNG backend, e.g. prng4.js\n\n\t// For best results, put code like\n\t// <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>\n\t// in your main HTML document.\n\n\tvar rng_state;\n\tvar rng_pool;\n\tvar rng_pptr;\n\n\t// Mix in a 32-bit integer into the pool\n\tfunction rng_seed_int(x) {\n\t  rng_pool[rng_pptr++] ^= x & 255;\n\t  rng_pool[rng_pptr++] ^= (x >> 8) & 255;\n\t  rng_pool[rng_pptr++] ^= (x >> 16) & 255;\n\t  rng_pool[rng_pptr++] ^= (x >> 24) & 255;\n\t  if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;\n\t}\n\n\t// Mix in the current time (w/milliseconds) into the pool\n\tfunction rng_seed_time() {\n\t  rng_seed_int(new Date().getTime());\n\t}\n\n\t// Initialize the pool with junk if needed.\n\tif(rng_pool == null) {\n\t  rng_pool = new Array();\n\t  rng_pptr = 0;\n\t  var t;\n\t  if(typeof window !== \"undefined\" && window.crypto) {\n\t\tif (window.crypto.getRandomValues) {\n\t\t  // Use webcrypto if available\n\t\t  var ua = new Uint8Array(32);\n\t\t  window.crypto.getRandomValues(ua);\n\t\t  for(t = 0; t < 32; ++t)\n\t\t\trng_pool[rng_pptr++] = ua[t];\n\t\t}\n\t\telse if(navigator.appName == \"Netscape\" && navigator.appVersion < \"5\") {\n\t\t  // Extract entropy (256 bits) from NS4 RNG if available\n\t\t  var z = window.crypto.random(32);\n\t\t  for(t = 0; t < z.length; ++t)\n\t\t\trng_pool[rng_pptr++] = z.charCodeAt(t) & 255;\n\t\t}\n\t  }\n\t  while(rng_pptr < rng_psize) {  // extract some randomness from Math.random()\n\t\tt = Math.floor(65536 * Math.random());\n\t\trng_pool[rng_pptr++] = t >>> 8;\n\t\trng_pool[rng_pptr++] = t & 255;\n\t  }\n\t  rng_pptr = 0;\n\t  rng_seed_time();\n\t  //rng_seed_int(window.screenX);\n\t  //rng_seed_int(window.screenY);\n\t}\n\n\tfunction rng_get_byte() {\n\t  if(rng_state == null) {\n\t\trng_seed_time();\n\t\trng_state = prng_newstate();\n\t\trng_state.init(rng_pool);\n\t\tfor(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)\n\t\t  rng_pool[rng_pptr] = 0;\n\t\trng_pptr = 0;\n\t\t//rng_pool = null;\n\t  }\n\t  // TODO: allow reseeding after first request\n\t  return rng_state.next();\n\t}\n\n\tfunction rng_get_bytes(ba) {\n\t  var i;\n\t  for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();\n\t}\n\n\tfunction SecureRandom() {}\n\n\tSecureRandom.prototype.nextBytes = rng_get_bytes;\n\n\t// prng4.js - uses Arcfour as a PRNG\n\n\tfunction Arcfour() {\n\t  this.i = 0;\n\t  this.j = 0;\n\t  this.S = new Array();\n\t}\n\n\t// Initialize arcfour context from key, an array of ints, each from [0..255]\n\tfunction ARC4init(key) {\n\t  var i, j, t;\n\t  for(i = 0; i < 256; ++i)\n\t\tthis.S[i] = i;\n\t  j = 0;\n\t  for(i = 0; i < 256; ++i) {\n\t\tj = (j + this.S[i] + key[i % key.length]) & 255;\n\t\tt = this.S[i];\n\t\tthis.S[i] = this.S[j];\n\t\tthis.S[j] = t;\n\t  }\n\t  this.i = 0;\n\t  this.j = 0;\n\t}\n\n\tfunction ARC4next() {\n\t  var t;\n\t  this.i = (this.i + 1) & 255;\n\t  this.j = (this.j + this.S[this.i]) & 255;\n\t  t = this.S[this.i];\n\t  this.S[this.i] = this.S[this.j];\n\t  this.S[this.j] = t;\n\t  return this.S[(t + this.S[this.i]) & 255];\n\t}\n\n\tArcfour.prototype.init = ARC4init;\n\tArcfour.prototype.next = ARC4next;\n\n\t// Plug in your RNG constructor here\n\tfunction prng_newstate() {\n\t  return new Arcfour();\n\t}\n\n\t// Pool size must be a multiple of 4 and greater than 32.\n\t// An array of bytes the size of the pool will be passed to init()\n\tvar rng_psize = 256;\n\n  BigInteger.SecureRandom = SecureRandom;\n  BigInteger.BigInteger = BigInteger;\n  if (true) {\n    exports = module.exports = BigInteger;\n  } else {}\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zc2hway9ub2RlX21vZHVsZXMvanNibi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQSxpQkFBaUIsU0FBUzs7QUFFMUIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixlQUFlLGNBQWM7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsZUFBZSwrQkFBK0I7O0FBRXhFO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQywwQkFBMEIsT0FBTztBQUNqQywwQkFBMEIsT0FBTztBQUNqQywwQkFBMEIsT0FBTztBQUNqQywwQkFBMEIsT0FBTztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEMsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxvQkFBb0Isb0JBQW9CO0FBQ3hDLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiw2QkFBNkIsbUJBQW1CO0FBQ2hELDJCQUEyQixlQUFlOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixpQ0FBaUM7QUFDakMscUNBQXFDO0FBQ3JDLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsOEJBQThCLGVBQWU7O0FBRTdDLHlCQUF5QjtBQUN6QixnQ0FBZ0MsbUJBQW1COztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXLFFBQVE7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGVBQWUsZ0JBQWdCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEIsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCLHdCQUF3QixlQUFlLDRCQUE0Qjs7QUFFbkU7QUFDQSwwQkFBMEI7QUFDMUIsdUJBQXVCLGVBQWUsMkJBQTJCOztBQUVqRTtBQUNBLDJCQUEyQjtBQUMzQix3QkFBd0IsZUFBZSw0QkFBNEI7O0FBRW5FO0FBQ0EsOEJBQThCO0FBQzlCLDJCQUEyQixlQUFlLCtCQUErQjs7QUFFekU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QywwQkFBMEIsU0FBUztBQUNuQyx5QkFBeUIsU0FBUztBQUNsQyx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZUFBZSxpQkFBaUI7O0FBRXhEO0FBQ0EsNkJBQTZCLGVBQWUsaUJBQWlCOztBQUU3RDtBQUNBLDZCQUE2QixlQUFlLHNCQUFzQjs7QUFFbEU7QUFDQSwwQkFBMEIsZUFBZSxrQkFBa0I7O0FBRTNEO0FBQ0EsMkJBQTJCLGVBQWUseUJBQXlCOztBQUVuRTtBQUNBLDhCQUE4QixlQUFlLHlCQUF5Qjs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNkJBQTZCO0FBQzdCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWUsYUFBYSxnQkFBZ0I7QUFDekQ7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsaUNBQWlDLGVBQWU7O0FBRWhELHNCQUFzQjtBQUN0QixtQ0FBbUMsbUJBQW1COztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDLDJCQUEyQixjQUFjO0FBQ3pDLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlLGVBQWU7QUFDdkQsbUNBQW1DLE9BQU8sT0FBTyxRQUFRO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsT0FBTyxRQUFRO0FBQ3hDLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVcsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUNBQW1DLDhCQUE4QjtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLElBQThCO0FBQ3BDO0FBQ0EsSUFBSSxLQUFLLEVBR047O0FBRUgsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvc3NocGsvbm9kZV9tb2R1bGVzL2pzYm4vaW5kZXguanM/ZjlmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcblxuICAgIC8vIENvcHlyaWdodCAoYykgMjAwNSAgVG9tIFd1XG4gICAgLy8gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAvLyBTZWUgXCJMSUNFTlNFXCIgZm9yIGRldGFpbHMuXG5cbiAgICAvLyBCYXNpYyBKYXZhU2NyaXB0IEJOIGxpYnJhcnkgLSBzdWJzZXQgdXNlZnVsIGZvciBSU0EgZW5jcnlwdGlvbi5cblxuICAgIC8vIEJpdHMgcGVyIGRpZ2l0XG4gICAgdmFyIGRiaXRzO1xuXG4gICAgLy8gSmF2YVNjcmlwdCBlbmdpbmUgYW5hbHlzaXNcbiAgICB2YXIgY2FuYXJ5ID0gMHhkZWFkYmVlZmNhZmU7XG4gICAgdmFyIGpfbG0gPSAoKGNhbmFyeSYweGZmZmZmZik9PTB4ZWZjYWZlKTtcblxuICAgIC8vIChwdWJsaWMpIENvbnN0cnVjdG9yXG4gICAgZnVuY3Rpb24gQmlnSW50ZWdlcihhLGIsYykge1xuICAgICAgaWYoYSAhPSBudWxsKVxuICAgICAgICBpZihcIm51bWJlclwiID09IHR5cGVvZiBhKSB0aGlzLmZyb21OdW1iZXIoYSxiLGMpO1xuICAgICAgICBlbHNlIGlmKGIgPT0gbnVsbCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBhKSB0aGlzLmZyb21TdHJpbmcoYSwyNTYpO1xuICAgICAgICBlbHNlIHRoaXMuZnJvbVN0cmluZyhhLGIpO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBuZXcsIHVuc2V0IEJpZ0ludGVnZXJcbiAgICBmdW5jdGlvbiBuYmkoKSB7IHJldHVybiBuZXcgQmlnSW50ZWdlcihudWxsKTsgfVxuXG4gICAgLy8gYW06IENvbXB1dGUgd19qICs9ICh4KnRoaXNfaSksIHByb3BhZ2F0ZSBjYXJyaWVzLFxuICAgIC8vIGMgaXMgaW5pdGlhbCBjYXJyeSwgcmV0dXJucyBmaW5hbCBjYXJyeS5cbiAgICAvLyBjIDwgMypkdmFsdWUsIHggPCAyKmR2YWx1ZSwgdGhpc19pIDwgZHZhbHVlXG4gICAgLy8gV2UgbmVlZCB0byBzZWxlY3QgdGhlIGZhc3Rlc3Qgb25lIHRoYXQgd29ya3MgaW4gdGhpcyBlbnZpcm9ubWVudC5cblxuICAgIC8vIGFtMTogdXNlIGEgc2luZ2xlIG11bHQgYW5kIGRpdmlkZSB0byBnZXQgdGhlIGhpZ2ggYml0cyxcbiAgICAvLyBtYXggZGlnaXQgYml0cyBzaG91bGQgYmUgMjYgYmVjYXVzZVxuICAgIC8vIG1heCBpbnRlcm5hbCB2YWx1ZSA9IDIqZHZhbHVlXjItMipkdmFsdWUgKDwgMl41MylcbiAgICBmdW5jdGlvbiBhbTEoaSx4LHcsaixjLG4pIHtcbiAgICAgIHdoaWxlKC0tbiA+PSAwKSB7XG4gICAgICAgIHZhciB2ID0geCp0aGlzW2krK10rd1tqXStjO1xuICAgICAgICBjID0gTWF0aC5mbG9vcih2LzB4NDAwMDAwMCk7XG4gICAgICAgIHdbaisrXSA9IHYmMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIC8vIGFtMiBhdm9pZHMgYSBiaWcgbXVsdC1hbmQtZXh0cmFjdCBjb21wbGV0ZWx5LlxuICAgIC8vIE1heCBkaWdpdCBiaXRzIHNob3VsZCBiZSA8PSAzMCBiZWNhdXNlIHdlIGRvIGJpdHdpc2Ugb3BzXG4gICAgLy8gb24gdmFsdWVzIHVwIHRvIDIqaGR2YWx1ZV4yLWhkdmFsdWUtMSAoPCAyXjMxKVxuICAgIGZ1bmN0aW9uIGFtMihpLHgsdyxqLGMsbikge1xuICAgICAgdmFyIHhsID0geCYweDdmZmYsIHhoID0geD4+MTU7XG4gICAgICB3aGlsZSgtLW4gPj0gMCkge1xuICAgICAgICB2YXIgbCA9IHRoaXNbaV0mMHg3ZmZmO1xuICAgICAgICB2YXIgaCA9IHRoaXNbaSsrXT4+MTU7XG4gICAgICAgIHZhciBtID0geGgqbCtoKnhsO1xuICAgICAgICBsID0geGwqbCsoKG0mMHg3ZmZmKTw8MTUpK3dbal0rKGMmMHgzZmZmZmZmZik7XG4gICAgICAgIGMgPSAobD4+PjMwKSsobT4+PjE1KSt4aCpoKyhjPj4+MzApO1xuICAgICAgICB3W2orK10gPSBsJjB4M2ZmZmZmZmY7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgLy8gQWx0ZXJuYXRlbHksIHNldCBtYXggZGlnaXQgYml0cyB0byAyOCBzaW5jZSBzb21lXG4gICAgLy8gYnJvd3NlcnMgc2xvdyBkb3duIHdoZW4gZGVhbGluZyB3aXRoIDMyLWJpdCBudW1iZXJzLlxuICAgIGZ1bmN0aW9uIGFtMyhpLHgsdyxqLGMsbikge1xuICAgICAgdmFyIHhsID0geCYweDNmZmYsIHhoID0geD4+MTQ7XG4gICAgICB3aGlsZSgtLW4gPj0gMCkge1xuICAgICAgICB2YXIgbCA9IHRoaXNbaV0mMHgzZmZmO1xuICAgICAgICB2YXIgaCA9IHRoaXNbaSsrXT4+MTQ7XG4gICAgICAgIHZhciBtID0geGgqbCtoKnhsO1xuICAgICAgICBsID0geGwqbCsoKG0mMHgzZmZmKTw8MTQpK3dbal0rYztcbiAgICAgICAgYyA9IChsPj4yOCkrKG0+PjE0KSt4aCpoO1xuICAgICAgICB3W2orK10gPSBsJjB4ZmZmZmZmZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICB2YXIgaW5Ccm93c2VyID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICBpZihpbkJyb3dzZXIgJiYgal9sbSAmJiAobmF2aWdhdG9yLmFwcE5hbWUgPT0gXCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcIikpIHtcbiAgICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0yO1xuICAgICAgZGJpdHMgPSAzMDtcbiAgICB9XG4gICAgZWxzZSBpZihpbkJyb3dzZXIgJiYgal9sbSAmJiAobmF2aWdhdG9yLmFwcE5hbWUgIT0gXCJOZXRzY2FwZVwiKSkge1xuICAgICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTE7XG4gICAgICBkYml0cyA9IDI2O1xuICAgIH1cbiAgICBlbHNlIHsgLy8gTW96aWxsYS9OZXRzY2FwZSBzZWVtcyB0byBwcmVmZXIgYW0zXG4gICAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGFtMztcbiAgICAgIGRiaXRzID0gMjg7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuREIgPSBkYml0cztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ETSA9ICgoMTw8ZGJpdHMpLTEpO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLkRWID0gKDE8PGRiaXRzKTtcblxuICAgIHZhciBCSV9GUCA9IDUyO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLkZWID0gTWF0aC5wb3coMixCSV9GUCk7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuRjEgPSBCSV9GUC1kYml0cztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5GMiA9IDIqZGJpdHMtQklfRlA7XG5cbiAgICAvLyBEaWdpdCBjb252ZXJzaW9uc1xuICAgIHZhciBCSV9STSA9IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7XG4gICAgdmFyIEJJX1JDID0gbmV3IEFycmF5KCk7XG4gICAgdmFyIHJyLHZ2O1xuICAgIHJyID0gXCIwXCIuY2hhckNvZGVBdCgwKTtcbiAgICBmb3IodnYgPSAwOyB2diA8PSA5OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2O1xuICAgIHJyID0gXCJhXCIuY2hhckNvZGVBdCgwKTtcbiAgICBmb3IodnYgPSAxMDsgdnYgPCAzNjsgKyt2dikgQklfUkNbcnIrK10gPSB2djtcbiAgICByciA9IFwiQVwiLmNoYXJDb2RlQXQoMCk7XG4gICAgZm9yKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIEJJX1JDW3JyKytdID0gdnY7XG5cbiAgICBmdW5jdGlvbiBpbnQyY2hhcihuKSB7IHJldHVybiBCSV9STS5jaGFyQXQobik7IH1cbiAgICBmdW5jdGlvbiBpbnRBdChzLGkpIHtcbiAgICAgIHZhciBjID0gQklfUkNbcy5jaGFyQ29kZUF0KGkpXTtcbiAgICAgIHJldHVybiAoYz09bnVsbCk/LTE6YztcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSBjb3B5IHRoaXMgdG8gclxuICAgIGZ1bmN0aW9uIGJucENvcHlUbyhyKSB7XG4gICAgICBmb3IodmFyIGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHJbaV0gPSB0aGlzW2ldO1xuICAgICAgci50ID0gdGhpcy50O1xuICAgICAgci5zID0gdGhpcy5zO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIGludGVnZXIgdmFsdWUgeCwgLURWIDw9IHggPCBEVlxuICAgIGZ1bmN0aW9uIGJucEZyb21JbnQoeCkge1xuICAgICAgdGhpcy50ID0gMTtcbiAgICAgIHRoaXMucyA9ICh4PDApPy0xOjA7XG4gICAgICBpZih4ID4gMCkgdGhpc1swXSA9IHg7XG4gICAgICBlbHNlIGlmKHggPCAtMSkgdGhpc1swXSA9IHgrdGhpcy5EVjtcbiAgICAgIGVsc2UgdGhpcy50ID0gMDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gYmlnaW50IGluaXRpYWxpemVkIHRvIHZhbHVlXG4gICAgZnVuY3Rpb24gbmJ2KGkpIHsgdmFyIHIgPSBuYmkoKTsgci5mcm9tSW50KGkpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgc2V0IGZyb20gc3RyaW5nIGFuZCByYWRpeFxuICAgIGZ1bmN0aW9uIGJucEZyb21TdHJpbmcocyxiKSB7XG4gICAgICB2YXIgaztcbiAgICAgIGlmKGIgPT0gMTYpIGsgPSA0O1xuICAgICAgZWxzZSBpZihiID09IDgpIGsgPSAzO1xuICAgICAgZWxzZSBpZihiID09IDI1NikgayA9IDg7IC8vIGJ5dGUgYXJyYXlcbiAgICAgIGVsc2UgaWYoYiA9PSAyKSBrID0gMTtcbiAgICAgIGVsc2UgaWYoYiA9PSAzMikgayA9IDU7XG4gICAgICBlbHNlIGlmKGIgPT0gNCkgayA9IDI7XG4gICAgICBlbHNlIHsgdGhpcy5mcm9tUmFkaXgocyxiKTsgcmV0dXJuOyB9XG4gICAgICB0aGlzLnQgPSAwO1xuICAgICAgdGhpcy5zID0gMDtcbiAgICAgIHZhciBpID0gcy5sZW5ndGgsIG1pID0gZmFsc2UsIHNoID0gMDtcbiAgICAgIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgICAgIHZhciB4ID0gKGs9PTgpP3NbaV0mMHhmZjppbnRBdChzLGkpO1xuICAgICAgICBpZih4IDwgMCkge1xuICAgICAgICAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiKSBtaSA9IHRydWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbWkgPSBmYWxzZTtcbiAgICAgICAgaWYoc2ggPT0gMClcbiAgICAgICAgICB0aGlzW3RoaXMudCsrXSA9IHg7XG4gICAgICAgIGVsc2UgaWYoc2grayA+IHRoaXMuREIpIHtcbiAgICAgICAgICB0aGlzW3RoaXMudC0xXSB8PSAoeCYoKDE8PCh0aGlzLkRCLXNoKSktMSkpPDxzaDtcbiAgICAgICAgICB0aGlzW3RoaXMudCsrXSA9ICh4Pj4odGhpcy5EQi1zaCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzW3RoaXMudC0xXSB8PSB4PDxzaDtcbiAgICAgICAgc2ggKz0gaztcbiAgICAgICAgaWYoc2ggPj0gdGhpcy5EQikgc2ggLT0gdGhpcy5EQjtcbiAgICAgIH1cbiAgICAgIGlmKGsgPT0gOCAmJiAoc1swXSYweDgwKSAhPSAwKSB7XG4gICAgICAgIHRoaXMucyA9IC0xO1xuICAgICAgICBpZihzaCA+IDApIHRoaXNbdGhpcy50LTFdIHw9ICgoMTw8KHRoaXMuREItc2gpKS0xKTw8c2g7XG4gICAgICB9XG4gICAgICB0aGlzLmNsYW1wKCk7XG4gICAgICBpZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgY2xhbXAgb2ZmIGV4Y2VzcyBoaWdoIHdvcmRzXG4gICAgZnVuY3Rpb24gYm5wQ2xhbXAoKSB7XG4gICAgICB2YXIgYyA9IHRoaXMucyZ0aGlzLkRNO1xuICAgICAgd2hpbGUodGhpcy50ID4gMCAmJiB0aGlzW3RoaXMudC0xXSA9PSBjKSAtLXRoaXMudDtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIGluIGdpdmVuIHJhZGl4XG4gICAgZnVuY3Rpb24gYm5Ub1N0cmluZyhiKSB7XG4gICAgICBpZih0aGlzLnMgPCAwKSByZXR1cm4gXCItXCIrdGhpcy5uZWdhdGUoKS50b1N0cmluZyhiKTtcbiAgICAgIHZhciBrO1xuICAgICAgaWYoYiA9PSAxNikgayA9IDQ7XG4gICAgICBlbHNlIGlmKGIgPT0gOCkgayA9IDM7XG4gICAgICBlbHNlIGlmKGIgPT0gMikgayA9IDE7XG4gICAgICBlbHNlIGlmKGIgPT0gMzIpIGsgPSA1O1xuICAgICAgZWxzZSBpZihiID09IDQpIGsgPSAyO1xuICAgICAgZWxzZSByZXR1cm4gdGhpcy50b1JhZGl4KGIpO1xuICAgICAgdmFyIGttID0gKDE8PGspLTEsIGQsIG0gPSBmYWxzZSwgciA9IFwiXCIsIGkgPSB0aGlzLnQ7XG4gICAgICB2YXIgcCA9IHRoaXMuREItKGkqdGhpcy5EQiklaztcbiAgICAgIGlmKGktLSA+IDApIHtcbiAgICAgICAgaWYocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzW2ldPj5wKSA+IDApIHsgbSA9IHRydWU7IHIgPSBpbnQyY2hhcihkKTsgfVxuICAgICAgICB3aGlsZShpID49IDApIHtcbiAgICAgICAgICBpZihwIDwgaykge1xuICAgICAgICAgICAgZCA9ICh0aGlzW2ldJigoMTw8cCktMSkpPDwoay1wKTtcbiAgICAgICAgICAgIGQgfD0gdGhpc1stLWldPj4ocCs9dGhpcy5EQi1rKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkID0gKHRoaXNbaV0+PihwLT1rKSkma207XG4gICAgICAgICAgICBpZihwIDw9IDApIHsgcCArPSB0aGlzLkRCOyAtLWk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoZCA+IDApIG0gPSB0cnVlO1xuICAgICAgICAgIGlmKG0pIHIgKz0gaW50MmNoYXIoZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtP3I6XCIwXCI7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgLXRoaXNcbiAgICBmdW5jdGlvbiBibk5lZ2F0ZSgpIHsgdmFyIHIgPSBuYmkoKTsgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMscik7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSB8dGhpc3xcbiAgICBmdW5jdGlvbiBibkFicygpIHsgcmV0dXJuICh0aGlzLnM8MCk/dGhpcy5uZWdhdGUoKTp0aGlzOyB9XG5cbiAgICAvLyAocHVibGljKSByZXR1cm4gKyBpZiB0aGlzID4gYSwgLSBpZiB0aGlzIDwgYSwgMCBpZiBlcXVhbFxuICAgIGZ1bmN0aW9uIGJuQ29tcGFyZVRvKGEpIHtcbiAgICAgIHZhciByID0gdGhpcy5zLWEucztcbiAgICAgIGlmKHIgIT0gMCkgcmV0dXJuIHI7XG4gICAgICB2YXIgaSA9IHRoaXMudDtcbiAgICAgIHIgPSBpLWEudDtcbiAgICAgIGlmKHIgIT0gMCkgcmV0dXJuICh0aGlzLnM8MCk/LXI6cjtcbiAgICAgIHdoaWxlKC0taSA+PSAwKSBpZigocj10aGlzW2ldLWFbaV0pICE9IDApIHJldHVybiByO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBiaXQgbGVuZ3RoIG9mIHRoZSBpbnRlZ2VyIHhcbiAgICBmdW5jdGlvbiBuYml0cyh4KSB7XG4gICAgICB2YXIgciA9IDEsIHQ7XG4gICAgICBpZigodD14Pj4+MTYpICE9IDApIHsgeCA9IHQ7IHIgKz0gMTY7IH1cbiAgICAgIGlmKCh0PXg+PjgpICE9IDApIHsgeCA9IHQ7IHIgKz0gODsgfVxuICAgICAgaWYoKHQ9eD4+NCkgIT0gMCkgeyB4ID0gdDsgciArPSA0OyB9XG4gICAgICBpZigodD14Pj4yKSAhPSAwKSB7IHggPSB0OyByICs9IDI7IH1cbiAgICAgIGlmKCh0PXg+PjEpICE9IDApIHsgeCA9IHQ7IHIgKz0gMTsgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHRoZSBudW1iZXIgb2YgYml0cyBpbiBcInRoaXNcIlxuICAgIGZ1bmN0aW9uIGJuQml0TGVuZ3RoKCkge1xuICAgICAgaWYodGhpcy50IDw9IDApIHJldHVybiAwO1xuICAgICAgcmV0dXJuIHRoaXMuREIqKHRoaXMudC0xKStuYml0cyh0aGlzW3RoaXMudC0xXV4odGhpcy5zJnRoaXMuRE0pKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyA8PCBuKkRCXG4gICAgZnVuY3Rpb24gYm5wRExTaGlmdFRvKG4scikge1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IoaSA9IHRoaXMudC0xOyBpID49IDA7IC0taSkgcltpK25dID0gdGhpc1tpXTtcbiAgICAgIGZvcihpID0gbi0xOyBpID49IDA7IC0taSkgcltpXSA9IDA7XG4gICAgICByLnQgPSB0aGlzLnQrbjtcbiAgICAgIHIucyA9IHRoaXMucztcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyA+PiBuKkRCXG4gICAgZnVuY3Rpb24gYm5wRFJTaGlmdFRvKG4scikge1xuICAgICAgZm9yKHZhciBpID0gbjsgaSA8IHRoaXMudDsgKytpKSByW2ktbl0gPSB0aGlzW2ldO1xuICAgICAgci50ID0gTWF0aC5tYXgodGhpcy50LW4sMCk7XG4gICAgICByLnMgPSB0aGlzLnM7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgblxuICAgIGZ1bmN0aW9uIGJucExTaGlmdFRvKG4scikge1xuICAgICAgdmFyIGJzID0gbiV0aGlzLkRCO1xuICAgICAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gICAgICB2YXIgYm0gPSAoMTw8Y2JzKS0xO1xuICAgICAgdmFyIGRzID0gTWF0aC5mbG9vcihuL3RoaXMuREIpLCBjID0gKHRoaXMuczw8YnMpJnRoaXMuRE0sIGk7XG4gICAgICBmb3IoaSA9IHRoaXMudC0xOyBpID49IDA7IC0taSkge1xuICAgICAgICByW2krZHMrMV0gPSAodGhpc1tpXT4+Y2JzKXxjO1xuICAgICAgICBjID0gKHRoaXNbaV0mYm0pPDxicztcbiAgICAgIH1cbiAgICAgIGZvcihpID0gZHMtMTsgaSA+PSAwOyAtLWkpIHJbaV0gPSAwO1xuICAgICAgcltkc10gPSBjO1xuICAgICAgci50ID0gdGhpcy50K2RzKzE7XG4gICAgICByLnMgPSB0aGlzLnM7XG4gICAgICByLmNsYW1wKCk7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gblxuICAgIGZ1bmN0aW9uIGJucFJTaGlmdFRvKG4scikge1xuICAgICAgci5zID0gdGhpcy5zO1xuICAgICAgdmFyIGRzID0gTWF0aC5mbG9vcihuL3RoaXMuREIpO1xuICAgICAgaWYoZHMgPj0gdGhpcy50KSB7IHIudCA9IDA7IHJldHVybjsgfVxuICAgICAgdmFyIGJzID0gbiV0aGlzLkRCO1xuICAgICAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gICAgICB2YXIgYm0gPSAoMTw8YnMpLTE7XG4gICAgICByWzBdID0gdGhpc1tkc10+PmJzO1xuICAgICAgZm9yKHZhciBpID0gZHMrMTsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgICAgIHJbaS1kcy0xXSB8PSAodGhpc1tpXSZibSk8PGNicztcbiAgICAgICAgcltpLWRzXSA9IHRoaXNbaV0+PmJzO1xuICAgICAgfVxuICAgICAgaWYoYnMgPiAwKSByW3RoaXMudC1kcy0xXSB8PSAodGhpcy5zJmJtKTw8Y2JzO1xuICAgICAgci50ID0gdGhpcy50LWRzO1xuICAgICAgci5jbGFtcCgpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIC0gYVxuICAgIGZ1bmN0aW9uIGJucFN1YlRvKGEscikge1xuICAgICAgdmFyIGkgPSAwLCBjID0gMCwgbSA9IE1hdGgubWluKGEudCx0aGlzLnQpO1xuICAgICAgd2hpbGUoaSA8IG0pIHtcbiAgICAgICAgYyArPSB0aGlzW2ldLWFbaV07XG4gICAgICAgIHJbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICAgIH1cbiAgICAgIGlmKGEudCA8IHRoaXMudCkge1xuICAgICAgICBjIC09IGEucztcbiAgICAgICAgd2hpbGUoaSA8IHRoaXMudCkge1xuICAgICAgICAgIGMgKz0gdGhpc1tpXTtcbiAgICAgICAgICByW2krK10gPSBjJnRoaXMuRE07XG4gICAgICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICAgICAgfVxuICAgICAgICBjICs9IHRoaXMucztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjICs9IHRoaXMucztcbiAgICAgICAgd2hpbGUoaSA8IGEudCkge1xuICAgICAgICAgIGMgLT0gYVtpXTtcbiAgICAgICAgICByW2krK10gPSBjJnRoaXMuRE07XG4gICAgICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICAgICAgfVxuICAgICAgICBjIC09IGEucztcbiAgICAgIH1cbiAgICAgIHIucyA9IChjPDApPy0xOjA7XG4gICAgICBpZihjIDwgLTEpIHJbaSsrXSA9IHRoaXMuRFYrYztcbiAgICAgIGVsc2UgaWYoYyA+IDApIHJbaSsrXSA9IGM7XG4gICAgICByLnQgPSBpO1xuICAgICAgci5jbGFtcCgpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzICogYSwgciAhPSB0aGlzLGEgKEhBQyAxNC4xMilcbiAgICAvLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG4gICAgZnVuY3Rpb24gYm5wTXVsdGlwbHlUbyhhLHIpIHtcbiAgICAgIHZhciB4ID0gdGhpcy5hYnMoKSwgeSA9IGEuYWJzKCk7XG4gICAgICB2YXIgaSA9IHgudDtcbiAgICAgIHIudCA9IGkreS50O1xuICAgICAgd2hpbGUoLS1pID49IDApIHJbaV0gPSAwO1xuICAgICAgZm9yKGkgPSAwOyBpIDwgeS50OyArK2kpIHJbaSt4LnRdID0geC5hbSgwLHlbaV0scixpLDAseC50KTtcbiAgICAgIHIucyA9IDA7XG4gICAgICByLmNsYW1wKCk7XG4gICAgICBpZih0aGlzLnMgIT0gYS5zKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpc14yLCByICE9IHRoaXMgKEhBQyAxNC4xNilcbiAgICBmdW5jdGlvbiBibnBTcXVhcmVUbyhyKSB7XG4gICAgICB2YXIgeCA9IHRoaXMuYWJzKCk7XG4gICAgICB2YXIgaSA9IHIudCA9IDIqeC50O1xuICAgICAgd2hpbGUoLS1pID49IDApIHJbaV0gPSAwO1xuICAgICAgZm9yKGkgPSAwOyBpIDwgeC50LTE7ICsraSkge1xuICAgICAgICB2YXIgYyA9IHguYW0oaSx4W2ldLHIsMippLDAsMSk7XG4gICAgICAgIGlmKChyW2kreC50XSs9eC5hbShpKzEsMip4W2ldLHIsMippKzEsYyx4LnQtaS0xKSkgPj0geC5EVikge1xuICAgICAgICAgIHJbaSt4LnRdIC09IHguRFY7XG4gICAgICAgICAgcltpK3gudCsxXSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKHIudCA+IDApIHJbci50LTFdICs9IHguYW0oaSx4W2ldLHIsMippLDAsMSk7XG4gICAgICByLnMgPSAwO1xuICAgICAgci5jbGFtcCgpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIGRpdmlkZSB0aGlzIGJ5IG0sIHF1b3RpZW50IGFuZCByZW1haW5kZXIgdG8gcSwgciAoSEFDIDE0LjIwKVxuICAgIC8vIHIgIT0gcSwgdGhpcyAhPSBtLiAgcSBvciByIG1heSBiZSBudWxsLlxuICAgIGZ1bmN0aW9uIGJucERpdlJlbVRvKG0scSxyKSB7XG4gICAgICB2YXIgcG0gPSBtLmFicygpO1xuICAgICAgaWYocG0udCA8PSAwKSByZXR1cm47XG4gICAgICB2YXIgcHQgPSB0aGlzLmFicygpO1xuICAgICAgaWYocHQudCA8IHBtLnQpIHtcbiAgICAgICAgaWYocSAhPSBudWxsKSBxLmZyb21JbnQoMCk7XG4gICAgICAgIGlmKHIgIT0gbnVsbCkgdGhpcy5jb3B5VG8ocik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmKHIgPT0gbnVsbCkgciA9IG5iaSgpO1xuICAgICAgdmFyIHkgPSBuYmkoKSwgdHMgPSB0aGlzLnMsIG1zID0gbS5zO1xuICAgICAgdmFyIG5zaCA9IHRoaXMuREItbmJpdHMocG1bcG0udC0xXSk7ICAgLy8gbm9ybWFsaXplIG1vZHVsdXNcbiAgICAgIGlmKG5zaCA+IDApIHsgcG0ubFNoaWZ0VG8obnNoLHkpOyBwdC5sU2hpZnRUbyhuc2gscik7IH1cbiAgICAgIGVsc2UgeyBwbS5jb3B5VG8oeSk7IHB0LmNvcHlUbyhyKTsgfVxuICAgICAgdmFyIHlzID0geS50O1xuICAgICAgdmFyIHkwID0geVt5cy0xXTtcbiAgICAgIGlmKHkwID09IDApIHJldHVybjtcbiAgICAgIHZhciB5dCA9IHkwKigxPDx0aGlzLkYxKSsoKHlzPjEpP3lbeXMtMl0+PnRoaXMuRjI6MCk7XG4gICAgICB2YXIgZDEgPSB0aGlzLkZWL3l0LCBkMiA9ICgxPDx0aGlzLkYxKS95dCwgZSA9IDE8PHRoaXMuRjI7XG4gICAgICB2YXIgaSA9IHIudCwgaiA9IGkteXMsIHQgPSAocT09bnVsbCk/bmJpKCk6cTtcbiAgICAgIHkuZGxTaGlmdFRvKGosdCk7XG4gICAgICBpZihyLmNvbXBhcmVUbyh0KSA+PSAwKSB7XG4gICAgICAgIHJbci50KytdID0gMTtcbiAgICAgICAgci5zdWJUbyh0LHIpO1xuICAgICAgfVxuICAgICAgQmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKHlzLHQpO1xuICAgICAgdC5zdWJUbyh5LHkpOyAgLy8gXCJuZWdhdGl2ZVwiIHkgc28gd2UgY2FuIHJlcGxhY2Ugc3ViIHdpdGggYW0gbGF0ZXJcbiAgICAgIHdoaWxlKHkudCA8IHlzKSB5W3kudCsrXSA9IDA7XG4gICAgICB3aGlsZSgtLWogPj0gMCkge1xuICAgICAgICAvLyBFc3RpbWF0ZSBxdW90aWVudCBkaWdpdFxuICAgICAgICB2YXIgcWQgPSAoclstLWldPT15MCk/dGhpcy5ETTpNYXRoLmZsb29yKHJbaV0qZDErKHJbaS0xXStlKSpkMik7XG4gICAgICAgIGlmKChyW2ldKz15LmFtKDAscWQscixqLDAseXMpKSA8IHFkKSB7ICAgLy8gVHJ5IGl0IG91dFxuICAgICAgICAgIHkuZGxTaGlmdFRvKGosdCk7XG4gICAgICAgICAgci5zdWJUbyh0LHIpO1xuICAgICAgICAgIHdoaWxlKHJbaV0gPCAtLXFkKSByLnN1YlRvKHQscik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKHEgIT0gbnVsbCkge1xuICAgICAgICByLmRyU2hpZnRUbyh5cyxxKTtcbiAgICAgICAgaWYodHMgIT0gbXMpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhxLHEpO1xuICAgICAgfVxuICAgICAgci50ID0geXM7XG4gICAgICByLmNsYW1wKCk7XG4gICAgICBpZihuc2ggPiAwKSByLnJTaGlmdFRvKG5zaCxyKTsgLy8gRGVub3JtYWxpemUgcmVtYWluZGVyXG4gICAgICBpZih0cyA8IDApIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLHIpO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgbW9kIGFcbiAgICBmdW5jdGlvbiBibk1vZChhKSB7XG4gICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgdGhpcy5hYnMoKS5kaXZSZW1UbyhhLG51bGwscik7XG4gICAgICBpZih0aGlzLnMgPCAwICYmIHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuWkVSTykgPiAwKSBhLnN1YlRvKHIscik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyBNb2R1bGFyIHJlZHVjdGlvbiB1c2luZyBcImNsYXNzaWNcIiBhbGdvcml0aG1cbiAgICBmdW5jdGlvbiBDbGFzc2ljKG0pIHsgdGhpcy5tID0gbTsgfVxuICAgIGZ1bmN0aW9uIGNDb252ZXJ0KHgpIHtcbiAgICAgIGlmKHgucyA8IDAgfHwgeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSByZXR1cm4geC5tb2QodGhpcy5tKTtcbiAgICAgIGVsc2UgcmV0dXJuIHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNSZXZlcnQoeCkgeyByZXR1cm4geDsgfVxuICAgIGZ1bmN0aW9uIGNSZWR1Y2UoeCkgeyB4LmRpdlJlbVRvKHRoaXMubSxudWxsLHgpOyB9XG4gICAgZnVuY3Rpb24gY011bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuICAgIGZ1bmN0aW9uIGNTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuICAgIENsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBjQ29udmVydDtcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5yZXZlcnQgPSBjUmV2ZXJ0O1xuICAgIENsYXNzaWMucHJvdG90eXBlLnJlZHVjZSA9IGNSZWR1Y2U7XG4gICAgQ2xhc3NpYy5wcm90b3R5cGUubXVsVG8gPSBjTXVsVG87XG4gICAgQ2xhc3NpYy5wcm90b3R5cGUuc3FyVG8gPSBjU3FyVG87XG5cbiAgICAvLyAocHJvdGVjdGVkKSByZXR1cm4gXCItMS90aGlzICUgMl5EQlwiOyB1c2VmdWwgZm9yIE1vbnQuIHJlZHVjdGlvblxuICAgIC8vIGp1c3RpZmljYXRpb246XG4gICAgLy8gICAgICAgICB4eSA9PSAxIChtb2QgbSlcbiAgICAvLyAgICAgICAgIHh5ID0gIDEra21cbiAgICAvLyAgIHh5KDIteHkpID0gKDEra20pKDEta20pXG4gICAgLy8geFt5KDIteHkpXSA9IDEta14ybV4yXG4gICAgLy8geFt5KDIteHkpXSA9PSAxIChtb2QgbV4yKVxuICAgIC8vIGlmIHkgaXMgMS94IG1vZCBtLCB0aGVuIHkoMi14eSkgaXMgMS94IG1vZCBtXjJcbiAgICAvLyBzaG91bGQgcmVkdWNlIHggYW5kIHkoMi14eSkgYnkgbV4yIGF0IGVhY2ggc3RlcCB0byBrZWVwIHNpemUgYm91bmRlZC5cbiAgICAvLyBKUyBtdWx0aXBseSBcIm92ZXJmbG93c1wiIGRpZmZlcmVudGx5IGZyb20gQy9DKyssIHNvIGNhcmUgaXMgbmVlZGVkIGhlcmUuXG4gICAgZnVuY3Rpb24gYm5wSW52RGlnaXQoKSB7XG4gICAgICBpZih0aGlzLnQgPCAxKSByZXR1cm4gMDtcbiAgICAgIHZhciB4ID0gdGhpc1swXTtcbiAgICAgIGlmKCh4JjEpID09IDApIHJldHVybiAwO1xuICAgICAgdmFyIHkgPSB4JjM7ICAgICAgIC8vIHkgPT0gMS94IG1vZCAyXjJcbiAgICAgIHkgPSAoeSooMi0oeCYweGYpKnkpKSYweGY7IC8vIHkgPT0gMS94IG1vZCAyXjRcbiAgICAgIHkgPSAoeSooMi0oeCYweGZmKSp5KSkmMHhmZjsgICAvLyB5ID09IDEveCBtb2QgMl44XG4gICAgICB5ID0gKHkqKDItKCgoeCYweGZmZmYpKnkpJjB4ZmZmZikpKSYweGZmZmY7ICAgIC8vIHkgPT0gMS94IG1vZCAyXjE2XG4gICAgICAvLyBsYXN0IHN0ZXAgLSBjYWxjdWxhdGUgaW52ZXJzZSBtb2QgRFYgZGlyZWN0bHk7XG4gICAgICAvLyBhc3N1bWVzIDE2IDwgREIgPD0gMzIgYW5kIGFzc3VtZXMgYWJpbGl0eSB0byBoYW5kbGUgNDgtYml0IGludHNcbiAgICAgIHkgPSAoeSooMi14KnkldGhpcy5EVikpJXRoaXMuRFY7ICAgICAgIC8vIHkgPT0gMS94IG1vZCAyXmRiaXRzXG4gICAgICAvLyB3ZSByZWFsbHkgd2FudCB0aGUgbmVnYXRpdmUgaW52ZXJzZSwgYW5kIC1EViA8IHkgPCBEVlxuICAgICAgcmV0dXJuICh5PjApP3RoaXMuRFYteToteTtcbiAgICB9XG5cbiAgICAvLyBNb250Z29tZXJ5IHJlZHVjdGlvblxuICAgIGZ1bmN0aW9uIE1vbnRnb21lcnkobSkge1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMubXAgPSBtLmludkRpZ2l0KCk7XG4gICAgICB0aGlzLm1wbCA9IHRoaXMubXAmMHg3ZmZmO1xuICAgICAgdGhpcy5tcGggPSB0aGlzLm1wPj4xNTtcbiAgICAgIHRoaXMudW0gPSAoMTw8KG0uREItMTUpKS0xO1xuICAgICAgdGhpcy5tdDIgPSAyKm0udDtcbiAgICB9XG5cbiAgICAvLyB4UiBtb2QgbVxuICAgIGZ1bmN0aW9uIG1vbnRDb252ZXJ0KHgpIHtcbiAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICB4LmFicygpLmRsU2hpZnRUbyh0aGlzLm0udCxyKTtcbiAgICAgIHIuZGl2UmVtVG8odGhpcy5tLG51bGwscik7XG4gICAgICBpZih4LnMgPCAwICYmIHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuWkVSTykgPiAwKSB0aGlzLm0uc3ViVG8ocixyKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIHgvUiBtb2QgbVxuICAgIGZ1bmN0aW9uIG1vbnRSZXZlcnQoeCkge1xuICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgIHguY29weVRvKHIpO1xuICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyB4ID0geC9SIG1vZCBtIChIQUMgMTQuMzIpXG4gICAgZnVuY3Rpb24gbW9udFJlZHVjZSh4KSB7XG4gICAgICB3aGlsZSh4LnQgPD0gdGhpcy5tdDIpIC8vIHBhZCB4IHNvIGFtIGhhcyBlbm91Z2ggcm9vbSBsYXRlclxuICAgICAgICB4W3gudCsrXSA9IDA7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5tLnQ7ICsraSkge1xuICAgICAgICAvLyBmYXN0ZXIgd2F5IG9mIGNhbGN1bGF0aW5nIHUwID0geFtpXSptcCBtb2QgRFZcbiAgICAgICAgdmFyIGogPSB4W2ldJjB4N2ZmZjtcbiAgICAgICAgdmFyIHUwID0gKGoqdGhpcy5tcGwrKCgoaip0aGlzLm1waCsoeFtpXT4+MTUpKnRoaXMubXBsKSZ0aGlzLnVtKTw8MTUpKSZ4LkRNO1xuICAgICAgICAvLyB1c2UgYW0gdG8gY29tYmluZSB0aGUgbXVsdGlwbHktc2hpZnQtYWRkIGludG8gb25lIGNhbGxcbiAgICAgICAgaiA9IGkrdGhpcy5tLnQ7XG4gICAgICAgIHhbal0gKz0gdGhpcy5tLmFtKDAsdTAseCxpLDAsdGhpcy5tLnQpO1xuICAgICAgICAvLyBwcm9wYWdhdGUgY2FycnlcbiAgICAgICAgd2hpbGUoeFtqXSA+PSB4LkRWKSB7IHhbal0gLT0geC5EVjsgeFsrK2pdKys7IH1cbiAgICAgIH1cbiAgICAgIHguY2xhbXAoKTtcbiAgICAgIHguZHJTaGlmdFRvKHRoaXMubS50LHgpO1xuICAgICAgaWYoeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB4LnN1YlRvKHRoaXMubSx4KTtcbiAgICB9XG5cbiAgICAvLyByID0gXCJ4XjIvUiBtb2QgbVwiOyB4ICE9IHJcbiAgICBmdW5jdGlvbiBtb250U3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbiAgICAvLyByID0gXCJ4eS9SIG1vZCBtXCI7IHgseSAhPSByXG4gICAgZnVuY3Rpb24gbW9udE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUuY29udmVydCA9IG1vbnRDb252ZXJ0O1xuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLnJldmVydCA9IG1vbnRSZXZlcnQ7XG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gbW9udFJlZHVjZTtcbiAgICBNb250Z29tZXJ5LnByb3RvdHlwZS5tdWxUbyA9IG1vbnRNdWxUbztcbiAgICBNb250Z29tZXJ5LnByb3RvdHlwZS5zcXJUbyA9IG1vbnRTcXJUbztcblxuICAgIC8vIChwcm90ZWN0ZWQpIHRydWUgaWZmIHRoaXMgaXMgZXZlblxuICAgIGZ1bmN0aW9uIGJucElzRXZlbigpIHsgcmV0dXJuICgodGhpcy50PjApPyh0aGlzWzBdJjEpOnRoaXMucykgPT0gMDsgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgdGhpc15lLCBlIDwgMl4zMiwgZG9pbmcgc3FyIGFuZCBtdWwgd2l0aCBcInJcIiAoSEFDIDE0Ljc5KVxuICAgIGZ1bmN0aW9uIGJucEV4cChlLHopIHtcbiAgICAgIGlmKGUgPiAweGZmZmZmZmZmIHx8IGUgPCAxKSByZXR1cm4gQmlnSW50ZWdlci5PTkU7XG4gICAgICB2YXIgciA9IG5iaSgpLCByMiA9IG5iaSgpLCBnID0gei5jb252ZXJ0KHRoaXMpLCBpID0gbmJpdHMoZSktMTtcbiAgICAgIGcuY29weVRvKHIpO1xuICAgICAgd2hpbGUoLS1pID49IDApIHtcbiAgICAgICAgei5zcXJUbyhyLHIyKTtcbiAgICAgICAgaWYoKGUmKDE8PGkpKSA+IDApIHoubXVsVG8ocjIsZyxyKTtcbiAgICAgICAgZWxzZSB7IHZhciB0ID0gcjsgciA9IHIyOyByMiA9IHQ7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB6LnJldmVydChyKTtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzXmUgJSBtLCAwIDw9IGUgPCAyXjMyXG4gICAgZnVuY3Rpb24gYm5Nb2RQb3dJbnQoZSxtKSB7XG4gICAgICB2YXIgejtcbiAgICAgIGlmKGUgPCAyNTYgfHwgbS5pc0V2ZW4oKSkgeiA9IG5ldyBDbGFzc2ljKG0pOyBlbHNlIHogPSBuZXcgTW9udGdvbWVyeShtKTtcbiAgICAgIHJldHVybiB0aGlzLmV4cChlLHopO1xuICAgIH1cblxuICAgIC8vIHByb3RlY3RlZFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvcHlUbyA9IGJucENvcHlUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tSW50ID0gYm5wRnJvbUludDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gYm5wRnJvbVN0cmluZztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGFtcCA9IGJucENsYW1wO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRsU2hpZnRUbyA9IGJucERMU2hpZnRUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kclNoaWZ0VG8gPSBibnBEUlNoaWZ0VG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubFNoaWZ0VG8gPSBibnBMU2hpZnRUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5yU2hpZnRUbyA9IGJucFJTaGlmdFRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YlRvID0gYm5wU3ViVG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlUbyA9IGJucE11bHRpcGx5VG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlVG8gPSBibnBTcXVhcmVUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZSZW1UbyA9IGJucERpdlJlbVRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmludkRpZ2l0ID0gYm5wSW52RGlnaXQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gYm5wSXNFdmVuO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmV4cCA9IGJucEV4cDtcblxuICAgIC8vIHB1YmxpY1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nID0gYm5Ub1N0cmluZztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBibk5lZ2F0ZTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hYnMgPSBibkFicztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBibkNvbXBhcmVUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBibkJpdExlbmd0aDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2QgPSBibk1vZDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3dJbnQgPSBibk1vZFBvd0ludDtcblxuICAgIC8vIFwiY29uc3RhbnRzXCJcbiAgICBCaWdJbnRlZ2VyLlpFUk8gPSBuYnYoMCk7XG4gICAgQmlnSW50ZWdlci5PTkUgPSBuYnYoMSk7XG5cbiAgICAvLyBDb3B5cmlnaHQgKGMpIDIwMDUtMjAwOSAgVG9tIFd1XG4gICAgLy8gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAvLyBTZWUgXCJMSUNFTlNFXCIgZm9yIGRldGFpbHMuXG5cbiAgICAvLyBFeHRlbmRlZCBKYXZhU2NyaXB0IEJOIGZ1bmN0aW9ucywgcmVxdWlyZWQgZm9yIFJTQSBwcml2YXRlIG9wcy5cblxuICAgIC8vIFZlcnNpb24gMS4xOiBuZXcgQmlnSW50ZWdlcihcIjBcIiwgMTApIHJldHVybnMgXCJwcm9wZXJcIiB6ZXJvXG4gICAgLy8gVmVyc2lvbiAxLjI6IHNxdWFyZSgpIEFQSSwgaXNQcm9iYWJsZVByaW1lIGZpeFxuXG4gICAgLy8gKHB1YmxpYylcbiAgICBmdW5jdGlvbiBibkNsb25lKCkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmNvcHlUbyhyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBpbnRlZ2VyXG4gICAgZnVuY3Rpb24gYm5JbnRWYWx1ZSgpIHtcbiAgICAgIGlmKHRoaXMucyA8IDApIHtcbiAgICAgICAgaWYodGhpcy50ID09IDEpIHJldHVybiB0aGlzWzBdLXRoaXMuRFY7XG4gICAgICAgIGVsc2UgaWYodGhpcy50ID09IDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodGhpcy50ID09IDEpIHJldHVybiB0aGlzWzBdO1xuICAgICAgZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIDA7XG4gICAgICAvLyBhc3N1bWVzIDE2IDwgREIgPCAzMlxuICAgICAgcmV0dXJuICgodGhpc1sxXSYoKDE8PCgzMi10aGlzLkRCKSktMSkpPDx0aGlzLkRCKXx0aGlzWzBdO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBieXRlXG4gICAgZnVuY3Rpb24gYm5CeXRlVmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXNbMF08PDI0KT4+MjQ7IH1cblxuICAgIC8vIChwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBzaG9ydCAoYXNzdW1lcyBEQj49MTYpXG4gICAgZnVuY3Rpb24gYm5TaG9ydFZhbHVlKCkgeyByZXR1cm4gKHRoaXMudD09MCk/dGhpcy5zOih0aGlzWzBdPDwxNik+PjE2OyB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSByZXR1cm4geCBzLnQuIHJeeCA8IERWXG4gICAgZnVuY3Rpb24gYm5wQ2h1bmtTaXplKHIpIHsgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5MTjIqdGhpcy5EQi9NYXRoLmxvZyhyKSk7IH1cblxuICAgIC8vIChwdWJsaWMpIDAgaWYgdGhpcyA9PSAwLCAxIGlmIHRoaXMgPiAwXG4gICAgZnVuY3Rpb24gYm5TaWdOdW0oKSB7XG4gICAgICBpZih0aGlzLnMgPCAwKSByZXR1cm4gLTE7XG4gICAgICBlbHNlIGlmKHRoaXMudCA8PSAwIHx8ICh0aGlzLnQgPT0gMSAmJiB0aGlzWzBdIDw9IDApKSByZXR1cm4gMDtcbiAgICAgIGVsc2UgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgY29udmVydCB0byByYWRpeCBzdHJpbmdcbiAgICBmdW5jdGlvbiBibnBUb1JhZGl4KGIpIHtcbiAgICAgIGlmKGIgPT0gbnVsbCkgYiA9IDEwO1xuICAgICAgaWYodGhpcy5zaWdudW0oKSA9PSAwIHx8IGIgPCAyIHx8IGIgPiAzNikgcmV0dXJuIFwiMFwiO1xuICAgICAgdmFyIGNzID0gdGhpcy5jaHVua1NpemUoYik7XG4gICAgICB2YXIgYSA9IE1hdGgucG93KGIsY3MpO1xuICAgICAgdmFyIGQgPSBuYnYoYSksIHkgPSBuYmkoKSwgeiA9IG5iaSgpLCByID0gXCJcIjtcbiAgICAgIHRoaXMuZGl2UmVtVG8oZCx5LHopO1xuICAgICAgd2hpbGUoeS5zaWdudW0oKSA+IDApIHtcbiAgICAgICAgciA9IChhK3ouaW50VmFsdWUoKSkudG9TdHJpbmcoYikuc3Vic3RyKDEpICsgcjtcbiAgICAgICAgeS5kaXZSZW1UbyhkLHkseik7XG4gICAgICB9XG4gICAgICByZXR1cm4gei5pbnRWYWx1ZSgpLnRvU3RyaW5nKGIpICsgcjtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSBjb252ZXJ0IGZyb20gcmFkaXggc3RyaW5nXG4gICAgZnVuY3Rpb24gYm5wRnJvbVJhZGl4KHMsYikge1xuICAgICAgdGhpcy5mcm9tSW50KDApO1xuICAgICAgaWYoYiA9PSBudWxsKSBiID0gMTA7XG4gICAgICB2YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKTtcbiAgICAgIHZhciBkID0gTWF0aC5wb3coYixjcyksIG1pID0gZmFsc2UsIGogPSAwLCB3ID0gMDtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB4ID0gaW50QXQocyxpKTtcbiAgICAgICAgaWYoeCA8IDApIHtcbiAgICAgICAgICBpZihzLmNoYXJBdChpKSA9PSBcIi1cIiAmJiB0aGlzLnNpZ251bSgpID09IDApIG1pID0gdHJ1ZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB3ID0gYip3K3g7XG4gICAgICAgIGlmKCsraiA+PSBjcykge1xuICAgICAgICAgIHRoaXMuZE11bHRpcGx5KGQpO1xuICAgICAgICAgIHRoaXMuZEFkZE9mZnNldCh3LDApO1xuICAgICAgICAgIGogPSAwO1xuICAgICAgICAgIHcgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihqID4gMCkge1xuICAgICAgICB0aGlzLmRNdWx0aXBseShNYXRoLnBvdyhiLGopKTtcbiAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG4gICAgICB9XG4gICAgICBpZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgYWx0ZXJuYXRlIGNvbnN0cnVjdG9yXG4gICAgZnVuY3Rpb24gYm5wRnJvbU51bWJlcihhLGIsYykge1xuICAgICAgaWYoXCJudW1iZXJcIiA9PSB0eXBlb2YgYikge1xuICAgICAgICAvLyBuZXcgQmlnSW50ZWdlcihpbnQsaW50LFJORylcbiAgICAgICAgaWYoYSA8IDIpIHRoaXMuZnJvbUludCgxKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5mcm9tTnVtYmVyKGEsYyk7XG4gICAgICAgICAgaWYoIXRoaXMudGVzdEJpdChhLTEpKVx0Ly8gZm9yY2UgTVNCIHNldFxuICAgICAgICAgICAgdGhpcy5iaXR3aXNlVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEtMSksb3Bfb3IsdGhpcyk7XG4gICAgICAgICAgaWYodGhpcy5pc0V2ZW4oKSkgdGhpcy5kQWRkT2Zmc2V0KDEsMCk7IC8vIGZvcmNlIG9kZFxuICAgICAgICAgIHdoaWxlKCF0aGlzLmlzUHJvYmFibGVQcmltZShiKSkge1xuICAgICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KDIsMCk7XG4gICAgICAgICAgICBpZih0aGlzLmJpdExlbmd0aCgpID4gYSkgdGhpcy5zdWJUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYS0xKSx0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBuZXcgQmlnSW50ZWdlcihpbnQsUk5HKVxuICAgICAgICB2YXIgeCA9IG5ldyBBcnJheSgpLCB0ID0gYSY3O1xuICAgICAgICB4Lmxlbmd0aCA9IChhPj4zKSsxO1xuICAgICAgICBiLm5leHRCeXRlcyh4KTtcbiAgICAgICAgaWYodCA+IDApIHhbMF0gJj0gKCgxPDx0KS0xKTsgZWxzZSB4WzBdID0gMDtcbiAgICAgICAgdGhpcy5mcm9tU3RyaW5nKHgsMjU2KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAocHVibGljKSBjb252ZXJ0IHRvIGJpZ2VuZGlhbiBieXRlIGFycmF5XG4gICAgZnVuY3Rpb24gYm5Ub0J5dGVBcnJheSgpIHtcbiAgICAgIHZhciBpID0gdGhpcy50LCByID0gbmV3IEFycmF5KCk7XG4gICAgICByWzBdID0gdGhpcy5zO1xuICAgICAgdmFyIHAgPSB0aGlzLkRCLShpKnRoaXMuREIpJTgsIGQsIGsgPSAwO1xuICAgICAgaWYoaS0tID4gMCkge1xuICAgICAgICBpZihwIDwgdGhpcy5EQiAmJiAoZCA9IHRoaXNbaV0+PnApICE9ICh0aGlzLnMmdGhpcy5ETSk+PnApXG4gICAgICAgICAgcltrKytdID0gZHwodGhpcy5zPDwodGhpcy5EQi1wKSk7XG4gICAgICAgIHdoaWxlKGkgPj0gMCkge1xuICAgICAgICAgIGlmKHAgPCA4KSB7XG4gICAgICAgICAgICBkID0gKHRoaXNbaV0mKCgxPDxwKS0xKSk8PCg4LXApO1xuICAgICAgICAgICAgZCB8PSB0aGlzWy0taV0+PihwKz10aGlzLkRCLTgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGQgPSAodGhpc1tpXT4+KHAtPTgpKSYweGZmO1xuICAgICAgICAgICAgaWYocCA8PSAwKSB7IHAgKz0gdGhpcy5EQjsgLS1pOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKChkJjB4ODApICE9IDApIGQgfD0gLTI1NjtcbiAgICAgICAgICBpZihrID09IDAgJiYgKHRoaXMucyYweDgwKSAhPSAoZCYweDgwKSkgKytrO1xuICAgICAgICAgIGlmKGsgPiAwIHx8IGQgIT0gdGhpcy5zKSByW2srK10gPSBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBibkVxdWFscyhhKSB7IHJldHVybih0aGlzLmNvbXBhcmVUbyhhKT09MCk7IH1cbiAgICBmdW5jdGlvbiBibk1pbihhKSB7IHJldHVybih0aGlzLmNvbXBhcmVUbyhhKTwwKT90aGlzOmE7IH1cbiAgICBmdW5jdGlvbiBibk1heChhKSB7IHJldHVybih0aGlzLmNvbXBhcmVUbyhhKT4wKT90aGlzOmE7IH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIG9wIGEgKGJpdHdpc2UpXG4gICAgZnVuY3Rpb24gYm5wQml0d2lzZVRvKGEsb3Ascikge1xuICAgICAgdmFyIGksIGYsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbiAgICAgIGZvcihpID0gMDsgaSA8IG07ICsraSkgcltpXSA9IG9wKHRoaXNbaV0sYVtpXSk7XG4gICAgICBpZihhLnQgPCB0aGlzLnQpIHtcbiAgICAgICAgZiA9IGEucyZ0aGlzLkRNO1xuICAgICAgICBmb3IoaSA9IG07IGkgPCB0aGlzLnQ7ICsraSkgcltpXSA9IG9wKHRoaXNbaV0sZik7XG4gICAgICAgIHIudCA9IHRoaXMudDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmID0gdGhpcy5zJnRoaXMuRE07XG4gICAgICAgIGZvcihpID0gbTsgaSA8IGEudDsgKytpKSByW2ldID0gb3AoZixhW2ldKTtcbiAgICAgICAgci50ID0gYS50O1xuICAgICAgfVxuICAgICAgci5zID0gb3AodGhpcy5zLGEucyk7XG4gICAgICByLmNsYW1wKCk7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyAmIGFcbiAgICBmdW5jdGlvbiBvcF9hbmQoeCx5KSB7IHJldHVybiB4Jnk7IH1cbiAgICBmdW5jdGlvbiBibkFuZChhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYml0d2lzZVRvKGEsb3BfYW5kLHIpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyB8IGFcbiAgICBmdW5jdGlvbiBvcF9vcih4LHkpIHsgcmV0dXJuIHh8eTsgfVxuICAgIGZ1bmN0aW9uIGJuT3IoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX29yLHIpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyBeIGFcbiAgICBmdW5jdGlvbiBvcF94b3IoeCx5KSB7IHJldHVybiB4Xnk7IH1cbiAgICBmdW5jdGlvbiBiblhvcihhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYml0d2lzZVRvKGEsb3BfeG9yLHIpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyAmIH5hXG4gICAgZnVuY3Rpb24gb3BfYW5kbm90KHgseSkgeyByZXR1cm4geCZ+eTsgfVxuICAgIGZ1bmN0aW9uIGJuQW5kTm90KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9hbmRub3Qscik7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSB+dGhpc1xuICAgIGZ1bmN0aW9uIGJuTm90KCkge1xuICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkgcltpXSA9IHRoaXMuRE0mfnRoaXNbaV07XG4gICAgICByLnQgPSB0aGlzLnQ7XG4gICAgICByLnMgPSB+dGhpcy5zO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyA8PCBuXG4gICAgZnVuY3Rpb24gYm5TaGlmdExlZnQobikge1xuICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgIGlmKG4gPCAwKSB0aGlzLnJTaGlmdFRvKC1uLHIpOyBlbHNlIHRoaXMubFNoaWZ0VG8obixyKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgPj4gblxuICAgIGZ1bmN0aW9uIGJuU2hpZnRSaWdodChuKSB7XG4gICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgaWYobiA8IDApIHRoaXMubFNoaWZ0VG8oLW4scik7IGVsc2UgdGhpcy5yU2hpZnRUbyhuLHIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIGluZGV4IG9mIGxvd2VzdCAxLWJpdCBpbiB4LCB4IDwgMl4zMVxuICAgIGZ1bmN0aW9uIGxiaXQoeCkge1xuICAgICAgaWYoeCA9PSAwKSByZXR1cm4gLTE7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICBpZigoeCYweGZmZmYpID09IDApIHsgeCA+Pj0gMTY7IHIgKz0gMTY7IH1cbiAgICAgIGlmKCh4JjB4ZmYpID09IDApIHsgeCA+Pj0gODsgciArPSA4OyB9XG4gICAgICBpZigoeCYweGYpID09IDApIHsgeCA+Pj0gNDsgciArPSA0OyB9XG4gICAgICBpZigoeCYzKSA9PSAwKSB7IHggPj49IDI7IHIgKz0gMjsgfVxuICAgICAgaWYoKHgmMSkgPT0gMCkgKytyO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgcmV0dXJucyBpbmRleCBvZiBsb3dlc3QgMS1iaXQgKG9yIC0xIGlmIG5vbmUpXG4gICAgZnVuY3Rpb24gYm5HZXRMb3dlc3RTZXRCaXQoKSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpXG4gICAgICAgIGlmKHRoaXNbaV0gIT0gMCkgcmV0dXJuIGkqdGhpcy5EQitsYml0KHRoaXNbaV0pO1xuICAgICAgaWYodGhpcy5zIDwgMCkgcmV0dXJuIHRoaXMudCp0aGlzLkRCO1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBudW1iZXIgb2YgMSBiaXRzIGluIHhcbiAgICBmdW5jdGlvbiBjYml0KHgpIHtcbiAgICAgIHZhciByID0gMDtcbiAgICAgIHdoaWxlKHggIT0gMCkgeyB4ICY9IHgtMTsgKytyOyB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSByZXR1cm4gbnVtYmVyIG9mIHNldCBiaXRzXG4gICAgZnVuY3Rpb24gYm5CaXRDb3VudCgpIHtcbiAgICAgIHZhciByID0gMCwgeCA9IHRoaXMucyZ0aGlzLkRNO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByICs9IGNiaXQodGhpc1tpXV54KTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHRydWUgaWZmIG50aCBiaXQgaXMgc2V0XG4gICAgZnVuY3Rpb24gYm5UZXN0Qml0KG4pIHtcbiAgICAgIHZhciBqID0gTWF0aC5mbG9vcihuL3RoaXMuREIpO1xuICAgICAgaWYoaiA+PSB0aGlzLnQpIHJldHVybih0aGlzLnMhPTApO1xuICAgICAgcmV0dXJuKCh0aGlzW2pdJigxPDwobiV0aGlzLkRCKSkpIT0wKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSB0aGlzIG9wICgxPDxuKVxuICAgIGZ1bmN0aW9uIGJucENoYW5nZUJpdChuLG9wKSB7XG4gICAgICB2YXIgciA9IEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChuKTtcbiAgICAgIHRoaXMuYml0d2lzZVRvKHIsb3Ascik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzIHwgKDE8PG4pXG4gICAgZnVuY3Rpb24gYm5TZXRCaXQobikgeyByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF9vcik7IH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgJiB+KDE8PG4pXG4gICAgZnVuY3Rpb24gYm5DbGVhckJpdChuKSB7IHJldHVybiB0aGlzLmNoYW5nZUJpdChuLG9wX2FuZG5vdCk7IH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgXiAoMTw8bilcbiAgICBmdW5jdGlvbiBibkZsaXBCaXQobikgeyByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF94b3IpOyB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyArIGFcbiAgICBmdW5jdGlvbiBibnBBZGRUbyhhLHIpIHtcbiAgICAgIHZhciBpID0gMCwgYyA9IDAsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbiAgICAgIHdoaWxlKGkgPCBtKSB7XG4gICAgICAgIGMgKz0gdGhpc1tpXSthW2ldO1xuICAgICAgICByW2krK10gPSBjJnRoaXMuRE07XG4gICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICB9XG4gICAgICBpZihhLnQgPCB0aGlzLnQpIHtcbiAgICAgICAgYyArPSBhLnM7XG4gICAgICAgIHdoaWxlKGkgPCB0aGlzLnQpIHtcbiAgICAgICAgICBjICs9IHRoaXNbaV07XG4gICAgICAgICAgcltpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgIH1cbiAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICAgIHdoaWxlKGkgPCBhLnQpIHtcbiAgICAgICAgICBjICs9IGFbaV07XG4gICAgICAgICAgcltpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgIH1cbiAgICAgICAgYyArPSBhLnM7XG4gICAgICB9XG4gICAgICByLnMgPSAoYzwwKT8tMTowO1xuICAgICAgaWYoYyA+IDApIHJbaSsrXSA9IGM7XG4gICAgICBlbHNlIGlmKGMgPCAtMSkgcltpKytdID0gdGhpcy5EVitjO1xuICAgICAgci50ID0gaTtcbiAgICAgIHIuY2xhbXAoKTtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzICsgYVxuICAgIGZ1bmN0aW9uIGJuQWRkKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5hZGRUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyAtIGFcbiAgICBmdW5jdGlvbiBiblN1YnRyYWN0KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5zdWJUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyAqIGFcbiAgICBmdW5jdGlvbiBibk11bHRpcGx5KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5tdWx0aXBseVRvKGEscik7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzXjJcbiAgICBmdW5jdGlvbiBiblNxdWFyZSgpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5zcXVhcmVUbyhyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgLyBhXG4gICAgZnVuY3Rpb24gYm5EaXZpZGUoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmRpdlJlbVRvKGEscixudWxsKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgJSBhXG4gICAgZnVuY3Rpb24gYm5SZW1haW5kZXIoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmRpdlJlbVRvKGEsbnVsbCxyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIFt0aGlzL2EsdGhpcyVhXVxuICAgIGZ1bmN0aW9uIGJuRGl2aWRlQW5kUmVtYWluZGVyKGEpIHtcbiAgICAgIHZhciBxID0gbmJpKCksIHIgPSBuYmkoKTtcbiAgICAgIHRoaXMuZGl2UmVtVG8oYSxxLHIpO1xuICAgICAgcmV0dXJuIG5ldyBBcnJheShxLHIpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXMgKj0gbiwgdGhpcyA+PSAwLCAxIDwgbiA8IERWXG4gICAgZnVuY3Rpb24gYm5wRE11bHRpcGx5KG4pIHtcbiAgICAgIHRoaXNbdGhpcy50XSA9IHRoaXMuYW0oMCxuLTEsdGhpcywwLDAsdGhpcy50KTtcbiAgICAgICsrdGhpcy50O1xuICAgICAgdGhpcy5jbGFtcCgpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXMgKz0gbiA8PCB3IHdvcmRzLCB0aGlzID49IDBcbiAgICBmdW5jdGlvbiBibnBEQWRkT2Zmc2V0KG4sdykge1xuICAgICAgaWYobiA9PSAwKSByZXR1cm47XG4gICAgICB3aGlsZSh0aGlzLnQgPD0gdykgdGhpc1t0aGlzLnQrK10gPSAwO1xuICAgICAgdGhpc1t3XSArPSBuO1xuICAgICAgd2hpbGUodGhpc1t3XSA+PSB0aGlzLkRWKSB7XG4gICAgICAgIHRoaXNbd10gLT0gdGhpcy5EVjtcbiAgICAgICAgaWYoKyt3ID49IHRoaXMudCkgdGhpc1t0aGlzLnQrK10gPSAwO1xuICAgICAgICArK3RoaXNbd107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQSBcIm51bGxcIiByZWR1Y2VyXG4gICAgZnVuY3Rpb24gTnVsbEV4cCgpIHt9XG4gICAgZnVuY3Rpb24gbk5vcCh4KSB7IHJldHVybiB4OyB9XG4gICAgZnVuY3Rpb24gbk11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB9XG4gICAgZnVuY3Rpb24gblNxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB9XG5cbiAgICBOdWxsRXhwLnByb3RvdHlwZS5jb252ZXJ0ID0gbk5vcDtcbiAgICBOdWxsRXhwLnByb3RvdHlwZS5yZXZlcnQgPSBuTm9wO1xuICAgIE51bGxFeHAucHJvdG90eXBlLm11bFRvID0gbk11bFRvO1xuICAgIE51bGxFeHAucHJvdG90eXBlLnNxclRvID0gblNxclRvO1xuXG4gICAgLy8gKHB1YmxpYykgdGhpc15lXG4gICAgZnVuY3Rpb24gYm5Qb3coZSkgeyByZXR1cm4gdGhpcy5leHAoZSxuZXcgTnVsbEV4cCgpKTsgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IGxvd2VyIG4gd29yZHMgb2YgXCJ0aGlzICogYVwiLCBhLnQgPD0gblxuICAgIC8vIFwidGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbiAgICBmdW5jdGlvbiBibnBNdWx0aXBseUxvd2VyVG8oYSxuLHIpIHtcbiAgICAgIHZhciBpID0gTWF0aC5taW4odGhpcy50K2EudCxuKTtcbiAgICAgIHIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcbiAgICAgIHIudCA9IGk7XG4gICAgICB3aGlsZShpID4gMCkgclstLWldID0gMDtcbiAgICAgIHZhciBqO1xuICAgICAgZm9yKGogPSByLnQtdGhpcy50OyBpIDwgajsgKytpKSByW2krdGhpcy50XSA9IHRoaXMuYW0oMCxhW2ldLHIsaSwwLHRoaXMudCk7XG4gICAgICBmb3IoaiA9IE1hdGgubWluKGEudCxuKTsgaSA8IGo7ICsraSkgdGhpcy5hbSgwLGFbaV0scixpLDAsbi1pKTtcbiAgICAgIHIuY2xhbXAoKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSByID0gXCJ0aGlzICogYVwiIHdpdGhvdXQgbG93ZXIgbiB3b3JkcywgbiA+IDBcbiAgICAvLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG4gICAgZnVuY3Rpb24gYm5wTXVsdGlwbHlVcHBlclRvKGEsbixyKSB7XG4gICAgICAtLW47XG4gICAgICB2YXIgaSA9IHIudCA9IHRoaXMudCthLnQtbjtcbiAgICAgIHIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcbiAgICAgIHdoaWxlKC0taSA+PSAwKSByW2ldID0gMDtcbiAgICAgIGZvcihpID0gTWF0aC5tYXgobi10aGlzLnQsMCk7IGkgPCBhLnQ7ICsraSlcbiAgICAgICAgclt0aGlzLnQraS1uXSA9IHRoaXMuYW0obi1pLGFbaV0sciwwLDAsdGhpcy50K2ktbik7XG4gICAgICByLmNsYW1wKCk7XG4gICAgICByLmRyU2hpZnRUbygxLHIpO1xuICAgIH1cblxuICAgIC8vIEJhcnJldHQgbW9kdWxhciByZWR1Y3Rpb25cbiAgICBmdW5jdGlvbiBCYXJyZXR0KG0pIHtcbiAgICAgIC8vIHNldHVwIEJhcnJldHRcbiAgICAgIHRoaXMucjIgPSBuYmkoKTtcbiAgICAgIHRoaXMucTMgPSBuYmkoKTtcbiAgICAgIEJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbygyKm0udCx0aGlzLnIyKTtcbiAgICAgIHRoaXMubXUgPSB0aGlzLnIyLmRpdmlkZShtKTtcbiAgICAgIHRoaXMubSA9IG07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmFycmV0dENvbnZlcnQoeCkge1xuICAgICAgaWYoeC5zIDwgMCB8fCB4LnQgPiAyKnRoaXMubS50KSByZXR1cm4geC5tb2QodGhpcy5tKTtcbiAgICAgIGVsc2UgaWYoeC5jb21wYXJlVG8odGhpcy5tKSA8IDApIHJldHVybiB4O1xuICAgICAgZWxzZSB7IHZhciByID0gbmJpKCk7IHguY29weVRvKHIpOyB0aGlzLnJlZHVjZShyKTsgcmV0dXJuIHI7IH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiYXJyZXR0UmV2ZXJ0KHgpIHsgcmV0dXJuIHg7IH1cblxuICAgIC8vIHggPSB4IG1vZCBtIChIQUMgMTQuNDIpXG4gICAgZnVuY3Rpb24gYmFycmV0dFJlZHVjZSh4KSB7XG4gICAgICB4LmRyU2hpZnRUbyh0aGlzLm0udC0xLHRoaXMucjIpO1xuICAgICAgaWYoeC50ID4gdGhpcy5tLnQrMSkgeyB4LnQgPSB0aGlzLm0udCsxOyB4LmNsYW1wKCk7IH1cbiAgICAgIHRoaXMubXUubXVsdGlwbHlVcHBlclRvKHRoaXMucjIsdGhpcy5tLnQrMSx0aGlzLnEzKTtcbiAgICAgIHRoaXMubS5tdWx0aXBseUxvd2VyVG8odGhpcy5xMyx0aGlzLm0udCsxLHRoaXMucjIpO1xuICAgICAgd2hpbGUoeC5jb21wYXJlVG8odGhpcy5yMikgPCAwKSB4LmRBZGRPZmZzZXQoMSx0aGlzLm0udCsxKTtcbiAgICAgIHguc3ViVG8odGhpcy5yMix4KTtcbiAgICAgIHdoaWxlKHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgeC5zdWJUbyh0aGlzLm0seCk7XG4gICAgfVxuXG4gICAgLy8gciA9IHheMiBtb2QgbTsgeCAhPSByXG4gICAgZnVuY3Rpb24gYmFycmV0dFNxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG4gICAgLy8gciA9IHgqeSBtb2QgbTsgeCx5ICE9IHJcbiAgICBmdW5jdGlvbiBiYXJyZXR0TXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbiAgICBCYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0ID0gYmFycmV0dENvbnZlcnQ7XG4gICAgQmFycmV0dC5wcm90b3R5cGUucmV2ZXJ0ID0gYmFycmV0dFJldmVydDtcbiAgICBCYXJyZXR0LnByb3RvdHlwZS5yZWR1Y2UgPSBiYXJyZXR0UmVkdWNlO1xuICAgIEJhcnJldHQucHJvdG90eXBlLm11bFRvID0gYmFycmV0dE11bFRvO1xuICAgIEJhcnJldHQucHJvdG90eXBlLnNxclRvID0gYmFycmV0dFNxclRvO1xuXG4gICAgLy8gKHB1YmxpYykgdGhpc15lICUgbSAoSEFDIDE0Ljg1KVxuICAgIGZ1bmN0aW9uIGJuTW9kUG93KGUsbSkge1xuICAgICAgdmFyIGkgPSBlLmJpdExlbmd0aCgpLCBrLCByID0gbmJ2KDEpLCB6O1xuICAgICAgaWYoaSA8PSAwKSByZXR1cm4gcjtcbiAgICAgIGVsc2UgaWYoaSA8IDE4KSBrID0gMTtcbiAgICAgIGVsc2UgaWYoaSA8IDQ4KSBrID0gMztcbiAgICAgIGVsc2UgaWYoaSA8IDE0NCkgayA9IDQ7XG4gICAgICBlbHNlIGlmKGkgPCA3NjgpIGsgPSA1O1xuICAgICAgZWxzZSBrID0gNjtcbiAgICAgIGlmKGkgPCA4KVxuICAgICAgICB6ID0gbmV3IENsYXNzaWMobSk7XG4gICAgICBlbHNlIGlmKG0uaXNFdmVuKCkpXG4gICAgICAgIHogPSBuZXcgQmFycmV0dChtKTtcbiAgICAgIGVsc2VcbiAgICAgICAgeiA9IG5ldyBNb250Z29tZXJ5KG0pO1xuXG4gICAgICAvLyBwcmVjb21wdXRhdGlvblxuICAgICAgdmFyIGcgPSBuZXcgQXJyYXkoKSwgbiA9IDMsIGsxID0gay0xLCBrbSA9ICgxPDxrKS0xO1xuICAgICAgZ1sxXSA9IHouY29udmVydCh0aGlzKTtcbiAgICAgIGlmKGsgPiAxKSB7XG4gICAgICAgIHZhciBnMiA9IG5iaSgpO1xuICAgICAgICB6LnNxclRvKGdbMV0sZzIpO1xuICAgICAgICB3aGlsZShuIDw9IGttKSB7XG4gICAgICAgICAgZ1tuXSA9IG5iaSgpO1xuICAgICAgICAgIHoubXVsVG8oZzIsZ1tuLTJdLGdbbl0pO1xuICAgICAgICAgIG4gKz0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaiA9IGUudC0xLCB3LCBpczEgPSB0cnVlLCByMiA9IG5iaSgpLCB0O1xuICAgICAgaSA9IG5iaXRzKGVbal0pLTE7XG4gICAgICB3aGlsZShqID49IDApIHtcbiAgICAgICAgaWYoaSA+PSBrMSkgdyA9IChlW2pdPj4oaS1rMSkpJmttO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB3ID0gKGVbal0mKCgxPDwoaSsxKSktMSkpPDwoazEtaSk7XG4gICAgICAgICAgaWYoaiA+IDApIHcgfD0gZVtqLTFdPj4odGhpcy5EQitpLWsxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG4gPSBrO1xuICAgICAgICB3aGlsZSgodyYxKSA9PSAwKSB7IHcgPj49IDE7IC0tbjsgfVxuICAgICAgICBpZigoaSAtPSBuKSA8IDApIHsgaSArPSB0aGlzLkRCOyAtLWo7IH1cbiAgICAgICAgaWYoaXMxKSB7XHQvLyByZXQgPT0gMSwgZG9uJ3QgYm90aGVyIHNxdWFyaW5nIG9yIG11bHRpcGx5aW5nIGl0XG4gICAgICAgICAgZ1t3XS5jb3B5VG8ocik7XG4gICAgICAgICAgaXMxID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgd2hpbGUobiA+IDEpIHsgei5zcXJUbyhyLHIyKTsgei5zcXJUbyhyMixyKTsgbiAtPSAyOyB9XG4gICAgICAgICAgaWYobiA+IDApIHouc3FyVG8ocixyMik7IGVsc2UgeyB0ID0gcjsgciA9IHIyOyByMiA9IHQ7IH1cbiAgICAgICAgICB6Lm11bFRvKHIyLGdbd10scik7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZShqID49IDAgJiYgKGVbal0mKDE8PGkpKSA9PSAwKSB7XG4gICAgICAgICAgei5zcXJUbyhyLHIyKTsgdCA9IHI7IHIgPSByMjsgcjIgPSB0O1xuICAgICAgICAgIGlmKC0taSA8IDApIHsgaSA9IHRoaXMuREItMTsgLS1qOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB6LnJldmVydChyKTtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSBnY2QodGhpcyxhKSAoSEFDIDE0LjU0KVxuICAgIGZ1bmN0aW9uIGJuR0NEKGEpIHtcbiAgICAgIHZhciB4ID0gKHRoaXMuczwwKT90aGlzLm5lZ2F0ZSgpOnRoaXMuY2xvbmUoKTtcbiAgICAgIHZhciB5ID0gKGEuczwwKT9hLm5lZ2F0ZSgpOmEuY2xvbmUoKTtcbiAgICAgIGlmKHguY29tcGFyZVRvKHkpIDwgMCkgeyB2YXIgdCA9IHg7IHggPSB5OyB5ID0gdDsgfVxuICAgICAgdmFyIGkgPSB4LmdldExvd2VzdFNldEJpdCgpLCBnID0geS5nZXRMb3dlc3RTZXRCaXQoKTtcbiAgICAgIGlmKGcgPCAwKSByZXR1cm4geDtcbiAgICAgIGlmKGkgPCBnKSBnID0gaTtcbiAgICAgIGlmKGcgPiAwKSB7XG4gICAgICAgIHguclNoaWZ0VG8oZyx4KTtcbiAgICAgICAgeS5yU2hpZnRUbyhnLHkpO1xuICAgICAgfVxuICAgICAgd2hpbGUoeC5zaWdudW0oKSA+IDApIHtcbiAgICAgICAgaWYoKGkgPSB4LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHguclNoaWZ0VG8oaSx4KTtcbiAgICAgICAgaWYoKGkgPSB5LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHkuclNoaWZ0VG8oaSx5KTtcbiAgICAgICAgaWYoeC5jb21wYXJlVG8oeSkgPj0gMCkge1xuICAgICAgICAgIHguc3ViVG8oeSx4KTtcbiAgICAgICAgICB4LnJTaGlmdFRvKDEseCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgeS5zdWJUbyh4LHkpO1xuICAgICAgICAgIHkuclNoaWZ0VG8oMSx5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoZyA+IDApIHkubFNoaWZ0VG8oZyx5KTtcbiAgICAgIHJldHVybiB5O1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXMgJSBuLCBuIDwgMl4yNlxuICAgIGZ1bmN0aW9uIGJucE1vZEludChuKSB7XG4gICAgICBpZihuIDw9IDApIHJldHVybiAwO1xuICAgICAgdmFyIGQgPSB0aGlzLkRWJW4sIHIgPSAodGhpcy5zPDApP24tMTowO1xuICAgICAgaWYodGhpcy50ID4gMClcbiAgICAgICAgaWYoZCA9PSAwKSByID0gdGhpc1swXSVuO1xuICAgICAgICBlbHNlIGZvcih2YXIgaSA9IHRoaXMudC0xOyBpID49IDA7IC0taSkgciA9IChkKnIrdGhpc1tpXSklbjtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIDEvdGhpcyAlIG0gKEhBQyAxNC42MSlcbiAgICBmdW5jdGlvbiBibk1vZEludmVyc2UobSkge1xuICAgICAgdmFyIGFjID0gbS5pc0V2ZW4oKTtcbiAgICAgIGlmKCh0aGlzLmlzRXZlbigpICYmIGFjKSB8fCBtLnNpZ251bSgpID09IDApIHJldHVybiBCaWdJbnRlZ2VyLlpFUk87XG4gICAgICB2YXIgdSA9IG0uY2xvbmUoKSwgdiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIHZhciBhID0gbmJ2KDEpLCBiID0gbmJ2KDApLCBjID0gbmJ2KDApLCBkID0gbmJ2KDEpO1xuICAgICAgd2hpbGUodS5zaWdudW0oKSAhPSAwKSB7XG4gICAgICAgIHdoaWxlKHUuaXNFdmVuKCkpIHtcbiAgICAgICAgICB1LnJTaGlmdFRvKDEsdSk7XG4gICAgICAgICAgaWYoYWMpIHtcbiAgICAgICAgICAgIGlmKCFhLmlzRXZlbigpIHx8ICFiLmlzRXZlbigpKSB7IGEuYWRkVG8odGhpcyxhKTsgYi5zdWJUbyhtLGIpOyB9XG4gICAgICAgICAgICBhLnJTaGlmdFRvKDEsYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYoIWIuaXNFdmVuKCkpIGIuc3ViVG8obSxiKTtcbiAgICAgICAgICBiLnJTaGlmdFRvKDEsYik7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUodi5pc0V2ZW4oKSkge1xuICAgICAgICAgIHYuclNoaWZ0VG8oMSx2KTtcbiAgICAgICAgICBpZihhYykge1xuICAgICAgICAgICAgaWYoIWMuaXNFdmVuKCkgfHwgIWQuaXNFdmVuKCkpIHsgYy5hZGRUbyh0aGlzLGMpOyBkLnN1YlRvKG0sZCk7IH1cbiAgICAgICAgICAgIGMuclNoaWZ0VG8oMSxjKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZighZC5pc0V2ZW4oKSkgZC5zdWJUbyhtLGQpO1xuICAgICAgICAgIGQuclNoaWZ0VG8oMSxkKTtcbiAgICAgICAgfVxuICAgICAgICBpZih1LmNvbXBhcmVUbyh2KSA+PSAwKSB7XG4gICAgICAgICAgdS5zdWJUbyh2LHUpO1xuICAgICAgICAgIGlmKGFjKSBhLnN1YlRvKGMsYSk7XG4gICAgICAgICAgYi5zdWJUbyhkLGIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHYuc3ViVG8odSx2KTtcbiAgICAgICAgICBpZihhYykgYy5zdWJUbyhhLGMpO1xuICAgICAgICAgIGQuc3ViVG8oYixkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYodi5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDApIHJldHVybiBCaWdJbnRlZ2VyLlpFUk87XG4gICAgICBpZihkLmNvbXBhcmVUbyhtKSA+PSAwKSByZXR1cm4gZC5zdWJ0cmFjdChtKTtcbiAgICAgIGlmKGQuc2lnbnVtKCkgPCAwKSBkLmFkZFRvKG0sZCk7IGVsc2UgcmV0dXJuIGQ7XG4gICAgICBpZihkLnNpZ251bSgpIDwgMCkgcmV0dXJuIGQuYWRkKG0pOyBlbHNlIHJldHVybiBkO1xuICAgIH1cblxuICAgIHZhciBsb3dwcmltZXMgPSBbMiwzLDUsNywxMSwxMywxNywxOSwyMywyOSwzMSwzNyw0MSw0Myw0Nyw1Myw1OSw2MSw2Nyw3MSw3Myw3OSw4Myw4OSw5NywxMDEsMTAzLDEwNywxMDksMTEzLDEyNywxMzEsMTM3LDEzOSwxNDksMTUxLDE1NywxNjMsMTY3LDE3MywxNzksMTgxLDE5MSwxOTMsMTk3LDE5OSwyMTEsMjIzLDIyNywyMjksMjMzLDIzOSwyNDEsMjUxLDI1NywyNjMsMjY5LDI3MSwyNzcsMjgxLDI4MywyOTMsMzA3LDMxMSwzMTMsMzE3LDMzMSwzMzcsMzQ3LDM0OSwzNTMsMzU5LDM2NywzNzMsMzc5LDM4MywzODksMzk3LDQwMSw0MDksNDE5LDQyMSw0MzEsNDMzLDQzOSw0NDMsNDQ5LDQ1Nyw0NjEsNDYzLDQ2Nyw0NzksNDg3LDQ5MSw0OTksNTAzLDUwOSw1MjEsNTIzLDU0MSw1NDcsNTU3LDU2Myw1NjksNTcxLDU3Nyw1ODcsNTkzLDU5OSw2MDEsNjA3LDYxMyw2MTcsNjE5LDYzMSw2NDEsNjQzLDY0Nyw2NTMsNjU5LDY2MSw2NzMsNjc3LDY4Myw2OTEsNzAxLDcwOSw3MTksNzI3LDczMyw3MzksNzQzLDc1MSw3NTcsNzYxLDc2OSw3NzMsNzg3LDc5Nyw4MDksODExLDgyMSw4MjMsODI3LDgyOSw4MzksODUzLDg1Nyw4NTksODYzLDg3Nyw4ODEsODgzLDg4Nyw5MDcsOTExLDkxOSw5MjksOTM3LDk0MSw5NDcsOTUzLDk2Nyw5NzEsOTc3LDk4Myw5OTEsOTk3XTtcbiAgICB2YXIgbHBsaW0gPSAoMTw8MjYpL2xvd3ByaW1lc1tsb3dwcmltZXMubGVuZ3RoLTFdO1xuXG4gICAgLy8gKHB1YmxpYykgdGVzdCBwcmltYWxpdHkgd2l0aCBjZXJ0YWludHkgPj0gMS0uNV50XG4gICAgZnVuY3Rpb24gYm5Jc1Byb2JhYmxlUHJpbWUodCkge1xuICAgICAgdmFyIGksIHggPSB0aGlzLmFicygpO1xuICAgICAgaWYoeC50ID09IDEgJiYgeFswXSA8PSBsb3dwcmltZXNbbG93cHJpbWVzLmxlbmd0aC0xXSkge1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBsb3dwcmltZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYoeFswXSA9PSBsb3dwcmltZXNbaV0pIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZih4LmlzRXZlbigpKSByZXR1cm4gZmFsc2U7XG4gICAgICBpID0gMTtcbiAgICAgIHdoaWxlKGkgPCBsb3dwcmltZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBtID0gbG93cHJpbWVzW2ldLCBqID0gaSsxO1xuICAgICAgICB3aGlsZShqIDwgbG93cHJpbWVzLmxlbmd0aCAmJiBtIDwgbHBsaW0pIG0gKj0gbG93cHJpbWVzW2orK107XG4gICAgICAgIG0gPSB4Lm1vZEludChtKTtcbiAgICAgICAgd2hpbGUoaSA8IGopIGlmKG0lbG93cHJpbWVzW2krK10gPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHgubWlsbGVyUmFiaW4odCk7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgdHJ1ZSBpZiBwcm9iYWJseSBwcmltZSAoSEFDIDQuMjQsIE1pbGxlci1SYWJpbilcbiAgICBmdW5jdGlvbiBibnBNaWxsZXJSYWJpbih0KSB7XG4gICAgICB2YXIgbjEgPSB0aGlzLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICAgIHZhciBrID0gbjEuZ2V0TG93ZXN0U2V0Qml0KCk7XG4gICAgICBpZihrIDw9IDApIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciByID0gbjEuc2hpZnRSaWdodChrKTtcbiAgICAgIHQgPSAodCsxKT4+MTtcbiAgICAgIGlmKHQgPiBsb3dwcmltZXMubGVuZ3RoKSB0ID0gbG93cHJpbWVzLmxlbmd0aDtcbiAgICAgIHZhciBhID0gbmJpKCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdDsgKytpKSB7XG4gICAgICAgIC8vUGljayBiYXNlcyBhdCByYW5kb20sIGluc3RlYWQgb2Ygc3RhcnRpbmcgYXQgMlxuICAgICAgICBhLmZyb21JbnQobG93cHJpbWVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpsb3dwcmltZXMubGVuZ3RoKV0pO1xuICAgICAgICB2YXIgeSA9IGEubW9kUG93KHIsdGhpcyk7XG4gICAgICAgIGlmKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwICYmIHkuY29tcGFyZVRvKG4xKSAhPSAwKSB7XG4gICAgICAgICAgdmFyIGogPSAxO1xuICAgICAgICAgIHdoaWxlKGorKyA8IGsgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgICAgICAgIHkgPSB5Lm1vZFBvd0ludCgyLHRoaXMpO1xuICAgICAgICAgICAgaWYoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoeS5jb21wYXJlVG8objEpICE9IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gcHJvdGVjdGVkXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY2h1bmtTaXplID0gYm5wQ2h1bmtTaXplO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvUmFkaXggPSBibnBUb1JhZGl4O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21SYWRpeCA9IGJucEZyb21SYWRpeDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gYm5wRnJvbU51bWJlcjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXR3aXNlVG8gPSBibnBCaXR3aXNlVG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY2hhbmdlQml0ID0gYm5wQ2hhbmdlQml0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFkZFRvID0gYm5wQWRkVG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZE11bHRpcGx5ID0gYm5wRE11bHRpcGx5O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRBZGRPZmZzZXQgPSBibnBEQWRkT2Zmc2V0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5TG93ZXJUbyA9IGJucE11bHRpcGx5TG93ZXJUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVVwcGVyVG8gPSBibnBNdWx0aXBseVVwcGVyVG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW50ID0gYm5wTW9kSW50O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1pbGxlclJhYmluID0gYm5wTWlsbGVyUmFiaW47XG5cbiAgICAvLyBwdWJsaWNcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbG9uZSA9IGJuQ2xvbmU7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaW50VmFsdWUgPSBibkludFZhbHVlO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJ5dGVWYWx1ZSA9IGJuQnl0ZVZhbHVlO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNob3J0VmFsdWUgPSBiblNob3J0VmFsdWU7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2lnbnVtID0gYm5TaWdOdW07XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9CeXRlQXJyYXkgPSBiblRvQnl0ZUFycmF5O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IGJuRXF1YWxzO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1pbiA9IGJuTWluO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1heCA9IGJuTWF4O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGJuQW5kO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm9yID0gYm5PcjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS54b3IgPSBiblhvcjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmROb3QgPSBibkFuZE5vdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3QgPSBibk5vdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQgPSBiblNoaWZ0TGVmdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gYm5TaGlmdFJpZ2h0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdldExvd2VzdFNldEJpdCA9IGJuR2V0TG93ZXN0U2V0Qml0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdENvdW50ID0gYm5CaXRDb3VudDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50ZXN0Qml0ID0gYm5UZXN0Qml0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNldEJpdCA9IGJuU2V0Qml0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsZWFyQml0ID0gYm5DbGVhckJpdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mbGlwQml0ID0gYm5GbGlwQml0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFkZCA9IGJuQWRkO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0ID0gYm5TdWJ0cmFjdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGJuTXVsdGlwbHk7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlID0gYm5EaXZpZGU7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyID0gYm5SZW1haW5kZXI7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlQW5kUmVtYWluZGVyID0gYm5EaXZpZGVBbmRSZW1haW5kZXI7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93ID0gYm5Nb2RQb3c7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52ZXJzZSA9IGJuTW9kSW52ZXJzZTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBiblBvdztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nY2QgPSBibkdDRDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBibklzUHJvYmFibGVQcmltZTtcblxuICAgIC8vIEpTQk4tc3BlY2lmaWMgZXh0ZW5zaW9uXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlID0gYm5TcXVhcmU7XG5cbiAgICAvLyBFeHBvc2UgdGhlIEJhcnJldHQgZnVuY3Rpb25cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5CYXJyZXR0ID0gQmFycmV0dFxuXG4gICAgLy8gQmlnSW50ZWdlciBpbnRlcmZhY2VzIG5vdCBpbXBsZW1lbnRlZCBpbiBqc2JuOlxuXG4gICAgLy8gQmlnSW50ZWdlcihpbnQgc2lnbnVtLCBieXRlW10gbWFnbml0dWRlKVxuICAgIC8vIGRvdWJsZSBkb3VibGVWYWx1ZSgpXG4gICAgLy8gZmxvYXQgZmxvYXRWYWx1ZSgpXG4gICAgLy8gaW50IGhhc2hDb2RlKClcbiAgICAvLyBsb25nIGxvbmdWYWx1ZSgpXG4gICAgLy8gc3RhdGljIEJpZ0ludGVnZXIgdmFsdWVPZihsb25nIHZhbClcblxuXHQvLyBSYW5kb20gbnVtYmVyIGdlbmVyYXRvciAtIHJlcXVpcmVzIGEgUFJORyBiYWNrZW5kLCBlLmcuIHBybmc0LmpzXG5cblx0Ly8gRm9yIGJlc3QgcmVzdWx0cywgcHV0IGNvZGUgbGlrZVxuXHQvLyA8Ym9keSBvbkNsaWNrPSdybmdfc2VlZF90aW1lKCk7JyBvbktleVByZXNzPSdybmdfc2VlZF90aW1lKCk7Jz5cblx0Ly8gaW4geW91ciBtYWluIEhUTUwgZG9jdW1lbnQuXG5cblx0dmFyIHJuZ19zdGF0ZTtcblx0dmFyIHJuZ19wb29sO1xuXHR2YXIgcm5nX3BwdHI7XG5cblx0Ly8gTWl4IGluIGEgMzItYml0IGludGVnZXIgaW50byB0aGUgcG9vbFxuXHRmdW5jdGlvbiBybmdfc2VlZF9pbnQoeCkge1xuXHQgIHJuZ19wb29sW3JuZ19wcHRyKytdIF49IHggJiAyNTU7XG5cdCAgcm5nX3Bvb2xbcm5nX3BwdHIrK10gXj0gKHggPj4gOCkgJiAyNTU7XG5cdCAgcm5nX3Bvb2xbcm5nX3BwdHIrK10gXj0gKHggPj4gMTYpICYgMjU1O1xuXHQgIHJuZ19wb29sW3JuZ19wcHRyKytdIF49ICh4ID4+IDI0KSAmIDI1NTtcblx0ICBpZihybmdfcHB0ciA+PSBybmdfcHNpemUpIHJuZ19wcHRyIC09IHJuZ19wc2l6ZTtcblx0fVxuXG5cdC8vIE1peCBpbiB0aGUgY3VycmVudCB0aW1lICh3L21pbGxpc2Vjb25kcykgaW50byB0aGUgcG9vbFxuXHRmdW5jdGlvbiBybmdfc2VlZF90aW1lKCkge1xuXHQgIHJuZ19zZWVkX2ludChuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG5cdH1cblxuXHQvLyBJbml0aWFsaXplIHRoZSBwb29sIHdpdGgganVuayBpZiBuZWVkZWQuXG5cdGlmKHJuZ19wb29sID09IG51bGwpIHtcblx0ICBybmdfcG9vbCA9IG5ldyBBcnJheSgpO1xuXHQgIHJuZ19wcHRyID0gMDtcblx0ICB2YXIgdDtcblx0ICBpZih0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5jcnlwdG8pIHtcblx0XHRpZiAod2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcblx0XHQgIC8vIFVzZSB3ZWJjcnlwdG8gaWYgYXZhaWxhYmxlXG5cdFx0ICB2YXIgdWEgPSBuZXcgVWludDhBcnJheSgzMik7XG5cdFx0ICB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh1YSk7XG5cdFx0ICBmb3IodCA9IDA7IHQgPCAzMjsgKyt0KVxuXHRcdFx0cm5nX3Bvb2xbcm5nX3BwdHIrK10gPSB1YVt0XTtcblx0XHR9XG5cdFx0ZWxzZSBpZihuYXZpZ2F0b3IuYXBwTmFtZSA9PSBcIk5ldHNjYXBlXCIgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24gPCBcIjVcIikge1xuXHRcdCAgLy8gRXh0cmFjdCBlbnRyb3B5ICgyNTYgYml0cykgZnJvbSBOUzQgUk5HIGlmIGF2YWlsYWJsZVxuXHRcdCAgdmFyIHogPSB3aW5kb3cuY3J5cHRvLnJhbmRvbSgzMik7XG5cdFx0ICBmb3IodCA9IDA7IHQgPCB6Lmxlbmd0aDsgKyt0KVxuXHRcdFx0cm5nX3Bvb2xbcm5nX3BwdHIrK10gPSB6LmNoYXJDb2RlQXQodCkgJiAyNTU7XG5cdFx0fVxuXHQgIH1cblx0ICB3aGlsZShybmdfcHB0ciA8IHJuZ19wc2l6ZSkgeyAgLy8gZXh0cmFjdCBzb21lIHJhbmRvbW5lc3MgZnJvbSBNYXRoLnJhbmRvbSgpXG5cdFx0dCA9IE1hdGguZmxvb3IoNjU1MzYgKiBNYXRoLnJhbmRvbSgpKTtcblx0XHRybmdfcG9vbFtybmdfcHB0cisrXSA9IHQgPj4+IDg7XG5cdFx0cm5nX3Bvb2xbcm5nX3BwdHIrK10gPSB0ICYgMjU1O1xuXHQgIH1cblx0ICBybmdfcHB0ciA9IDA7XG5cdCAgcm5nX3NlZWRfdGltZSgpO1xuXHQgIC8vcm5nX3NlZWRfaW50KHdpbmRvdy5zY3JlZW5YKTtcblx0ICAvL3JuZ19zZWVkX2ludCh3aW5kb3cuc2NyZWVuWSk7XG5cdH1cblxuXHRmdW5jdGlvbiBybmdfZ2V0X2J5dGUoKSB7XG5cdCAgaWYocm5nX3N0YXRlID09IG51bGwpIHtcblx0XHRybmdfc2VlZF90aW1lKCk7XG5cdFx0cm5nX3N0YXRlID0gcHJuZ19uZXdzdGF0ZSgpO1xuXHRcdHJuZ19zdGF0ZS5pbml0KHJuZ19wb29sKTtcblx0XHRmb3Iocm5nX3BwdHIgPSAwOyBybmdfcHB0ciA8IHJuZ19wb29sLmxlbmd0aDsgKytybmdfcHB0cilcblx0XHQgIHJuZ19wb29sW3JuZ19wcHRyXSA9IDA7XG5cdFx0cm5nX3BwdHIgPSAwO1xuXHRcdC8vcm5nX3Bvb2wgPSBudWxsO1xuXHQgIH1cblx0ICAvLyBUT0RPOiBhbGxvdyByZXNlZWRpbmcgYWZ0ZXIgZmlyc3QgcmVxdWVzdFxuXHQgIHJldHVybiBybmdfc3RhdGUubmV4dCgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm5nX2dldF9ieXRlcyhiYSkge1xuXHQgIHZhciBpO1xuXHQgIGZvcihpID0gMDsgaSA8IGJhLmxlbmd0aDsgKytpKSBiYVtpXSA9IHJuZ19nZXRfYnl0ZSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gU2VjdXJlUmFuZG9tKCkge31cblxuXHRTZWN1cmVSYW5kb20ucHJvdG90eXBlLm5leHRCeXRlcyA9IHJuZ19nZXRfYnl0ZXM7XG5cblx0Ly8gcHJuZzQuanMgLSB1c2VzIEFyY2ZvdXIgYXMgYSBQUk5HXG5cblx0ZnVuY3Rpb24gQXJjZm91cigpIHtcblx0ICB0aGlzLmkgPSAwO1xuXHQgIHRoaXMuaiA9IDA7XG5cdCAgdGhpcy5TID0gbmV3IEFycmF5KCk7XG5cdH1cblxuXHQvLyBJbml0aWFsaXplIGFyY2ZvdXIgY29udGV4dCBmcm9tIGtleSwgYW4gYXJyYXkgb2YgaW50cywgZWFjaCBmcm9tIFswLi4yNTVdXG5cdGZ1bmN0aW9uIEFSQzRpbml0KGtleSkge1xuXHQgIHZhciBpLCBqLCB0O1xuXHQgIGZvcihpID0gMDsgaSA8IDI1NjsgKytpKVxuXHRcdHRoaXMuU1tpXSA9IGk7XG5cdCAgaiA9IDA7XG5cdCAgZm9yKGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcblx0XHRqID0gKGogKyB0aGlzLlNbaV0gKyBrZXlbaSAlIGtleS5sZW5ndGhdKSAmIDI1NTtcblx0XHR0ID0gdGhpcy5TW2ldO1xuXHRcdHRoaXMuU1tpXSA9IHRoaXMuU1tqXTtcblx0XHR0aGlzLlNbal0gPSB0O1xuXHQgIH1cblx0ICB0aGlzLmkgPSAwO1xuXHQgIHRoaXMuaiA9IDA7XG5cdH1cblxuXHRmdW5jdGlvbiBBUkM0bmV4dCgpIHtcblx0ICB2YXIgdDtcblx0ICB0aGlzLmkgPSAodGhpcy5pICsgMSkgJiAyNTU7XG5cdCAgdGhpcy5qID0gKHRoaXMuaiArIHRoaXMuU1t0aGlzLmldKSAmIDI1NTtcblx0ICB0ID0gdGhpcy5TW3RoaXMuaV07XG5cdCAgdGhpcy5TW3RoaXMuaV0gPSB0aGlzLlNbdGhpcy5qXTtcblx0ICB0aGlzLlNbdGhpcy5qXSA9IHQ7XG5cdCAgcmV0dXJuIHRoaXMuU1sodCArIHRoaXMuU1t0aGlzLmldKSAmIDI1NV07XG5cdH1cblxuXHRBcmNmb3VyLnByb3RvdHlwZS5pbml0ID0gQVJDNGluaXQ7XG5cdEFyY2ZvdXIucHJvdG90eXBlLm5leHQgPSBBUkM0bmV4dDtcblxuXHQvLyBQbHVnIGluIHlvdXIgUk5HIGNvbnN0cnVjdG9yIGhlcmVcblx0ZnVuY3Rpb24gcHJuZ19uZXdzdGF0ZSgpIHtcblx0ICByZXR1cm4gbmV3IEFyY2ZvdXIoKTtcblx0fVxuXG5cdC8vIFBvb2wgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCBhbmQgZ3JlYXRlciB0aGFuIDMyLlxuXHQvLyBBbiBhcnJheSBvZiBieXRlcyB0aGUgc2l6ZSBvZiB0aGUgcG9vbCB3aWxsIGJlIHBhc3NlZCB0byBpbml0KClcblx0dmFyIHJuZ19wc2l6ZSA9IDI1NjtcblxuICBCaWdJbnRlZ2VyLlNlY3VyZVJhbmRvbSA9IFNlY3VyZVJhbmRvbTtcbiAgQmlnSW50ZWdlci5CaWdJbnRlZ2VyID0gQmlnSW50ZWdlcjtcbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEJpZ0ludGVnZXI7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5CaWdJbnRlZ2VyID0gQmlnSW50ZWdlcjtcbiAgICB0aGlzLlNlY3VyZVJhbmRvbSA9IFNlY3VyZVJhbmRvbTtcbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sshpk/node_modules/jsbn/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sshpk/node_modules/jsbn/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/sshpk/node_modules/jsbn/index.js ***!
  \*******************************************************/
/***/ (function(module, exports) {

eval("(function(){\n\n    // Copyright (c) 2005  Tom Wu\n    // All Rights Reserved.\n    // See \"LICENSE\" for details.\n\n    // Basic JavaScript BN library - subset useful for RSA encryption.\n\n    // Bits per digit\n    var dbits;\n\n    // JavaScript engine analysis\n    var canary = 0xdeadbeefcafe;\n    var j_lm = ((canary&0xffffff)==0xefcafe);\n\n    // (public) Constructor\n    function BigInteger(a,b,c) {\n      if(a != null)\n        if(\"number\" == typeof a) this.fromNumber(a,b,c);\n        else if(b == null && \"string\" != typeof a) this.fromString(a,256);\n        else this.fromString(a,b);\n    }\n\n    // return new, unset BigInteger\n    function nbi() { return new BigInteger(null); }\n\n    // am: Compute w_j += (x*this_i), propagate carries,\n    // c is initial carry, returns final carry.\n    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n    // We need to select the fastest one that works in this environment.\n\n    // am1: use a single mult and divide to get the high bits,\n    // max digit bits should be 26 because\n    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n    function am1(i,x,w,j,c,n) {\n      while(--n >= 0) {\n        var v = x*this[i++]+w[j]+c;\n        c = Math.floor(v/0x4000000);\n        w[j++] = v&0x3ffffff;\n      }\n      return c;\n    }\n    // am2 avoids a big mult-and-extract completely.\n    // Max digit bits should be <= 30 because we do bitwise ops\n    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n    function am2(i,x,w,j,c,n) {\n      var xl = x&0x7fff, xh = x>>15;\n      while(--n >= 0) {\n        var l = this[i]&0x7fff;\n        var h = this[i++]>>15;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n        w[j++] = l&0x3fffffff;\n      }\n      return c;\n    }\n    // Alternately, set max digit bits to 28 since some\n    // browsers slow down when dealing with 32-bit numbers.\n    function am3(i,x,w,j,c,n) {\n      var xl = x&0x3fff, xh = x>>14;\n      while(--n >= 0) {\n        var l = this[i]&0x3fff;\n        var h = this[i++]>>14;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n        c = (l>>28)+(m>>14)+xh*h;\n        w[j++] = l&0xfffffff;\n      }\n      return c;\n    }\n    var inBrowser = typeof navigator !== \"undefined\";\n    if(inBrowser && j_lm && (navigator.appName == \"Microsoft Internet Explorer\")) {\n      BigInteger.prototype.am = am2;\n      dbits = 30;\n    }\n    else if(inBrowser && j_lm && (navigator.appName != \"Netscape\")) {\n      BigInteger.prototype.am = am1;\n      dbits = 26;\n    }\n    else { // Mozilla/Netscape seems to prefer am3\n      BigInteger.prototype.am = am3;\n      dbits = 28;\n    }\n\n    BigInteger.prototype.DB = dbits;\n    BigInteger.prototype.DM = ((1<<dbits)-1);\n    BigInteger.prototype.DV = (1<<dbits);\n\n    var BI_FP = 52;\n    BigInteger.prototype.FV = Math.pow(2,BI_FP);\n    BigInteger.prototype.F1 = BI_FP-dbits;\n    BigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n    // Digit conversions\n    var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n    var BI_RC = new Array();\n    var rr,vv;\n    rr = \"0\".charCodeAt(0);\n    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n    rr = \"a\".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n    rr = \"A\".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n    function int2char(n) { return BI_RM.charAt(n); }\n    function intAt(s,i) {\n      var c = BI_RC[s.charCodeAt(i)];\n      return (c==null)?-1:c;\n    }\n\n    // (protected) copy this to r\n    function bnpCopyTo(r) {\n      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n      r.t = this.t;\n      r.s = this.s;\n    }\n\n    // (protected) set from integer value x, -DV <= x < DV\n    function bnpFromInt(x) {\n      this.t = 1;\n      this.s = (x<0)?-1:0;\n      if(x > 0) this[0] = x;\n      else if(x < -1) this[0] = x+this.DV;\n      else this.t = 0;\n    }\n\n    // return bigint initialized to value\n    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n    // (protected) set from string and radix\n    function bnpFromString(s,b) {\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 256) k = 8; // byte array\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else { this.fromRadix(s,b); return; }\n      this.t = 0;\n      this.s = 0;\n      var i = s.length, mi = false, sh = 0;\n      while(--i >= 0) {\n        var x = (k==8)?s[i]&0xff:intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == \"-\") mi = true;\n          continue;\n        }\n        mi = false;\n        if(sh == 0)\n          this[this.t++] = x;\n        else if(sh+k > this.DB) {\n          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n          this[this.t++] = (x>>(this.DB-sh));\n        }\n        else\n          this[this.t-1] |= x<<sh;\n        sh += k;\n        if(sh >= this.DB) sh -= this.DB;\n      }\n      if(k == 8 && (s[0]&0x80) != 0) {\n        this.s = -1;\n        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n      }\n      this.clamp();\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) clamp off excess high words\n    function bnpClamp() {\n      var c = this.s&this.DM;\n      while(this.t > 0 && this[this.t-1] == c) --this.t;\n    }\n\n    // (public) return string representation in given radix\n    function bnToString(b) {\n      if(this.s < 0) return \"-\"+this.negate().toString(b);\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else return this.toRadix(b);\n      var km = (1<<k)-1, d, m = false, r = \"\", i = this.t;\n      var p = this.DB-(i*this.DB)%k;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n        while(i >= 0) {\n          if(p < k) {\n            d = (this[i]&((1<<p)-1))<<(k-p);\n            d |= this[--i]>>(p+=this.DB-k);\n          }\n          else {\n            d = (this[i]>>(p-=k))&km;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if(d > 0) m = true;\n          if(m) r += int2char(d);\n        }\n      }\n      return m?r:\"0\";\n    }\n\n    // (public) -this\n    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n    // (public) |this|\n    function bnAbs() { return (this.s<0)?this.negate():this; }\n\n    // (public) return + if this > a, - if this < a, 0 if equal\n    function bnCompareTo(a) {\n      var r = this.s-a.s;\n      if(r != 0) return r;\n      var i = this.t;\n      r = i-a.t;\n      if(r != 0) return (this.s<0)?-r:r;\n      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n      return 0;\n    }\n\n    // returns bit length of the integer x\n    function nbits(x) {\n      var r = 1, t;\n      if((t=x>>>16) != 0) { x = t; r += 16; }\n      if((t=x>>8) != 0) { x = t; r += 8; }\n      if((t=x>>4) != 0) { x = t; r += 4; }\n      if((t=x>>2) != 0) { x = t; r += 2; }\n      if((t=x>>1) != 0) { x = t; r += 1; }\n      return r;\n    }\n\n    // (public) return the number of bits in \"this\"\n    function bnBitLength() {\n      if(this.t <= 0) return 0;\n      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n    }\n\n    // (protected) r = this << n*DB\n    function bnpDLShiftTo(n,r) {\n      var i;\n      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n      for(i = n-1; i >= 0; --i) r[i] = 0;\n      r.t = this.t+n;\n      r.s = this.s;\n    }\n\n    // (protected) r = this >> n*DB\n    function bnpDRShiftTo(n,r) {\n      for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n      r.t = Math.max(this.t-n,0);\n      r.s = this.s;\n    }\n\n    // (protected) r = this << n\n    function bnpLShiftTo(n,r) {\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<cbs)-1;\n      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n      for(i = this.t-1; i >= 0; --i) {\n        r[i+ds+1] = (this[i]>>cbs)|c;\n        c = (this[i]&bm)<<bs;\n      }\n      for(i = ds-1; i >= 0; --i) r[i] = 0;\n      r[ds] = c;\n      r.t = this.t+ds+1;\n      r.s = this.s;\n      r.clamp();\n    }\n\n    // (protected) r = this >> n\n    function bnpRShiftTo(n,r) {\n      r.s = this.s;\n      var ds = Math.floor(n/this.DB);\n      if(ds >= this.t) { r.t = 0; return; }\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<bs)-1;\n      r[0] = this[ds]>>bs;\n      for(var i = ds+1; i < this.t; ++i) {\n        r[i-ds-1] |= (this[i]&bm)<<cbs;\n        r[i-ds] = this[i]>>bs;\n      }\n      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n      r.t = this.t-ds;\n      r.clamp();\n    }\n\n    // (protected) r = this - a\n    function bnpSubTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]-a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c -= a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c -= a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c -= a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c < -1) r[i++] = this.DV+c;\n      else if(c > 0) r[i++] = c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (protected) r = this * a, r != this,a (HAC 14.12)\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyTo(a,r) {\n      var x = this.abs(), y = a.abs();\n      var i = x.t;\n      r.t = i+y.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n      r.s = 0;\n      r.clamp();\n      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (protected) r = this^2, r != this (HAC 14.16)\n    function bnpSquareTo(r) {\n      var x = this.abs();\n      var i = r.t = 2*x.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < x.t-1; ++i) {\n        var c = x.am(i,x[i],r,2*i,0,1);\n        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n          r[i+x.t] -= x.DV;\n          r[i+x.t+1] = 1;\n        }\n      }\n      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n      r.s = 0;\n      r.clamp();\n    }\n\n    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n    // r != q, this != m.  q or r may be null.\n    function bnpDivRemTo(m,q,r) {\n      var pm = m.abs();\n      if(pm.t <= 0) return;\n      var pt = this.abs();\n      if(pt.t < pm.t) {\n        if(q != null) q.fromInt(0);\n        if(r != null) this.copyTo(r);\n        return;\n      }\n      if(r == null) r = nbi();\n      var y = nbi(), ts = this.s, ms = m.s;\n      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus\n      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n      else { pm.copyTo(y); pt.copyTo(r); }\n      var ys = y.t;\n      var y0 = y[ys-1];\n      if(y0 == 0) return;\n      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n      var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n      y.dlShiftTo(j,t);\n      if(r.compareTo(t) >= 0) {\n        r[r.t++] = 1;\n        r.subTo(t,r);\n      }\n      BigInteger.ONE.dlShiftTo(ys,t);\n      t.subTo(y,y);  // \"negative\" y so we can replace sub with am later\n      while(y.t < ys) y[y.t++] = 0;\n      while(--j >= 0) {\n        // Estimate quotient digit\n        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out\n          y.dlShiftTo(j,t);\n          r.subTo(t,r);\n          while(r[i] < --qd) r.subTo(t,r);\n        }\n      }\n      if(q != null) {\n        r.drShiftTo(ys,q);\n        if(ts != ms) BigInteger.ZERO.subTo(q,q);\n      }\n      r.t = ys;\n      r.clamp();\n      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder\n      if(ts < 0) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (public) this mod a\n    function bnMod(a) {\n      var r = nbi();\n      this.abs().divRemTo(a,null,r);\n      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n      return r;\n    }\n\n    // Modular reduction using \"classic\" algorithm\n    function Classic(m) { this.m = m; }\n    function cConvert(x) {\n      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n      else return x;\n    }\n    function cRevert(x) { return x; }\n    function cReduce(x) { x.divRemTo(this.m,null,x); }\n    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    Classic.prototype.convert = cConvert;\n    Classic.prototype.revert = cRevert;\n    Classic.prototype.reduce = cReduce;\n    Classic.prototype.mulTo = cMulTo;\n    Classic.prototype.sqrTo = cSqrTo;\n\n    // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n    // justification:\n    //         xy == 1 (mod m)\n    //         xy =  1+km\n    //   xy(2-xy) = (1+km)(1-km)\n    // x[y(2-xy)] = 1-k^2m^2\n    // x[y(2-xy)] == 1 (mod m^2)\n    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n    // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n    function bnpInvDigit() {\n      if(this.t < 1) return 0;\n      var x = this[0];\n      if((x&1) == 0) return 0;\n      var y = x&3;       // y == 1/x mod 2^2\n      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4\n      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8\n      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16\n      // last step - calculate inverse mod DV directly;\n      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits\n      // we really want the negative inverse, and -DV < y < DV\n      return (y>0)?this.DV-y:-y;\n    }\n\n    // Montgomery reduction\n    function Montgomery(m) {\n      this.m = m;\n      this.mp = m.invDigit();\n      this.mpl = this.mp&0x7fff;\n      this.mph = this.mp>>15;\n      this.um = (1<<(m.DB-15))-1;\n      this.mt2 = 2*m.t;\n    }\n\n    // xR mod m\n    function montConvert(x) {\n      var r = nbi();\n      x.abs().dlShiftTo(this.m.t,r);\n      r.divRemTo(this.m,null,r);\n      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n      return r;\n    }\n\n    // x/R mod m\n    function montRevert(x) {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n\n    // x = x/R mod m (HAC 14.32)\n    function montReduce(x) {\n      while(x.t <= this.mt2) // pad x so am has enough room later\n        x[x.t++] = 0;\n      for(var i = 0; i < this.m.t; ++i) {\n        // faster way of calculating u0 = x[i]*mp mod DV\n        var j = x[i]&0x7fff;\n        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n        // use am to combine the multiply-shift-add into one call\n        j = i+this.m.t;\n        x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n        // propagate carry\n        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n      }\n      x.clamp();\n      x.drShiftTo(this.m.t,x);\n      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = \"x^2/R mod m\"; x != r\n    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = \"xy/R mod m\"; x,y != r\n    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Montgomery.prototype.convert = montConvert;\n    Montgomery.prototype.revert = montRevert;\n    Montgomery.prototype.reduce = montReduce;\n    Montgomery.prototype.mulTo = montMulTo;\n    Montgomery.prototype.sqrTo = montSqrTo;\n\n    // (protected) true iff this is even\n    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n    // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n    function bnpExp(e,z) {\n      if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n      g.copyTo(r);\n      while(--i >= 0) {\n        z.sqrTo(r,r2);\n        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n        else { var t = r; r = r2; r2 = t; }\n      }\n      return z.revert(r);\n    }\n\n    // (public) this^e % m, 0 <= e < 2^32\n    function bnModPowInt(e,m) {\n      var z;\n      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n      return this.exp(e,z);\n    }\n\n    // protected\n    BigInteger.prototype.copyTo = bnpCopyTo;\n    BigInteger.prototype.fromInt = bnpFromInt;\n    BigInteger.prototype.fromString = bnpFromString;\n    BigInteger.prototype.clamp = bnpClamp;\n    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n    BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n    BigInteger.prototype.lShiftTo = bnpLShiftTo;\n    BigInteger.prototype.rShiftTo = bnpRShiftTo;\n    BigInteger.prototype.subTo = bnpSubTo;\n    BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n    BigInteger.prototype.squareTo = bnpSquareTo;\n    BigInteger.prototype.divRemTo = bnpDivRemTo;\n    BigInteger.prototype.invDigit = bnpInvDigit;\n    BigInteger.prototype.isEven = bnpIsEven;\n    BigInteger.prototype.exp = bnpExp;\n\n    // public\n    BigInteger.prototype.toString = bnToString;\n    BigInteger.prototype.negate = bnNegate;\n    BigInteger.prototype.abs = bnAbs;\n    BigInteger.prototype.compareTo = bnCompareTo;\n    BigInteger.prototype.bitLength = bnBitLength;\n    BigInteger.prototype.mod = bnMod;\n    BigInteger.prototype.modPowInt = bnModPowInt;\n\n    // \"constants\"\n    BigInteger.ZERO = nbv(0);\n    BigInteger.ONE = nbv(1);\n\n    // Copyright (c) 2005-2009  Tom Wu\n    // All Rights Reserved.\n    // See \"LICENSE\" for details.\n\n    // Extended JavaScript BN functions, required for RSA private ops.\n\n    // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n    // Version 1.2: square() API, isProbablePrime fix\n\n    // (public)\n    function bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n    // (public) return value as integer\n    function bnIntValue() {\n      if(this.s < 0) {\n        if(this.t == 1) return this[0]-this.DV;\n        else if(this.t == 0) return -1;\n      }\n      else if(this.t == 1) return this[0];\n      else if(this.t == 0) return 0;\n      // assumes 16 < DB < 32\n      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n    }\n\n    // (public) return value as byte\n    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n    // (public) return value as short (assumes DB>=16)\n    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n    // (protected) return x s.t. r^x < DV\n    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n    // (public) 0 if this == 0, 1 if this > 0\n    function bnSigNum() {\n      if(this.s < 0) return -1;\n      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n      else return 1;\n    }\n\n    // (protected) convert to radix string\n    function bnpToRadix(b) {\n      if(b == null) b = 10;\n      if(this.signum() == 0 || b < 2 || b > 36) return \"0\";\n      var cs = this.chunkSize(b);\n      var a = Math.pow(b,cs);\n      var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\n      this.divRemTo(d,y,z);\n      while(y.signum() > 0) {\n        r = (a+z.intValue()).toString(b).substr(1) + r;\n        y.divRemTo(d,y,z);\n      }\n      return z.intValue().toString(b) + r;\n    }\n\n    // (protected) convert from radix string\n    function bnpFromRadix(s,b) {\n      this.fromInt(0);\n      if(b == null) b = 10;\n      var cs = this.chunkSize(b);\n      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n      for(var i = 0; i < s.length; ++i) {\n        var x = intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n          continue;\n        }\n        w = b*w+x;\n        if(++j >= cs) {\n          this.dMultiply(d);\n          this.dAddOffset(w,0);\n          j = 0;\n          w = 0;\n        }\n      }\n      if(j > 0) {\n        this.dMultiply(Math.pow(b,j));\n        this.dAddOffset(w,0);\n      }\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) alternate constructor\n    function bnpFromNumber(a,b,c) {\n      if(\"number\" == typeof b) {\n        // new BigInteger(int,int,RNG)\n        if(a < 2) this.fromInt(1);\n        else {\n          this.fromNumber(a,c);\n          if(!this.testBit(a-1))\t// force MSB set\n            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n          if(this.isEven()) this.dAddOffset(1,0); // force odd\n          while(!this.isProbablePrime(b)) {\n            this.dAddOffset(2,0);\n            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n          }\n        }\n      }\n      else {\n        // new BigInteger(int,RNG)\n        var x = new Array(), t = a&7;\n        x.length = (a>>3)+1;\n        b.nextBytes(x);\n        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n        this.fromString(x,256);\n      }\n    }\n\n    // (public) convert to bigendian byte array\n    function bnToByteArray() {\n      var i = this.t, r = new Array();\n      r[0] = this.s;\n      var p = this.DB-(i*this.DB)%8, d, k = 0;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n          r[k++] = d|(this.s<<(this.DB-p));\n        while(i >= 0) {\n          if(p < 8) {\n            d = (this[i]&((1<<p)-1))<<(8-p);\n            d |= this[--i]>>(p+=this.DB-8);\n          }\n          else {\n            d = (this[i]>>(p-=8))&0xff;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if((d&0x80) != 0) d |= -256;\n          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n          if(k > 0 || d != this.s) r[k++] = d;\n        }\n      }\n      return r;\n    }\n\n    function bnEquals(a) { return(this.compareTo(a)==0); }\n    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }\n    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n    // (protected) r = this op a (bitwise)\n    function bnpBitwiseTo(a,op,r) {\n      var i, f, m = Math.min(a.t,this.t);\n      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n      if(a.t < this.t) {\n        f = a.s&this.DM;\n        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n        r.t = this.t;\n      }\n      else {\n        f = this.s&this.DM;\n        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n        r.t = a.t;\n      }\n      r.s = op(this.s,a.s);\n      r.clamp();\n    }\n\n    // (public) this & a\n    function op_and(x,y) { return x&y; }\n    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n    // (public) this | a\n    function op_or(x,y) { return x|y; }\n    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n    // (public) this ^ a\n    function op_xor(x,y) { return x^y; }\n    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n    // (public) this & ~a\n    function op_andnot(x,y) { return x&~y; }\n    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n    // (public) ~this\n    function bnNot() {\n      var r = nbi();\n      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n      r.t = this.t;\n      r.s = ~this.s;\n      return r;\n    }\n\n    // (public) this << n\n    function bnShiftLeft(n) {\n      var r = nbi();\n      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n      return r;\n    }\n\n    // (public) this >> n\n    function bnShiftRight(n) {\n      var r = nbi();\n      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n      return r;\n    }\n\n    // return index of lowest 1-bit in x, x < 2^31\n    function lbit(x) {\n      if(x == 0) return -1;\n      var r = 0;\n      if((x&0xffff) == 0) { x >>= 16; r += 16; }\n      if((x&0xff) == 0) { x >>= 8; r += 8; }\n      if((x&0xf) == 0) { x >>= 4; r += 4; }\n      if((x&3) == 0) { x >>= 2; r += 2; }\n      if((x&1) == 0) ++r;\n      return r;\n    }\n\n    // (public) returns index of lowest 1-bit (or -1 if none)\n    function bnGetLowestSetBit() {\n      for(var i = 0; i < this.t; ++i)\n        if(this[i] != 0) return i*this.DB+lbit(this[i]);\n      if(this.s < 0) return this.t*this.DB;\n      return -1;\n    }\n\n    // return number of 1 bits in x\n    function cbit(x) {\n      var r = 0;\n      while(x != 0) { x &= x-1; ++r; }\n      return r;\n    }\n\n    // (public) return number of set bits\n    function bnBitCount() {\n      var r = 0, x = this.s&this.DM;\n      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n      return r;\n    }\n\n    // (public) true iff nth bit is set\n    function bnTestBit(n) {\n      var j = Math.floor(n/this.DB);\n      if(j >= this.t) return(this.s!=0);\n      return((this[j]&(1<<(n%this.DB)))!=0);\n    }\n\n    // (protected) this op (1<<n)\n    function bnpChangeBit(n,op) {\n      var r = BigInteger.ONE.shiftLeft(n);\n      this.bitwiseTo(r,op,r);\n      return r;\n    }\n\n    // (public) this | (1<<n)\n    function bnSetBit(n) { return this.changeBit(n,op_or); }\n\n    // (public) this & ~(1<<n)\n    function bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n    // (public) this ^ (1<<n)\n    function bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n    // (protected) r = this + a\n    function bnpAddTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]+a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c += a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c += a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c > 0) r[i++] = c;\n      else if(c < -1) r[i++] = this.DV+c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (public) this + a\n    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n    // (public) this - a\n    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n    // (public) this * a\n    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n    // (public) this^2\n    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n    // (public) this / a\n    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n    // (public) this % a\n    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n    // (public) [this/a,this%a]\n    function bnDivideAndRemainder(a) {\n      var q = nbi(), r = nbi();\n      this.divRemTo(a,q,r);\n      return new Array(q,r);\n    }\n\n    // (protected) this *= n, this >= 0, 1 < n < DV\n    function bnpDMultiply(n) {\n      this[this.t] = this.am(0,n-1,this,0,0,this.t);\n      ++this.t;\n      this.clamp();\n    }\n\n    // (protected) this += n << w words, this >= 0\n    function bnpDAddOffset(n,w) {\n      if(n == 0) return;\n      while(this.t <= w) this[this.t++] = 0;\n      this[w] += n;\n      while(this[w] >= this.DV) {\n        this[w] -= this.DV;\n        if(++w >= this.t) this[this.t++] = 0;\n        ++this[w];\n      }\n    }\n\n    // A \"null\" reducer\n    function NullExp() {}\n    function nNop(x) { return x; }\n    function nMulTo(x,y,r) { x.multiplyTo(y,r); }\n    function nSqrTo(x,r) { x.squareTo(r); }\n\n    NullExp.prototype.convert = nNop;\n    NullExp.prototype.revert = nNop;\n    NullExp.prototype.mulTo = nMulTo;\n    NullExp.prototype.sqrTo = nSqrTo;\n\n    // (public) this^e\n    function bnPow(e) { return this.exp(e,new NullExp()); }\n\n    // (protected) r = lower n words of \"this * a\", a.t <= n\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyLowerTo(a,n,r) {\n      var i = Math.min(this.t+a.t,n);\n      r.s = 0; // assumes a,this >= 0\n      r.t = i;\n      while(i > 0) r[--i] = 0;\n      var j;\n      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n      r.clamp();\n    }\n\n    // (protected) r = \"this * a\" without lower n words, n > 0\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyUpperTo(a,n,r) {\n      --n;\n      var i = r.t = this.t+a.t-n;\n      r.s = 0; // assumes a,this >= 0\n      while(--i >= 0) r[i] = 0;\n      for(i = Math.max(n-this.t,0); i < a.t; ++i)\n        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n      r.clamp();\n      r.drShiftTo(1,r);\n    }\n\n    // Barrett modular reduction\n    function Barrett(m) {\n      // setup Barrett\n      this.r2 = nbi();\n      this.q3 = nbi();\n      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n      this.mu = this.r2.divide(m);\n      this.m = m;\n    }\n\n    function barrettConvert(x) {\n      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n      else if(x.compareTo(this.m) < 0) return x;\n      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n    }\n\n    function barrettRevert(x) { return x; }\n\n    // x = x mod m (HAC 14.42)\n    function barrettReduce(x) {\n      x.drShiftTo(this.m.t-1,this.r2);\n      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n      x.subTo(this.r2,x);\n      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = x^2 mod m; x != r\n    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = x*y mod m; x,y != r\n    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Barrett.prototype.convert = barrettConvert;\n    Barrett.prototype.revert = barrettRevert;\n    Barrett.prototype.reduce = barrettReduce;\n    Barrett.prototype.mulTo = barrettMulTo;\n    Barrett.prototype.sqrTo = barrettSqrTo;\n\n    // (public) this^e % m (HAC 14.85)\n    function bnModPow(e,m) {\n      var i = e.bitLength(), k, r = nbv(1), z;\n      if(i <= 0) return r;\n      else if(i < 18) k = 1;\n      else if(i < 48) k = 3;\n      else if(i < 144) k = 4;\n      else if(i < 768) k = 5;\n      else k = 6;\n      if(i < 8)\n        z = new Classic(m);\n      else if(m.isEven())\n        z = new Barrett(m);\n      else\n        z = new Montgomery(m);\n\n      // precomputation\n      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n      g[1] = z.convert(this);\n      if(k > 1) {\n        var g2 = nbi();\n        z.sqrTo(g[1],g2);\n        while(n <= km) {\n          g[n] = nbi();\n          z.mulTo(g2,g[n-2],g[n]);\n          n += 2;\n        }\n      }\n\n      var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n      i = nbits(e[j])-1;\n      while(j >= 0) {\n        if(i >= k1) w = (e[j]>>(i-k1))&km;\n        else {\n          w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n        }\n\n        n = k;\n        while((w&1) == 0) { w >>= 1; --n; }\n        if((i -= n) < 0) { i += this.DB; --j; }\n        if(is1) {\t// ret == 1, don't bother squaring or multiplying it\n          g[w].copyTo(r);\n          is1 = false;\n        }\n        else {\n          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n          z.mulTo(r2,g[w],r);\n        }\n\n        while(j >= 0 && (e[j]&(1<<i)) == 0) {\n          z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n          if(--i < 0) { i = this.DB-1; --j; }\n        }\n      }\n      return z.revert(r);\n    }\n\n    // (public) gcd(this,a) (HAC 14.54)\n    function bnGCD(a) {\n      var x = (this.s<0)?this.negate():this.clone();\n      var y = (a.s<0)?a.negate():a.clone();\n      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n      var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n      if(g < 0) return x;\n      if(i < g) g = i;\n      if(g > 0) {\n        x.rShiftTo(g,x);\n        y.rShiftTo(g,y);\n      }\n      while(x.signum() > 0) {\n        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n        if(x.compareTo(y) >= 0) {\n          x.subTo(y,x);\n          x.rShiftTo(1,x);\n        }\n        else {\n          y.subTo(x,y);\n          y.rShiftTo(1,y);\n        }\n      }\n      if(g > 0) y.lShiftTo(g,y);\n      return y;\n    }\n\n    // (protected) this % n, n < 2^26\n    function bnpModInt(n) {\n      if(n <= 0) return 0;\n      var d = this.DV%n, r = (this.s<0)?n-1:0;\n      if(this.t > 0)\n        if(d == 0) r = this[0]%n;\n        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n      return r;\n    }\n\n    // (public) 1/this % m (HAC 14.61)\n    function bnModInverse(m) {\n      var ac = m.isEven();\n      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n      var u = m.clone(), v = this.clone();\n      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n      while(u.signum() != 0) {\n        while(u.isEven()) {\n          u.rShiftTo(1,u);\n          if(ac) {\n            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n            a.rShiftTo(1,a);\n          }\n          else if(!b.isEven()) b.subTo(m,b);\n          b.rShiftTo(1,b);\n        }\n        while(v.isEven()) {\n          v.rShiftTo(1,v);\n          if(ac) {\n            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n            c.rShiftTo(1,c);\n          }\n          else if(!d.isEven()) d.subTo(m,d);\n          d.rShiftTo(1,d);\n        }\n        if(u.compareTo(v) >= 0) {\n          u.subTo(v,u);\n          if(ac) a.subTo(c,a);\n          b.subTo(d,b);\n        }\n        else {\n          v.subTo(u,v);\n          if(ac) c.subTo(a,c);\n          d.subTo(b,d);\n        }\n      }\n      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n      if(d.compareTo(m) >= 0) return d.subtract(m);\n      if(d.signum() < 0) d.addTo(m,d); else return d;\n      if(d.signum() < 0) return d.add(m); else return d;\n    }\n\n    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\n    var lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n    // (public) test primality with certainty >= 1-.5^t\n    function bnIsProbablePrime(t) {\n      var i, x = this.abs();\n      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n        for(i = 0; i < lowprimes.length; ++i)\n          if(x[0] == lowprimes[i]) return true;\n        return false;\n      }\n      if(x.isEven()) return false;\n      i = 1;\n      while(i < lowprimes.length) {\n        var m = lowprimes[i], j = i+1;\n        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n        m = x.modInt(m);\n        while(i < j) if(m%lowprimes[i++] == 0) return false;\n      }\n      return x.millerRabin(t);\n    }\n\n    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n    function bnpMillerRabin(t) {\n      var n1 = this.subtract(BigInteger.ONE);\n      var k = n1.getLowestSetBit();\n      if(k <= 0) return false;\n      var r = n1.shiftRight(k);\n      t = (t+1)>>1;\n      if(t > lowprimes.length) t = lowprimes.length;\n      var a = nbi();\n      for(var i = 0; i < t; ++i) {\n        //Pick bases at random, instead of starting at 2\n        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n        var y = a.modPow(r,this);\n        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n          var j = 1;\n          while(j++ < k && y.compareTo(n1) != 0) {\n            y = y.modPowInt(2,this);\n            if(y.compareTo(BigInteger.ONE) == 0) return false;\n          }\n          if(y.compareTo(n1) != 0) return false;\n        }\n      }\n      return true;\n    }\n\n    // protected\n    BigInteger.prototype.chunkSize = bnpChunkSize;\n    BigInteger.prototype.toRadix = bnpToRadix;\n    BigInteger.prototype.fromRadix = bnpFromRadix;\n    BigInteger.prototype.fromNumber = bnpFromNumber;\n    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n    BigInteger.prototype.changeBit = bnpChangeBit;\n    BigInteger.prototype.addTo = bnpAddTo;\n    BigInteger.prototype.dMultiply = bnpDMultiply;\n    BigInteger.prototype.dAddOffset = bnpDAddOffset;\n    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n    BigInteger.prototype.modInt = bnpModInt;\n    BigInteger.prototype.millerRabin = bnpMillerRabin;\n\n    // public\n    BigInteger.prototype.clone = bnClone;\n    BigInteger.prototype.intValue = bnIntValue;\n    BigInteger.prototype.byteValue = bnByteValue;\n    BigInteger.prototype.shortValue = bnShortValue;\n    BigInteger.prototype.signum = bnSigNum;\n    BigInteger.prototype.toByteArray = bnToByteArray;\n    BigInteger.prototype.equals = bnEquals;\n    BigInteger.prototype.min = bnMin;\n    BigInteger.prototype.max = bnMax;\n    BigInteger.prototype.and = bnAnd;\n    BigInteger.prototype.or = bnOr;\n    BigInteger.prototype.xor = bnXor;\n    BigInteger.prototype.andNot = bnAndNot;\n    BigInteger.prototype.not = bnNot;\n    BigInteger.prototype.shiftLeft = bnShiftLeft;\n    BigInteger.prototype.shiftRight = bnShiftRight;\n    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n    BigInteger.prototype.bitCount = bnBitCount;\n    BigInteger.prototype.testBit = bnTestBit;\n    BigInteger.prototype.setBit = bnSetBit;\n    BigInteger.prototype.clearBit = bnClearBit;\n    BigInteger.prototype.flipBit = bnFlipBit;\n    BigInteger.prototype.add = bnAdd;\n    BigInteger.prototype.subtract = bnSubtract;\n    BigInteger.prototype.multiply = bnMultiply;\n    BigInteger.prototype.divide = bnDivide;\n    BigInteger.prototype.remainder = bnRemainder;\n    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n    BigInteger.prototype.modPow = bnModPow;\n    BigInteger.prototype.modInverse = bnModInverse;\n    BigInteger.prototype.pow = bnPow;\n    BigInteger.prototype.gcd = bnGCD;\n    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n    // JSBN-specific extension\n    BigInteger.prototype.square = bnSquare;\n\n    // Expose the Barrett function\n    BigInteger.prototype.Barrett = Barrett\n\n    // BigInteger interfaces not implemented in jsbn:\n\n    // BigInteger(int signum, byte[] magnitude)\n    // double doubleValue()\n    // float floatValue()\n    // int hashCode()\n    // long longValue()\n    // static BigInteger valueOf(long val)\n\n\t// Random number generator - requires a PRNG backend, e.g. prng4.js\n\n\t// For best results, put code like\n\t// <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>\n\t// in your main HTML document.\n\n\tvar rng_state;\n\tvar rng_pool;\n\tvar rng_pptr;\n\n\t// Mix in a 32-bit integer into the pool\n\tfunction rng_seed_int(x) {\n\t  rng_pool[rng_pptr++] ^= x & 255;\n\t  rng_pool[rng_pptr++] ^= (x >> 8) & 255;\n\t  rng_pool[rng_pptr++] ^= (x >> 16) & 255;\n\t  rng_pool[rng_pptr++] ^= (x >> 24) & 255;\n\t  if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;\n\t}\n\n\t// Mix in the current time (w/milliseconds) into the pool\n\tfunction rng_seed_time() {\n\t  rng_seed_int(new Date().getTime());\n\t}\n\n\t// Initialize the pool with junk if needed.\n\tif(rng_pool == null) {\n\t  rng_pool = new Array();\n\t  rng_pptr = 0;\n\t  var t;\n\t  if(typeof window !== \"undefined\" && window.crypto) {\n\t\tif (window.crypto.getRandomValues) {\n\t\t  // Use webcrypto if available\n\t\t  var ua = new Uint8Array(32);\n\t\t  window.crypto.getRandomValues(ua);\n\t\t  for(t = 0; t < 32; ++t)\n\t\t\trng_pool[rng_pptr++] = ua[t];\n\t\t}\n\t\telse if(navigator.appName == \"Netscape\" && navigator.appVersion < \"5\") {\n\t\t  // Extract entropy (256 bits) from NS4 RNG if available\n\t\t  var z = window.crypto.random(32);\n\t\t  for(t = 0; t < z.length; ++t)\n\t\t\trng_pool[rng_pptr++] = z.charCodeAt(t) & 255;\n\t\t}\n\t  }\n\t  while(rng_pptr < rng_psize) {  // extract some randomness from Math.random()\n\t\tt = Math.floor(65536 * Math.random());\n\t\trng_pool[rng_pptr++] = t >>> 8;\n\t\trng_pool[rng_pptr++] = t & 255;\n\t  }\n\t  rng_pptr = 0;\n\t  rng_seed_time();\n\t  //rng_seed_int(window.screenX);\n\t  //rng_seed_int(window.screenY);\n\t}\n\n\tfunction rng_get_byte() {\n\t  if(rng_state == null) {\n\t\trng_seed_time();\n\t\trng_state = prng_newstate();\n\t\trng_state.init(rng_pool);\n\t\tfor(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)\n\t\t  rng_pool[rng_pptr] = 0;\n\t\trng_pptr = 0;\n\t\t//rng_pool = null;\n\t  }\n\t  // TODO: allow reseeding after first request\n\t  return rng_state.next();\n\t}\n\n\tfunction rng_get_bytes(ba) {\n\t  var i;\n\t  for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();\n\t}\n\n\tfunction SecureRandom() {}\n\n\tSecureRandom.prototype.nextBytes = rng_get_bytes;\n\n\t// prng4.js - uses Arcfour as a PRNG\n\n\tfunction Arcfour() {\n\t  this.i = 0;\n\t  this.j = 0;\n\t  this.S = new Array();\n\t}\n\n\t// Initialize arcfour context from key, an array of ints, each from [0..255]\n\tfunction ARC4init(key) {\n\t  var i, j, t;\n\t  for(i = 0; i < 256; ++i)\n\t\tthis.S[i] = i;\n\t  j = 0;\n\t  for(i = 0; i < 256; ++i) {\n\t\tj = (j + this.S[i] + key[i % key.length]) & 255;\n\t\tt = this.S[i];\n\t\tthis.S[i] = this.S[j];\n\t\tthis.S[j] = t;\n\t  }\n\t  this.i = 0;\n\t  this.j = 0;\n\t}\n\n\tfunction ARC4next() {\n\t  var t;\n\t  this.i = (this.i + 1) & 255;\n\t  this.j = (this.j + this.S[this.i]) & 255;\n\t  t = this.S[this.i];\n\t  this.S[this.i] = this.S[this.j];\n\t  this.S[this.j] = t;\n\t  return this.S[(t + this.S[this.i]) & 255];\n\t}\n\n\tArcfour.prototype.init = ARC4init;\n\tArcfour.prototype.next = ARC4next;\n\n\t// Plug in your RNG constructor here\n\tfunction prng_newstate() {\n\t  return new Arcfour();\n\t}\n\n\t// Pool size must be a multiple of 4 and greater than 32.\n\t// An array of bytes the size of the pool will be passed to init()\n\tvar rng_psize = 256;\n\n  BigInteger.SecureRandom = SecureRandom;\n  BigInteger.BigInteger = BigInteger;\n  if (true) {\n    exports = module.exports = BigInteger;\n  } else {}\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3NocGsvbm9kZV9tb2R1bGVzL2pzYm4vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0EsaUJBQWlCLFNBQVM7O0FBRTFCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZUFBZSxjQUFjOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsVUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGVBQWUsK0JBQStCOztBQUV4RTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkMsMEJBQTBCLE9BQU87QUFDakMsMEJBQTBCLE9BQU87QUFDakMsMEJBQTBCLE9BQU87QUFDakMsMEJBQTBCLE9BQU87QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0Msb0JBQW9CLG9CQUFvQjtBQUN4QyxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsNkJBQTZCLG1CQUFtQjtBQUNoRCwyQkFBMkIsZUFBZTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsaUNBQWlDO0FBQ2pDLHFDQUFxQztBQUNyQyxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLDhCQUE4QixlQUFlOztBQUU3Qyx5QkFBeUI7QUFDekIsZ0NBQWdDLG1CQUFtQjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVyxRQUFRO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixlQUFlLGdCQUFnQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0Isd0JBQXdCO0FBQ3hCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQix3QkFBd0IsZUFBZSw0QkFBNEI7O0FBRW5FO0FBQ0EsMEJBQTBCO0FBQzFCLHVCQUF1QixlQUFlLDJCQUEyQjs7QUFFakU7QUFDQSwyQkFBMkI7QUFDM0Isd0JBQXdCLGVBQWUsNEJBQTRCOztBQUVuRTtBQUNBLDhCQUE4QjtBQUM5QiwyQkFBMkIsZUFBZSwrQkFBK0I7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEMsMEJBQTBCLFNBQVM7QUFDbkMseUJBQXlCLFNBQVM7QUFDbEMsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGVBQWUsaUJBQWlCOztBQUV4RDtBQUNBLDZCQUE2QixlQUFlLGlCQUFpQjs7QUFFN0Q7QUFDQSw2QkFBNkIsZUFBZSxzQkFBc0I7O0FBRWxFO0FBQ0EsMEJBQTBCLGVBQWUsa0JBQWtCOztBQUUzRDtBQUNBLDJCQUEyQixlQUFlLHlCQUF5Qjs7QUFFbkU7QUFDQSw4QkFBOEIsZUFBZSx5QkFBeUI7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDZCQUE2QjtBQUM3QiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQywrQkFBK0IsT0FBTztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlLGFBQWEsZ0JBQWdCO0FBQ3pEOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLGlDQUFpQyxlQUFlOztBQUVoRCxzQkFBc0I7QUFDdEIsbUNBQW1DLG1CQUFtQjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsU0FBUztBQUNyQywyQkFBMkIsY0FBYztBQUN6QyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZSxlQUFlO0FBQ3ZELG1DQUFtQyxPQUFPLE9BQU8sUUFBUTtBQUN6RDtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLE9BQU8sUUFBUTtBQUN4Qyx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1DQUFtQyw4QkFBOEI7QUFDakU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxJQUE4QjtBQUNwQztBQUNBLElBQUksS0FBSyxFQUdOOztBQUVILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL3NzaHBrL25vZGVfbW9kdWxlcy9qc2JuL2luZGV4LmpzPzcwY2UiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XG5cbiAgICAvLyBDb3B5cmlnaHQgKGMpIDIwMDUgIFRvbSBXdVxuICAgIC8vIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgLy8gU2VlIFwiTElDRU5TRVwiIGZvciBkZXRhaWxzLlxuXG4gICAgLy8gQmFzaWMgSmF2YVNjcmlwdCBCTiBsaWJyYXJ5IC0gc3Vic2V0IHVzZWZ1bCBmb3IgUlNBIGVuY3J5cHRpb24uXG5cbiAgICAvLyBCaXRzIHBlciBkaWdpdFxuICAgIHZhciBkYml0cztcblxuICAgIC8vIEphdmFTY3JpcHQgZW5naW5lIGFuYWx5c2lzXG4gICAgdmFyIGNhbmFyeSA9IDB4ZGVhZGJlZWZjYWZlO1xuICAgIHZhciBqX2xtID0gKChjYW5hcnkmMHhmZmZmZmYpPT0weGVmY2FmZSk7XG5cbiAgICAvLyAocHVibGljKSBDb25zdHJ1Y3RvclxuICAgIGZ1bmN0aW9uIEJpZ0ludGVnZXIoYSxiLGMpIHtcbiAgICAgIGlmKGEgIT0gbnVsbClcbiAgICAgICAgaWYoXCJudW1iZXJcIiA9PSB0eXBlb2YgYSkgdGhpcy5mcm9tTnVtYmVyKGEsYixjKTtcbiAgICAgICAgZWxzZSBpZihiID09IG51bGwgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgYSkgdGhpcy5mcm9tU3RyaW5nKGEsMjU2KTtcbiAgICAgICAgZWxzZSB0aGlzLmZyb21TdHJpbmcoYSxiKTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gbmV3LCB1bnNldCBCaWdJbnRlZ2VyXG4gICAgZnVuY3Rpb24gbmJpKCkgeyByZXR1cm4gbmV3IEJpZ0ludGVnZXIobnVsbCk7IH1cblxuICAgIC8vIGFtOiBDb21wdXRlIHdfaiArPSAoeCp0aGlzX2kpLCBwcm9wYWdhdGUgY2FycmllcyxcbiAgICAvLyBjIGlzIGluaXRpYWwgY2FycnksIHJldHVybnMgZmluYWwgY2FycnkuXG4gICAgLy8gYyA8IDMqZHZhbHVlLCB4IDwgMipkdmFsdWUsIHRoaXNfaSA8IGR2YWx1ZVxuICAgIC8vIFdlIG5lZWQgdG8gc2VsZWN0IHRoZSBmYXN0ZXN0IG9uZSB0aGF0IHdvcmtzIGluIHRoaXMgZW52aXJvbm1lbnQuXG5cbiAgICAvLyBhbTE6IHVzZSBhIHNpbmdsZSBtdWx0IGFuZCBkaXZpZGUgdG8gZ2V0IHRoZSBoaWdoIGJpdHMsXG4gICAgLy8gbWF4IGRpZ2l0IGJpdHMgc2hvdWxkIGJlIDI2IGJlY2F1c2VcbiAgICAvLyBtYXggaW50ZXJuYWwgdmFsdWUgPSAyKmR2YWx1ZV4yLTIqZHZhbHVlICg8IDJeNTMpXG4gICAgZnVuY3Rpb24gYW0xKGkseCx3LGosYyxuKSB7XG4gICAgICB3aGlsZSgtLW4gPj0gMCkge1xuICAgICAgICB2YXIgdiA9IHgqdGhpc1tpKytdK3dbal0rYztcbiAgICAgICAgYyA9IE1hdGguZmxvb3Iodi8weDQwMDAwMDApO1xuICAgICAgICB3W2orK10gPSB2JjB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICAvLyBhbTIgYXZvaWRzIGEgYmlnIG11bHQtYW5kLWV4dHJhY3QgY29tcGxldGVseS5cbiAgICAvLyBNYXggZGlnaXQgYml0cyBzaG91bGQgYmUgPD0gMzAgYmVjYXVzZSB3ZSBkbyBiaXR3aXNlIG9wc1xuICAgIC8vIG9uIHZhbHVlcyB1cCB0byAyKmhkdmFsdWVeMi1oZHZhbHVlLTEgKDwgMl4zMSlcbiAgICBmdW5jdGlvbiBhbTIoaSx4LHcsaixjLG4pIHtcbiAgICAgIHZhciB4bCA9IHgmMHg3ZmZmLCB4aCA9IHg+PjE1O1xuICAgICAgd2hpbGUoLS1uID49IDApIHtcbiAgICAgICAgdmFyIGwgPSB0aGlzW2ldJjB4N2ZmZjtcbiAgICAgICAgdmFyIGggPSB0aGlzW2krK10+PjE1O1xuICAgICAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICAgICAgbCA9IHhsKmwrKChtJjB4N2ZmZik8PDE1KSt3W2pdKyhjJjB4M2ZmZmZmZmYpO1xuICAgICAgICBjID0gKGw+Pj4zMCkrKG0+Pj4xNSkreGgqaCsoYz4+PjMwKTtcbiAgICAgICAgd1tqKytdID0gbCYweDNmZmZmZmZmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIC8vIEFsdGVybmF0ZWx5LCBzZXQgbWF4IGRpZ2l0IGJpdHMgdG8gMjggc2luY2Ugc29tZVxuICAgIC8vIGJyb3dzZXJzIHNsb3cgZG93biB3aGVuIGRlYWxpbmcgd2l0aCAzMi1iaXQgbnVtYmVycy5cbiAgICBmdW5jdGlvbiBhbTMoaSx4LHcsaixjLG4pIHtcbiAgICAgIHZhciB4bCA9IHgmMHgzZmZmLCB4aCA9IHg+PjE0O1xuICAgICAgd2hpbGUoLS1uID49IDApIHtcbiAgICAgICAgdmFyIGwgPSB0aGlzW2ldJjB4M2ZmZjtcbiAgICAgICAgdmFyIGggPSB0aGlzW2krK10+PjE0O1xuICAgICAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICAgICAgbCA9IHhsKmwrKChtJjB4M2ZmZik8PDE0KSt3W2pdK2M7XG4gICAgICAgIGMgPSAobD4+MjgpKyhtPj4xNCkreGgqaDtcbiAgICAgICAgd1tqKytdID0gbCYweGZmZmZmZmY7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgdmFyIGluQnJvd3NlciA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgaWYoaW5Ccm93c2VyICYmIGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lID09IFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCIpKSB7XG4gICAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGFtMjtcbiAgICAgIGRiaXRzID0gMzA7XG4gICAgfVxuICAgIGVsc2UgaWYoaW5Ccm93c2VyICYmIGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lICE9IFwiTmV0c2NhcGVcIikpIHtcbiAgICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0xO1xuICAgICAgZGJpdHMgPSAyNjtcbiAgICB9XG4gICAgZWxzZSB7IC8vIE1vemlsbGEvTmV0c2NhcGUgc2VlbXMgdG8gcHJlZmVyIGFtM1xuICAgICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gICAgICBkYml0cyA9IDI4O1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLkRCID0gZGJpdHM7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuRE0gPSAoKDE8PGRiaXRzKS0xKTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5EViA9ICgxPDxkYml0cyk7XG5cbiAgICB2YXIgQklfRlAgPSA1MjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5GViA9IE1hdGgucG93KDIsQklfRlApO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLkYxID0gQklfRlAtZGJpdHM7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuRjIgPSAyKmRiaXRzLUJJX0ZQO1xuXG4gICAgLy8gRGlnaXQgY29udmVyc2lvbnNcbiAgICB2YXIgQklfUk0gPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xuICAgIHZhciBCSV9SQyA9IG5ldyBBcnJheSgpO1xuICAgIHZhciBycix2djtcbiAgICByciA9IFwiMFwiLmNoYXJDb2RlQXQoMCk7XG4gICAgZm9yKHZ2ID0gMDsgdnYgPD0gOTsgKyt2dikgQklfUkNbcnIrK10gPSB2djtcbiAgICByciA9IFwiYVwiLmNoYXJDb2RlQXQoMCk7XG4gICAgZm9yKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIEJJX1JDW3JyKytdID0gdnY7XG4gICAgcnIgPSBcIkFcIi5jaGFyQ29kZUF0KDApO1xuICAgIGZvcih2diA9IDEwOyB2diA8IDM2OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2O1xuXG4gICAgZnVuY3Rpb24gaW50MmNoYXIobikgeyByZXR1cm4gQklfUk0uY2hhckF0KG4pOyB9XG4gICAgZnVuY3Rpb24gaW50QXQocyxpKSB7XG4gICAgICB2YXIgYyA9IEJJX1JDW3MuY2hhckNvZGVBdChpKV07XG4gICAgICByZXR1cm4gKGM9PW51bGwpPy0xOmM7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgY29weSB0aGlzIHRvIHJcbiAgICBmdW5jdGlvbiBibnBDb3B5VG8ocikge1xuICAgICAgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByW2ldID0gdGhpc1tpXTtcbiAgICAgIHIudCA9IHRoaXMudDtcbiAgICAgIHIucyA9IHRoaXMucztcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBpbnRlZ2VyIHZhbHVlIHgsIC1EViA8PSB4IDwgRFZcbiAgICBmdW5jdGlvbiBibnBGcm9tSW50KHgpIHtcbiAgICAgIHRoaXMudCA9IDE7XG4gICAgICB0aGlzLnMgPSAoeDwwKT8tMTowO1xuICAgICAgaWYoeCA+IDApIHRoaXNbMF0gPSB4O1xuICAgICAgZWxzZSBpZih4IDwgLTEpIHRoaXNbMF0gPSB4K3RoaXMuRFY7XG4gICAgICBlbHNlIHRoaXMudCA9IDA7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIGJpZ2ludCBpbml0aWFsaXplZCB0byB2YWx1ZVxuICAgIGZ1bmN0aW9uIG5idihpKSB7IHZhciByID0gbmJpKCk7IHIuZnJvbUludChpKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIHN0cmluZyBhbmQgcmFkaXhcbiAgICBmdW5jdGlvbiBibnBGcm9tU3RyaW5nKHMsYikge1xuICAgICAgdmFyIGs7XG4gICAgICBpZihiID09IDE2KSBrID0gNDtcbiAgICAgIGVsc2UgaWYoYiA9PSA4KSBrID0gMztcbiAgICAgIGVsc2UgaWYoYiA9PSAyNTYpIGsgPSA4OyAvLyBieXRlIGFycmF5XG4gICAgICBlbHNlIGlmKGIgPT0gMikgayA9IDE7XG4gICAgICBlbHNlIGlmKGIgPT0gMzIpIGsgPSA1O1xuICAgICAgZWxzZSBpZihiID09IDQpIGsgPSAyO1xuICAgICAgZWxzZSB7IHRoaXMuZnJvbVJhZGl4KHMsYik7IHJldHVybjsgfVxuICAgICAgdGhpcy50ID0gMDtcbiAgICAgIHRoaXMucyA9IDA7XG4gICAgICB2YXIgaSA9IHMubGVuZ3RoLCBtaSA9IGZhbHNlLCBzaCA9IDA7XG4gICAgICB3aGlsZSgtLWkgPj0gMCkge1xuICAgICAgICB2YXIgeCA9IChrPT04KT9zW2ldJjB4ZmY6aW50QXQocyxpKTtcbiAgICAgICAgaWYoeCA8IDApIHtcbiAgICAgICAgICBpZihzLmNoYXJBdChpKSA9PSBcIi1cIikgbWkgPSB0cnVlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1pID0gZmFsc2U7XG4gICAgICAgIGlmKHNoID09IDApXG4gICAgICAgICAgdGhpc1t0aGlzLnQrK10gPSB4O1xuICAgICAgICBlbHNlIGlmKHNoK2sgPiB0aGlzLkRCKSB7XG4gICAgICAgICAgdGhpc1t0aGlzLnQtMV0gfD0gKHgmKCgxPDwodGhpcy5EQi1zaCkpLTEpKTw8c2g7XG4gICAgICAgICAgdGhpc1t0aGlzLnQrK10gPSAoeD4+KHRoaXMuREItc2gpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpc1t0aGlzLnQtMV0gfD0geDw8c2g7XG4gICAgICAgIHNoICs9IGs7XG4gICAgICAgIGlmKHNoID49IHRoaXMuREIpIHNoIC09IHRoaXMuREI7XG4gICAgICB9XG4gICAgICBpZihrID09IDggJiYgKHNbMF0mMHg4MCkgIT0gMCkge1xuICAgICAgICB0aGlzLnMgPSAtMTtcbiAgICAgICAgaWYoc2ggPiAwKSB0aGlzW3RoaXMudC0xXSB8PSAoKDE8PCh0aGlzLkRCLXNoKSktMSk8PHNoO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGFtcCgpO1xuICAgICAgaWYobWkpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLHRoaXMpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIGNsYW1wIG9mZiBleGNlc3MgaGlnaCB3b3Jkc1xuICAgIGZ1bmN0aW9uIGJucENsYW1wKCkge1xuICAgICAgdmFyIGMgPSB0aGlzLnMmdGhpcy5ETTtcbiAgICAgIHdoaWxlKHRoaXMudCA+IDAgJiYgdGhpc1t0aGlzLnQtMV0gPT0gYykgLS10aGlzLnQ7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxuICAgIGZ1bmN0aW9uIGJuVG9TdHJpbmcoYikge1xuICAgICAgaWYodGhpcy5zIDwgMCkgcmV0dXJuIFwiLVwiK3RoaXMubmVnYXRlKCkudG9TdHJpbmcoYik7XG4gICAgICB2YXIgaztcbiAgICAgIGlmKGIgPT0gMTYpIGsgPSA0O1xuICAgICAgZWxzZSBpZihiID09IDgpIGsgPSAzO1xuICAgICAgZWxzZSBpZihiID09IDIpIGsgPSAxO1xuICAgICAgZWxzZSBpZihiID09IDMyKSBrID0gNTtcbiAgICAgIGVsc2UgaWYoYiA9PSA0KSBrID0gMjtcbiAgICAgIGVsc2UgcmV0dXJuIHRoaXMudG9SYWRpeChiKTtcbiAgICAgIHZhciBrbSA9ICgxPDxrKS0xLCBkLCBtID0gZmFsc2UsIHIgPSBcIlwiLCBpID0gdGhpcy50O1xuICAgICAgdmFyIHAgPSB0aGlzLkRCLShpKnRoaXMuREIpJWs7XG4gICAgICBpZihpLS0gPiAwKSB7XG4gICAgICAgIGlmKHAgPCB0aGlzLkRCICYmIChkID0gdGhpc1tpXT4+cCkgPiAwKSB7IG0gPSB0cnVlOyByID0gaW50MmNoYXIoZCk7IH1cbiAgICAgICAgd2hpbGUoaSA+PSAwKSB7XG4gICAgICAgICAgaWYocCA8IGspIHtcbiAgICAgICAgICAgIGQgPSAodGhpc1tpXSYoKDE8PHApLTEpKTw8KGstcCk7XG4gICAgICAgICAgICBkIHw9IHRoaXNbLS1pXT4+KHArPXRoaXMuREItayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZCA9ICh0aGlzW2ldPj4ocC09aykpJmttO1xuICAgICAgICAgICAgaWYocCA8PSAwKSB7IHAgKz0gdGhpcy5EQjsgLS1pOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGQgPiAwKSBtID0gdHJ1ZTtcbiAgICAgICAgICBpZihtKSByICs9IGludDJjaGFyKGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbT9yOlwiMFwiO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIC10aGlzXG4gICAgZnVuY3Rpb24gYm5OZWdhdGUoKSB7IHZhciByID0gbmJpKCk7IEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLHIpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHB1YmxpYykgfHRoaXN8XG4gICAgZnVuY3Rpb24gYm5BYnMoKSB7IHJldHVybiAodGhpcy5zPDApP3RoaXMubmVnYXRlKCk6dGhpczsgfVxuXG4gICAgLy8gKHB1YmxpYykgcmV0dXJuICsgaWYgdGhpcyA+IGEsIC0gaWYgdGhpcyA8IGEsIDAgaWYgZXF1YWxcbiAgICBmdW5jdGlvbiBibkNvbXBhcmVUbyhhKSB7XG4gICAgICB2YXIgciA9IHRoaXMucy1hLnM7XG4gICAgICBpZihyICE9IDApIHJldHVybiByO1xuICAgICAgdmFyIGkgPSB0aGlzLnQ7XG4gICAgICByID0gaS1hLnQ7XG4gICAgICBpZihyICE9IDApIHJldHVybiAodGhpcy5zPDApPy1yOnI7XG4gICAgICB3aGlsZSgtLWkgPj0gMCkgaWYoKHI9dGhpc1tpXS1hW2ldKSAhPSAwKSByZXR1cm4gcjtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgYml0IGxlbmd0aCBvZiB0aGUgaW50ZWdlciB4XG4gICAgZnVuY3Rpb24gbmJpdHMoeCkge1xuICAgICAgdmFyIHIgPSAxLCB0O1xuICAgICAgaWYoKHQ9eD4+PjE2KSAhPSAwKSB7IHggPSB0OyByICs9IDE2OyB9XG4gICAgICBpZigodD14Pj44KSAhPSAwKSB7IHggPSB0OyByICs9IDg7IH1cbiAgICAgIGlmKCh0PXg+PjQpICE9IDApIHsgeCA9IHQ7IHIgKz0gNDsgfVxuICAgICAgaWYoKHQ9eD4+MikgIT0gMCkgeyB4ID0gdDsgciArPSAyOyB9XG4gICAgICBpZigodD14Pj4xKSAhPSAwKSB7IHggPSB0OyByICs9IDE7IH1cbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHJldHVybiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gXCJ0aGlzXCJcbiAgICBmdW5jdGlvbiBibkJpdExlbmd0aCgpIHtcbiAgICAgIGlmKHRoaXMudCA8PSAwKSByZXR1cm4gMDtcbiAgICAgIHJldHVybiB0aGlzLkRCKih0aGlzLnQtMSkrbmJpdHModGhpc1t0aGlzLnQtMV1eKHRoaXMucyZ0aGlzLkRNKSk7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgbipEQlxuICAgIGZ1bmN0aW9uIGJucERMU2hpZnRUbyhuLHIpIHtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yKGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHJbaStuXSA9IHRoaXNbaV07XG4gICAgICBmb3IoaSA9IG4tMTsgaSA+PSAwOyAtLWkpIHJbaV0gPSAwO1xuICAgICAgci50ID0gdGhpcy50K247XG4gICAgICByLnMgPSB0aGlzLnM7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gbipEQlxuICAgIGZ1bmN0aW9uIGJucERSU2hpZnRUbyhuLHIpIHtcbiAgICAgIGZvcih2YXIgaSA9IG47IGkgPCB0aGlzLnQ7ICsraSkgcltpLW5dID0gdGhpc1tpXTtcbiAgICAgIHIudCA9IE1hdGgubWF4KHRoaXMudC1uLDApO1xuICAgICAgci5zID0gdGhpcy5zO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIDw8IG5cbiAgICBmdW5jdGlvbiBibnBMU2hpZnRUbyhuLHIpIHtcbiAgICAgIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgICAgIHZhciBjYnMgPSB0aGlzLkRCLWJzO1xuICAgICAgdmFyIGJtID0gKDE8PGNicyktMTtcbiAgICAgIHZhciBkcyA9IE1hdGguZmxvb3Iobi90aGlzLkRCKSwgYyA9ICh0aGlzLnM8PGJzKSZ0aGlzLkRNLCBpO1xuICAgICAgZm9yKGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgcltpK2RzKzFdID0gKHRoaXNbaV0+PmNicyl8YztcbiAgICAgICAgYyA9ICh0aGlzW2ldJmJtKTw8YnM7XG4gICAgICB9XG4gICAgICBmb3IoaSA9IGRzLTE7IGkgPj0gMDsgLS1pKSByW2ldID0gMDtcbiAgICAgIHJbZHNdID0gYztcbiAgICAgIHIudCA9IHRoaXMudCtkcysxO1xuICAgICAgci5zID0gdGhpcy5zO1xuICAgICAgci5jbGFtcCgpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG5cbiAgICBmdW5jdGlvbiBibnBSU2hpZnRUbyhuLHIpIHtcbiAgICAgIHIucyA9IHRoaXMucztcbiAgICAgIHZhciBkcyA9IE1hdGguZmxvb3Iobi90aGlzLkRCKTtcbiAgICAgIGlmKGRzID49IHRoaXMudCkgeyByLnQgPSAwOyByZXR1cm47IH1cbiAgICAgIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgICAgIHZhciBjYnMgPSB0aGlzLkRCLWJzO1xuICAgICAgdmFyIGJtID0gKDE8PGJzKS0xO1xuICAgICAgclswXSA9IHRoaXNbZHNdPj5icztcbiAgICAgIGZvcih2YXIgaSA9IGRzKzE7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgICAgICByW2ktZHMtMV0gfD0gKHRoaXNbaV0mYm0pPDxjYnM7XG4gICAgICAgIHJbaS1kc10gPSB0aGlzW2ldPj5icztcbiAgICAgIH1cbiAgICAgIGlmKGJzID4gMCkgclt0aGlzLnQtZHMtMV0gfD0gKHRoaXMucyZibSk8PGNicztcbiAgICAgIHIudCA9IHRoaXMudC1kcztcbiAgICAgIHIuY2xhbXAoKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyAtIGFcbiAgICBmdW5jdGlvbiBibnBTdWJUbyhhLHIpIHtcbiAgICAgIHZhciBpID0gMCwgYyA9IDAsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbiAgICAgIHdoaWxlKGkgPCBtKSB7XG4gICAgICAgIGMgKz0gdGhpc1tpXS1hW2ldO1xuICAgICAgICByW2krK10gPSBjJnRoaXMuRE07XG4gICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICB9XG4gICAgICBpZihhLnQgPCB0aGlzLnQpIHtcbiAgICAgICAgYyAtPSBhLnM7XG4gICAgICAgIHdoaWxlKGkgPCB0aGlzLnQpIHtcbiAgICAgICAgICBjICs9IHRoaXNbaV07XG4gICAgICAgICAgcltpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgIH1cbiAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICAgIHdoaWxlKGkgPCBhLnQpIHtcbiAgICAgICAgICBjIC09IGFbaV07XG4gICAgICAgICAgcltpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgIH1cbiAgICAgICAgYyAtPSBhLnM7XG4gICAgICB9XG4gICAgICByLnMgPSAoYzwwKT8tMTowO1xuICAgICAgaWYoYyA8IC0xKSByW2krK10gPSB0aGlzLkRWK2M7XG4gICAgICBlbHNlIGlmKGMgPiAwKSByW2krK10gPSBjO1xuICAgICAgci50ID0gaTtcbiAgICAgIHIuY2xhbXAoKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyAqIGEsIHIgIT0gdGhpcyxhIChIQUMgMTQuMTIpXG4gICAgLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuICAgIGZ1bmN0aW9uIGJucE11bHRpcGx5VG8oYSxyKSB7XG4gICAgICB2YXIgeCA9IHRoaXMuYWJzKCksIHkgPSBhLmFicygpO1xuICAgICAgdmFyIGkgPSB4LnQ7XG4gICAgICByLnQgPSBpK3kudDtcbiAgICAgIHdoaWxlKC0taSA+PSAwKSByW2ldID0gMDtcbiAgICAgIGZvcihpID0gMDsgaSA8IHkudDsgKytpKSByW2kreC50XSA9IHguYW0oMCx5W2ldLHIsaSwwLHgudCk7XG4gICAgICByLnMgPSAwO1xuICAgICAgci5jbGFtcCgpO1xuICAgICAgaWYodGhpcy5zICE9IGEucykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIscik7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXNeMiwgciAhPSB0aGlzIChIQUMgMTQuMTYpXG4gICAgZnVuY3Rpb24gYm5wU3F1YXJlVG8ocikge1xuICAgICAgdmFyIHggPSB0aGlzLmFicygpO1xuICAgICAgdmFyIGkgPSByLnQgPSAyKngudDtcbiAgICAgIHdoaWxlKC0taSA+PSAwKSByW2ldID0gMDtcbiAgICAgIGZvcihpID0gMDsgaSA8IHgudC0xOyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSB4LmFtKGkseFtpXSxyLDIqaSwwLDEpO1xuICAgICAgICBpZigocltpK3gudF0rPXguYW0oaSsxLDIqeFtpXSxyLDIqaSsxLGMseC50LWktMSkpID49IHguRFYpIHtcbiAgICAgICAgICByW2kreC50XSAtPSB4LkRWO1xuICAgICAgICAgIHJbaSt4LnQrMV0gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihyLnQgPiAwKSByW3IudC0xXSArPSB4LmFtKGkseFtpXSxyLDIqaSwwLDEpO1xuICAgICAgci5zID0gMDtcbiAgICAgIHIuY2xhbXAoKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSBkaXZpZGUgdGhpcyBieSBtLCBxdW90aWVudCBhbmQgcmVtYWluZGVyIHRvIHEsIHIgKEhBQyAxNC4yMClcbiAgICAvLyByICE9IHEsIHRoaXMgIT0gbS4gIHEgb3IgciBtYXkgYmUgbnVsbC5cbiAgICBmdW5jdGlvbiBibnBEaXZSZW1UbyhtLHEscikge1xuICAgICAgdmFyIHBtID0gbS5hYnMoKTtcbiAgICAgIGlmKHBtLnQgPD0gMCkgcmV0dXJuO1xuICAgICAgdmFyIHB0ID0gdGhpcy5hYnMoKTtcbiAgICAgIGlmKHB0LnQgPCBwbS50KSB7XG4gICAgICAgIGlmKHEgIT0gbnVsbCkgcS5mcm9tSW50KDApO1xuICAgICAgICBpZihyICE9IG51bGwpIHRoaXMuY29weVRvKHIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZihyID09IG51bGwpIHIgPSBuYmkoKTtcbiAgICAgIHZhciB5ID0gbmJpKCksIHRzID0gdGhpcy5zLCBtcyA9IG0ucztcbiAgICAgIHZhciBuc2ggPSB0aGlzLkRCLW5iaXRzKHBtW3BtLnQtMV0pOyAgIC8vIG5vcm1hbGl6ZSBtb2R1bHVzXG4gICAgICBpZihuc2ggPiAwKSB7IHBtLmxTaGlmdFRvKG5zaCx5KTsgcHQubFNoaWZ0VG8obnNoLHIpOyB9XG4gICAgICBlbHNlIHsgcG0uY29weVRvKHkpOyBwdC5jb3B5VG8ocik7IH1cbiAgICAgIHZhciB5cyA9IHkudDtcbiAgICAgIHZhciB5MCA9IHlbeXMtMV07XG4gICAgICBpZih5MCA9PSAwKSByZXR1cm47XG4gICAgICB2YXIgeXQgPSB5MCooMTw8dGhpcy5GMSkrKCh5cz4xKT95W3lzLTJdPj50aGlzLkYyOjApO1xuICAgICAgdmFyIGQxID0gdGhpcy5GVi95dCwgZDIgPSAoMTw8dGhpcy5GMSkveXQsIGUgPSAxPDx0aGlzLkYyO1xuICAgICAgdmFyIGkgPSByLnQsIGogPSBpLXlzLCB0ID0gKHE9PW51bGwpP25iaSgpOnE7XG4gICAgICB5LmRsU2hpZnRUbyhqLHQpO1xuICAgICAgaWYoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgICAgICByW3IudCsrXSA9IDE7XG4gICAgICAgIHIuc3ViVG8odCxyKTtcbiAgICAgIH1cbiAgICAgIEJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbyh5cyx0KTtcbiAgICAgIHQuc3ViVG8oeSx5KTsgIC8vIFwibmVnYXRpdmVcIiB5IHNvIHdlIGNhbiByZXBsYWNlIHN1YiB3aXRoIGFtIGxhdGVyXG4gICAgICB3aGlsZSh5LnQgPCB5cykgeVt5LnQrK10gPSAwO1xuICAgICAgd2hpbGUoLS1qID49IDApIHtcbiAgICAgICAgLy8gRXN0aW1hdGUgcXVvdGllbnQgZGlnaXRcbiAgICAgICAgdmFyIHFkID0gKHJbLS1pXT09eTApP3RoaXMuRE06TWF0aC5mbG9vcihyW2ldKmQxKyhyW2ktMV0rZSkqZDIpO1xuICAgICAgICBpZigocltpXSs9eS5hbSgwLHFkLHIsaiwwLHlzKSkgPCBxZCkgeyAgIC8vIFRyeSBpdCBvdXRcbiAgICAgICAgICB5LmRsU2hpZnRUbyhqLHQpO1xuICAgICAgICAgIHIuc3ViVG8odCxyKTtcbiAgICAgICAgICB3aGlsZShyW2ldIDwgLS1xZCkgci5zdWJUbyh0LHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihxICE9IG51bGwpIHtcbiAgICAgICAgci5kclNoaWZ0VG8oeXMscSk7XG4gICAgICAgIGlmKHRzICE9IG1zKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocSxxKTtcbiAgICAgIH1cbiAgICAgIHIudCA9IHlzO1xuICAgICAgci5jbGFtcCgpO1xuICAgICAgaWYobnNoID4gMCkgci5yU2hpZnRUbyhuc2gscik7IC8vIERlbm9ybWFsaXplIHJlbWFpbmRlclxuICAgICAgaWYodHMgPCAwKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzIG1vZCBhXG4gICAgZnVuY3Rpb24gYm5Nb2QoYSkge1xuICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgIHRoaXMuYWJzKCkuZGl2UmVtVG8oYSxudWxsLHIpO1xuICAgICAgaWYodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgYS5zdWJUbyhyLHIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8gTW9kdWxhciByZWR1Y3Rpb24gdXNpbmcgXCJjbGFzc2ljXCIgYWxnb3JpdGhtXG4gICAgZnVuY3Rpb24gQ2xhc3NpYyhtKSB7IHRoaXMubSA9IG07IH1cbiAgICBmdW5jdGlvbiBjQ29udmVydCh4KSB7XG4gICAgICBpZih4LnMgPCAwIHx8IHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG4gICAgICBlbHNlIHJldHVybiB4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjUmV2ZXJ0KHgpIHsgcmV0dXJuIHg7IH1cbiAgICBmdW5jdGlvbiBjUmVkdWNlKHgpIHsgeC5kaXZSZW1Ubyh0aGlzLm0sbnVsbCx4KTsgfVxuICAgIGZ1bmN0aW9uIGNNdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgdGhpcy5yZWR1Y2Uocik7IH1cbiAgICBmdW5jdGlvbiBjU3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbiAgICBDbGFzc2ljLnByb3RvdHlwZS5jb252ZXJ0ID0gY0NvbnZlcnQ7XG4gICAgQ2xhc3NpYy5wcm90b3R5cGUucmV2ZXJ0ID0gY1JldmVydDtcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBjUmVkdWNlO1xuICAgIENsYXNzaWMucHJvdG90eXBlLm11bFRvID0gY011bFRvO1xuICAgIENsYXNzaWMucHJvdG90eXBlLnNxclRvID0gY1NxclRvO1xuXG4gICAgLy8gKHByb3RlY3RlZCkgcmV0dXJuIFwiLTEvdGhpcyAlIDJeREJcIjsgdXNlZnVsIGZvciBNb250LiByZWR1Y3Rpb25cbiAgICAvLyBqdXN0aWZpY2F0aW9uOlxuICAgIC8vICAgICAgICAgeHkgPT0gMSAobW9kIG0pXG4gICAgLy8gICAgICAgICB4eSA9ICAxK2ttXG4gICAgLy8gICB4eSgyLXh5KSA9ICgxK2ttKSgxLWttKVxuICAgIC8vIHhbeSgyLXh5KV0gPSAxLWteMm1eMlxuICAgIC8vIHhbeSgyLXh5KV0gPT0gMSAobW9kIG1eMilcbiAgICAvLyBpZiB5IGlzIDEveCBtb2QgbSwgdGhlbiB5KDIteHkpIGlzIDEveCBtb2QgbV4yXG4gICAgLy8gc2hvdWxkIHJlZHVjZSB4IGFuZCB5KDIteHkpIGJ5IG1eMiBhdCBlYWNoIHN0ZXAgdG8ga2VlcCBzaXplIGJvdW5kZWQuXG4gICAgLy8gSlMgbXVsdGlwbHkgXCJvdmVyZmxvd3NcIiBkaWZmZXJlbnRseSBmcm9tIEMvQysrLCBzbyBjYXJlIGlzIG5lZWRlZCBoZXJlLlxuICAgIGZ1bmN0aW9uIGJucEludkRpZ2l0KCkge1xuICAgICAgaWYodGhpcy50IDwgMSkgcmV0dXJuIDA7XG4gICAgICB2YXIgeCA9IHRoaXNbMF07XG4gICAgICBpZigoeCYxKSA9PSAwKSByZXR1cm4gMDtcbiAgICAgIHZhciB5ID0geCYzOyAgICAgICAvLyB5ID09IDEveCBtb2QgMl4yXG4gICAgICB5ID0gKHkqKDItKHgmMHhmKSp5KSkmMHhmOyAvLyB5ID09IDEveCBtb2QgMl40XG4gICAgICB5ID0gKHkqKDItKHgmMHhmZikqeSkpJjB4ZmY7ICAgLy8geSA9PSAxL3ggbW9kIDJeOFxuICAgICAgeSA9ICh5KigyLSgoKHgmMHhmZmZmKSp5KSYweGZmZmYpKSkmMHhmZmZmOyAgICAvLyB5ID09IDEveCBtb2QgMl4xNlxuICAgICAgLy8gbGFzdCBzdGVwIC0gY2FsY3VsYXRlIGludmVyc2UgbW9kIERWIGRpcmVjdGx5O1xuICAgICAgLy8gYXNzdW1lcyAxNiA8IERCIDw9IDMyIGFuZCBhc3N1bWVzIGFiaWxpdHkgdG8gaGFuZGxlIDQ4LWJpdCBpbnRzXG4gICAgICB5ID0gKHkqKDIteCp5JXRoaXMuRFYpKSV0aGlzLkRWOyAgICAgICAvLyB5ID09IDEveCBtb2QgMl5kYml0c1xuICAgICAgLy8gd2UgcmVhbGx5IHdhbnQgdGhlIG5lZ2F0aXZlIGludmVyc2UsIGFuZCAtRFYgPCB5IDwgRFZcbiAgICAgIHJldHVybiAoeT4wKT90aGlzLkRWLXk6LXk7XG4gICAgfVxuXG4gICAgLy8gTW9udGdvbWVyeSByZWR1Y3Rpb25cbiAgICBmdW5jdGlvbiBNb250Z29tZXJ5KG0pIHtcbiAgICAgIHRoaXMubSA9IG07XG4gICAgICB0aGlzLm1wID0gbS5pbnZEaWdpdCgpO1xuICAgICAgdGhpcy5tcGwgPSB0aGlzLm1wJjB4N2ZmZjtcbiAgICAgIHRoaXMubXBoID0gdGhpcy5tcD4+MTU7XG4gICAgICB0aGlzLnVtID0gKDE8PChtLkRCLTE1KSktMTtcbiAgICAgIHRoaXMubXQyID0gMiptLnQ7XG4gICAgfVxuXG4gICAgLy8geFIgbW9kIG1cbiAgICBmdW5jdGlvbiBtb250Q29udmVydCh4KSB7XG4gICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgeC5hYnMoKS5kbFNoaWZ0VG8odGhpcy5tLnQscik7XG4gICAgICByLmRpdlJlbVRvKHRoaXMubSxudWxsLHIpO1xuICAgICAgaWYoeC5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgdGhpcy5tLnN1YlRvKHIscik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyB4L1IgbW9kIG1cbiAgICBmdW5jdGlvbiBtb250UmV2ZXJ0KHgpIHtcbiAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICB4LmNvcHlUbyhyKTtcbiAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8geCA9IHgvUiBtb2QgbSAoSEFDIDE0LjMyKVxuICAgIGZ1bmN0aW9uIG1vbnRSZWR1Y2UoeCkge1xuICAgICAgd2hpbGUoeC50IDw9IHRoaXMubXQyKSAvLyBwYWQgeCBzbyBhbSBoYXMgZW5vdWdoIHJvb20gbGF0ZXJcbiAgICAgICAgeFt4LnQrK10gPSAwO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubS50OyArK2kpIHtcbiAgICAgICAgLy8gZmFzdGVyIHdheSBvZiBjYWxjdWxhdGluZyB1MCA9IHhbaV0qbXAgbW9kIERWXG4gICAgICAgIHZhciBqID0geFtpXSYweDdmZmY7XG4gICAgICAgIHZhciB1MCA9IChqKnRoaXMubXBsKygoKGoqdGhpcy5tcGgrKHhbaV0+PjE1KSp0aGlzLm1wbCkmdGhpcy51bSk8PDE1KSkmeC5ETTtcbiAgICAgICAgLy8gdXNlIGFtIHRvIGNvbWJpbmUgdGhlIG11bHRpcGx5LXNoaWZ0LWFkZCBpbnRvIG9uZSBjYWxsXG4gICAgICAgIGogPSBpK3RoaXMubS50O1xuICAgICAgICB4W2pdICs9IHRoaXMubS5hbSgwLHUwLHgsaSwwLHRoaXMubS50KTtcbiAgICAgICAgLy8gcHJvcGFnYXRlIGNhcnJ5XG4gICAgICAgIHdoaWxlKHhbal0gPj0geC5EVikgeyB4W2pdIC09IHguRFY7IHhbKytqXSsrOyB9XG4gICAgICB9XG4gICAgICB4LmNsYW1wKCk7XG4gICAgICB4LmRyU2hpZnRUbyh0aGlzLm0udCx4KTtcbiAgICAgIGlmKHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgeC5zdWJUbyh0aGlzLm0seCk7XG4gICAgfVxuXG4gICAgLy8gciA9IFwieF4yL1IgbW9kIG1cIjsgeCAhPSByXG4gICAgZnVuY3Rpb24gbW9udFNxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG4gICAgLy8gciA9IFwieHkvUiBtb2QgbVwiOyB4LHkgIT0gclxuICAgIGZ1bmN0aW9uIG1vbnRNdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLmNvbnZlcnQgPSBtb250Q29udmVydDtcbiAgICBNb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBtb250UmV2ZXJ0O1xuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLnJlZHVjZSA9IG1vbnRSZWR1Y2U7XG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUubXVsVG8gPSBtb250TXVsVG87XG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBtb250U3FyVG87XG5cbiAgICAvLyAocHJvdGVjdGVkKSB0cnVlIGlmZiB0aGlzIGlzIGV2ZW5cbiAgICBmdW5jdGlvbiBibnBJc0V2ZW4oKSB7IHJldHVybiAoKHRoaXMudD4wKT8odGhpc1swXSYxKTp0aGlzLnMpID09IDA7IH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXNeZSwgZSA8IDJeMzIsIGRvaW5nIHNxciBhbmQgbXVsIHdpdGggXCJyXCIgKEhBQyAxNC43OSlcbiAgICBmdW5jdGlvbiBibnBFeHAoZSx6KSB7XG4gICAgICBpZihlID4gMHhmZmZmZmZmZiB8fCBlIDwgMSkgcmV0dXJuIEJpZ0ludGVnZXIuT05FO1xuICAgICAgdmFyIHIgPSBuYmkoKSwgcjIgPSBuYmkoKSwgZyA9IHouY29udmVydCh0aGlzKSwgaSA9IG5iaXRzKGUpLTE7XG4gICAgICBnLmNvcHlUbyhyKTtcbiAgICAgIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgICAgIHouc3FyVG8ocixyMik7XG4gICAgICAgIGlmKChlJigxPDxpKSkgPiAwKSB6Lm11bFRvKHIyLGcscik7XG4gICAgICAgIGVsc2UgeyB2YXIgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gei5yZXZlcnQocik7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpc15lICUgbSwgMCA8PSBlIDwgMl4zMlxuICAgIGZ1bmN0aW9uIGJuTW9kUG93SW50KGUsbSkge1xuICAgICAgdmFyIHo7XG4gICAgICBpZihlIDwgMjU2IHx8IG0uaXNFdmVuKCkpIHogPSBuZXcgQ2xhc3NpYyhtKTsgZWxzZSB6ID0gbmV3IE1vbnRnb21lcnkobSk7XG4gICAgICByZXR1cm4gdGhpcy5leHAoZSx6KTtcbiAgICB9XG5cbiAgICAvLyBwcm90ZWN0ZWRcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb3B5VG8gPSBibnBDb3B5VG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbUludCA9IGJucEZyb21JbnQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGJucEZyb21TdHJpbmc7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY2xhbXAgPSBibnBDbGFtcDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kbFNoaWZ0VG8gPSBibnBETFNoaWZ0VG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZHJTaGlmdFRvID0gYm5wRFJTaGlmdFRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmxTaGlmdFRvID0gYm5wTFNoaWZ0VG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuclNoaWZ0VG8gPSBibnBSU2hpZnRUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJUbyA9IGJucFN1YlRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VG8gPSBibnBNdWx0aXBseVRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZVRvID0gYm5wU3F1YXJlVG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2UmVtVG8gPSBibnBEaXZSZW1UbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnZEaWdpdCA9IGJucEludkRpZ2l0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGJucElzRXZlbjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5leHAgPSBibnBFeHA7XG5cbiAgICAvLyBwdWJsaWNcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGJuVG9TdHJpbmc7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubmVnYXRlID0gYm5OZWdhdGU7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWJzID0gYm5BYnM7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gYm5Db21wYXJlVG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoID0gYm5CaXRMZW5ndGg7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kID0gYm5Nb2Q7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93SW50ID0gYm5Nb2RQb3dJbnQ7XG5cbiAgICAvLyBcImNvbnN0YW50c1wiXG4gICAgQmlnSW50ZWdlci5aRVJPID0gbmJ2KDApO1xuICAgIEJpZ0ludGVnZXIuT05FID0gbmJ2KDEpO1xuXG4gICAgLy8gQ29weXJpZ2h0IChjKSAyMDA1LTIwMDkgIFRvbSBXdVxuICAgIC8vIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgLy8gU2VlIFwiTElDRU5TRVwiIGZvciBkZXRhaWxzLlxuXG4gICAgLy8gRXh0ZW5kZWQgSmF2YVNjcmlwdCBCTiBmdW5jdGlvbnMsIHJlcXVpcmVkIGZvciBSU0EgcHJpdmF0ZSBvcHMuXG5cbiAgICAvLyBWZXJzaW9uIDEuMTogbmV3IEJpZ0ludGVnZXIoXCIwXCIsIDEwKSByZXR1cm5zIFwicHJvcGVyXCIgemVyb1xuICAgIC8vIFZlcnNpb24gMS4yOiBzcXVhcmUoKSBBUEksIGlzUHJvYmFibGVQcmltZSBmaXhcblxuICAgIC8vIChwdWJsaWMpXG4gICAgZnVuY3Rpb24gYm5DbG9uZSgpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5jb3B5VG8ocik7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgaW50ZWdlclxuICAgIGZ1bmN0aW9uIGJuSW50VmFsdWUoKSB7XG4gICAgICBpZih0aGlzLnMgPCAwKSB7XG4gICAgICAgIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpc1swXS10aGlzLkRWO1xuICAgICAgICBlbHNlIGlmKHRoaXMudCA9PSAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpc1swXTtcbiAgICAgIGVsc2UgaWYodGhpcy50ID09IDApIHJldHVybiAwO1xuICAgICAgLy8gYXNzdW1lcyAxNiA8IERCIDwgMzJcbiAgICAgIHJldHVybiAoKHRoaXNbMV0mKCgxPDwoMzItdGhpcy5EQikpLTEpKTw8dGhpcy5EQil8dGhpc1swXTtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgYnl0ZVxuICAgIGZ1bmN0aW9uIGJuQnl0ZVZhbHVlKCkgeyByZXR1cm4gKHRoaXMudD09MCk/dGhpcy5zOih0aGlzWzBdPDwyNCk+PjI0OyB9XG5cbiAgICAvLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgc2hvcnQgKGFzc3VtZXMgREI+PTE2KVxuICAgIGZ1bmN0aW9uIGJuU2hvcnRWYWx1ZSgpIHsgcmV0dXJuICh0aGlzLnQ9PTApP3RoaXMuczoodGhpc1swXTw8MTYpPj4xNjsgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgcmV0dXJuIHggcy50LiByXnggPCBEVlxuICAgIGZ1bmN0aW9uIGJucENodW5rU2l6ZShyKSB7IHJldHVybiBNYXRoLmZsb29yKE1hdGguTE4yKnRoaXMuREIvTWF0aC5sb2cocikpOyB9XG5cbiAgICAvLyAocHVibGljKSAwIGlmIHRoaXMgPT0gMCwgMSBpZiB0aGlzID4gMFxuICAgIGZ1bmN0aW9uIGJuU2lnTnVtKCkge1xuICAgICAgaWYodGhpcy5zIDwgMCkgcmV0dXJuIC0xO1xuICAgICAgZWxzZSBpZih0aGlzLnQgPD0gMCB8fCAodGhpcy50ID09IDEgJiYgdGhpc1swXSA8PSAwKSkgcmV0dXJuIDA7XG4gICAgICBlbHNlIHJldHVybiAxO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIGNvbnZlcnQgdG8gcmFkaXggc3RyaW5nXG4gICAgZnVuY3Rpb24gYm5wVG9SYWRpeChiKSB7XG4gICAgICBpZihiID09IG51bGwpIGIgPSAxMDtcbiAgICAgIGlmKHRoaXMuc2lnbnVtKCkgPT0gMCB8fCBiIDwgMiB8fCBiID4gMzYpIHJldHVybiBcIjBcIjtcbiAgICAgIHZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpO1xuICAgICAgdmFyIGEgPSBNYXRoLnBvdyhiLGNzKTtcbiAgICAgIHZhciBkID0gbmJ2KGEpLCB5ID0gbmJpKCksIHogPSBuYmkoKSwgciA9IFwiXCI7XG4gICAgICB0aGlzLmRpdlJlbVRvKGQseSx6KTtcbiAgICAgIHdoaWxlKHkuc2lnbnVtKCkgPiAwKSB7XG4gICAgICAgIHIgPSAoYSt6LmludFZhbHVlKCkpLnRvU3RyaW5nKGIpLnN1YnN0cigxKSArIHI7XG4gICAgICAgIHkuZGl2UmVtVG8oZCx5LHopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHouaW50VmFsdWUoKS50b1N0cmluZyhiKSArIHI7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgY29udmVydCBmcm9tIHJhZGl4IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGJucEZyb21SYWRpeChzLGIpIHtcbiAgICAgIHRoaXMuZnJvbUludCgwKTtcbiAgICAgIGlmKGIgPT0gbnVsbCkgYiA9IDEwO1xuICAgICAgdmFyIGNzID0gdGhpcy5jaHVua1NpemUoYik7XG4gICAgICB2YXIgZCA9IE1hdGgucG93KGIsY3MpLCBtaSA9IGZhbHNlLCBqID0gMCwgdyA9IDA7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgeCA9IGludEF0KHMsaSk7XG4gICAgICAgIGlmKHggPCAwKSB7XG4gICAgICAgICAgaWYocy5jaGFyQXQoaSkgPT0gXCItXCIgJiYgdGhpcy5zaWdudW0oKSA9PSAwKSBtaSA9IHRydWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdyA9IGIqdyt4O1xuICAgICAgICBpZigrK2ogPj0gY3MpIHtcbiAgICAgICAgICB0aGlzLmRNdWx0aXBseShkKTtcbiAgICAgICAgICB0aGlzLmRBZGRPZmZzZXQodywwKTtcbiAgICAgICAgICBqID0gMDtcbiAgICAgICAgICB3ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoaiA+IDApIHtcbiAgICAgICAgdGhpcy5kTXVsdGlwbHkoTWF0aC5wb3coYixqKSk7XG4gICAgICAgIHRoaXMuZEFkZE9mZnNldCh3LDApO1xuICAgICAgfVxuICAgICAgaWYobWkpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLHRoaXMpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIGFsdGVybmF0ZSBjb25zdHJ1Y3RvclxuICAgIGZ1bmN0aW9uIGJucEZyb21OdW1iZXIoYSxiLGMpIHtcbiAgICAgIGlmKFwibnVtYmVyXCIgPT0gdHlwZW9mIGIpIHtcbiAgICAgICAgLy8gbmV3IEJpZ0ludGVnZXIoaW50LGludCxSTkcpXG4gICAgICAgIGlmKGEgPCAyKSB0aGlzLmZyb21JbnQoMSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuZnJvbU51bWJlcihhLGMpO1xuICAgICAgICAgIGlmKCF0aGlzLnRlc3RCaXQoYS0xKSlcdC8vIGZvcmNlIE1TQiBzZXRcbiAgICAgICAgICAgIHRoaXMuYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhLTEpLG9wX29yLHRoaXMpO1xuICAgICAgICAgIGlmKHRoaXMuaXNFdmVuKCkpIHRoaXMuZEFkZE9mZnNldCgxLDApOyAvLyBmb3JjZSBvZGRcbiAgICAgICAgICB3aGlsZSghdGhpcy5pc1Byb2JhYmxlUHJpbWUoYikpIHtcbiAgICAgICAgICAgIHRoaXMuZEFkZE9mZnNldCgyLDApO1xuICAgICAgICAgICAgaWYodGhpcy5iaXRMZW5ndGgoKSA+IGEpIHRoaXMuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEtMSksdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gbmV3IEJpZ0ludGVnZXIoaW50LFJORylcbiAgICAgICAgdmFyIHggPSBuZXcgQXJyYXkoKSwgdCA9IGEmNztcbiAgICAgICAgeC5sZW5ndGggPSAoYT4+MykrMTtcbiAgICAgICAgYi5uZXh0Qnl0ZXMoeCk7XG4gICAgICAgIGlmKHQgPiAwKSB4WzBdICY9ICgoMTw8dCktMSk7IGVsc2UgeFswXSA9IDA7XG4gICAgICAgIHRoaXMuZnJvbVN0cmluZyh4LDI1Nik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgY29udmVydCB0byBiaWdlbmRpYW4gYnl0ZSBhcnJheVxuICAgIGZ1bmN0aW9uIGJuVG9CeXRlQXJyYXkoKSB7XG4gICAgICB2YXIgaSA9IHRoaXMudCwgciA9IG5ldyBBcnJheSgpO1xuICAgICAgclswXSA9IHRoaXMucztcbiAgICAgIHZhciBwID0gdGhpcy5EQi0oaSp0aGlzLkRCKSU4LCBkLCBrID0gMDtcbiAgICAgIGlmKGktLSA+IDApIHtcbiAgICAgICAgaWYocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzW2ldPj5wKSAhPSAodGhpcy5zJnRoaXMuRE0pPj5wKVxuICAgICAgICAgIHJbaysrXSA9IGR8KHRoaXMuczw8KHRoaXMuREItcCkpO1xuICAgICAgICB3aGlsZShpID49IDApIHtcbiAgICAgICAgICBpZihwIDwgOCkge1xuICAgICAgICAgICAgZCA9ICh0aGlzW2ldJigoMTw8cCktMSkpPDwoOC1wKTtcbiAgICAgICAgICAgIGQgfD0gdGhpc1stLWldPj4ocCs9dGhpcy5EQi04KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkID0gKHRoaXNbaV0+PihwLT04KSkmMHhmZjtcbiAgICAgICAgICAgIGlmKHAgPD0gMCkgeyBwICs9IHRoaXMuREI7IC0taTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZigoZCYweDgwKSAhPSAwKSBkIHw9IC0yNTY7XG4gICAgICAgICAgaWYoayA9PSAwICYmICh0aGlzLnMmMHg4MCkgIT0gKGQmMHg4MCkpICsraztcbiAgICAgICAgICBpZihrID4gMCB8fCBkICE9IHRoaXMucykgcltrKytdID0gZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYm5FcXVhbHMoYSkgeyByZXR1cm4odGhpcy5jb21wYXJlVG8oYSk9PTApOyB9XG4gICAgZnVuY3Rpb24gYm5NaW4oYSkgeyByZXR1cm4odGhpcy5jb21wYXJlVG8oYSk8MCk/dGhpczphOyB9XG4gICAgZnVuY3Rpb24gYm5NYXgoYSkgeyByZXR1cm4odGhpcy5jb21wYXJlVG8oYSk+MCk/dGhpczphOyB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyBvcCBhIChiaXR3aXNlKVxuICAgIGZ1bmN0aW9uIGJucEJpdHdpc2VUbyhhLG9wLHIpIHtcbiAgICAgIHZhciBpLCBmLCBtID0gTWF0aC5taW4oYS50LHRoaXMudCk7XG4gICAgICBmb3IoaSA9IDA7IGkgPCBtOyArK2kpIHJbaV0gPSBvcCh0aGlzW2ldLGFbaV0pO1xuICAgICAgaWYoYS50IDwgdGhpcy50KSB7XG4gICAgICAgIGYgPSBhLnMmdGhpcy5ETTtcbiAgICAgICAgZm9yKGkgPSBtOyBpIDwgdGhpcy50OyArK2kpIHJbaV0gPSBvcCh0aGlzW2ldLGYpO1xuICAgICAgICByLnQgPSB0aGlzLnQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZiA9IHRoaXMucyZ0aGlzLkRNO1xuICAgICAgICBmb3IoaSA9IG07IGkgPCBhLnQ7ICsraSkgcltpXSA9IG9wKGYsYVtpXSk7XG4gICAgICAgIHIudCA9IGEudDtcbiAgICAgIH1cbiAgICAgIHIucyA9IG9wKHRoaXMucyxhLnMpO1xuICAgICAgci5jbGFtcCgpO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgJiBhXG4gICAgZnVuY3Rpb24gb3BfYW5kKHgseSkgeyByZXR1cm4geCZ5OyB9XG4gICAgZnVuY3Rpb24gYm5BbmQoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX2FuZCxyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgfCBhXG4gICAgZnVuY3Rpb24gb3Bfb3IoeCx5KSB7IHJldHVybiB4fHk7IH1cbiAgICBmdW5jdGlvbiBibk9yKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9vcixyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgXiBhXG4gICAgZnVuY3Rpb24gb3BfeG9yKHgseSkgeyByZXR1cm4geF55OyB9XG4gICAgZnVuY3Rpb24gYm5Yb3IoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX3hvcixyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgJiB+YVxuICAgIGZ1bmN0aW9uIG9wX2FuZG5vdCh4LHkpIHsgcmV0dXJuIHgmfnk7IH1cbiAgICBmdW5jdGlvbiBibkFuZE5vdChhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYml0d2lzZVRvKGEsb3BfYW5kbm90LHIpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHB1YmxpYykgfnRoaXNcbiAgICBmdW5jdGlvbiBibk5vdCgpIHtcbiAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpIHJbaV0gPSB0aGlzLkRNJn50aGlzW2ldO1xuICAgICAgci50ID0gdGhpcy50O1xuICAgICAgci5zID0gfnRoaXMucztcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgPDwgblxuICAgIGZ1bmN0aW9uIGJuU2hpZnRMZWZ0KG4pIHtcbiAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICBpZihuIDwgMCkgdGhpcy5yU2hpZnRUbygtbixyKTsgZWxzZSB0aGlzLmxTaGlmdFRvKG4scik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzID4+IG5cbiAgICBmdW5jdGlvbiBiblNoaWZ0UmlnaHQobikge1xuICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgIGlmKG4gPCAwKSB0aGlzLmxTaGlmdFRvKC1uLHIpOyBlbHNlIHRoaXMuclNoaWZ0VG8obixyKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBpbmRleCBvZiBsb3dlc3QgMS1iaXQgaW4geCwgeCA8IDJeMzFcbiAgICBmdW5jdGlvbiBsYml0KHgpIHtcbiAgICAgIGlmKHggPT0gMCkgcmV0dXJuIC0xO1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgaWYoKHgmMHhmZmZmKSA9PSAwKSB7IHggPj49IDE2OyByICs9IDE2OyB9XG4gICAgICBpZigoeCYweGZmKSA9PSAwKSB7IHggPj49IDg7IHIgKz0gODsgfVxuICAgICAgaWYoKHgmMHhmKSA9PSAwKSB7IHggPj49IDQ7IHIgKz0gNDsgfVxuICAgICAgaWYoKHgmMykgPT0gMCkgeyB4ID4+PSAyOyByICs9IDI7IH1cbiAgICAgIGlmKCh4JjEpID09IDApICsrcjtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHJldHVybnMgaW5kZXggb2YgbG93ZXN0IDEtYml0IChvciAtMSBpZiBub25lKVxuICAgIGZ1bmN0aW9uIGJuR2V0TG93ZXN0U2V0Qml0KCkge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKVxuICAgICAgICBpZih0aGlzW2ldICE9IDApIHJldHVybiBpKnRoaXMuREIrbGJpdCh0aGlzW2ldKTtcbiAgICAgIGlmKHRoaXMucyA8IDApIHJldHVybiB0aGlzLnQqdGhpcy5EQjtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gbnVtYmVyIG9mIDEgYml0cyBpbiB4XG4gICAgZnVuY3Rpb24gY2JpdCh4KSB7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICB3aGlsZSh4ICE9IDApIHsgeCAmPSB4LTE7ICsrcjsgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIG51bWJlciBvZiBzZXQgYml0c1xuICAgIGZ1bmN0aW9uIGJuQml0Q291bnQoKSB7XG4gICAgICB2YXIgciA9IDAsIHggPSB0aGlzLnMmdGhpcy5ETTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkgciArPSBjYml0KHRoaXNbaV1eeCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSB0cnVlIGlmZiBudGggYml0IGlzIHNldFxuICAgIGZ1bmN0aW9uIGJuVGVzdEJpdChuKSB7XG4gICAgICB2YXIgaiA9IE1hdGguZmxvb3Iobi90aGlzLkRCKTtcbiAgICAgIGlmKGogPj0gdGhpcy50KSByZXR1cm4odGhpcy5zIT0wKTtcbiAgICAgIHJldHVybigodGhpc1tqXSYoMTw8KG4ldGhpcy5EQikpKSE9MCk7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgdGhpcyBvcCAoMTw8bilcbiAgICBmdW5jdGlvbiBibnBDaGFuZ2VCaXQobixvcCkge1xuICAgICAgdmFyIHIgPSBCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQobik7XG4gICAgICB0aGlzLmJpdHdpc2VUbyhyLG9wLHIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyB8ICgxPDxuKVxuICAgIGZ1bmN0aW9uIGJuU2V0Qml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3Bfb3IpOyB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzICYgfigxPDxuKVxuICAgIGZ1bmN0aW9uIGJuQ2xlYXJCaXQobikgeyByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF9hbmRub3QpOyB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzIF4gKDE8PG4pXG4gICAgZnVuY3Rpb24gYm5GbGlwQml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3BfeG9yKTsgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgKyBhXG4gICAgZnVuY3Rpb24gYm5wQWRkVG8oYSxyKSB7XG4gICAgICB2YXIgaSA9IDAsIGMgPSAwLCBtID0gTWF0aC5taW4oYS50LHRoaXMudCk7XG4gICAgICB3aGlsZShpIDwgbSkge1xuICAgICAgICBjICs9IHRoaXNbaV0rYVtpXTtcbiAgICAgICAgcltpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgfVxuICAgICAgaWYoYS50IDwgdGhpcy50KSB7XG4gICAgICAgIGMgKz0gYS5zO1xuICAgICAgICB3aGlsZShpIDwgdGhpcy50KSB7XG4gICAgICAgICAgYyArPSB0aGlzW2ldO1xuICAgICAgICAgIHJbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICB9XG4gICAgICAgIGMgKz0gdGhpcy5zO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGMgKz0gdGhpcy5zO1xuICAgICAgICB3aGlsZShpIDwgYS50KSB7XG4gICAgICAgICAgYyArPSBhW2ldO1xuICAgICAgICAgIHJbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICB9XG4gICAgICAgIGMgKz0gYS5zO1xuICAgICAgfVxuICAgICAgci5zID0gKGM8MCk/LTE6MDtcbiAgICAgIGlmKGMgPiAwKSByW2krK10gPSBjO1xuICAgICAgZWxzZSBpZihjIDwgLTEpIHJbaSsrXSA9IHRoaXMuRFYrYztcbiAgICAgIHIudCA9IGk7XG4gICAgICByLmNsYW1wKCk7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyArIGFcbiAgICBmdW5jdGlvbiBibkFkZChhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYWRkVG8oYSxyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgLSBhXG4gICAgZnVuY3Rpb24gYm5TdWJ0cmFjdChhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuc3ViVG8oYSxyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgKiBhXG4gICAgZnVuY3Rpb24gYm5NdWx0aXBseShhKSB7IHZhciByID0gbmJpKCk7IHRoaXMubXVsdGlwbHlUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpc14yXG4gICAgZnVuY3Rpb24gYm5TcXVhcmUoKSB7IHZhciByID0gbmJpKCk7IHRoaXMuc3F1YXJlVG8ocik7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzIC8gYVxuICAgIGZ1bmN0aW9uIGJuRGl2aWRlKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLHIsbnVsbCk7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzICUgYVxuICAgIGZ1bmN0aW9uIGJuUmVtYWluZGVyKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLG51bGwscik7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSBbdGhpcy9hLHRoaXMlYV1cbiAgICBmdW5jdGlvbiBibkRpdmlkZUFuZFJlbWFpbmRlcihhKSB7XG4gICAgICB2YXIgcSA9IG5iaSgpLCByID0gbmJpKCk7XG4gICAgICB0aGlzLmRpdlJlbVRvKGEscSxyKTtcbiAgICAgIHJldHVybiBuZXcgQXJyYXkocSxyKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSB0aGlzICo9IG4sIHRoaXMgPj0gMCwgMSA8IG4gPCBEVlxuICAgIGZ1bmN0aW9uIGJucERNdWx0aXBseShuKSB7XG4gICAgICB0aGlzW3RoaXMudF0gPSB0aGlzLmFtKDAsbi0xLHRoaXMsMCwwLHRoaXMudCk7XG4gICAgICArK3RoaXMudDtcbiAgICAgIHRoaXMuY2xhbXAoKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSB0aGlzICs9IG4gPDwgdyB3b3JkcywgdGhpcyA+PSAwXG4gICAgZnVuY3Rpb24gYm5wREFkZE9mZnNldChuLHcpIHtcbiAgICAgIGlmKG4gPT0gMCkgcmV0dXJuO1xuICAgICAgd2hpbGUodGhpcy50IDw9IHcpIHRoaXNbdGhpcy50KytdID0gMDtcbiAgICAgIHRoaXNbd10gKz0gbjtcbiAgICAgIHdoaWxlKHRoaXNbd10gPj0gdGhpcy5EVikge1xuICAgICAgICB0aGlzW3ddIC09IHRoaXMuRFY7XG4gICAgICAgIGlmKCsrdyA+PSB0aGlzLnQpIHRoaXNbdGhpcy50KytdID0gMDtcbiAgICAgICAgKyt0aGlzW3ddO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEEgXCJudWxsXCIgcmVkdWNlclxuICAgIGZ1bmN0aW9uIE51bGxFeHAoKSB7fVxuICAgIGZ1bmN0aW9uIG5Ob3AoeCkgeyByZXR1cm4geDsgfVxuICAgIGZ1bmN0aW9uIG5NdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgfVxuICAgIGZ1bmN0aW9uIG5TcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgfVxuXG4gICAgTnVsbEV4cC5wcm90b3R5cGUuY29udmVydCA9IG5Ob3A7XG4gICAgTnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0ID0gbk5vcDtcbiAgICBOdWxsRXhwLnByb3RvdHlwZS5tdWxUbyA9IG5NdWxUbztcbiAgICBOdWxsRXhwLnByb3RvdHlwZS5zcXJUbyA9IG5TcXJUbztcblxuICAgIC8vIChwdWJsaWMpIHRoaXNeZVxuICAgIGZ1bmN0aW9uIGJuUG93KGUpIHsgcmV0dXJuIHRoaXMuZXhwKGUsbmV3IE51bGxFeHAoKSk7IH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSBsb3dlciBuIHdvcmRzIG9mIFwidGhpcyAqIGFcIiwgYS50IDw9IG5cbiAgICAvLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG4gICAgZnVuY3Rpb24gYm5wTXVsdGlwbHlMb3dlclRvKGEsbixyKSB7XG4gICAgICB2YXIgaSA9IE1hdGgubWluKHRoaXMudCthLnQsbik7XG4gICAgICByLnMgPSAwOyAvLyBhc3N1bWVzIGEsdGhpcyA+PSAwXG4gICAgICByLnQgPSBpO1xuICAgICAgd2hpbGUoaSA+IDApIHJbLS1pXSA9IDA7XG4gICAgICB2YXIgajtcbiAgICAgIGZvcihqID0gci50LXRoaXMudDsgaSA8IGo7ICsraSkgcltpK3RoaXMudF0gPSB0aGlzLmFtKDAsYVtpXSxyLGksMCx0aGlzLnQpO1xuICAgICAgZm9yKGogPSBNYXRoLm1pbihhLnQsbik7IGkgPCBqOyArK2kpIHRoaXMuYW0oMCxhW2ldLHIsaSwwLG4taSk7XG4gICAgICByLmNsYW1wKCk7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IFwidGhpcyAqIGFcIiB3aXRob3V0IGxvd2VyIG4gd29yZHMsIG4gPiAwXG4gICAgLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuICAgIGZ1bmN0aW9uIGJucE11bHRpcGx5VXBwZXJUbyhhLG4scikge1xuICAgICAgLS1uO1xuICAgICAgdmFyIGkgPSByLnQgPSB0aGlzLnQrYS50LW47XG4gICAgICByLnMgPSAwOyAvLyBhc3N1bWVzIGEsdGhpcyA+PSAwXG4gICAgICB3aGlsZSgtLWkgPj0gMCkgcltpXSA9IDA7XG4gICAgICBmb3IoaSA9IE1hdGgubWF4KG4tdGhpcy50LDApOyBpIDwgYS50OyArK2kpXG4gICAgICAgIHJbdGhpcy50K2ktbl0gPSB0aGlzLmFtKG4taSxhW2ldLHIsMCwwLHRoaXMudCtpLW4pO1xuICAgICAgci5jbGFtcCgpO1xuICAgICAgci5kclNoaWZ0VG8oMSxyKTtcbiAgICB9XG5cbiAgICAvLyBCYXJyZXR0IG1vZHVsYXIgcmVkdWN0aW9uXG4gICAgZnVuY3Rpb24gQmFycmV0dChtKSB7XG4gICAgICAvLyBzZXR1cCBCYXJyZXR0XG4gICAgICB0aGlzLnIyID0gbmJpKCk7XG4gICAgICB0aGlzLnEzID0gbmJpKCk7XG4gICAgICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oMiptLnQsdGhpcy5yMik7XG4gICAgICB0aGlzLm11ID0gdGhpcy5yMi5kaXZpZGUobSk7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJhcnJldHRDb252ZXJ0KHgpIHtcbiAgICAgIGlmKHgucyA8IDAgfHwgeC50ID4gMip0aGlzLm0udCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG4gICAgICBlbHNlIGlmKHguY29tcGFyZVRvKHRoaXMubSkgPCAwKSByZXR1cm4geDtcbiAgICAgIGVsc2UgeyB2YXIgciA9IG5iaSgpOyB4LmNvcHlUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IHJldHVybiByOyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmFycmV0dFJldmVydCh4KSB7IHJldHVybiB4OyB9XG5cbiAgICAvLyB4ID0geCBtb2QgbSAoSEFDIDE0LjQyKVxuICAgIGZ1bmN0aW9uIGJhcnJldHRSZWR1Y2UoeCkge1xuICAgICAgeC5kclNoaWZ0VG8odGhpcy5tLnQtMSx0aGlzLnIyKTtcbiAgICAgIGlmKHgudCA+IHRoaXMubS50KzEpIHsgeC50ID0gdGhpcy5tLnQrMTsgeC5jbGFtcCgpOyB9XG4gICAgICB0aGlzLm11Lm11bHRpcGx5VXBwZXJUbyh0aGlzLnIyLHRoaXMubS50KzEsdGhpcy5xMyk7XG4gICAgICB0aGlzLm0ubXVsdGlwbHlMb3dlclRvKHRoaXMucTMsdGhpcy5tLnQrMSx0aGlzLnIyKTtcbiAgICAgIHdoaWxlKHguY29tcGFyZVRvKHRoaXMucjIpIDwgMCkgeC5kQWRkT2Zmc2V0KDEsdGhpcy5tLnQrMSk7XG4gICAgICB4LnN1YlRvKHRoaXMucjIseCk7XG4gICAgICB3aGlsZSh4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHguc3ViVG8odGhpcy5tLHgpO1xuICAgIH1cblxuICAgIC8vIHIgPSB4XjIgbW9kIG07IHggIT0gclxuICAgIGZ1bmN0aW9uIGJhcnJldHRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuICAgIC8vIHIgPSB4KnkgbW9kIG07IHgseSAhPSByXG4gICAgZnVuY3Rpb24gYmFycmV0dE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG4gICAgQmFycmV0dC5wcm90b3R5cGUuY29udmVydCA9IGJhcnJldHRDb252ZXJ0O1xuICAgIEJhcnJldHQucHJvdG90eXBlLnJldmVydCA9IGJhcnJldHRSZXZlcnQ7XG4gICAgQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gYmFycmV0dFJlZHVjZTtcbiAgICBCYXJyZXR0LnByb3RvdHlwZS5tdWxUbyA9IGJhcnJldHRNdWxUbztcbiAgICBCYXJyZXR0LnByb3RvdHlwZS5zcXJUbyA9IGJhcnJldHRTcXJUbztcblxuICAgIC8vIChwdWJsaWMpIHRoaXNeZSAlIG0gKEhBQyAxNC44NSlcbiAgICBmdW5jdGlvbiBibk1vZFBvdyhlLG0pIHtcbiAgICAgIHZhciBpID0gZS5iaXRMZW5ndGgoKSwgaywgciA9IG5idigxKSwgejtcbiAgICAgIGlmKGkgPD0gMCkgcmV0dXJuIHI7XG4gICAgICBlbHNlIGlmKGkgPCAxOCkgayA9IDE7XG4gICAgICBlbHNlIGlmKGkgPCA0OCkgayA9IDM7XG4gICAgICBlbHNlIGlmKGkgPCAxNDQpIGsgPSA0O1xuICAgICAgZWxzZSBpZihpIDwgNzY4KSBrID0gNTtcbiAgICAgIGVsc2UgayA9IDY7XG4gICAgICBpZihpIDwgOClcbiAgICAgICAgeiA9IG5ldyBDbGFzc2ljKG0pO1xuICAgICAgZWxzZSBpZihtLmlzRXZlbigpKVxuICAgICAgICB6ID0gbmV3IEJhcnJldHQobSk7XG4gICAgICBlbHNlXG4gICAgICAgIHogPSBuZXcgTW9udGdvbWVyeShtKTtcblxuICAgICAgLy8gcHJlY29tcHV0YXRpb25cbiAgICAgIHZhciBnID0gbmV3IEFycmF5KCksIG4gPSAzLCBrMSA9IGstMSwga20gPSAoMTw8ayktMTtcbiAgICAgIGdbMV0gPSB6LmNvbnZlcnQodGhpcyk7XG4gICAgICBpZihrID4gMSkge1xuICAgICAgICB2YXIgZzIgPSBuYmkoKTtcbiAgICAgICAgei5zcXJUbyhnWzFdLGcyKTtcbiAgICAgICAgd2hpbGUobiA8PSBrbSkge1xuICAgICAgICAgIGdbbl0gPSBuYmkoKTtcbiAgICAgICAgICB6Lm11bFRvKGcyLGdbbi0yXSxnW25dKTtcbiAgICAgICAgICBuICs9IDI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGogPSBlLnQtMSwgdywgaXMxID0gdHJ1ZSwgcjIgPSBuYmkoKSwgdDtcbiAgICAgIGkgPSBuYml0cyhlW2pdKS0xO1xuICAgICAgd2hpbGUoaiA+PSAwKSB7XG4gICAgICAgIGlmKGkgPj0gazEpIHcgPSAoZVtqXT4+KGktazEpKSZrbTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdyA9IChlW2pdJigoMTw8KGkrMSkpLTEpKTw8KGsxLWkpO1xuICAgICAgICAgIGlmKGogPiAwKSB3IHw9IGVbai0xXT4+KHRoaXMuREIraS1rMSk7XG4gICAgICAgIH1cblxuICAgICAgICBuID0gaztcbiAgICAgICAgd2hpbGUoKHcmMSkgPT0gMCkgeyB3ID4+PSAxOyAtLW47IH1cbiAgICAgICAgaWYoKGkgLT0gbikgPCAwKSB7IGkgKz0gdGhpcy5EQjsgLS1qOyB9XG4gICAgICAgIGlmKGlzMSkge1x0Ly8gcmV0ID09IDEsIGRvbid0IGJvdGhlciBzcXVhcmluZyBvciBtdWx0aXBseWluZyBpdFxuICAgICAgICAgIGdbd10uY29weVRvKHIpO1xuICAgICAgICAgIGlzMSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHdoaWxlKG4gPiAxKSB7IHouc3FyVG8ocixyMik7IHouc3FyVG8ocjIscik7IG4gLT0gMjsgfVxuICAgICAgICAgIGlmKG4gPiAwKSB6LnNxclRvKHIscjIpOyBlbHNlIHsgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gICAgICAgICAgei5tdWxUbyhyMixnW3ddLHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUoaiA+PSAwICYmIChlW2pdJigxPDxpKSkgPT0gMCkge1xuICAgICAgICAgIHouc3FyVG8ocixyMik7IHQgPSByOyByID0gcjI7IHIyID0gdDtcbiAgICAgICAgICBpZigtLWkgPCAwKSB7IGkgPSB0aGlzLkRCLTE7IC0tajsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gei5yZXZlcnQocik7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgZ2NkKHRoaXMsYSkgKEhBQyAxNC41NClcbiAgICBmdW5jdGlvbiBibkdDRChhKSB7XG4gICAgICB2YXIgeCA9ICh0aGlzLnM8MCk/dGhpcy5uZWdhdGUoKTp0aGlzLmNsb25lKCk7XG4gICAgICB2YXIgeSA9IChhLnM8MCk/YS5uZWdhdGUoKTphLmNsb25lKCk7XG4gICAgICBpZih4LmNvbXBhcmVUbyh5KSA8IDApIHsgdmFyIHQgPSB4OyB4ID0geTsgeSA9IHQ7IH1cbiAgICAgIHZhciBpID0geC5nZXRMb3dlc3RTZXRCaXQoKSwgZyA9IHkuZ2V0TG93ZXN0U2V0Qml0KCk7XG4gICAgICBpZihnIDwgMCkgcmV0dXJuIHg7XG4gICAgICBpZihpIDwgZykgZyA9IGk7XG4gICAgICBpZihnID4gMCkge1xuICAgICAgICB4LnJTaGlmdFRvKGcseCk7XG4gICAgICAgIHkuclNoaWZ0VG8oZyx5KTtcbiAgICAgIH1cbiAgICAgIHdoaWxlKHguc2lnbnVtKCkgPiAwKSB7XG4gICAgICAgIGlmKChpID0geC5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB4LnJTaGlmdFRvKGkseCk7XG4gICAgICAgIGlmKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB5LnJTaGlmdFRvKGkseSk7XG4gICAgICAgIGlmKHguY29tcGFyZVRvKHkpID49IDApIHtcbiAgICAgICAgICB4LnN1YlRvKHkseCk7XG4gICAgICAgICAgeC5yU2hpZnRUbygxLHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHkuc3ViVG8oeCx5KTtcbiAgICAgICAgICB5LnJTaGlmdFRvKDEseSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKGcgPiAwKSB5LmxTaGlmdFRvKGcseSk7XG4gICAgICByZXR1cm4geTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSB0aGlzICUgbiwgbiA8IDJeMjZcbiAgICBmdW5jdGlvbiBibnBNb2RJbnQobikge1xuICAgICAgaWYobiA8PSAwKSByZXR1cm4gMDtcbiAgICAgIHZhciBkID0gdGhpcy5EViVuLCByID0gKHRoaXMuczwwKT9uLTE6MDtcbiAgICAgIGlmKHRoaXMudCA+IDApXG4gICAgICAgIGlmKGQgPT0gMCkgciA9IHRoaXNbMF0lbjtcbiAgICAgICAgZWxzZSBmb3IodmFyIGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHIgPSAoZCpyK3RoaXNbaV0pJW47XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSAxL3RoaXMgJSBtIChIQUMgMTQuNjEpXG4gICAgZnVuY3Rpb24gYm5Nb2RJbnZlcnNlKG0pIHtcbiAgICAgIHZhciBhYyA9IG0uaXNFdmVuKCk7XG4gICAgICBpZigodGhpcy5pc0V2ZW4oKSAmJiBhYykgfHwgbS5zaWdudW0oKSA9PSAwKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xuICAgICAgdmFyIHUgPSBtLmNsb25lKCksIHYgPSB0aGlzLmNsb25lKCk7XG4gICAgICB2YXIgYSA9IG5idigxKSwgYiA9IG5idigwKSwgYyA9IG5idigwKSwgZCA9IG5idigxKTtcbiAgICAgIHdoaWxlKHUuc2lnbnVtKCkgIT0gMCkge1xuICAgICAgICB3aGlsZSh1LmlzRXZlbigpKSB7XG4gICAgICAgICAgdS5yU2hpZnRUbygxLHUpO1xuICAgICAgICAgIGlmKGFjKSB7XG4gICAgICAgICAgICBpZighYS5pc0V2ZW4oKSB8fCAhYi5pc0V2ZW4oKSkgeyBhLmFkZFRvKHRoaXMsYSk7IGIuc3ViVG8obSxiKTsgfVxuICAgICAgICAgICAgYS5yU2hpZnRUbygxLGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKCFiLmlzRXZlbigpKSBiLnN1YlRvKG0sYik7XG4gICAgICAgICAgYi5yU2hpZnRUbygxLGIpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKHYuaXNFdmVuKCkpIHtcbiAgICAgICAgICB2LnJTaGlmdFRvKDEsdik7XG4gICAgICAgICAgaWYoYWMpIHtcbiAgICAgICAgICAgIGlmKCFjLmlzRXZlbigpIHx8ICFkLmlzRXZlbigpKSB7IGMuYWRkVG8odGhpcyxjKTsgZC5zdWJUbyhtLGQpOyB9XG4gICAgICAgICAgICBjLnJTaGlmdFRvKDEsYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYoIWQuaXNFdmVuKCkpIGQuc3ViVG8obSxkKTtcbiAgICAgICAgICBkLnJTaGlmdFRvKDEsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodS5jb21wYXJlVG8odikgPj0gMCkge1xuICAgICAgICAgIHUuc3ViVG8odix1KTtcbiAgICAgICAgICBpZihhYykgYS5zdWJUbyhjLGEpO1xuICAgICAgICAgIGIuc3ViVG8oZCxiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2LnN1YlRvKHUsdik7XG4gICAgICAgICAgaWYoYWMpIGMuc3ViVG8oYSxjKTtcbiAgICAgICAgICBkLnN1YlRvKGIsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKHYuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xuICAgICAgaWYoZC5jb21wYXJlVG8obSkgPj0gMCkgcmV0dXJuIGQuc3VidHJhY3QobSk7XG4gICAgICBpZihkLnNpZ251bSgpIDwgMCkgZC5hZGRUbyhtLGQpOyBlbHNlIHJldHVybiBkO1xuICAgICAgaWYoZC5zaWdudW0oKSA8IDApIHJldHVybiBkLmFkZChtKTsgZWxzZSByZXR1cm4gZDtcbiAgICB9XG5cbiAgICB2YXIgbG93cHJpbWVzID0gWzIsMyw1LDcsMTEsMTMsMTcsMTksMjMsMjksMzEsMzcsNDEsNDMsNDcsNTMsNTksNjEsNjcsNzEsNzMsNzksODMsODksOTcsMTAxLDEwMywxMDcsMTA5LDExMywxMjcsMTMxLDEzNywxMzksMTQ5LDE1MSwxNTcsMTYzLDE2NywxNzMsMTc5LDE4MSwxOTEsMTkzLDE5NywxOTksMjExLDIyMywyMjcsMjI5LDIzMywyMzksMjQxLDI1MSwyNTcsMjYzLDI2OSwyNzEsMjc3LDI4MSwyODMsMjkzLDMwNywzMTEsMzEzLDMxNywzMzEsMzM3LDM0NywzNDksMzUzLDM1OSwzNjcsMzczLDM3OSwzODMsMzg5LDM5Nyw0MDEsNDA5LDQxOSw0MjEsNDMxLDQzMyw0MzksNDQzLDQ0OSw0NTcsNDYxLDQ2Myw0NjcsNDc5LDQ4Nyw0OTEsNDk5LDUwMyw1MDksNTIxLDUyMyw1NDEsNTQ3LDU1Nyw1NjMsNTY5LDU3MSw1NzcsNTg3LDU5Myw1OTksNjAxLDYwNyw2MTMsNjE3LDYxOSw2MzEsNjQxLDY0Myw2NDcsNjUzLDY1OSw2NjEsNjczLDY3Nyw2ODMsNjkxLDcwMSw3MDksNzE5LDcyNyw3MzMsNzM5LDc0Myw3NTEsNzU3LDc2MSw3NjksNzczLDc4Nyw3OTcsODA5LDgxMSw4MjEsODIzLDgyNyw4MjksODM5LDg1Myw4NTcsODU5LDg2Myw4NzcsODgxLDg4Myw4ODcsOTA3LDkxMSw5MTksOTI5LDkzNyw5NDEsOTQ3LDk1Myw5NjcsOTcxLDk3Nyw5ODMsOTkxLDk5N107XG4gICAgdmFyIGxwbGltID0gKDE8PDI2KS9sb3dwcmltZXNbbG93cHJpbWVzLmxlbmd0aC0xXTtcblxuICAgIC8vIChwdWJsaWMpIHRlc3QgcHJpbWFsaXR5IHdpdGggY2VydGFpbnR5ID49IDEtLjVedFxuICAgIGZ1bmN0aW9uIGJuSXNQcm9iYWJsZVByaW1lKHQpIHtcbiAgICAgIHZhciBpLCB4ID0gdGhpcy5hYnMoKTtcbiAgICAgIGlmKHgudCA9PSAxICYmIHhbMF0gPD0gbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV0pIHtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbG93cHJpbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmKHhbMF0gPT0gbG93cHJpbWVzW2ldKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYoeC5pc0V2ZW4oKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaSA9IDE7XG4gICAgICB3aGlsZShpIDwgbG93cHJpbWVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbSA9IGxvd3ByaW1lc1tpXSwgaiA9IGkrMTtcbiAgICAgICAgd2hpbGUoaiA8IGxvd3ByaW1lcy5sZW5ndGggJiYgbSA8IGxwbGltKSBtICo9IGxvd3ByaW1lc1tqKytdO1xuICAgICAgICBtID0geC5tb2RJbnQobSk7XG4gICAgICAgIHdoaWxlKGkgPCBqKSBpZihtJWxvd3ByaW1lc1tpKytdID09IDApIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4Lm1pbGxlclJhYmluKHQpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHRydWUgaWYgcHJvYmFibHkgcHJpbWUgKEhBQyA0LjI0LCBNaWxsZXItUmFiaW4pXG4gICAgZnVuY3Rpb24gYm5wTWlsbGVyUmFiaW4odCkge1xuICAgICAgdmFyIG4xID0gdGhpcy5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICB2YXIgayA9IG4xLmdldExvd2VzdFNldEJpdCgpO1xuICAgICAgaWYoayA8PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgciA9IG4xLnNoaWZ0UmlnaHQoayk7XG4gICAgICB0ID0gKHQrMSk+PjE7XG4gICAgICBpZih0ID4gbG93cHJpbWVzLmxlbmd0aCkgdCA9IGxvd3ByaW1lcy5sZW5ndGg7XG4gICAgICB2YXIgYSA9IG5iaSgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHQ7ICsraSkge1xuICAgICAgICAvL1BpY2sgYmFzZXMgYXQgcmFuZG9tLCBpbnN0ZWFkIG9mIHN0YXJ0aW5nIGF0IDJcbiAgICAgICAgYS5mcm9tSW50KGxvd3ByaW1lc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqbG93cHJpbWVzLmxlbmd0aCldKTtcbiAgICAgICAgdmFyIHkgPSBhLm1vZFBvdyhyLHRoaXMpO1xuICAgICAgICBpZih5LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgIT0gMCAmJiB5LmNvbXBhcmVUbyhuMSkgIT0gMCkge1xuICAgICAgICAgIHZhciBqID0gMTtcbiAgICAgICAgICB3aGlsZShqKysgPCBrICYmIHkuY29tcGFyZVRvKG4xKSAhPSAwKSB7XG4gICAgICAgICAgICB5ID0geS5tb2RQb3dJbnQoMix0aGlzKTtcbiAgICAgICAgICAgIGlmKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHkuY29tcGFyZVRvKG4xKSAhPSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIHByb3RlY3RlZFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNodW5rU2l6ZSA9IGJucENodW5rU2l6ZTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1JhZGl4ID0gYm5wVG9SYWRpeDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tUmFkaXggPSBibnBGcm9tUmFkaXg7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbU51bWJlciA9IGJucEZyb21OdW1iZXI7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYml0d2lzZVRvID0gYm5wQml0d2lzZVRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNoYW5nZUJpdCA9IGJucENoYW5nZUJpdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGRUbyA9IGJucEFkZFRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRNdWx0aXBseSA9IGJucERNdWx0aXBseTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kQWRkT2Zmc2V0ID0gYm5wREFkZE9mZnNldDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseUxvd2VyVG8gPSBibnBNdWx0aXBseUxvd2VyVG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlVcHBlclRvID0gYm5wTXVsdGlwbHlVcHBlclRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludCA9IGJucE1vZEludDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5taWxsZXJSYWJpbiA9IGJucE1pbGxlclJhYmluO1xuXG4gICAgLy8gcHVibGljXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY2xvbmUgPSBibkNsb25lO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmludFZhbHVlID0gYm5JbnRWYWx1ZTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ieXRlVmFsdWUgPSBibkJ5dGVWYWx1ZTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaG9ydFZhbHVlID0gYm5TaG9ydFZhbHVlO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNpZ251bSA9IGJuU2lnTnVtO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5ID0gYm5Ub0J5dGVBcnJheTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBibkVxdWFscztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5taW4gPSBibk1pbjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBibk1heDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBibkFuZDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5vciA9IGJuT3I7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUueG9yID0gYm5Yb3I7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kTm90ID0gYm5BbmROb3Q7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubm90ID0gYm5Ob3Q7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gYm5TaGlmdExlZnQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodCA9IGJuU2hpZnRSaWdodDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nZXRMb3dlc3RTZXRCaXQgPSBibkdldExvd2VzdFNldEJpdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRDb3VudCA9IGJuQml0Q291bnQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudGVzdEJpdCA9IGJuVGVzdEJpdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zZXRCaXQgPSBiblNldEJpdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGVhckJpdCA9IGJuQ2xlYXJCaXQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZmxpcEJpdCA9IGJuRmxpcEJpdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBibkFkZDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGJuU3VidHJhY3Q7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHkgPSBibk11bHRpcGx5O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZSA9IGJuRGl2aWRlO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IGJuUmVtYWluZGVyO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZUFuZFJlbWFpbmRlciA9IGJuRGl2aWRlQW5kUmVtYWluZGVyO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdyA9IGJuTW9kUG93O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBibk1vZEludmVyc2U7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUucG93ID0gYm5Qb3c7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZ2NkID0gYm5HQ0Q7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gYm5Jc1Byb2JhYmxlUHJpbWU7XG5cbiAgICAvLyBKU0JOLXNwZWNpZmljIGV4dGVuc2lvblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGJuU3F1YXJlO1xuXG4gICAgLy8gRXhwb3NlIHRoZSBCYXJyZXR0IGZ1bmN0aW9uXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuQmFycmV0dCA9IEJhcnJldHRcblxuICAgIC8vIEJpZ0ludGVnZXIgaW50ZXJmYWNlcyBub3QgaW1wbGVtZW50ZWQgaW4ganNibjpcblxuICAgIC8vIEJpZ0ludGVnZXIoaW50IHNpZ251bSwgYnl0ZVtdIG1hZ25pdHVkZSlcbiAgICAvLyBkb3VibGUgZG91YmxlVmFsdWUoKVxuICAgIC8vIGZsb2F0IGZsb2F0VmFsdWUoKVxuICAgIC8vIGludCBoYXNoQ29kZSgpXG4gICAgLy8gbG9uZyBsb25nVmFsdWUoKVxuICAgIC8vIHN0YXRpYyBCaWdJbnRlZ2VyIHZhbHVlT2YobG9uZyB2YWwpXG5cblx0Ly8gUmFuZG9tIG51bWJlciBnZW5lcmF0b3IgLSByZXF1aXJlcyBhIFBSTkcgYmFja2VuZCwgZS5nLiBwcm5nNC5qc1xuXG5cdC8vIEZvciBiZXN0IHJlc3VsdHMsIHB1dCBjb2RlIGxpa2Vcblx0Ly8gPGJvZHkgb25DbGljaz0ncm5nX3NlZWRfdGltZSgpOycgb25LZXlQcmVzcz0ncm5nX3NlZWRfdGltZSgpOyc+XG5cdC8vIGluIHlvdXIgbWFpbiBIVE1MIGRvY3VtZW50LlxuXG5cdHZhciBybmdfc3RhdGU7XG5cdHZhciBybmdfcG9vbDtcblx0dmFyIHJuZ19wcHRyO1xuXG5cdC8vIE1peCBpbiBhIDMyLWJpdCBpbnRlZ2VyIGludG8gdGhlIHBvb2xcblx0ZnVuY3Rpb24gcm5nX3NlZWRfaW50KHgpIHtcblx0ICBybmdfcG9vbFtybmdfcHB0cisrXSBePSB4ICYgMjU1O1xuXHQgIHJuZ19wb29sW3JuZ19wcHRyKytdIF49ICh4ID4+IDgpICYgMjU1O1xuXHQgIHJuZ19wb29sW3JuZ19wcHRyKytdIF49ICh4ID4+IDE2KSAmIDI1NTtcblx0ICBybmdfcG9vbFtybmdfcHB0cisrXSBePSAoeCA+PiAyNCkgJiAyNTU7XG5cdCAgaWYocm5nX3BwdHIgPj0gcm5nX3BzaXplKSBybmdfcHB0ciAtPSBybmdfcHNpemU7XG5cdH1cblxuXHQvLyBNaXggaW4gdGhlIGN1cnJlbnQgdGltZSAody9taWxsaXNlY29uZHMpIGludG8gdGhlIHBvb2xcblx0ZnVuY3Rpb24gcm5nX3NlZWRfdGltZSgpIHtcblx0ICBybmdfc2VlZF9pbnQobmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuXHR9XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgcG9vbCB3aXRoIGp1bmsgaWYgbmVlZGVkLlxuXHRpZihybmdfcG9vbCA9PSBudWxsKSB7XG5cdCAgcm5nX3Bvb2wgPSBuZXcgQXJyYXkoKTtcblx0ICBybmdfcHB0ciA9IDA7XG5cdCAgdmFyIHQ7XG5cdCAgaWYodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY3J5cHRvKSB7XG5cdFx0aWYgKHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG5cdFx0ICAvLyBVc2Ugd2ViY3J5cHRvIGlmIGF2YWlsYWJsZVxuXHRcdCAgdmFyIHVhID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuXHRcdCAgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXModWEpO1xuXHRcdCAgZm9yKHQgPSAwOyB0IDwgMzI7ICsrdClcblx0XHRcdHJuZ19wb29sW3JuZ19wcHRyKytdID0gdWFbdF07XG5cdFx0fVxuXHRcdGVsc2UgaWYobmF2aWdhdG9yLmFwcE5hbWUgPT0gXCJOZXRzY2FwZVwiICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uIDwgXCI1XCIpIHtcblx0XHQgIC8vIEV4dHJhY3QgZW50cm9weSAoMjU2IGJpdHMpIGZyb20gTlM0IFJORyBpZiBhdmFpbGFibGVcblx0XHQgIHZhciB6ID0gd2luZG93LmNyeXB0by5yYW5kb20oMzIpO1xuXHRcdCAgZm9yKHQgPSAwOyB0IDwgei5sZW5ndGg7ICsrdClcblx0XHRcdHJuZ19wb29sW3JuZ19wcHRyKytdID0gei5jaGFyQ29kZUF0KHQpICYgMjU1O1xuXHRcdH1cblx0ICB9XG5cdCAgd2hpbGUocm5nX3BwdHIgPCBybmdfcHNpemUpIHsgIC8vIGV4dHJhY3Qgc29tZSByYW5kb21uZXNzIGZyb20gTWF0aC5yYW5kb20oKVxuXHRcdHQgPSBNYXRoLmZsb29yKDY1NTM2ICogTWF0aC5yYW5kb20oKSk7XG5cdFx0cm5nX3Bvb2xbcm5nX3BwdHIrK10gPSB0ID4+PiA4O1xuXHRcdHJuZ19wb29sW3JuZ19wcHRyKytdID0gdCAmIDI1NTtcblx0ICB9XG5cdCAgcm5nX3BwdHIgPSAwO1xuXHQgIHJuZ19zZWVkX3RpbWUoKTtcblx0ICAvL3JuZ19zZWVkX2ludCh3aW5kb3cuc2NyZWVuWCk7XG5cdCAgLy9ybmdfc2VlZF9pbnQod2luZG93LnNjcmVlblkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm5nX2dldF9ieXRlKCkge1xuXHQgIGlmKHJuZ19zdGF0ZSA9PSBudWxsKSB7XG5cdFx0cm5nX3NlZWRfdGltZSgpO1xuXHRcdHJuZ19zdGF0ZSA9IHBybmdfbmV3c3RhdGUoKTtcblx0XHRybmdfc3RhdGUuaW5pdChybmdfcG9vbCk7XG5cdFx0Zm9yKHJuZ19wcHRyID0gMDsgcm5nX3BwdHIgPCBybmdfcG9vbC5sZW5ndGg7ICsrcm5nX3BwdHIpXG5cdFx0ICBybmdfcG9vbFtybmdfcHB0cl0gPSAwO1xuXHRcdHJuZ19wcHRyID0gMDtcblx0XHQvL3JuZ19wb29sID0gbnVsbDtcblx0ICB9XG5cdCAgLy8gVE9ETzogYWxsb3cgcmVzZWVkaW5nIGFmdGVyIGZpcnN0IHJlcXVlc3Rcblx0ICByZXR1cm4gcm5nX3N0YXRlLm5leHQoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJuZ19nZXRfYnl0ZXMoYmEpIHtcblx0ICB2YXIgaTtcblx0ICBmb3IoaSA9IDA7IGkgPCBiYS5sZW5ndGg7ICsraSkgYmFbaV0gPSBybmdfZ2V0X2J5dGUoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIFNlY3VyZVJhbmRvbSgpIHt9XG5cblx0U2VjdXJlUmFuZG9tLnByb3RvdHlwZS5uZXh0Qnl0ZXMgPSBybmdfZ2V0X2J5dGVzO1xuXG5cdC8vIHBybmc0LmpzIC0gdXNlcyBBcmNmb3VyIGFzIGEgUFJOR1xuXG5cdGZ1bmN0aW9uIEFyY2ZvdXIoKSB7XG5cdCAgdGhpcy5pID0gMDtcblx0ICB0aGlzLmogPSAwO1xuXHQgIHRoaXMuUyA9IG5ldyBBcnJheSgpO1xuXHR9XG5cblx0Ly8gSW5pdGlhbGl6ZSBhcmNmb3VyIGNvbnRleHQgZnJvbSBrZXksIGFuIGFycmF5IG9mIGludHMsIGVhY2ggZnJvbSBbMC4uMjU1XVxuXHRmdW5jdGlvbiBBUkM0aW5pdChrZXkpIHtcblx0ICB2YXIgaSwgaiwgdDtcblx0ICBmb3IoaSA9IDA7IGkgPCAyNTY7ICsraSlcblx0XHR0aGlzLlNbaV0gPSBpO1xuXHQgIGogPSAwO1xuXHQgIGZvcihpID0gMDsgaSA8IDI1NjsgKytpKSB7XG5cdFx0aiA9IChqICsgdGhpcy5TW2ldICsga2V5W2kgJSBrZXkubGVuZ3RoXSkgJiAyNTU7XG5cdFx0dCA9IHRoaXMuU1tpXTtcblx0XHR0aGlzLlNbaV0gPSB0aGlzLlNbal07XG5cdFx0dGhpcy5TW2pdID0gdDtcblx0ICB9XG5cdCAgdGhpcy5pID0gMDtcblx0ICB0aGlzLmogPSAwO1xuXHR9XG5cblx0ZnVuY3Rpb24gQVJDNG5leHQoKSB7XG5cdCAgdmFyIHQ7XG5cdCAgdGhpcy5pID0gKHRoaXMuaSArIDEpICYgMjU1O1xuXHQgIHRoaXMuaiA9ICh0aGlzLmogKyB0aGlzLlNbdGhpcy5pXSkgJiAyNTU7XG5cdCAgdCA9IHRoaXMuU1t0aGlzLmldO1xuXHQgIHRoaXMuU1t0aGlzLmldID0gdGhpcy5TW3RoaXMual07XG5cdCAgdGhpcy5TW3RoaXMual0gPSB0O1xuXHQgIHJldHVybiB0aGlzLlNbKHQgKyB0aGlzLlNbdGhpcy5pXSkgJiAyNTVdO1xuXHR9XG5cblx0QXJjZm91ci5wcm90b3R5cGUuaW5pdCA9IEFSQzRpbml0O1xuXHRBcmNmb3VyLnByb3RvdHlwZS5uZXh0ID0gQVJDNG5leHQ7XG5cblx0Ly8gUGx1ZyBpbiB5b3VyIFJORyBjb25zdHJ1Y3RvciBoZXJlXG5cdGZ1bmN0aW9uIHBybmdfbmV3c3RhdGUoKSB7XG5cdCAgcmV0dXJuIG5ldyBBcmNmb3VyKCk7XG5cdH1cblxuXHQvLyBQb29sIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQgYW5kIGdyZWF0ZXIgdGhhbiAzMi5cblx0Ly8gQW4gYXJyYXkgb2YgYnl0ZXMgdGhlIHNpemUgb2YgdGhlIHBvb2wgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpXG5cdHZhciBybmdfcHNpemUgPSAyNTY7XG5cbiAgQmlnSW50ZWdlci5TZWN1cmVSYW5kb20gPSBTZWN1cmVSYW5kb207XG4gIEJpZ0ludGVnZXIuQmlnSW50ZWdlciA9IEJpZ0ludGVnZXI7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBCaWdJbnRlZ2VyO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuQmlnSW50ZWdlciA9IEJpZ0ludGVnZXI7XG4gICAgdGhpcy5TZWN1cmVSYW5kb20gPSBTZWN1cmVSYW5kb207XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sshpk/node_modules/jsbn/index.js\n");

/***/ })

};
;