/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jsforce";
exports.ids = ["vendor-chunks/jsforce"];
exports.modules = {

/***/ "(action-browser)/./node_modules/jsforce/index.js":
/*!***************************************!*\
  !*** ./node_modules/jsforce/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/jsforce */ \"(action-browser)/./node_modules/jsforce/lib/jsforce.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLG1IQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9pbmRleC5qcz83MTlkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvanNmb3JjZScpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/index.js":
/*!***************************************!*\
  !*** ./node_modules/jsforce/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/jsforce */ \"(rsc)/./node_modules/jsforce/lib/jsforce.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3R0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvaW5kZXguanM/NGFlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2pzZm9yY2UnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/VERSION.js":
/*!*********************************************!*\
  !*** ./node_modules/jsforce/lib/VERSION.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = '1.11.1';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9WRVJTSU9OLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL1ZFUlNJT04uanM/ZjYwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9ICcxLjExLjEnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/VERSION.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/VERSION.js":
/*!*********************************************!*\
  !*** ./node_modules/jsforce/lib/VERSION.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = '1.11.1';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvVkVSU0lPTi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9WRVJTSU9OLmpzPzYzZWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSAnMS4xMS4xJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/VERSION.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/_required.js":
/*!***********************************************!*\
  !*** ./node_modules/jsforce/lib/_required.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// This file content is dynamically created in build script\n\nmodule.exports = {\n  'inherits': __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\"),\n  'util': __webpack_require__(/*! util */ \"util\"),\n  'events': __webpack_require__(/*! events */ \"events\"),\n  'lodash/core': __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n  'readable-stream': __webpack_require__(/*! readable-stream */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/readable.js\"),\n  'multistream': __webpack_require__(/*! multistream */ \"(action-browser)/./node_modules/multistream/index.js\"),\n  './VERSION': __webpack_require__(/*! ./VERSION */ \"(action-browser)/./node_modules/jsforce/lib/VERSION.js\"),\n  './cache': __webpack_require__(/*! ./cache */ \"(action-browser)/./node_modules/jsforce/lib/cache.js\"),\n  './connection': __webpack_require__(/*! ./connection */ \"(action-browser)/./node_modules/jsforce/lib/connection.js\"),\n  './core': __webpack_require__(/*! ./core */ \"(action-browser)/./node_modules/jsforce/lib/core.js\"),\n  './csv': __webpack_require__(/*! ./csv */ \"(action-browser)/./node_modules/jsforce/lib/csv.js\"),\n  './date': __webpack_require__(/*! ./date */ \"(action-browser)/./node_modules/jsforce/lib/date.js\"),\n  './http-api': __webpack_require__(/*! ./http-api */ \"(action-browser)/./node_modules/jsforce/lib/http-api.js\"),\n  './logger': __webpack_require__(/*! ./logger */ \"(action-browser)/./node_modules/jsforce/lib/logger.js\"),\n  './oauth2': __webpack_require__(/*! ./oauth2 */ \"(action-browser)/./node_modules/jsforce/lib/oauth2.js\"),\n  './process': __webpack_require__(/*! ./process */ \"(action-browser)/./node_modules/jsforce/lib/process.js\"),\n  './promise': __webpack_require__(/*! ./promise */ \"(action-browser)/./node_modules/jsforce/lib/promise.js\"),\n  './query': __webpack_require__(/*! ./query */ \"(action-browser)/./node_modules/jsforce/lib/query.js\"),\n  './quick-action': __webpack_require__(/*! ./quick-action */ \"(action-browser)/./node_modules/jsforce/lib/quick-action.js\"),\n  './record-stream': __webpack_require__(/*! ./record-stream */ \"(action-browser)/./node_modules/jsforce/lib/record-stream.js\"),\n  './record': __webpack_require__(/*! ./record */ \"(action-browser)/./node_modules/jsforce/lib/record.js\"),\n  './soap': __webpack_require__(/*! ./soap */ \"(action-browser)/./node_modules/jsforce/lib/soap.js\"),\n  './sobject': __webpack_require__(/*! ./sobject */ \"(action-browser)/./node_modules/jsforce/lib/sobject.js\"),\n  './soql-builder': __webpack_require__(/*! ./soql-builder */ \"(action-browser)/./node_modules/jsforce/lib/soql-builder.js\"),\n  './transport': __webpack_require__(/*! ./transport */ \"(action-browser)/./node_modules/jsforce/lib/transport.js\")\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9fcmVxdWlyZWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHNFQUFVO0FBQ2hDLFVBQVUsbUJBQU8sQ0FBQyxrQkFBTTtBQUN4QixZQUFZLG1CQUFPLENBQUMsc0JBQVE7QUFDNUIsaUJBQWlCLG1CQUFPLENBQUMsbUVBQWE7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMseUdBQWlCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHlFQUFhO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQyx5RUFBVztBQUNsQyxhQUFhLG1CQUFPLENBQUMscUVBQVM7QUFDOUIsa0JBQWtCLG1CQUFPLENBQUMsK0VBQWM7QUFDeEMsWUFBWSxtQkFBTyxDQUFDLG1FQUFRO0FBQzVCLFdBQVcsbUJBQU8sQ0FBQyxpRUFBTztBQUMxQixZQUFZLG1CQUFPLENBQUMsbUVBQVE7QUFDNUIsZ0JBQWdCLG1CQUFPLENBQUMsMkVBQVk7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLHVFQUFVO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyx1RUFBVTtBQUNoQyxlQUFlLG1CQUFPLENBQUMseUVBQVc7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLHlFQUFXO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxxRUFBUztBQUM5QixvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBZ0I7QUFDNUMscUJBQXFCLG1CQUFPLENBQUMscUZBQWlCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQyx1RUFBVTtBQUNoQyxZQUFZLG1CQUFPLENBQUMsbUVBQVE7QUFDNUIsZUFBZSxtQkFBTyxDQUFDLHlFQUFXO0FBQ2xDLG9CQUFvQixtQkFBTyxDQUFDLG1GQUFnQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQyw2RUFBYTtBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvX3JlcXVpcmVkLmpzP2YyMWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIGNvbnRlbnQgaXMgZHluYW1pY2FsbHkgY3JlYXRlZCBpbiBidWlsZCBzY3JpcHRcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICdpbmhlcml0cyc6IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICd1dGlsJzogcmVxdWlyZSgndXRpbCcpLFxuICAnZXZlbnRzJzogcmVxdWlyZSgnZXZlbnRzJyksXG4gICdsb2Rhc2gvY29yZSc6IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyksXG4gICdyZWFkYWJsZS1zdHJlYW0nOiByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKSxcbiAgJ211bHRpc3RyZWFtJzogcmVxdWlyZSgnbXVsdGlzdHJlYW0nKSxcbiAgJy4vVkVSU0lPTic6IHJlcXVpcmUoJy4vVkVSU0lPTicpLFxuICAnLi9jYWNoZSc6IHJlcXVpcmUoJy4vY2FjaGUnKSxcbiAgJy4vY29ubmVjdGlvbic6IHJlcXVpcmUoJy4vY29ubmVjdGlvbicpLFxuICAnLi9jb3JlJzogcmVxdWlyZSgnLi9jb3JlJyksXG4gICcuL2Nzdic6IHJlcXVpcmUoJy4vY3N2JyksXG4gICcuL2RhdGUnOiByZXF1aXJlKCcuL2RhdGUnKSxcbiAgJy4vaHR0cC1hcGknOiByZXF1aXJlKCcuL2h0dHAtYXBpJyksXG4gICcuL2xvZ2dlcic6IHJlcXVpcmUoJy4vbG9nZ2VyJyksXG4gICcuL29hdXRoMic6IHJlcXVpcmUoJy4vb2F1dGgyJyksXG4gICcuL3Byb2Nlc3MnOiByZXF1aXJlKCcuL3Byb2Nlc3MnKSxcbiAgJy4vcHJvbWlzZSc6IHJlcXVpcmUoJy4vcHJvbWlzZScpLFxuICAnLi9xdWVyeSc6IHJlcXVpcmUoJy4vcXVlcnknKSxcbiAgJy4vcXVpY2stYWN0aW9uJzogcmVxdWlyZSgnLi9xdWljay1hY3Rpb24nKSxcbiAgJy4vcmVjb3JkLXN0cmVhbSc6IHJlcXVpcmUoJy4vcmVjb3JkLXN0cmVhbScpLFxuICAnLi9yZWNvcmQnOiByZXF1aXJlKCcuL3JlY29yZCcpLFxuICAnLi9zb2FwJzogcmVxdWlyZSgnLi9zb2FwJyksXG4gICcuL3NvYmplY3QnOiByZXF1aXJlKCcuL3NvYmplY3QnKSxcbiAgJy4vc29xbC1idWlsZGVyJzogcmVxdWlyZSgnLi9zb3FsLWJ1aWxkZXInKSxcbiAgJy4vdHJhbnNwb3J0JzogcmVxdWlyZSgnLi90cmFuc3BvcnQnKVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/_required.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/_required.js":
/*!***********************************************!*\
  !*** ./node_modules/jsforce/lib/_required.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// This file content is dynamically created in build script\n\nmodule.exports = {\n  'inherits': __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\"),\n  'util': __webpack_require__(/*! util */ \"util\"),\n  'events': __webpack_require__(/*! events */ \"events\"),\n  'lodash/core': __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n  'readable-stream': __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/readable.js\"),\n  'multistream': __webpack_require__(/*! multistream */ \"(rsc)/./node_modules/multistream/index.js\"),\n  './VERSION': __webpack_require__(/*! ./VERSION */ \"(rsc)/./node_modules/jsforce/lib/VERSION.js\"),\n  './cache': __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/jsforce/lib/cache.js\"),\n  './connection': __webpack_require__(/*! ./connection */ \"(rsc)/./node_modules/jsforce/lib/connection.js\"),\n  './core': __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/jsforce/lib/core.js\"),\n  './csv': __webpack_require__(/*! ./csv */ \"(rsc)/./node_modules/jsforce/lib/csv.js\"),\n  './date': __webpack_require__(/*! ./date */ \"(rsc)/./node_modules/jsforce/lib/date.js\"),\n  './http-api': __webpack_require__(/*! ./http-api */ \"(rsc)/./node_modules/jsforce/lib/http-api.js\"),\n  './logger': __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/jsforce/lib/logger.js\"),\n  './oauth2': __webpack_require__(/*! ./oauth2 */ \"(rsc)/./node_modules/jsforce/lib/oauth2.js\"),\n  './process': __webpack_require__(/*! ./process */ \"(rsc)/./node_modules/jsforce/lib/process.js\"),\n  './promise': __webpack_require__(/*! ./promise */ \"(rsc)/./node_modules/jsforce/lib/promise.js\"),\n  './query': __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/jsforce/lib/query.js\"),\n  './quick-action': __webpack_require__(/*! ./quick-action */ \"(rsc)/./node_modules/jsforce/lib/quick-action.js\"),\n  './record-stream': __webpack_require__(/*! ./record-stream */ \"(rsc)/./node_modules/jsforce/lib/record-stream.js\"),\n  './record': __webpack_require__(/*! ./record */ \"(rsc)/./node_modules/jsforce/lib/record.js\"),\n  './soap': __webpack_require__(/*! ./soap */ \"(rsc)/./node_modules/jsforce/lib/soap.js\"),\n  './sobject': __webpack_require__(/*! ./sobject */ \"(rsc)/./node_modules/jsforce/lib/sobject.js\"),\n  './soql-builder': __webpack_require__(/*! ./soql-builder */ \"(rsc)/./node_modules/jsforce/lib/soql-builder.js\"),\n  './transport': __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/jsforce/lib/transport.js\")\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvX3JlcXVpcmVkLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7QUFDYjtBQUNBLGNBQWMsbUJBQU8sQ0FBQywyREFBVTtBQUNoQyxVQUFVLG1CQUFPLENBQUMsa0JBQU07QUFDeEIsWUFBWSxtQkFBTyxDQUFDLHNCQUFRO0FBQzVCLGlCQUFpQixtQkFBTyxDQUFDLHdEQUFhO0FBQ3RDLHFCQUFxQixtQkFBTyxDQUFDLDhGQUFpQjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyw4REFBYTtBQUN0QyxlQUFlLG1CQUFPLENBQUMsOERBQVc7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDBEQUFTO0FBQzlCLGtCQUFrQixtQkFBTyxDQUFDLG9FQUFjO0FBQ3hDLFlBQVksbUJBQU8sQ0FBQyx3REFBUTtBQUM1QixXQUFXLG1CQUFPLENBQUMsc0RBQU87QUFDMUIsWUFBWSxtQkFBTyxDQUFDLHdEQUFRO0FBQzVCLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFZO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyw0REFBVTtBQUNoQyxjQUFjLG1CQUFPLENBQUMsNERBQVU7QUFDaEMsZUFBZSxtQkFBTyxDQUFDLDhEQUFXO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyw4REFBVztBQUNsQyxhQUFhLG1CQUFPLENBQUMsMERBQVM7QUFDOUIsb0JBQW9CLG1CQUFPLENBQUMsd0VBQWdCO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLDBFQUFpQjtBQUM5QyxjQUFjLG1CQUFPLENBQUMsNERBQVU7QUFDaEMsWUFBWSxtQkFBTyxDQUFDLHdEQUFRO0FBQzVCLGVBQWUsbUJBQU8sQ0FBQyw4REFBVztBQUNsQyxvQkFBb0IsbUJBQU8sQ0FBQyx3RUFBZ0I7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsa0VBQWE7QUFDdEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL19yZXF1aXJlZC5qcz8xZDI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBjb250ZW50IGlzIGR5bmFtaWNhbGx5IGNyZWF0ZWQgaW4gYnVpbGQgc2NyaXB0XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAnaW5oZXJpdHMnOiByZXF1aXJlKCdpbmhlcml0cycpLFxuICAndXRpbCc6IHJlcXVpcmUoJ3V0aWwnKSxcbiAgJ2V2ZW50cyc6IHJlcXVpcmUoJ2V2ZW50cycpLFxuICAnbG9kYXNoL2NvcmUnOiByZXF1aXJlKCdsb2Rhc2gvY29yZScpLFxuICAncmVhZGFibGUtc3RyZWFtJzogcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJyksXG4gICdtdWx0aXN0cmVhbSc6IHJlcXVpcmUoJ211bHRpc3RyZWFtJyksXG4gICcuL1ZFUlNJT04nOiByZXF1aXJlKCcuL1ZFUlNJT04nKSxcbiAgJy4vY2FjaGUnOiByZXF1aXJlKCcuL2NhY2hlJyksXG4gICcuL2Nvbm5lY3Rpb24nOiByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKSxcbiAgJy4vY29yZSc6IHJlcXVpcmUoJy4vY29yZScpLFxuICAnLi9jc3YnOiByZXF1aXJlKCcuL2NzdicpLFxuICAnLi9kYXRlJzogcmVxdWlyZSgnLi9kYXRlJyksXG4gICcuL2h0dHAtYXBpJzogcmVxdWlyZSgnLi9odHRwLWFwaScpLFxuICAnLi9sb2dnZXInOiByZXF1aXJlKCcuL2xvZ2dlcicpLFxuICAnLi9vYXV0aDInOiByZXF1aXJlKCcuL29hdXRoMicpLFxuICAnLi9wcm9jZXNzJzogcmVxdWlyZSgnLi9wcm9jZXNzJyksXG4gICcuL3Byb21pc2UnOiByZXF1aXJlKCcuL3Byb21pc2UnKSxcbiAgJy4vcXVlcnknOiByZXF1aXJlKCcuL3F1ZXJ5JyksXG4gICcuL3F1aWNrLWFjdGlvbic6IHJlcXVpcmUoJy4vcXVpY2stYWN0aW9uJyksXG4gICcuL3JlY29yZC1zdHJlYW0nOiByZXF1aXJlKCcuL3JlY29yZC1zdHJlYW0nKSxcbiAgJy4vcmVjb3JkJzogcmVxdWlyZSgnLi9yZWNvcmQnKSxcbiAgJy4vc29hcCc6IHJlcXVpcmUoJy4vc29hcCcpLFxuICAnLi9zb2JqZWN0JzogcmVxdWlyZSgnLi9zb2JqZWN0JyksXG4gICcuL3NvcWwtYnVpbGRlcic6IHJlcXVpcmUoJy4vc29xbC1idWlsZGVyJyksXG4gICcuL3RyYW5zcG9ydCc6IHJlcXVpcmUoJy4vdHJhbnNwb3J0Jylcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/_required.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/api/analytics.js":
/*!***************************************************!*\
  !*** ./node_modules/jsforce/lib/api/analytics.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages Salesforce Analytics API\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar _ = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    jsforce = __webpack_require__(/*! ../core */ \"(action-browser)/./node_modules/jsforce/lib/core.js\"),\n    Promise  = __webpack_require__(/*! ../promise */ \"(action-browser)/./node_modules/jsforce/lib/promise.js\");\n\n/**\n * Report instance to retrieving asynchronously executed result\n *\n * @protected\n * @class Analytics~ReportInstance\n * @param {Analytics~Report} report - Report\n * @param {String} id - Report instance id\n */\nvar ReportInstance = function(report, id) {\n  this._report = report;\n  this._conn = report._conn;\n  this.id = id;\n};\n\n/**\n * Retrieve report result asynchronously executed\n *\n * @method Analytics~ReportInstance#retrieve\n * @param {Callback.<Analytics~ReportResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportResult>}\n */\nReportInstance.prototype.retrieve = function(callback) {\n  var conn = this._conn,\n      report = this._report;\n  var url = [ conn._baseUrl(), \"analytics\", \"reports\", report.id, \"instances\", this.id ].join('/');\n  return conn.request(url).thenCall(callback);\n};\n\n/**\n * Report object in Analytics API\n *\n * @protected\n * @class Analytics~Report\n * @param {Connection} conn Connection\n */\nvar Report = function(conn, id) {\n  this._conn = conn;\n  this.id = id;\n};\n\n/**\n * Describe report metadata\n *\n * @method Analytics~Report#describe\n * @param {Callback.<Analytics~ReportMetadata>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportMetadata>}\n */\nReport.prototype.describe = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"reports\", this.id, \"describe\" ].join('/');\n  return this._conn.request(url).thenCall(callback);\n};\n\n/**\n * Synonym of Analytics~Report#destroy()\n *\n * @method Analytics~Report#delete\n * @param {Callback.<Analytics~ReportResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportResult>}\n */\n/**\n * Synonym of Analytics~Report#destroy()\n *\n * @method Analytics~Report#del\n * @param {Callback.<Analytics~ReportResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportResult>}\n */\n/**\n * Destroy a report\n *\n * @method Analytics~Report#destroy\n * @param {Callback.<Analytics~ReportResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportResult>}\n */\nReport.prototype[\"delete\"] =\nReport.prototype.del =\nReport.prototype.destroy = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"reports\", this.id ].join('/');\n  return this._conn.request({method: 'DELETE', url: url}).thenCall(callback);\n};\n\n/**\n * Clones a given report\n *\n * @method Analytics~Report#clone\n * @param {String} name - The name of the new report\n * @param {Callback.<Analytics~ReportResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportResult>}\n */\nReport.prototype.clone = function(name, callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"reports\" ].join('/');\n  url += \"?cloneId=\" + this.id;\n  var data = { reportMetadata: { name: name } };\n  var params = { method : 'POST', url: url, headers: { \"Content-Type\" : \"application/json\" }, body: JSON.stringify(data)};\n\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Explain plan for executing report\n *\n * @method Analytics~Report#explain\n * @param {Callback.<ExplainInfo>} [callback] - Callback function\n * @returns {Promise.<ExplainInfo>}\n */\nReport.prototype.explain = function(callback) {\n  var url = \"/query/?explain=\" + this.id;\n  return this._conn.request(url).thenCall(callback);\n};\n\n\n/**\n * Run report synchronously\n *\n * @method Analytics~Report#execute\n * @param {Object} [options] - Options\n * @param {Boolean} options.details - Flag if include detail in result\n * @param {Analytics~ReportMetadata} options.metadata - Overriding report metadata\n * @param {Callback.<Analytics~ReportResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportResult>}\n */\nReport.prototype.run =\nReport.prototype.exec =\nReport.prototype.execute = function(options, callback) {\n  options = options || {};\n  if (_.isFunction(options)) {\n    callback = options;\n    options = {};\n  }\n  var url = [ this._conn._baseUrl(), \"analytics\", \"reports\", this.id ].join('/');\n  url += \"?includeDetails=\" + (options.details ? \"true\" : \"false\");\n  var params = { method : options.metadata ? 'POST' : 'GET', url : url };\n  if (options.metadata) {\n    params.headers = { \"Content-Type\" : \"application/json\" };\n    params.body = JSON.stringify(options.metadata);\n  }\n  return this._conn.request(params).thenCall(callback);\n};\n\n\n/**\n * Run report asynchronously\n *\n * @method Analytics~Report#executeAsync\n * @param {Object} [options] - Options\n * @param {Boolean} options.details - Flag if include detail in result\n * @param {Analytics~ReportMetadata} options.metadata - Overriding report metadata\n * @param {Callback.<Analytics~ReportInstanceAttrs>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportInstanceAttrs>}\n */\nReport.prototype.executeAsync = function(options, callback) {\n  options = options || {};\n  if (_.isFunction(options)) {\n    callback = options;\n    options = {};\n  }\n  var url = [ this._conn._baseUrl(), \"analytics\", \"reports\", this.id, \"instances\" ].join('/');\n  if (options.details) {\n    url += \"?includeDetails=true\";\n  }\n  var params = { method : 'POST', url : url, body: \"\" };\n  if (options.metadata) {\n    params.headers = { \"Content-Type\" : \"application/json\" };\n    params.body = JSON.stringify(options.metadata);\n  }\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Get report instance for specified instance ID\n *\n * @method Analytics~Report#instance\n * @param {String} id - Report instance ID\n * @returns {Analytics~ReportInstance}\n */\nReport.prototype.instance = function(id) {\n  return new ReportInstance(this, id);\n};\n\n/**\n * List report instances which had been executed asynchronously\n *\n * @method Analytics~Report#instances\n * @param {Callback.<Array.<Analytics~ReportInstanceAttrs>>} [callback] - Callback function\n * @returns {Promise.<Array.<Analytics~ReportInstanceAttrs>>}\n */\nReport.prototype.instances = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"reports\", this.id, \"instances\" ].join('/');\n  return this._conn.request(url).thenCall(callback);\n};\n\n/**\n * Dashboard object in the Analytics API\n *\n * @protected\n * @class Analytics-Dashboard\n * @param {Connection} conn Connection\n * @param {String} id - The Id\n */\n\nvar Dashboard = function(conn, id) {\n  this._conn = conn;\n  this.id = id;\n};\n\n/**\n * Describe dashboard metadata\n *\n * @method Analytics~Dashboard#describe\n * @param {Callback.<Analytics-DashboardMetadata>} [callback] - Callback function\n * @returns {Promise.<Analytics-DashboardMetadata>}\n */\nDashboard.prototype.describe = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"dashboards\", this.id, \"describe\" ].join('/');\n  return this._conn.request(url).thenCall(callback);\n};\n\n/**\n * Get details about dashboard components\n *\n * @method Analytics~Dashboard#components\n * @param {Callback.<Analytics-DashboardComponentMetadata>} [callback] - Callback function\n * @returns {Promise.<Analytics-DashboardComponentMetadata>}\n */\nDashboard.prototype.components = function(componentIds, callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"dashboards\", this.id].join('/');\n  var data = {};\n  if (_.isFunction(componentIds)) {\n    callback = componentIds;\n  } else if (_.isArray(componentIds)) {\n    data.componentIds = componentIds;\n  } else if (_.isString(componentIds)) {\n    data.componentIds = [ componentIds ];\n  }\n  var params = { method : 'POST', url : url, headers : { \"Content-Type\" : \"application/json\" }, body : JSON.stringify(data)};\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Get dashboard status\n *\n * @method Analytics~Dashboard#status\n * @param {Callback.<Analytics-DashboardStatusMetadata>} [callback] - Callback function\n * @returns {Promise.<Analytics-DashboardStatusMetadata>}\n */\nDashboard.prototype.status = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"dashboards\", this.id, \"status\" ].join('/');\n  return this._conn.request(url).thenCall(callback);\n};\n\n/**\n * Refresh a dashboard\n *\n * @method Analytics~Dashboard#refresh\n * @param {Callback.<Analytics-DashboardStatusUrl>} [callback] - Callback function\n * @returns {Promise.<Analytics-DashboardStatusUrl>}\n */\nDashboard.prototype.refresh = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"dashboards\", this.id ].join('/');\n  var params = { method : 'PUT', url : url, body: '' };\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Clone a dashboard\n *\n * @method Analytics~Dashboard#clone\n * @param {Callback.<Analytics-DashboardMetadata>} [callback] - Callback function\n * @returns {Promise.<Analytics-DashboardMetadata>}\n */\nDashboard.prototype.clone = function(name, folderid, callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"dashboards\" ].join('/');\n  url += \"?cloneId=\" + this.id;\n  var data = {};\n\n  if (_.isObject(name)) {\n    data = name;\n    callback = folderid;\n  } else {\n    data.name = name;\n    data.folderId = folderid;\n  }\n  var params = { method : 'POST', url : url, headers : { \"Content-Type\" : \"application/json\" }, body : JSON.stringify(data)};\n\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Synonym of Analytics~Dashboard#destroy()\n *\n * @method Analytics~Dashboard#delete\n * @param {Callback.<Analytics~DashboardResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~DashboardResult>}\n */\n/**\n * Synonym of Analytics~Dashboard#destroy()\n *\n * @method Analytics~Dashboard#del\n * @param {Callback.<Analytics~DashboardResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~DashboardResult>}\n */\n/**\n * Destroy a dashboard\n *\n * @method Analytics~Dashboard#destroy\n * @param {Callback.<Analytics~DashboardResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~DashboardResult>}\n */\nDashboard.prototype[\"delete\"] =\nDashboard.prototype.del =\nDashboard.prototype.destroy = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"dashboards\", this.id ].join('/');\n  return this._conn.request({method: 'DELETE', url: url}).thenCall(callback);\n};\n\n/**\n * API class for Analytics API\n *\n * @class\n * @param {Connection} conn Connection\n */\nvar Analytics = function(conn) {\n  this._conn = conn;\n};\n\n/**\n * Get report object of Analytics API\n *\n * @param {String} id - Report Id\n * @returns {Analytics~Report}\n */\nAnalytics.prototype.report = function(id) {\n  return new Report(this._conn, id);\n};\n\n/**\n * Get recent report list\n *\n * @param {Callback.<Array.<Analytics~ReportInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<Analytics~ReportInfo>>}\n */\nAnalytics.prototype.reports = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"reports\" ].join('/');\n  return this._conn.request(url).thenCall(callback);\n};\n\n/**\n * Get dashboard object of Analytics API\n *\n * @param {String} id - Dashboard Id\n * @returns {Analytics~Dashboard}\n */\nAnalytics.prototype.dashboard = function(id) {\n  return new Dashboard(this._conn, id);\n};\n\n/**\n * Get recent dashboard list\n *\n * @param {Callback.<Array.<Analytics~DashboardInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<Analytics~DashboardInfo>>}\n */\nAnalytics.prototype.dashboards = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"dashboards\" ].join('/');\n  return this._conn.request(url).thenCall(callback);\n};\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.analytics = new Analytics(conn);\n});\n\n\nmodule.exports = Analytics;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvYW5hbHl0aWNzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxtRUFBYTtBQUM3QixjQUFjLG1CQUFPLENBQUMsb0VBQVM7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLDBFQUFZOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFDQUFxQztBQUNoRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1DQUFtQztBQUM5QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQ0FBbUM7QUFDOUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsaUJBQWlCLHNDQUFzQyxxQ0FBcUM7O0FBRTVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsMEJBQTBCO0FBQ3JDLFdBQVcsbUNBQW1DO0FBQzlDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVywwQkFBMEI7QUFDckMsV0FBVywwQ0FBMEM7QUFDckQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrREFBa0Q7QUFDN0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdDQUF3QztBQUNuRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaURBQWlEO0FBQzVELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGlCQUFpQix3Q0FBd0MscUNBQXFDO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhDQUE4QztBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUNBQXlDO0FBQ3BELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0NBQXdDO0FBQ25ELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQXdDLHFDQUFxQzs7QUFFOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0NBQXNDO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQ0FBc0M7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNDQUFzQztBQUNqRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QztBQUNwRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQTRDO0FBQ3ZELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvYW5hbHl0aWNzLmpzPzgwMDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBNYW5hZ2VzIFNhbGVzZm9yY2UgQW5hbHl0aWNzIEFQSVxuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyksXG4gICAganNmb3JjZSA9IHJlcXVpcmUoJy4uL2NvcmUnKSxcbiAgICBQcm9taXNlICA9IHJlcXVpcmUoJy4uL3Byb21pc2UnKTtcblxuLyoqXG4gKiBSZXBvcnQgaW5zdGFuY2UgdG8gcmV0cmlldmluZyBhc3luY2hyb25vdXNseSBleGVjdXRlZCByZXN1bHRcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAY2xhc3MgQW5hbHl0aWNzflJlcG9ydEluc3RhbmNlXG4gKiBAcGFyYW0ge0FuYWx5dGljc35SZXBvcnR9IHJlcG9ydCAtIFJlcG9ydFxuICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gUmVwb3J0IGluc3RhbmNlIGlkXG4gKi9cbnZhciBSZXBvcnRJbnN0YW5jZSA9IGZ1bmN0aW9uKHJlcG9ydCwgaWQpIHtcbiAgdGhpcy5fcmVwb3J0ID0gcmVwb3J0O1xuICB0aGlzLl9jb25uID0gcmVwb3J0Ll9jb25uO1xuICB0aGlzLmlkID0gaWQ7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHJlcG9ydCByZXN1bHQgYXN5bmNocm9ub3VzbHkgZXhlY3V0ZWRcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35SZXBvcnRJbnN0YW5jZSNyZXRyaWV2ZVxuICogQHBhcmFtIHtDYWxsYmFjay48QW5hbHl0aWNzflJlcG9ydFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFuYWx5dGljc35SZXBvcnRSZXN1bHQ+fVxuICovXG5SZXBvcnRJbnN0YW5jZS5wcm90b3R5cGUucmV0cmlldmUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgY29ubiA9IHRoaXMuX2Nvbm4sXG4gICAgICByZXBvcnQgPSB0aGlzLl9yZXBvcnQ7XG4gIHZhciB1cmwgPSBbIGNvbm4uX2Jhc2VVcmwoKSwgXCJhbmFseXRpY3NcIiwgXCJyZXBvcnRzXCIsIHJlcG9ydC5pZCwgXCJpbnN0YW5jZXNcIiwgdGhpcy5pZCBdLmpvaW4oJy8nKTtcbiAgcmV0dXJuIGNvbm4ucmVxdWVzdCh1cmwpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmVwb3J0IG9iamVjdCBpbiBBbmFseXRpY3MgQVBJXG4gKlxuICogQHByb3RlY3RlZFxuICogQGNsYXNzIEFuYWx5dGljc35SZXBvcnRcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiBDb25uZWN0aW9uXG4gKi9cbnZhciBSZXBvcnQgPSBmdW5jdGlvbihjb25uLCBpZCkge1xuICB0aGlzLl9jb25uID0gY29ubjtcbiAgdGhpcy5pZCA9IGlkO1xufTtcblxuLyoqXG4gKiBEZXNjcmliZSByZXBvcnQgbWV0YWRhdGFcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35SZXBvcnQjZGVzY3JpYmVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFuYWx5dGljc35SZXBvcnRNZXRhZGF0YT59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFuYWx5dGljc35SZXBvcnRNZXRhZGF0YT59XG4gKi9cblJlcG9ydC5wcm90b3R5cGUuZGVzY3JpYmUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgdXJsID0gWyB0aGlzLl9jb25uLl9iYXNlVXJsKCksIFwiYW5hbHl0aWNzXCIsIFwicmVwb3J0c1wiLCB0aGlzLmlkLCBcImRlc2NyaWJlXCIgXS5qb2luKCcvJyk7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFN5bm9ueW0gb2YgQW5hbHl0aWNzflJlcG9ydCNkZXN0cm95KClcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35SZXBvcnQjZGVsZXRlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBbmFseXRpY3N+UmVwb3J0UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QW5hbHl0aWNzflJlcG9ydFJlc3VsdD59XG4gKi9cbi8qKlxuICogU3lub255bSBvZiBBbmFseXRpY3N+UmVwb3J0I2Rlc3Ryb3koKVxuICpcbiAqIEBtZXRob2QgQW5hbHl0aWNzflJlcG9ydCNkZWxcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFuYWx5dGljc35SZXBvcnRSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBbmFseXRpY3N+UmVwb3J0UmVzdWx0Pn1cbiAqL1xuLyoqXG4gKiBEZXN0cm95IGEgcmVwb3J0XG4gKlxuICogQG1ldGhvZCBBbmFseXRpY3N+UmVwb3J0I2Rlc3Ryb3lcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFuYWx5dGljc35SZXBvcnRSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBbmFseXRpY3N+UmVwb3J0UmVzdWx0Pn1cbiAqL1xuUmVwb3J0LnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9XG5SZXBvcnQucHJvdG90eXBlLmRlbCA9XG5SZXBvcnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgdXJsID0gWyB0aGlzLl9jb25uLl9iYXNlVXJsKCksIFwiYW5hbHl0aWNzXCIsIFwicmVwb3J0c1wiLCB0aGlzLmlkIF0uam9pbignLycpO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHttZXRob2Q6ICdERUxFVEUnLCB1cmw6IHVybH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQ2xvbmVzIGEgZ2l2ZW4gcmVwb3J0XG4gKlxuICogQG1ldGhvZCBBbmFseXRpY3N+UmVwb3J0I2Nsb25lXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBuZXcgcmVwb3J0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBbmFseXRpY3N+UmVwb3J0UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QW5hbHl0aWNzflJlcG9ydFJlc3VsdD59XG4gKi9cblJlcG9ydC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICB2YXIgdXJsID0gWyB0aGlzLl9jb25uLl9iYXNlVXJsKCksIFwiYW5hbHl0aWNzXCIsIFwicmVwb3J0c1wiIF0uam9pbignLycpO1xuICB1cmwgKz0gXCI/Y2xvbmVJZD1cIiArIHRoaXMuaWQ7XG4gIHZhciBkYXRhID0geyByZXBvcnRNZXRhZGF0YTogeyBuYW1lOiBuYW1lIH0gfTtcbiAgdmFyIHBhcmFtcyA9IHsgbWV0aG9kIDogJ1BPU1QnLCB1cmw6IHVybCwgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiIDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSl9O1xuXG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QocGFyYW1zKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEV4cGxhaW4gcGxhbiBmb3IgZXhlY3V0aW5nIHJlcG9ydFxuICpcbiAqIEBtZXRob2QgQW5hbHl0aWNzflJlcG9ydCNleHBsYWluXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxFeHBsYWluSW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEV4cGxhaW5JbmZvPn1cbiAqL1xuUmVwb3J0LnByb3RvdHlwZS5leHBsYWluID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFwiL3F1ZXJ5Lz9leHBsYWluPVwiICsgdGhpcy5pZDtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdCh1cmwpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cblxuLyoqXG4gKiBSdW4gcmVwb3J0IHN5bmNocm9ub3VzbHlcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35SZXBvcnQjZXhlY3V0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5kZXRhaWxzIC0gRmxhZyBpZiBpbmNsdWRlIGRldGFpbCBpbiByZXN1bHRcbiAqIEBwYXJhbSB7QW5hbHl0aWNzflJlcG9ydE1ldGFkYXRhfSBvcHRpb25zLm1ldGFkYXRhIC0gT3ZlcnJpZGluZyByZXBvcnQgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFuYWx5dGljc35SZXBvcnRSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBbmFseXRpY3N+UmVwb3J0UmVzdWx0Pn1cbiAqL1xuUmVwb3J0LnByb3RvdHlwZS5ydW4gPVxuUmVwb3J0LnByb3RvdHlwZS5leGVjID1cblJlcG9ydC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoXy5pc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICB2YXIgdXJsID0gWyB0aGlzLl9jb25uLl9iYXNlVXJsKCksIFwiYW5hbHl0aWNzXCIsIFwicmVwb3J0c1wiLCB0aGlzLmlkIF0uam9pbignLycpO1xuICB1cmwgKz0gXCI/aW5jbHVkZURldGFpbHM9XCIgKyAob3B0aW9ucy5kZXRhaWxzID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpO1xuICB2YXIgcGFyYW1zID0geyBtZXRob2QgOiBvcHRpb25zLm1ldGFkYXRhID8gJ1BPU1QnIDogJ0dFVCcsIHVybCA6IHVybCB9O1xuICBpZiAob3B0aW9ucy5tZXRhZGF0YSkge1xuICAgIHBhcmFtcy5oZWFkZXJzID0geyBcIkNvbnRlbnQtVHlwZVwiIDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgICBwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMubWV0YWRhdGEpO1xuICB9XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QocGFyYW1zKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG5cbi8qKlxuICogUnVuIHJlcG9ydCBhc3luY2hyb25vdXNseVxuICpcbiAqIEBtZXRob2QgQW5hbHl0aWNzflJlcG9ydCNleGVjdXRlQXN5bmNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuZGV0YWlscyAtIEZsYWcgaWYgaW5jbHVkZSBkZXRhaWwgaW4gcmVzdWx0XG4gKiBAcGFyYW0ge0FuYWx5dGljc35SZXBvcnRNZXRhZGF0YX0gb3B0aW9ucy5tZXRhZGF0YSAtIE92ZXJyaWRpbmcgcmVwb3J0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBbmFseXRpY3N+UmVwb3J0SW5zdGFuY2VBdHRycz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFuYWx5dGljc35SZXBvcnRJbnN0YW5jZUF0dHJzPn1cbiAqL1xuUmVwb3J0LnByb3RvdHlwZS5leGVjdXRlQXN5bmMgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgdmFyIHVybCA9IFsgdGhpcy5fY29ubi5fYmFzZVVybCgpLCBcImFuYWx5dGljc1wiLCBcInJlcG9ydHNcIiwgdGhpcy5pZCwgXCJpbnN0YW5jZXNcIiBdLmpvaW4oJy8nKTtcbiAgaWYgKG9wdGlvbnMuZGV0YWlscykge1xuICAgIHVybCArPSBcIj9pbmNsdWRlRGV0YWlscz10cnVlXCI7XG4gIH1cbiAgdmFyIHBhcmFtcyA9IHsgbWV0aG9kIDogJ1BPU1QnLCB1cmwgOiB1cmwsIGJvZHk6IFwiXCIgfTtcbiAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHtcbiAgICBwYXJhbXMuaGVhZGVycyA9IHsgXCJDb250ZW50LVR5cGVcIiA6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG4gICAgcGFyYW1zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLm1ldGFkYXRhKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHBhcmFtcykudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXQgcmVwb3J0IGluc3RhbmNlIGZvciBzcGVjaWZpZWQgaW5zdGFuY2UgSURcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35SZXBvcnQjaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIFJlcG9ydCBpbnN0YW5jZSBJRFxuICogQHJldHVybnMge0FuYWx5dGljc35SZXBvcnRJbnN0YW5jZX1cbiAqL1xuUmVwb3J0LnByb3RvdHlwZS5pbnN0YW5jZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiBuZXcgUmVwb3J0SW5zdGFuY2UodGhpcywgaWQpO1xufTtcblxuLyoqXG4gKiBMaXN0IHJlcG9ydCBpbnN0YW5jZXMgd2hpY2ggaGFkIGJlZW4gZXhlY3V0ZWQgYXN5bmNocm9ub3VzbHlcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35SZXBvcnQjaW5zdGFuY2VzXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48QW5hbHl0aWNzflJlcG9ydEluc3RhbmNlQXR0cnM+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXkuPEFuYWx5dGljc35SZXBvcnRJbnN0YW5jZUF0dHJzPj59XG4gKi9cblJlcG9ydC5wcm90b3R5cGUuaW5zdGFuY2VzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fY29ubi5fYmFzZVVybCgpLCBcImFuYWx5dGljc1wiLCBcInJlcG9ydHNcIiwgdGhpcy5pZCwgXCJpbnN0YW5jZXNcIiBdLmpvaW4oJy8nKTtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdCh1cmwpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRGFzaGJvYXJkIG9iamVjdCBpbiB0aGUgQW5hbHl0aWNzIEFQSVxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBjbGFzcyBBbmFseXRpY3MtRGFzaGJvYXJkXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gQ29ubmVjdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gVGhlIElkXG4gKi9cblxudmFyIERhc2hib2FyZCA9IGZ1bmN0aW9uKGNvbm4sIGlkKSB7XG4gIHRoaXMuX2Nvbm4gPSBjb25uO1xuICB0aGlzLmlkID0gaWQ7XG59O1xuXG4vKipcbiAqIERlc2NyaWJlIGRhc2hib2FyZCBtZXRhZGF0YVxuICpcbiAqIEBtZXRob2QgQW5hbHl0aWNzfkRhc2hib2FyZCNkZXNjcmliZVxuICogQHBhcmFtIHtDYWxsYmFjay48QW5hbHl0aWNzLURhc2hib2FyZE1ldGFkYXRhPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QW5hbHl0aWNzLURhc2hib2FyZE1ldGFkYXRhPn1cbiAqL1xuRGFzaGJvYXJkLnByb3RvdHlwZS5kZXNjcmliZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Nvbm4uX2Jhc2VVcmwoKSwgXCJhbmFseXRpY3NcIiwgXCJkYXNoYm9hcmRzXCIsIHRoaXMuaWQsIFwiZGVzY3JpYmVcIiBdLmpvaW4oJy8nKTtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdCh1cmwpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogR2V0IGRldGFpbHMgYWJvdXQgZGFzaGJvYXJkIGNvbXBvbmVudHNcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35EYXNoYm9hcmQjY29tcG9uZW50c1xuICogQHBhcmFtIHtDYWxsYmFjay48QW5hbHl0aWNzLURhc2hib2FyZENvbXBvbmVudE1ldGFkYXRhPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QW5hbHl0aWNzLURhc2hib2FyZENvbXBvbmVudE1ldGFkYXRhPn1cbiAqL1xuRGFzaGJvYXJkLnByb3RvdHlwZS5jb21wb25lbnRzID0gZnVuY3Rpb24oY29tcG9uZW50SWRzLCBjYWxsYmFjaykge1xuICB2YXIgdXJsID0gWyB0aGlzLl9jb25uLl9iYXNlVXJsKCksIFwiYW5hbHl0aWNzXCIsIFwiZGFzaGJvYXJkc1wiLCB0aGlzLmlkXS5qb2luKCcvJyk7XG4gIHZhciBkYXRhID0ge307XG4gIGlmIChfLmlzRnVuY3Rpb24oY29tcG9uZW50SWRzKSkge1xuICAgIGNhbGxiYWNrID0gY29tcG9uZW50SWRzO1xuICB9IGVsc2UgaWYgKF8uaXNBcnJheShjb21wb25lbnRJZHMpKSB7XG4gICAgZGF0YS5jb21wb25lbnRJZHMgPSBjb21wb25lbnRJZHM7XG4gIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhjb21wb25lbnRJZHMpKSB7XG4gICAgZGF0YS5jb21wb25lbnRJZHMgPSBbIGNvbXBvbmVudElkcyBdO1xuICB9XG4gIHZhciBwYXJhbXMgPSB7IG1ldGhvZCA6ICdQT1NUJywgdXJsIDogdXJsLCBoZWFkZXJzIDogeyBcIkNvbnRlbnQtVHlwZVwiIDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgYm9keSA6IEpTT04uc3RyaW5naWZ5KGRhdGEpfTtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdChwYXJhbXMpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogR2V0IGRhc2hib2FyZCBzdGF0dXNcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35EYXNoYm9hcmQjc3RhdHVzXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBbmFseXRpY3MtRGFzaGJvYXJkU3RhdHVzTWV0YWRhdGE+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBbmFseXRpY3MtRGFzaGJvYXJkU3RhdHVzTWV0YWRhdGE+fVxuICovXG5EYXNoYm9hcmQucHJvdG90eXBlLnN0YXR1cyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Nvbm4uX2Jhc2VVcmwoKSwgXCJhbmFseXRpY3NcIiwgXCJkYXNoYm9hcmRzXCIsIHRoaXMuaWQsIFwic3RhdHVzXCIgXS5qb2luKCcvJyk7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJlZnJlc2ggYSBkYXNoYm9hcmRcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35EYXNoYm9hcmQjcmVmcmVzaFxuICogQHBhcmFtIHtDYWxsYmFjay48QW5hbHl0aWNzLURhc2hib2FyZFN0YXR1c1VybD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFuYWx5dGljcy1EYXNoYm9hcmRTdGF0dXNVcmw+fVxuICovXG5EYXNoYm9hcmQucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgdXJsID0gWyB0aGlzLl9jb25uLl9iYXNlVXJsKCksIFwiYW5hbHl0aWNzXCIsIFwiZGFzaGJvYXJkc1wiLCB0aGlzLmlkIF0uam9pbignLycpO1xuICB2YXIgcGFyYW1zID0geyBtZXRob2QgOiAnUFVUJywgdXJsIDogdXJsLCBib2R5OiAnJyB9O1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHBhcmFtcykudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDbG9uZSBhIGRhc2hib2FyZFxuICpcbiAqIEBtZXRob2QgQW5hbHl0aWNzfkRhc2hib2FyZCNjbG9uZVxuICogQHBhcmFtIHtDYWxsYmFjay48QW5hbHl0aWNzLURhc2hib2FyZE1ldGFkYXRhPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QW5hbHl0aWNzLURhc2hib2FyZE1ldGFkYXRhPn1cbiAqL1xuRGFzaGJvYXJkLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKG5hbWUsIGZvbGRlcmlkLCBjYWxsYmFjaykge1xuICB2YXIgdXJsID0gWyB0aGlzLl9jb25uLl9iYXNlVXJsKCksIFwiYW5hbHl0aWNzXCIsIFwiZGFzaGJvYXJkc1wiIF0uam9pbignLycpO1xuICB1cmwgKz0gXCI/Y2xvbmVJZD1cIiArIHRoaXMuaWQ7XG4gIHZhciBkYXRhID0ge307XG5cbiAgaWYgKF8uaXNPYmplY3QobmFtZSkpIHtcbiAgICBkYXRhID0gbmFtZTtcbiAgICBjYWxsYmFjayA9IGZvbGRlcmlkO1xuICB9IGVsc2Uge1xuICAgIGRhdGEubmFtZSA9IG5hbWU7XG4gICAgZGF0YS5mb2xkZXJJZCA9IGZvbGRlcmlkO1xuICB9XG4gIHZhciBwYXJhbXMgPSB7IG1ldGhvZCA6ICdQT1NUJywgdXJsIDogdXJsLCBoZWFkZXJzIDogeyBcIkNvbnRlbnQtVHlwZVwiIDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgYm9keSA6IEpTT04uc3RyaW5naWZ5KGRhdGEpfTtcblxuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHBhcmFtcykudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTeW5vbnltIG9mIEFuYWx5dGljc35EYXNoYm9hcmQjZGVzdHJveSgpXG4gKlxuICogQG1ldGhvZCBBbmFseXRpY3N+RGFzaGJvYXJkI2RlbGV0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48QW5hbHl0aWNzfkRhc2hib2FyZFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFuYWx5dGljc35EYXNoYm9hcmRSZXN1bHQ+fVxuICovXG4vKipcbiAqIFN5bm9ueW0gb2YgQW5hbHl0aWNzfkRhc2hib2FyZCNkZXN0cm95KClcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35EYXNoYm9hcmQjZGVsXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBbmFseXRpY3N+RGFzaGJvYXJkUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QW5hbHl0aWNzfkRhc2hib2FyZFJlc3VsdD59XG4gKi9cbi8qKlxuICogRGVzdHJveSBhIGRhc2hib2FyZFxuICpcbiAqIEBtZXRob2QgQW5hbHl0aWNzfkRhc2hib2FyZCNkZXN0cm95XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBbmFseXRpY3N+RGFzaGJvYXJkUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QW5hbHl0aWNzfkRhc2hib2FyZFJlc3VsdD59XG4gKi9cbkRhc2hib2FyZC5wcm90b3R5cGVbXCJkZWxldGVcIl0gPVxuRGFzaGJvYXJkLnByb3RvdHlwZS5kZWwgPVxuRGFzaGJvYXJkLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fY29ubi5fYmFzZVVybCgpLCBcImFuYWx5dGljc1wiLCBcImRhc2hib2FyZHNcIiwgdGhpcy5pZCBdLmpvaW4oJy8nKTtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdCh7bWV0aG9kOiAnREVMRVRFJywgdXJsOiB1cmx9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEFQSSBjbGFzcyBmb3IgQW5hbHl0aWNzIEFQSVxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIENvbm5lY3Rpb25cbiAqL1xudmFyIEFuYWx5dGljcyA9IGZ1bmN0aW9uKGNvbm4pIHtcbiAgdGhpcy5fY29ubiA9IGNvbm47XG59O1xuXG4vKipcbiAqIEdldCByZXBvcnQgb2JqZWN0IG9mIEFuYWx5dGljcyBBUElcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBSZXBvcnQgSWRcbiAqIEByZXR1cm5zIHtBbmFseXRpY3N+UmVwb3J0fVxuICovXG5BbmFseXRpY3MucHJvdG90eXBlLnJlcG9ydCA9IGZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiBuZXcgUmVwb3J0KHRoaXMuX2Nvbm4sIGlkKTtcbn07XG5cbi8qKlxuICogR2V0IHJlY2VudCByZXBvcnQgbGlzdFxuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxBbmFseXRpY3N+UmVwb3J0SW5mbz4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheS48QW5hbHl0aWNzflJlcG9ydEluZm8+Pn1cbiAqL1xuQW5hbHl0aWNzLnByb3RvdHlwZS5yZXBvcnRzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fY29ubi5fYmFzZVVybCgpLCBcImFuYWx5dGljc1wiLCBcInJlcG9ydHNcIiBdLmpvaW4oJy8nKTtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdCh1cmwpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogR2V0IGRhc2hib2FyZCBvYmplY3Qgb2YgQW5hbHl0aWNzIEFQSVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIERhc2hib2FyZCBJZFxuICogQHJldHVybnMge0FuYWx5dGljc35EYXNoYm9hcmR9XG4gKi9cbkFuYWx5dGljcy5wcm90b3R5cGUuZGFzaGJvYXJkID0gZnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIG5ldyBEYXNoYm9hcmQodGhpcy5fY29ubiwgaWQpO1xufTtcblxuLyoqXG4gKiBHZXQgcmVjZW50IGRhc2hib2FyZCBsaXN0XG4gKlxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPEFuYWx5dGljc35EYXNoYm9hcmRJbmZvPj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxBbmFseXRpY3N+RGFzaGJvYXJkSW5mbz4+fVxuICovXG5BbmFseXRpY3MucHJvdG90eXBlLmRhc2hib2FyZHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgdXJsID0gWyB0aGlzLl9jb25uLl9iYXNlVXJsKCksIFwiYW5hbHl0aWNzXCIsIFwiZGFzaGJvYXJkc1wiIF0uam9pbignLycpO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHVybCkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKlxuICogUmVnaXN0ZXIgaG9vayBpbiBjb25uZWN0aW9uIGluc3RhbnRpYXRpb24gZm9yIGR5bmFtaWNhbGx5IGFkZGluZyB0aGlzIEFQSSBtb2R1bGUgZmVhdHVyZXNcbiAqL1xuanNmb3JjZS5vbignY29ubmVjdGlvbjpuZXcnLCBmdW5jdGlvbihjb25uKSB7XG4gIGNvbm4uYW5hbHl0aWNzID0gbmV3IEFuYWx5dGljcyhjb25uKTtcbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW5hbHl0aWNzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/api/analytics.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/api/analytics.js":
/*!***************************************************!*\
  !*** ./node_modules/jsforce/lib/api/analytics.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages Salesforce Analytics API\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar _ = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    jsforce = __webpack_require__(/*! ../core */ \"(rsc)/./node_modules/jsforce/lib/core.js\"),\n    Promise  = __webpack_require__(/*! ../promise */ \"(rsc)/./node_modules/jsforce/lib/promise.js\");\n\n/**\n * Report instance to retrieving asynchronously executed result\n *\n * @protected\n * @class Analytics~ReportInstance\n * @param {Analytics~Report} report - Report\n * @param {String} id - Report instance id\n */\nvar ReportInstance = function(report, id) {\n  this._report = report;\n  this._conn = report._conn;\n  this.id = id;\n};\n\n/**\n * Retrieve report result asynchronously executed\n *\n * @method Analytics~ReportInstance#retrieve\n * @param {Callback.<Analytics~ReportResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportResult>}\n */\nReportInstance.prototype.retrieve = function(callback) {\n  var conn = this._conn,\n      report = this._report;\n  var url = [ conn._baseUrl(), \"analytics\", \"reports\", report.id, \"instances\", this.id ].join('/');\n  return conn.request(url).thenCall(callback);\n};\n\n/**\n * Report object in Analytics API\n *\n * @protected\n * @class Analytics~Report\n * @param {Connection} conn Connection\n */\nvar Report = function(conn, id) {\n  this._conn = conn;\n  this.id = id;\n};\n\n/**\n * Describe report metadata\n *\n * @method Analytics~Report#describe\n * @param {Callback.<Analytics~ReportMetadata>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportMetadata>}\n */\nReport.prototype.describe = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"reports\", this.id, \"describe\" ].join('/');\n  return this._conn.request(url).thenCall(callback);\n};\n\n/**\n * Synonym of Analytics~Report#destroy()\n *\n * @method Analytics~Report#delete\n * @param {Callback.<Analytics~ReportResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportResult>}\n */\n/**\n * Synonym of Analytics~Report#destroy()\n *\n * @method Analytics~Report#del\n * @param {Callback.<Analytics~ReportResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportResult>}\n */\n/**\n * Destroy a report\n *\n * @method Analytics~Report#destroy\n * @param {Callback.<Analytics~ReportResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportResult>}\n */\nReport.prototype[\"delete\"] =\nReport.prototype.del =\nReport.prototype.destroy = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"reports\", this.id ].join('/');\n  return this._conn.request({method: 'DELETE', url: url}).thenCall(callback);\n};\n\n/**\n * Clones a given report\n *\n * @method Analytics~Report#clone\n * @param {String} name - The name of the new report\n * @param {Callback.<Analytics~ReportResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportResult>}\n */\nReport.prototype.clone = function(name, callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"reports\" ].join('/');\n  url += \"?cloneId=\" + this.id;\n  var data = { reportMetadata: { name: name } };\n  var params = { method : 'POST', url: url, headers: { \"Content-Type\" : \"application/json\" }, body: JSON.stringify(data)};\n\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Explain plan for executing report\n *\n * @method Analytics~Report#explain\n * @param {Callback.<ExplainInfo>} [callback] - Callback function\n * @returns {Promise.<ExplainInfo>}\n */\nReport.prototype.explain = function(callback) {\n  var url = \"/query/?explain=\" + this.id;\n  return this._conn.request(url).thenCall(callback);\n};\n\n\n/**\n * Run report synchronously\n *\n * @method Analytics~Report#execute\n * @param {Object} [options] - Options\n * @param {Boolean} options.details - Flag if include detail in result\n * @param {Analytics~ReportMetadata} options.metadata - Overriding report metadata\n * @param {Callback.<Analytics~ReportResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportResult>}\n */\nReport.prototype.run =\nReport.prototype.exec =\nReport.prototype.execute = function(options, callback) {\n  options = options || {};\n  if (_.isFunction(options)) {\n    callback = options;\n    options = {};\n  }\n  var url = [ this._conn._baseUrl(), \"analytics\", \"reports\", this.id ].join('/');\n  url += \"?includeDetails=\" + (options.details ? \"true\" : \"false\");\n  var params = { method : options.metadata ? 'POST' : 'GET', url : url };\n  if (options.metadata) {\n    params.headers = { \"Content-Type\" : \"application/json\" };\n    params.body = JSON.stringify(options.metadata);\n  }\n  return this._conn.request(params).thenCall(callback);\n};\n\n\n/**\n * Run report asynchronously\n *\n * @method Analytics~Report#executeAsync\n * @param {Object} [options] - Options\n * @param {Boolean} options.details - Flag if include detail in result\n * @param {Analytics~ReportMetadata} options.metadata - Overriding report metadata\n * @param {Callback.<Analytics~ReportInstanceAttrs>} [callback] - Callback function\n * @returns {Promise.<Analytics~ReportInstanceAttrs>}\n */\nReport.prototype.executeAsync = function(options, callback) {\n  options = options || {};\n  if (_.isFunction(options)) {\n    callback = options;\n    options = {};\n  }\n  var url = [ this._conn._baseUrl(), \"analytics\", \"reports\", this.id, \"instances\" ].join('/');\n  if (options.details) {\n    url += \"?includeDetails=true\";\n  }\n  var params = { method : 'POST', url : url, body: \"\" };\n  if (options.metadata) {\n    params.headers = { \"Content-Type\" : \"application/json\" };\n    params.body = JSON.stringify(options.metadata);\n  }\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Get report instance for specified instance ID\n *\n * @method Analytics~Report#instance\n * @param {String} id - Report instance ID\n * @returns {Analytics~ReportInstance}\n */\nReport.prototype.instance = function(id) {\n  return new ReportInstance(this, id);\n};\n\n/**\n * List report instances which had been executed asynchronously\n *\n * @method Analytics~Report#instances\n * @param {Callback.<Array.<Analytics~ReportInstanceAttrs>>} [callback] - Callback function\n * @returns {Promise.<Array.<Analytics~ReportInstanceAttrs>>}\n */\nReport.prototype.instances = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"reports\", this.id, \"instances\" ].join('/');\n  return this._conn.request(url).thenCall(callback);\n};\n\n/**\n * Dashboard object in the Analytics API\n *\n * @protected\n * @class Analytics-Dashboard\n * @param {Connection} conn Connection\n * @param {String} id - The Id\n */\n\nvar Dashboard = function(conn, id) {\n  this._conn = conn;\n  this.id = id;\n};\n\n/**\n * Describe dashboard metadata\n *\n * @method Analytics~Dashboard#describe\n * @param {Callback.<Analytics-DashboardMetadata>} [callback] - Callback function\n * @returns {Promise.<Analytics-DashboardMetadata>}\n */\nDashboard.prototype.describe = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"dashboards\", this.id, \"describe\" ].join('/');\n  return this._conn.request(url).thenCall(callback);\n};\n\n/**\n * Get details about dashboard components\n *\n * @method Analytics~Dashboard#components\n * @param {Callback.<Analytics-DashboardComponentMetadata>} [callback] - Callback function\n * @returns {Promise.<Analytics-DashboardComponentMetadata>}\n */\nDashboard.prototype.components = function(componentIds, callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"dashboards\", this.id].join('/');\n  var data = {};\n  if (_.isFunction(componentIds)) {\n    callback = componentIds;\n  } else if (_.isArray(componentIds)) {\n    data.componentIds = componentIds;\n  } else if (_.isString(componentIds)) {\n    data.componentIds = [ componentIds ];\n  }\n  var params = { method : 'POST', url : url, headers : { \"Content-Type\" : \"application/json\" }, body : JSON.stringify(data)};\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Get dashboard status\n *\n * @method Analytics~Dashboard#status\n * @param {Callback.<Analytics-DashboardStatusMetadata>} [callback] - Callback function\n * @returns {Promise.<Analytics-DashboardStatusMetadata>}\n */\nDashboard.prototype.status = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"dashboards\", this.id, \"status\" ].join('/');\n  return this._conn.request(url).thenCall(callback);\n};\n\n/**\n * Refresh a dashboard\n *\n * @method Analytics~Dashboard#refresh\n * @param {Callback.<Analytics-DashboardStatusUrl>} [callback] - Callback function\n * @returns {Promise.<Analytics-DashboardStatusUrl>}\n */\nDashboard.prototype.refresh = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"dashboards\", this.id ].join('/');\n  var params = { method : 'PUT', url : url, body: '' };\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Clone a dashboard\n *\n * @method Analytics~Dashboard#clone\n * @param {Callback.<Analytics-DashboardMetadata>} [callback] - Callback function\n * @returns {Promise.<Analytics-DashboardMetadata>}\n */\nDashboard.prototype.clone = function(name, folderid, callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"dashboards\" ].join('/');\n  url += \"?cloneId=\" + this.id;\n  var data = {};\n\n  if (_.isObject(name)) {\n    data = name;\n    callback = folderid;\n  } else {\n    data.name = name;\n    data.folderId = folderid;\n  }\n  var params = { method : 'POST', url : url, headers : { \"Content-Type\" : \"application/json\" }, body : JSON.stringify(data)};\n\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Synonym of Analytics~Dashboard#destroy()\n *\n * @method Analytics~Dashboard#delete\n * @param {Callback.<Analytics~DashboardResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~DashboardResult>}\n */\n/**\n * Synonym of Analytics~Dashboard#destroy()\n *\n * @method Analytics~Dashboard#del\n * @param {Callback.<Analytics~DashboardResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~DashboardResult>}\n */\n/**\n * Destroy a dashboard\n *\n * @method Analytics~Dashboard#destroy\n * @param {Callback.<Analytics~DashboardResult>} [callback] - Callback function\n * @returns {Promise.<Analytics~DashboardResult>}\n */\nDashboard.prototype[\"delete\"] =\nDashboard.prototype.del =\nDashboard.prototype.destroy = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"dashboards\", this.id ].join('/');\n  return this._conn.request({method: 'DELETE', url: url}).thenCall(callback);\n};\n\n/**\n * API class for Analytics API\n *\n * @class\n * @param {Connection} conn Connection\n */\nvar Analytics = function(conn) {\n  this._conn = conn;\n};\n\n/**\n * Get report object of Analytics API\n *\n * @param {String} id - Report Id\n * @returns {Analytics~Report}\n */\nAnalytics.prototype.report = function(id) {\n  return new Report(this._conn, id);\n};\n\n/**\n * Get recent report list\n *\n * @param {Callback.<Array.<Analytics~ReportInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<Analytics~ReportInfo>>}\n */\nAnalytics.prototype.reports = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"reports\" ].join('/');\n  return this._conn.request(url).thenCall(callback);\n};\n\n/**\n * Get dashboard object of Analytics API\n *\n * @param {String} id - Dashboard Id\n * @returns {Analytics~Dashboard}\n */\nAnalytics.prototype.dashboard = function(id) {\n  return new Dashboard(this._conn, id);\n};\n\n/**\n * Get recent dashboard list\n *\n * @param {Callback.<Array.<Analytics~DashboardInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<Analytics~DashboardInfo>>}\n */\nAnalytics.prototype.dashboards = function(callback) {\n  var url = [ this._conn._baseUrl(), \"analytics\", \"dashboards\" ].join('/');\n  return this._conn.request(url).thenCall(callback);\n};\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.analytics = new Analytics(conn);\n});\n\n\nmodule.exports = Analytics;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL2FuYWx5dGljcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixRQUFRLG1CQUFPLENBQUMsd0RBQWE7QUFDN0IsY0FBYyxtQkFBTyxDQUFDLHlEQUFTO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQywrREFBWTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1DQUFtQztBQUM5QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQ0FBcUM7QUFDaEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1DQUFtQztBQUM5QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUNBQW1DO0FBQzlDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQixzQ0FBc0MscUNBQXFDOztBQUU1RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLG1DQUFtQztBQUM5QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsMEJBQTBCO0FBQ3JDLFdBQVcsMENBQTBDO0FBQ3JELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0RBQWtEO0FBQzdELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3Q0FBd0M7QUFDbkQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlEQUFpRDtBQUM1RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQXdDLHFDQUFxQztBQUM5RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBOEM7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QztBQUNwRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdDQUF3QztBQUNuRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdDQUF3QyxxQ0FBcUM7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNDQUFzQztBQUNqRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0NBQXNDO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQ0FBc0M7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5Q0FBeUM7QUFDcEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUE0QztBQUN2RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL2FuYWx5dGljcy5qcz9mYzdhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgTWFuYWdlcyBTYWxlc2ZvcmNlIEFuYWx5dGljcyBBUElcbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpLFxuICAgIGpzZm9yY2UgPSByZXF1aXJlKCcuLi9jb3JlJyksXG4gICAgUHJvbWlzZSAgPSByZXF1aXJlKCcuLi9wcm9taXNlJyk7XG5cbi8qKlxuICogUmVwb3J0IGluc3RhbmNlIHRvIHJldHJpZXZpbmcgYXN5bmNocm9ub3VzbHkgZXhlY3V0ZWQgcmVzdWx0XG4gKlxuICogQHByb3RlY3RlZFxuICogQGNsYXNzIEFuYWx5dGljc35SZXBvcnRJbnN0YW5jZVxuICogQHBhcmFtIHtBbmFseXRpY3N+UmVwb3J0fSByZXBvcnQgLSBSZXBvcnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIFJlcG9ydCBpbnN0YW5jZSBpZFxuICovXG52YXIgUmVwb3J0SW5zdGFuY2UgPSBmdW5jdGlvbihyZXBvcnQsIGlkKSB7XG4gIHRoaXMuX3JlcG9ydCA9IHJlcG9ydDtcbiAgdGhpcy5fY29ubiA9IHJlcG9ydC5fY29ubjtcbiAgdGhpcy5pZCA9IGlkO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSByZXBvcnQgcmVzdWx0IGFzeW5jaHJvbm91c2x5IGV4ZWN1dGVkXG4gKlxuICogQG1ldGhvZCBBbmFseXRpY3N+UmVwb3J0SW5zdGFuY2UjcmV0cmlldmVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFuYWx5dGljc35SZXBvcnRSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBbmFseXRpY3N+UmVwb3J0UmVzdWx0Pn1cbiAqL1xuUmVwb3J0SW5zdGFuY2UucHJvdG90eXBlLnJldHJpZXZlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIGNvbm4gPSB0aGlzLl9jb25uLFxuICAgICAgcmVwb3J0ID0gdGhpcy5fcmVwb3J0O1xuICB2YXIgdXJsID0gWyBjb25uLl9iYXNlVXJsKCksIFwiYW5hbHl0aWNzXCIsIFwicmVwb3J0c1wiLCByZXBvcnQuaWQsIFwiaW5zdGFuY2VzXCIsIHRoaXMuaWQgXS5qb2luKCcvJyk7XG4gIHJldHVybiBjb25uLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJlcG9ydCBvYmplY3QgaW4gQW5hbHl0aWNzIEFQSVxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBjbGFzcyBBbmFseXRpY3N+UmVwb3J0XG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gQ29ubmVjdGlvblxuICovXG52YXIgUmVwb3J0ID0gZnVuY3Rpb24oY29ubiwgaWQpIHtcbiAgdGhpcy5fY29ubiA9IGNvbm47XG4gIHRoaXMuaWQgPSBpZDtcbn07XG5cbi8qKlxuICogRGVzY3JpYmUgcmVwb3J0IG1ldGFkYXRhXG4gKlxuICogQG1ldGhvZCBBbmFseXRpY3N+UmVwb3J0I2Rlc2NyaWJlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBbmFseXRpY3N+UmVwb3J0TWV0YWRhdGE+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBbmFseXRpY3N+UmVwb3J0TWV0YWRhdGE+fVxuICovXG5SZXBvcnQucHJvdG90eXBlLmRlc2NyaWJlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fY29ubi5fYmFzZVVybCgpLCBcImFuYWx5dGljc1wiLCBcInJlcG9ydHNcIiwgdGhpcy5pZCwgXCJkZXNjcmliZVwiIF0uam9pbignLycpO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHVybCkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTeW5vbnltIG9mIEFuYWx5dGljc35SZXBvcnQjZGVzdHJveSgpXG4gKlxuICogQG1ldGhvZCBBbmFseXRpY3N+UmVwb3J0I2RlbGV0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48QW5hbHl0aWNzflJlcG9ydFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFuYWx5dGljc35SZXBvcnRSZXN1bHQ+fVxuICovXG4vKipcbiAqIFN5bm9ueW0gb2YgQW5hbHl0aWNzflJlcG9ydCNkZXN0cm95KClcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35SZXBvcnQjZGVsXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBbmFseXRpY3N+UmVwb3J0UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QW5hbHl0aWNzflJlcG9ydFJlc3VsdD59XG4gKi9cbi8qKlxuICogRGVzdHJveSBhIHJlcG9ydFxuICpcbiAqIEBtZXRob2QgQW5hbHl0aWNzflJlcG9ydCNkZXN0cm95XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBbmFseXRpY3N+UmVwb3J0UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QW5hbHl0aWNzflJlcG9ydFJlc3VsdD59XG4gKi9cblJlcG9ydC5wcm90b3R5cGVbXCJkZWxldGVcIl0gPVxuUmVwb3J0LnByb3RvdHlwZS5kZWwgPVxuUmVwb3J0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fY29ubi5fYmFzZVVybCgpLCBcImFuYWx5dGljc1wiLCBcInJlcG9ydHNcIiwgdGhpcy5pZCBdLmpvaW4oJy8nKTtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdCh7bWV0aG9kOiAnREVMRVRFJywgdXJsOiB1cmx9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIENsb25lcyBhIGdpdmVuIHJlcG9ydFxuICpcbiAqIEBtZXRob2QgQW5hbHl0aWNzflJlcG9ydCNjbG9uZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbmV3IHJlcG9ydFxuICogQHBhcmFtIHtDYWxsYmFjay48QW5hbHl0aWNzflJlcG9ydFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFuYWx5dGljc35SZXBvcnRSZXN1bHQ+fVxuICovXG5SZXBvcnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fY29ubi5fYmFzZVVybCgpLCBcImFuYWx5dGljc1wiLCBcInJlcG9ydHNcIiBdLmpvaW4oJy8nKTtcbiAgdXJsICs9IFwiP2Nsb25lSWQ9XCIgKyB0aGlzLmlkO1xuICB2YXIgZGF0YSA9IHsgcmVwb3J0TWV0YWRhdGE6IHsgbmFtZTogbmFtZSB9IH07XG4gIHZhciBwYXJhbXMgPSB7IG1ldGhvZCA6ICdQT1NUJywgdXJsOiB1cmwsIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIiA6IFwiYXBwbGljYXRpb24vanNvblwiIH0sIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpfTtcblxuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHBhcmFtcykudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBFeHBsYWluIHBsYW4gZm9yIGV4ZWN1dGluZyByZXBvcnRcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35SZXBvcnQjZXhwbGFpblxuICogQHBhcmFtIHtDYWxsYmFjay48RXhwbGFpbkluZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxFeHBsYWluSW5mbz59XG4gKi9cblJlcG9ydC5wcm90b3R5cGUuZXhwbGFpbiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSBcIi9xdWVyeS8/ZXhwbGFpbj1cIiArIHRoaXMuaWQ7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG5cbi8qKlxuICogUnVuIHJlcG9ydCBzeW5jaHJvbm91c2x5XG4gKlxuICogQG1ldGhvZCBBbmFseXRpY3N+UmVwb3J0I2V4ZWN1dGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuZGV0YWlscyAtIEZsYWcgaWYgaW5jbHVkZSBkZXRhaWwgaW4gcmVzdWx0XG4gKiBAcGFyYW0ge0FuYWx5dGljc35SZXBvcnRNZXRhZGF0YX0gb3B0aW9ucy5tZXRhZGF0YSAtIE92ZXJyaWRpbmcgcmVwb3J0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBbmFseXRpY3N+UmVwb3J0UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QW5hbHl0aWNzflJlcG9ydFJlc3VsdD59XG4gKi9cblJlcG9ydC5wcm90b3R5cGUucnVuID1cblJlcG9ydC5wcm90b3R5cGUuZXhlYyA9XG5SZXBvcnQucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgdmFyIHVybCA9IFsgdGhpcy5fY29ubi5fYmFzZVVybCgpLCBcImFuYWx5dGljc1wiLCBcInJlcG9ydHNcIiwgdGhpcy5pZCBdLmpvaW4oJy8nKTtcbiAgdXJsICs9IFwiP2luY2x1ZGVEZXRhaWxzPVwiICsgKG9wdGlvbnMuZGV0YWlscyA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKTtcbiAgdmFyIHBhcmFtcyA9IHsgbWV0aG9kIDogb3B0aW9ucy5tZXRhZGF0YSA/ICdQT1NUJyA6ICdHRVQnLCB1cmwgOiB1cmwgfTtcbiAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHtcbiAgICBwYXJhbXMuaGVhZGVycyA9IHsgXCJDb250ZW50LVR5cGVcIiA6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG4gICAgcGFyYW1zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLm1ldGFkYXRhKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHBhcmFtcykudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuXG4vKipcbiAqIFJ1biByZXBvcnQgYXN5bmNocm9ub3VzbHlcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35SZXBvcnQjZXhlY3V0ZUFzeW5jXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmRldGFpbHMgLSBGbGFnIGlmIGluY2x1ZGUgZGV0YWlsIGluIHJlc3VsdFxuICogQHBhcmFtIHtBbmFseXRpY3N+UmVwb3J0TWV0YWRhdGF9IG9wdGlvbnMubWV0YWRhdGEgLSBPdmVycmlkaW5nIHJlcG9ydCBtZXRhZGF0YVxuICogQHBhcmFtIHtDYWxsYmFjay48QW5hbHl0aWNzflJlcG9ydEluc3RhbmNlQXR0cnM+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBbmFseXRpY3N+UmVwb3J0SW5zdGFuY2VBdHRycz59XG4gKi9cblJlcG9ydC5wcm90b3R5cGUuZXhlY3V0ZUFzeW5jID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChfLmlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Nvbm4uX2Jhc2VVcmwoKSwgXCJhbmFseXRpY3NcIiwgXCJyZXBvcnRzXCIsIHRoaXMuaWQsIFwiaW5zdGFuY2VzXCIgXS5qb2luKCcvJyk7XG4gIGlmIChvcHRpb25zLmRldGFpbHMpIHtcbiAgICB1cmwgKz0gXCI/aW5jbHVkZURldGFpbHM9dHJ1ZVwiO1xuICB9XG4gIHZhciBwYXJhbXMgPSB7IG1ldGhvZCA6ICdQT1NUJywgdXJsIDogdXJsLCBib2R5OiBcIlwiIH07XG4gIGlmIChvcHRpb25zLm1ldGFkYXRhKSB7XG4gICAgcGFyYW1zLmhlYWRlcnMgPSB7IFwiQ29udGVudC1UeXBlXCIgOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9O1xuICAgIHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5tZXRhZGF0YSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdChwYXJhbXMpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogR2V0IHJlcG9ydCBpbnN0YW5jZSBmb3Igc3BlY2lmaWVkIGluc3RhbmNlIElEXG4gKlxuICogQG1ldGhvZCBBbmFseXRpY3N+UmVwb3J0I2luc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBSZXBvcnQgaW5zdGFuY2UgSURcbiAqIEByZXR1cm5zIHtBbmFseXRpY3N+UmVwb3J0SW5zdGFuY2V9XG4gKi9cblJlcG9ydC5wcm90b3R5cGUuaW5zdGFuY2UgPSBmdW5jdGlvbihpZCkge1xuICByZXR1cm4gbmV3IFJlcG9ydEluc3RhbmNlKHRoaXMsIGlkKTtcbn07XG5cbi8qKlxuICogTGlzdCByZXBvcnQgaW5zdGFuY2VzIHdoaWNoIGhhZCBiZWVuIGV4ZWN1dGVkIGFzeW5jaHJvbm91c2x5XG4gKlxuICogQG1ldGhvZCBBbmFseXRpY3N+UmVwb3J0I2luc3RhbmNlc1xuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPEFuYWx5dGljc35SZXBvcnRJbnN0YW5jZUF0dHJzPj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxBbmFseXRpY3N+UmVwb3J0SW5zdGFuY2VBdHRycz4+fVxuICovXG5SZXBvcnQucHJvdG90eXBlLmluc3RhbmNlcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Nvbm4uX2Jhc2VVcmwoKSwgXCJhbmFseXRpY3NcIiwgXCJyZXBvcnRzXCIsIHRoaXMuaWQsIFwiaW5zdGFuY2VzXCIgXS5qb2luKCcvJyk7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIERhc2hib2FyZCBvYmplY3QgaW4gdGhlIEFuYWx5dGljcyBBUElcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAY2xhc3MgQW5hbHl0aWNzLURhc2hib2FyZFxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIENvbm5lY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIFRoZSBJZFxuICovXG5cbnZhciBEYXNoYm9hcmQgPSBmdW5jdGlvbihjb25uLCBpZCkge1xuICB0aGlzLl9jb25uID0gY29ubjtcbiAgdGhpcy5pZCA9IGlkO1xufTtcblxuLyoqXG4gKiBEZXNjcmliZSBkYXNoYm9hcmQgbWV0YWRhdGFcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35EYXNoYm9hcmQjZGVzY3JpYmVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFuYWx5dGljcy1EYXNoYm9hcmRNZXRhZGF0YT59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFuYWx5dGljcy1EYXNoYm9hcmRNZXRhZGF0YT59XG4gKi9cbkRhc2hib2FyZC5wcm90b3R5cGUuZGVzY3JpYmUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgdXJsID0gWyB0aGlzLl9jb25uLl9iYXNlVXJsKCksIFwiYW5hbHl0aWNzXCIsIFwiZGFzaGJvYXJkc1wiLCB0aGlzLmlkLCBcImRlc2NyaWJlXCIgXS5qb2luKCcvJyk7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldCBkZXRhaWxzIGFib3V0IGRhc2hib2FyZCBjb21wb25lbnRzXG4gKlxuICogQG1ldGhvZCBBbmFseXRpY3N+RGFzaGJvYXJkI2NvbXBvbmVudHNcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFuYWx5dGljcy1EYXNoYm9hcmRDb21wb25lbnRNZXRhZGF0YT59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFuYWx5dGljcy1EYXNoYm9hcmRDb21wb25lbnRNZXRhZGF0YT59XG4gKi9cbkRhc2hib2FyZC5wcm90b3R5cGUuY29tcG9uZW50cyA9IGZ1bmN0aW9uKGNvbXBvbmVudElkcywgY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fY29ubi5fYmFzZVVybCgpLCBcImFuYWx5dGljc1wiLCBcImRhc2hib2FyZHNcIiwgdGhpcy5pZF0uam9pbignLycpO1xuICB2YXIgZGF0YSA9IHt9O1xuICBpZiAoXy5pc0Z1bmN0aW9uKGNvbXBvbmVudElkcykpIHtcbiAgICBjYWxsYmFjayA9IGNvbXBvbmVudElkcztcbiAgfSBlbHNlIGlmIChfLmlzQXJyYXkoY29tcG9uZW50SWRzKSkge1xuICAgIGRhdGEuY29tcG9uZW50SWRzID0gY29tcG9uZW50SWRzO1xuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoY29tcG9uZW50SWRzKSkge1xuICAgIGRhdGEuY29tcG9uZW50SWRzID0gWyBjb21wb25lbnRJZHMgXTtcbiAgfVxuICB2YXIgcGFyYW1zID0geyBtZXRob2QgOiAnUE9TVCcsIHVybCA6IHVybCwgaGVhZGVycyA6IHsgXCJDb250ZW50LVR5cGVcIiA6IFwiYXBwbGljYXRpb24vanNvblwiIH0sIGJvZHkgOiBKU09OLnN0cmluZ2lmeShkYXRhKX07XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QocGFyYW1zKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldCBkYXNoYm9hcmQgc3RhdHVzXG4gKlxuICogQG1ldGhvZCBBbmFseXRpY3N+RGFzaGJvYXJkI3N0YXR1c1xuICogQHBhcmFtIHtDYWxsYmFjay48QW5hbHl0aWNzLURhc2hib2FyZFN0YXR1c01ldGFkYXRhPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QW5hbHl0aWNzLURhc2hib2FyZFN0YXR1c01ldGFkYXRhPn1cbiAqL1xuRGFzaGJvYXJkLnByb3RvdHlwZS5zdGF0dXMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgdXJsID0gWyB0aGlzLl9jb25uLl9iYXNlVXJsKCksIFwiYW5hbHl0aWNzXCIsIFwiZGFzaGJvYXJkc1wiLCB0aGlzLmlkLCBcInN0YXR1c1wiIF0uam9pbignLycpO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHVybCkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZWZyZXNoIGEgZGFzaGJvYXJkXG4gKlxuICogQG1ldGhvZCBBbmFseXRpY3N+RGFzaGJvYXJkI3JlZnJlc2hcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFuYWx5dGljcy1EYXNoYm9hcmRTdGF0dXNVcmw+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBbmFseXRpY3MtRGFzaGJvYXJkU3RhdHVzVXJsPn1cbiAqL1xuRGFzaGJvYXJkLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fY29ubi5fYmFzZVVybCgpLCBcImFuYWx5dGljc1wiLCBcImRhc2hib2FyZHNcIiwgdGhpcy5pZCBdLmpvaW4oJy8nKTtcbiAgdmFyIHBhcmFtcyA9IHsgbWV0aG9kIDogJ1BVVCcsIHVybCA6IHVybCwgYm9keTogJycgfTtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdChwYXJhbXMpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQ2xvbmUgYSBkYXNoYm9hcmRcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35EYXNoYm9hcmQjY2xvbmVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFuYWx5dGljcy1EYXNoYm9hcmRNZXRhZGF0YT59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFuYWx5dGljcy1EYXNoYm9hcmRNZXRhZGF0YT59XG4gKi9cbkRhc2hib2FyZC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbihuYW1lLCBmb2xkZXJpZCwgY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fY29ubi5fYmFzZVVybCgpLCBcImFuYWx5dGljc1wiLCBcImRhc2hib2FyZHNcIiBdLmpvaW4oJy8nKTtcbiAgdXJsICs9IFwiP2Nsb25lSWQ9XCIgKyB0aGlzLmlkO1xuICB2YXIgZGF0YSA9IHt9O1xuXG4gIGlmIChfLmlzT2JqZWN0KG5hbWUpKSB7XG4gICAgZGF0YSA9IG5hbWU7XG4gICAgY2FsbGJhY2sgPSBmb2xkZXJpZDtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLm5hbWUgPSBuYW1lO1xuICAgIGRhdGEuZm9sZGVySWQgPSBmb2xkZXJpZDtcbiAgfVxuICB2YXIgcGFyYW1zID0geyBtZXRob2QgOiAnUE9TVCcsIHVybCA6IHVybCwgaGVhZGVycyA6IHsgXCJDb250ZW50LVR5cGVcIiA6IFwiYXBwbGljYXRpb24vanNvblwiIH0sIGJvZHkgOiBKU09OLnN0cmluZ2lmeShkYXRhKX07XG5cbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdChwYXJhbXMpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU3lub255bSBvZiBBbmFseXRpY3N+RGFzaGJvYXJkI2Rlc3Ryb3koKVxuICpcbiAqIEBtZXRob2QgQW5hbHl0aWNzfkRhc2hib2FyZCNkZWxldGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFuYWx5dGljc35EYXNoYm9hcmRSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBbmFseXRpY3N+RGFzaGJvYXJkUmVzdWx0Pn1cbiAqL1xuLyoqXG4gKiBTeW5vbnltIG9mIEFuYWx5dGljc35EYXNoYm9hcmQjZGVzdHJveSgpXG4gKlxuICogQG1ldGhvZCBBbmFseXRpY3N+RGFzaGJvYXJkI2RlbFxuICogQHBhcmFtIHtDYWxsYmFjay48QW5hbHl0aWNzfkRhc2hib2FyZFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFuYWx5dGljc35EYXNoYm9hcmRSZXN1bHQ+fVxuICovXG4vKipcbiAqIERlc3Ryb3kgYSBkYXNoYm9hcmRcbiAqXG4gKiBAbWV0aG9kIEFuYWx5dGljc35EYXNoYm9hcmQjZGVzdHJveVxuICogQHBhcmFtIHtDYWxsYmFjay48QW5hbHl0aWNzfkRhc2hib2FyZFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFuYWx5dGljc35EYXNoYm9hcmRSZXN1bHQ+fVxuICovXG5EYXNoYm9hcmQucHJvdG90eXBlW1wiZGVsZXRlXCJdID1cbkRhc2hib2FyZC5wcm90b3R5cGUuZGVsID1cbkRhc2hib2FyZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Nvbm4uX2Jhc2VVcmwoKSwgXCJhbmFseXRpY3NcIiwgXCJkYXNoYm9hcmRzXCIsIHRoaXMuaWQgXS5qb2luKCcvJyk7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3Qoe21ldGhvZDogJ0RFTEVURScsIHVybDogdXJsfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBBUEkgY2xhc3MgZm9yIEFuYWx5dGljcyBBUElcbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiBDb25uZWN0aW9uXG4gKi9cbnZhciBBbmFseXRpY3MgPSBmdW5jdGlvbihjb25uKSB7XG4gIHRoaXMuX2Nvbm4gPSBjb25uO1xufTtcblxuLyoqXG4gKiBHZXQgcmVwb3J0IG9iamVjdCBvZiBBbmFseXRpY3MgQVBJXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gUmVwb3J0IElkXG4gKiBAcmV0dXJucyB7QW5hbHl0aWNzflJlcG9ydH1cbiAqL1xuQW5hbHl0aWNzLnByb3RvdHlwZS5yZXBvcnQgPSBmdW5jdGlvbihpZCkge1xuICByZXR1cm4gbmV3IFJlcG9ydCh0aGlzLl9jb25uLCBpZCk7XG59O1xuXG4vKipcbiAqIEdldCByZWNlbnQgcmVwb3J0IGxpc3RcbiAqXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48QW5hbHl0aWNzflJlcG9ydEluZm8+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXkuPEFuYWx5dGljc35SZXBvcnRJbmZvPj59XG4gKi9cbkFuYWx5dGljcy5wcm90b3R5cGUucmVwb3J0cyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Nvbm4uX2Jhc2VVcmwoKSwgXCJhbmFseXRpY3NcIiwgXCJyZXBvcnRzXCIgXS5qb2luKCcvJyk7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldCBkYXNoYm9hcmQgb2JqZWN0IG9mIEFuYWx5dGljcyBBUElcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBEYXNoYm9hcmQgSWRcbiAqIEByZXR1cm5zIHtBbmFseXRpY3N+RGFzaGJvYXJkfVxuICovXG5BbmFseXRpY3MucHJvdG90eXBlLmRhc2hib2FyZCA9IGZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiBuZXcgRGFzaGJvYXJkKHRoaXMuX2Nvbm4sIGlkKTtcbn07XG5cbi8qKlxuICogR2V0IHJlY2VudCBkYXNoYm9hcmQgbGlzdFxuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxBbmFseXRpY3N+RGFzaGJvYXJkSW5mbz4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheS48QW5hbHl0aWNzfkRhc2hib2FyZEluZm8+Pn1cbiAqL1xuQW5hbHl0aWNzLnByb3RvdHlwZS5kYXNoYm9hcmRzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fY29ubi5fYmFzZVVybCgpLCBcImFuYWx5dGljc1wiLCBcImRhc2hib2FyZHNcIiBdLmpvaW4oJy8nKTtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdCh1cmwpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLypcbiAqIFJlZ2lzdGVyIGhvb2sgaW4gY29ubmVjdGlvbiBpbnN0YW50aWF0aW9uIGZvciBkeW5hbWljYWxseSBhZGRpbmcgdGhpcyBBUEkgbW9kdWxlIGZlYXR1cmVzXG4gKi9cbmpzZm9yY2Uub24oJ2Nvbm5lY3Rpb246bmV3JywgZnVuY3Rpb24oY29ubikge1xuICBjb25uLmFuYWx5dGljcyA9IG5ldyBBbmFseXRpY3MoY29ubik7XG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFuYWx5dGljcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/api/analytics.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/api/apex.js":
/*!**********************************************!*\
  !*** ./node_modules/jsforce/lib/api/apex.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages Salesforce Apex REST endpoint calls\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar jsforce = __webpack_require__(/*! ../core */ \"(action-browser)/./node_modules/jsforce/lib/core.js\");\n\n/**\n * API class for Apex REST endpoint call\n *\n * @class\n * @param {Connection} conn Connection\n */\nvar Apex = function(conn) {\n  this._conn = conn;\n};\n\n/**\n * @private\n */\nApex.prototype._baseUrl = function() {\n  return this._conn.instanceUrl + \"/services/apexrest\";\n};\n\n/**\n * @private\n */\nApex.prototype._createRequestParams = function(method, path, body, options) {\n  var params = {\n    method: method,\n    url: this._baseUrl() + path\n  },\n  _headers = {};\n  if(options && 'object' === typeof options['headers']){\n    _headers = options['headers'];\n  }\n  if (!/^(GET|DELETE)$/i.test(method)) {\n    _headers[\"Content-Type\"] = \"application/json\";\n  }\n  params.headers = _headers;\n  if (body) {\n    var contentType = params.headers[\"Content-Type\"];\n    if (!contentType || contentType === \"application/json\") {\n      params.body = JSON.stringify(body);\n    } else {\n      params.body = body;\n    }\n  }\n  return params;\n};\n\n/**\n * Call Apex REST service in GET request\n *\n * @param {String} path - URL path to Apex REST service\n * @param {Object} options - Holds headers and other meta data for the request.\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nApex.prototype.get = function(path, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  return this._conn.request(this._createRequestParams('GET', path, undefined, options)).thenCall(callback);\n};\n\n/**\n * Call Apex REST service in POST request\n *\n * @param {String} path - URL path to Apex REST service\n * @param {Object} [body] - Request body\n * @param {Object} options - Holds headers and other meta data for the request.\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nApex.prototype.post = function(path, body, options, callback) {\n  if (typeof body === 'function') {\n    callback = body;\n    body = undefined;\n    options = undefined;\n  }\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var params = this._createRequestParams('POST', path, body, options);\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Call Apex REST service in PUT request\n *\n * @param {String} path - URL path to Apex REST service\n * @param {Object} [body] - Request body\n * @param {Object} [options] - Holds headers and other meta data for the request.\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nApex.prototype.put = function(path, body, options, callback) {\n  if (typeof body === 'function') {\n    callback = body;\n    body = undefined;\n    options = undefined;\n  }\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var params = this._createRequestParams('PUT', path, body, options);\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Call Apex REST service in PATCH request\n *\n * @param {String} path - URL path to Apex REST service\n * @param {Object} [body] - Request body\n * @param {Object} [options] - Holds headers and other meta data for the request.\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nApex.prototype.patch = function(path, body, options, callback) {\n  if (typeof body === 'function') {\n    callback = body;\n    body = undefined;\n    options = undefined;\n  }\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var params = this._createRequestParams('PATCH', path, body, options);\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Synonym of Apex#delete()\n *\n * @method Apex#del\n *\n * @param {String} path - URL path to Apex REST service\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\n/**\n * Call Apex REST service in DELETE request\n *\n * @method Apex#delete\n *\n * @param {String} path - URL path to Apex REST service\n * @param {Object} [options] - Holds headers and other meta data for the request.\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nApex.prototype.del =\n  Apex.prototype[\"delete\"] = function(path, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  return this._conn.request(this._createRequestParams('DELETE', path, undefined, options)).thenCall(callback);\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.apex = new Apex(conn);\n});\n\n\nmodule.exports = Apex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvYXBleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsb0VBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2FwaS9hcGV4LmpzP2MwNzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBNYW5hZ2VzIFNhbGVzZm9yY2UgQXBleCBSRVNUIGVuZHBvaW50IGNhbGxzXG4gKiBAYXV0aG9yIFNoaW5pY2hpIFRvbWl0YSA8c2hpbmljaGkudG9taXRhQGdtYWlsLmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBqc2ZvcmNlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG4vKipcbiAqIEFQSSBjbGFzcyBmb3IgQXBleCBSRVNUIGVuZHBvaW50IGNhbGxcbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiBDb25uZWN0aW9uXG4gKi9cbnZhciBBcGV4ID0gZnVuY3Rpb24oY29ubikge1xuICB0aGlzLl9jb25uID0gY29ubjtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuQXBleC5wcm90b3R5cGUuX2Jhc2VVcmwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4uaW5zdGFuY2VVcmwgKyBcIi9zZXJ2aWNlcy9hcGV4cmVzdFwiO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5BcGV4LnByb3RvdHlwZS5fY3JlYXRlUmVxdWVzdFBhcmFtcyA9IGZ1bmN0aW9uKG1ldGhvZCwgcGF0aCwgYm9keSwgb3B0aW9ucykge1xuICB2YXIgcGFyYW1zID0ge1xuICAgIG1ldGhvZDogbWV0aG9kLFxuICAgIHVybDogdGhpcy5fYmFzZVVybCgpICsgcGF0aFxuICB9LFxuICBfaGVhZGVycyA9IHt9O1xuICBpZihvcHRpb25zICYmICdvYmplY3QnID09PSB0eXBlb2Ygb3B0aW9uc1snaGVhZGVycyddKXtcbiAgICBfaGVhZGVycyA9IG9wdGlvbnNbJ2hlYWRlcnMnXTtcbiAgfVxuICBpZiAoIS9eKEdFVHxERUxFVEUpJC9pLnRlc3QobWV0aG9kKSkge1xuICAgIF9oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gIH1cbiAgcGFyYW1zLmhlYWRlcnMgPSBfaGVhZGVycztcbiAgaWYgKGJvZHkpIHtcbiAgICB2YXIgY29udGVudFR5cGUgPSBwYXJhbXMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXTtcbiAgICBpZiAoIWNvbnRlbnRUeXBlIHx8IGNvbnRlbnRUeXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikge1xuICAgICAgcGFyYW1zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zLmJvZHkgPSBib2R5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufTtcblxuLyoqXG4gKiBDYWxsIEFwZXggUkVTVCBzZXJ2aWNlIGluIEdFVCByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBVUkwgcGF0aCB0byBBcGV4IFJFU1Qgc2VydmljZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBIb2xkcyBoZWFkZXJzIGFuZCBvdGhlciBtZXRhIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtDYWxsYmFjay48T2JqZWN0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48T2JqZWN0Pn1cbiAqL1xuQXBleC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdCh0aGlzLl9jcmVhdGVSZXF1ZXN0UGFyYW1zKCdHRVQnLCBwYXRoLCB1bmRlZmluZWQsIG9wdGlvbnMpKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIENhbGwgQXBleCBSRVNUIHNlcnZpY2UgaW4gUE9TVCByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBVUkwgcGF0aCB0byBBcGV4IFJFU1Qgc2VydmljZVxuICogQHBhcmFtIHtPYmplY3R9IFtib2R5XSAtIFJlcXVlc3QgYm9keVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBIb2xkcyBoZWFkZXJzIGFuZCBvdGhlciBtZXRhIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtDYWxsYmFjay48T2JqZWN0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48T2JqZWN0Pn1cbiAqL1xuQXBleC5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uKHBhdGgsIGJvZHksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgYm9keSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYm9keTtcbiAgICBib2R5ID0gdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHBhcmFtcyA9IHRoaXMuX2NyZWF0ZVJlcXVlc3RQYXJhbXMoJ1BPU1QnLCBwYXRoLCBib2R5LCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdChwYXJhbXMpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQ2FsbCBBcGV4IFJFU1Qgc2VydmljZSBpbiBQVVQgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gVVJMIHBhdGggdG8gQXBleCBSRVNUIHNlcnZpY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYm9keV0gLSBSZXF1ZXN0IGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBIb2xkcyBoZWFkZXJzIGFuZCBvdGhlciBtZXRhIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtDYWxsYmFjay48T2JqZWN0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48T2JqZWN0Pn1cbiAqL1xuQXBleC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24ocGF0aCwgYm9keSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBib2R5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBib2R5O1xuICAgIGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgcGFyYW1zID0gdGhpcy5fY3JlYXRlUmVxdWVzdFBhcmFtcygnUFVUJywgcGF0aCwgYm9keSwgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QocGFyYW1zKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIENhbGwgQXBleCBSRVNUIHNlcnZpY2UgaW4gUEFUQ0ggcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gVVJMIHBhdGggdG8gQXBleCBSRVNUIHNlcnZpY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYm9keV0gLSBSZXF1ZXN0IGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBIb2xkcyBoZWFkZXJzIGFuZCBvdGhlciBtZXRhIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtDYWxsYmFjay48T2JqZWN0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48T2JqZWN0Pn1cbiAqL1xuQXBleC5wcm90b3R5cGUucGF0Y2ggPSBmdW5jdGlvbihwYXRoLCBib2R5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGJvZHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJvZHk7XG4gICAgYm9keSA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIHZhciBwYXJhbXMgPSB0aGlzLl9jcmVhdGVSZXF1ZXN0UGFyYW1zKCdQQVRDSCcsIHBhdGgsIGJvZHksIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHBhcmFtcykudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTeW5vbnltIG9mIEFwZXgjZGVsZXRlKClcbiAqXG4gKiBAbWV0aG9kIEFwZXgjZGVsXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBVUkwgcGF0aCB0byBBcGV4IFJFU1Qgc2VydmljZVxuICogQHBhcmFtIHtDYWxsYmFjay48T2JqZWN0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48T2JqZWN0Pn1cbiAqL1xuLyoqXG4gKiBDYWxsIEFwZXggUkVTVCBzZXJ2aWNlIGluIERFTEVURSByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBBcGV4I2RlbGV0ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gVVJMIHBhdGggdG8gQXBleCBSRVNUIHNlcnZpY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBIb2xkcyBoZWFkZXJzIGFuZCBvdGhlciBtZXRhIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtDYWxsYmFjay48T2JqZWN0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48T2JqZWN0Pn1cbiAqL1xuQXBleC5wcm90b3R5cGUuZGVsID1cbiAgQXBleC5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbihwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHRoaXMuX2NyZWF0ZVJlcXVlc3RQYXJhbXMoJ0RFTEVURScsIHBhdGgsIHVuZGVmaW5lZCwgb3B0aW9ucykpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKlxuICogUmVnaXN0ZXIgaG9vayBpbiBjb25uZWN0aW9uIGluc3RhbnRpYXRpb24gZm9yIGR5bmFtaWNhbGx5IGFkZGluZyB0aGlzIEFQSSBtb2R1bGUgZmVhdHVyZXNcbiAqL1xuanNmb3JjZS5vbignY29ubmVjdGlvbjpuZXcnLCBmdW5jdGlvbihjb25uKSB7XG4gIGNvbm4uYXBleCA9IG5ldyBBcGV4KGNvbm4pO1xufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBcGV4O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/api/apex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/api/apex.js":
/*!**********************************************!*\
  !*** ./node_modules/jsforce/lib/api/apex.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages Salesforce Apex REST endpoint calls\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar jsforce = __webpack_require__(/*! ../core */ \"(rsc)/./node_modules/jsforce/lib/core.js\");\n\n/**\n * API class for Apex REST endpoint call\n *\n * @class\n * @param {Connection} conn Connection\n */\nvar Apex = function(conn) {\n  this._conn = conn;\n};\n\n/**\n * @private\n */\nApex.prototype._baseUrl = function() {\n  return this._conn.instanceUrl + \"/services/apexrest\";\n};\n\n/**\n * @private\n */\nApex.prototype._createRequestParams = function(method, path, body, options) {\n  var params = {\n    method: method,\n    url: this._baseUrl() + path\n  },\n  _headers = {};\n  if(options && 'object' === typeof options['headers']){\n    _headers = options['headers'];\n  }\n  if (!/^(GET|DELETE)$/i.test(method)) {\n    _headers[\"Content-Type\"] = \"application/json\";\n  }\n  params.headers = _headers;\n  if (body) {\n    var contentType = params.headers[\"Content-Type\"];\n    if (!contentType || contentType === \"application/json\") {\n      params.body = JSON.stringify(body);\n    } else {\n      params.body = body;\n    }\n  }\n  return params;\n};\n\n/**\n * Call Apex REST service in GET request\n *\n * @param {String} path - URL path to Apex REST service\n * @param {Object} options - Holds headers and other meta data for the request.\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nApex.prototype.get = function(path, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  return this._conn.request(this._createRequestParams('GET', path, undefined, options)).thenCall(callback);\n};\n\n/**\n * Call Apex REST service in POST request\n *\n * @param {String} path - URL path to Apex REST service\n * @param {Object} [body] - Request body\n * @param {Object} options - Holds headers and other meta data for the request.\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nApex.prototype.post = function(path, body, options, callback) {\n  if (typeof body === 'function') {\n    callback = body;\n    body = undefined;\n    options = undefined;\n  }\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var params = this._createRequestParams('POST', path, body, options);\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Call Apex REST service in PUT request\n *\n * @param {String} path - URL path to Apex REST service\n * @param {Object} [body] - Request body\n * @param {Object} [options] - Holds headers and other meta data for the request.\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nApex.prototype.put = function(path, body, options, callback) {\n  if (typeof body === 'function') {\n    callback = body;\n    body = undefined;\n    options = undefined;\n  }\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var params = this._createRequestParams('PUT', path, body, options);\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Call Apex REST service in PATCH request\n *\n * @param {String} path - URL path to Apex REST service\n * @param {Object} [body] - Request body\n * @param {Object} [options] - Holds headers and other meta data for the request.\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nApex.prototype.patch = function(path, body, options, callback) {\n  if (typeof body === 'function') {\n    callback = body;\n    body = undefined;\n    options = undefined;\n  }\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var params = this._createRequestParams('PATCH', path, body, options);\n  return this._conn.request(params).thenCall(callback);\n};\n\n/**\n * Synonym of Apex#delete()\n *\n * @method Apex#del\n *\n * @param {String} path - URL path to Apex REST service\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\n/**\n * Call Apex REST service in DELETE request\n *\n * @method Apex#delete\n *\n * @param {String} path - URL path to Apex REST service\n * @param {Object} [options] - Holds headers and other meta data for the request.\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nApex.prototype.del =\n  Apex.prototype[\"delete\"] = function(path, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  return this._conn.request(this._createRequestParams('DELETE', path, undefined, options)).thenCall(callback);\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.apex = new Apex(conn);\n});\n\n\nmodule.exports = Apex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL2FwZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHlEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvYXBleC5qcz8wNDBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgTWFuYWdlcyBTYWxlc2ZvcmNlIEFwZXggUkVTVCBlbmRwb2ludCBjYWxsc1xuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIganNmb3JjZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuLyoqXG4gKiBBUEkgY2xhc3MgZm9yIEFwZXggUkVTVCBlbmRwb2ludCBjYWxsXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gQ29ubmVjdGlvblxuICovXG52YXIgQXBleCA9IGZ1bmN0aW9uKGNvbm4pIHtcbiAgdGhpcy5fY29ubiA9IGNvbm47XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkFwZXgucHJvdG90eXBlLl9iYXNlVXJsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jb25uLmluc3RhbmNlVXJsICsgXCIvc2VydmljZXMvYXBleHJlc3RcIjtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuQXBleC5wcm90b3R5cGUuX2NyZWF0ZVJlcXVlc3RQYXJhbXMgPSBmdW5jdGlvbihtZXRob2QsIHBhdGgsIGJvZHksIG9wdGlvbnMpIHtcbiAgdmFyIHBhcmFtcyA9IHtcbiAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICB1cmw6IHRoaXMuX2Jhc2VVcmwoKSArIHBhdGhcbiAgfSxcbiAgX2hlYWRlcnMgPSB7fTtcbiAgaWYob3B0aW9ucyAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG9wdGlvbnNbJ2hlYWRlcnMnXSl7XG4gICAgX2hlYWRlcnMgPSBvcHRpb25zWydoZWFkZXJzJ107XG4gIH1cbiAgaWYgKCEvXihHRVR8REVMRVRFKSQvaS50ZXN0KG1ldGhvZCkpIHtcbiAgICBfaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICB9XG4gIHBhcmFtcy5oZWFkZXJzID0gX2hlYWRlcnM7XG4gIGlmIChib2R5KSB7XG4gICAgdmFyIGNvbnRlbnRUeXBlID0gcGFyYW1zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl07XG4gICAgaWYgKCFjb250ZW50VHlwZSB8fCBjb250ZW50VHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIHtcbiAgICAgIHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtcy5ib2R5ID0gYm9keTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn07XG5cbi8qKlxuICogQ2FsbCBBcGV4IFJFU1Qgc2VydmljZSBpbiBHRVQgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gVVJMIHBhdGggdG8gQXBleCBSRVNUIHNlcnZpY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gSG9sZHMgaGVhZGVycyBhbmQgb3RoZXIgbWV0YSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE9iamVjdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59XG4gKi9cbkFwZXgucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QodGhpcy5fY3JlYXRlUmVxdWVzdFBhcmFtcygnR0VUJywgcGF0aCwgdW5kZWZpbmVkLCBvcHRpb25zKSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDYWxsIEFwZXggUkVTVCBzZXJ2aWNlIGluIFBPU1QgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gVVJMIHBhdGggdG8gQXBleCBSRVNUIHNlcnZpY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYm9keV0gLSBSZXF1ZXN0IGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gSG9sZHMgaGVhZGVycyBhbmQgb3RoZXIgbWV0YSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE9iamVjdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59XG4gKi9cbkFwZXgucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbihwYXRoLCBib2R5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGJvZHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJvZHk7XG4gICAgYm9keSA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIHZhciBwYXJhbXMgPSB0aGlzLl9jcmVhdGVSZXF1ZXN0UGFyYW1zKCdQT1NUJywgcGF0aCwgYm9keSwgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QocGFyYW1zKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIENhbGwgQXBleCBSRVNUIHNlcnZpY2UgaW4gUFVUIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIFVSTCBwYXRoIHRvIEFwZXggUkVTVCBzZXJ2aWNlXG4gKiBAcGFyYW0ge09iamVjdH0gW2JvZHldIC0gUmVxdWVzdCBib2R5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gSG9sZHMgaGVhZGVycyBhbmQgb3RoZXIgbWV0YSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE9iamVjdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59XG4gKi9cbkFwZXgucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uKHBhdGgsIGJvZHksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgYm9keSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYm9keTtcbiAgICBib2R5ID0gdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHBhcmFtcyA9IHRoaXMuX2NyZWF0ZVJlcXVlc3RQYXJhbXMoJ1BVVCcsIHBhdGgsIGJvZHksIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHBhcmFtcykudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDYWxsIEFwZXggUkVTVCBzZXJ2aWNlIGluIFBBVENIIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIFVSTCBwYXRoIHRvIEFwZXggUkVTVCBzZXJ2aWNlXG4gKiBAcGFyYW0ge09iamVjdH0gW2JvZHldIC0gUmVxdWVzdCBib2R5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gSG9sZHMgaGVhZGVycyBhbmQgb3RoZXIgbWV0YSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE9iamVjdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59XG4gKi9cbkFwZXgucHJvdG90eXBlLnBhdGNoID0gZnVuY3Rpb24ocGF0aCwgYm9keSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBib2R5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBib2R5O1xuICAgIGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgcGFyYW1zID0gdGhpcy5fY3JlYXRlUmVxdWVzdFBhcmFtcygnUEFUQ0gnLCBwYXRoLCBib2R5LCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdChwYXJhbXMpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU3lub255bSBvZiBBcGV4I2RlbGV0ZSgpXG4gKlxuICogQG1ldGhvZCBBcGV4I2RlbFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gVVJMIHBhdGggdG8gQXBleCBSRVNUIHNlcnZpY2VcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE9iamVjdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59XG4gKi9cbi8qKlxuICogQ2FsbCBBcGV4IFJFU1Qgc2VydmljZSBpbiBERUxFVEUgcmVxdWVzdFxuICpcbiAqIEBtZXRob2QgQXBleCNkZWxldGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIFVSTCBwYXRoIHRvIEFwZXggUkVTVCBzZXJ2aWNlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gSG9sZHMgaGVhZGVycyBhbmQgb3RoZXIgbWV0YSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE9iamVjdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59XG4gKi9cbkFwZXgucHJvdG90eXBlLmRlbCA9XG4gIEFwZXgucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24ocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdCh0aGlzLl9jcmVhdGVSZXF1ZXN0UGFyYW1zKCdERUxFVEUnLCBwYXRoLCB1bmRlZmluZWQsIG9wdGlvbnMpKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLypcbiAqIFJlZ2lzdGVyIGhvb2sgaW4gY29ubmVjdGlvbiBpbnN0YW50aWF0aW9uIGZvciBkeW5hbWljYWxseSBhZGRpbmcgdGhpcyBBUEkgbW9kdWxlIGZlYXR1cmVzXG4gKi9cbmpzZm9yY2Uub24oJ2Nvbm5lY3Rpb246bmV3JywgZnVuY3Rpb24oY29ubikge1xuICBjb25uLmFwZXggPSBuZXcgQXBleChjb25uKTtcbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQXBleDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/api/apex.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/api/bulk.js":
/*!**********************************************!*\
  !*** ./node_modules/jsforce/lib/api/bulk.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global process*/\n/**\n * @file Manages Salesforce Bulk API related operations\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar inherits     = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\"),\n    stream       = __webpack_require__(/*! readable-stream */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/readable.js\"),\n    Duplex       = stream.Duplex,\n    events       = __webpack_require__(/*! events */ \"events\"),\n    _            = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    joinStreams  = __webpack_require__(/*! multistream */ \"(action-browser)/./node_modules/multistream/index.js\"),\n    jsforce      = __webpack_require__(/*! ../core */ \"(action-browser)/./node_modules/jsforce/lib/core.js\"),\n    RecordStream = __webpack_require__(/*! ../record-stream */ \"(action-browser)/./node_modules/jsforce/lib/record-stream.js\"),\n    Promise      = __webpack_require__(/*! ../promise */ \"(action-browser)/./node_modules/jsforce/lib/promise.js\"),\n    HttpApi      = __webpack_require__(/*! ../http-api */ \"(action-browser)/./node_modules/jsforce/lib/http-api.js\");\n\n/*--------------------------------------------*/\n\n/**\n * Class for Bulk API Job\n *\n * @protected\n * @class Bulk~Job\n * @extends events.EventEmitter\n *\n * @param {Bulk} bulk - Bulk API object\n * @param {String} [type] - SObject type\n * @param {String} [operation] - Bulk load operation ('insert', 'update', 'upsert', 'delete', or 'hardDelete')\n * @param {Object} [options] - Options for bulk loading operation\n * @param {String} [options.extIdField] - External ID field name (used when upsert operation).\n * @param {String} [options.concurrencyMode] - 'Serial' or 'Parallel'. Defaults to Parallel.\n * @param {String} [jobId] - Job ID (if already available)\n */\nvar Job = function(bulk, type, operation, options, jobId) {\n  this._bulk = bulk;\n  this.type = type;\n  this.operation = operation;\n  this.options = options || {};\n  this.id = jobId;\n  this.state = this.id ? 'Open' : 'Unknown';\n  this._batches = {};\n};\n\ninherits(Job, events.EventEmitter);\n\n/**\n * @typedef {Object} Bulk~JobInfo\n * @prop {String} id - Job ID\n * @prop {String} object - Object type name\n * @prop {String} operation - Operation type of the job\n * @prop {String} state - Job status\n */\n\n/**\n * Return latest jobInfo from cache\n *\n * @method Bulk~Job#info\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.info = function(callback) {\n  var self = this;\n  // if cache is not available, check the latest\n  if (!this._jobInfo) {\n    this._jobInfo = this.check();\n  }\n  return this._jobInfo.thenCall(callback);\n};\n\n/**\n * Open new job and get jobinfo\n *\n * @method Bulk~Job#open\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.open = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  // if not requested opening job\n  if (!this._jobInfo) {\n    var operation = this.operation.toLowerCase();\n    if (operation === 'harddelete') { operation = 'hardDelete'; }\n    var body = [\n      '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n      '<jobInfo  xmlns=\"http://www.force.com/2009/06/asyncapi/dataload\">',\n        '<operation>' + operation + '</operation>',\n        '<object>' + this.type + '</object>',\n        (this.options.extIdField ?\n         '<externalIdFieldName>'+this.options.extIdField+'</externalIdFieldName>' :\n         ''),\n        (this.options.concurrencyMode ?\n         '<concurrencyMode>'+this.options.concurrencyMode+'</concurrencyMode>' :\n         ''),\n        (this.options.assignmentRuleId ?\n          '<assignmentRuleId>' + this.options.assignmentRuleId + '</assignmentRuleId>' :\n          ''),\n        '<contentType>CSV</contentType>',\n      '</jobInfo>'\n    ].join('');\n\n    this._jobInfo = bulk._request({\n      method : 'POST',\n      path : \"/job\",\n      body : body,\n      headers : {\n        \"Content-Type\" : \"application/xml; charset=utf-8\"\n      },\n      responseType: \"application/xml\"\n    }).then(function(res) {\n      self.emit(\"open\", res.jobInfo);\n      self.id = res.jobInfo.id;\n      self.state = res.jobInfo.state;\n      return res.jobInfo;\n    }, function(err) {\n      self.emit(\"error\", err);\n      throw err;\n    });\n  }\n  return this._jobInfo.thenCall(callback);\n};\n\n/**\n * Create a new batch instance in the job\n *\n * @method Bulk~Job#createBatch\n * @returns {Bulk~Batch}\n */\nJob.prototype.createBatch = function() {\n  var batch = new Batch(this);\n  var self = this;\n  batch.on('queue', function() {\n    self._batches[batch.id] = batch;\n  });\n  return batch;\n};\n\n/**\n * Get a batch instance specified by given batch ID\n *\n * @method Bulk~Job#batch\n * @param {String} batchId - Batch ID\n * @returns {Bulk~Batch}\n */\nJob.prototype.batch = function(batchId) {\n  var batch = this._batches[batchId];\n  if (!batch) {\n    batch = new Batch(this, batchId);\n    this._batches[batchId] = batch;\n  }\n  return batch;\n};\n\n/**\n * Check the latest job status from server\n *\n * @method Bulk~Job#check\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.check = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  this._jobInfo = this._waitAssign().then(function() {\n    return bulk._request({\n      method : 'GET',\n      path : \"/job/\" + self.id,\n      responseType: \"application/xml\"\n    });\n  }).then(function(res) {\n    logger.debug(res.jobInfo);\n    self.id = res.jobInfo.id;\n    self.type = res.jobInfo.object;\n    self.operation = res.jobInfo.operation;\n    self.state = res.jobInfo.state;\n    return res.jobInfo;\n  });\n  return this._jobInfo.thenCall(callback);\n};\n\n/**\n * Wait till the job is assigned to server\n *\n * @method Bulk~Job#info\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype._waitAssign = function(callback) {\n  return (this.id ? Promise.resolve({ id: this.id }) : this.open()).thenCall(callback);\n};\n\n\n/**\n * List all registered batch info in job\n *\n * @method Bulk~Job#list\n * @param {Callback.<Array.<Bulk~BatchInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<Bulk~BatchInfo>>}\n */\nJob.prototype.list = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  return this._waitAssign().then(function() {\n    return bulk._request({\n      method : 'GET',\n      path : \"/job/\" + self.id + \"/batch\",\n      responseType: \"application/xml\"\n    });\n  }).then(function(res) {\n    logger.debug(res.batchInfoList.batchInfo);\n    var batchInfoList = res.batchInfoList;\n    batchInfoList = _.isArray(batchInfoList.batchInfo) ? batchInfoList.batchInfo : [ batchInfoList.batchInfo ];\n    return batchInfoList;\n  }).thenCall(callback);\n\n};\n\n/**\n * Close opened job\n *\n * @method Bulk~Job#close\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.close = function() {\n  var self = this;\n  return this._changeState(\"Closed\").then(function(jobInfo) {\n    self.id = null;\n    self.emit(\"close\", jobInfo);\n    return jobInfo;\n  }, function(err) {\n    self.emit(\"error\", err);\n    throw err;\n  });\n};\n\n/**\n * Set the status to abort\n *\n * @method Bulk~Job#abort\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.abort = function() {\n  var self = this;\n  return this._changeState(\"Aborted\").then(function(jobInfo) {\n    self.id = null;\n    self.emit(\"abort\", jobInfo);\n    return jobInfo;\n  }, function(err) {\n    self.emit(\"error\", err);\n    throw err;\n  });\n};\n\n/**\n * @private\n */\nJob.prototype._changeState = function(state, callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  this._jobInfo = this._waitAssign().then(function() {\n    var body = [\n      '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n      '<jobInfo xmlns=\"http://www.force.com/2009/06/asyncapi/dataload\">',\n        '<state>' + state + '</state>',\n      '</jobInfo>'\n    ].join('');\n    return bulk._request({\n      method : 'POST',\n      path : \"/job/\" + self.id,\n      body : body,\n      headers : {\n        \"Content-Type\" : \"application/xml; charset=utf-8\"\n      },\n      responseType: \"application/xml\"\n    });\n  }).then(function(res) {\n    logger.debug(res.jobInfo);\n    self.state = res.jobInfo.state;\n    return res.jobInfo;\n  });\n  return this._jobInfo.thenCall(callback);\n\n};\n\n\n/*--------------------------------------------*/\n\n/**\n * Batch (extends RecordStream)\n *\n * @protected\n * @class Bulk~Batch\n * @extends {stream.Writable}\n * @implements {Promise.<Array.<RecordResult>>}\n * @param {Bulk~Job} job - Bulk job object\n * @param {String} [batchId] - Batch ID (if already available)\n */\nvar Batch = function(job, batchId) {\n  Batch.super_.call(this, { objectMode: true });\n  this.job = job;\n  this.id = batchId;\n  this._bulk = job._bulk;\n  this._deferred = Promise.defer();\n  this._setupDataStreams();\n};\n\ninherits(Batch, stream.Writable);\n\n\n/**\n * @private\n */\nBatch.prototype._setupDataStreams = function() {\n  var batch = this;\n  var converterOptions = { nullValue : '#N/A' };\n  this._uploadStream = new RecordStream.Serializable();\n  this._uploadDataStream = this._uploadStream.stream('csv', converterOptions);\n  this._downloadStream = new RecordStream.Parsable();\n  this._downloadDataStream = this._downloadStream.stream('csv', converterOptions);\n\n  this.on('finish', function() {\n    batch._uploadStream.end();\n  });\n  this._uploadDataStream.once('readable', function() {\n    batch.job.open().then(function() {\n      // pipe upload data to batch API request stream\n      batch._uploadDataStream.pipe(batch._createRequestStream());\n    });\n  });\n\n  // duplex data stream, opened access to API programmers by Batch#stream()\n  var dataStream = this._dataStream = new Duplex();\n  dataStream._write = function(data, enc, cb) {\n    batch._uploadDataStream.write(data, enc, cb);\n  };\n  dataStream.on('finish', function() {\n    batch._uploadDataStream.end();\n  });\n\n  this._downloadDataStream.on('readable', function() {\n    dataStream.read(0);\n  });\n  this._downloadDataStream.on('end', function() {\n    dataStream.push(null);\n  });\n  dataStream._read = function(size) {\n    var chunk;\n    while ((chunk = batch._downloadDataStream.read()) !== null) {\n      dataStream.push(chunk);\n    }\n  };\n};\n\n/**\n * Connect batch API and create stream instance of request/response\n *\n * @private\n * @returns {stream.Duplex}\n */\nBatch.prototype._createRequestStream = function() {\n  var batch = this;\n  var bulk = batch._bulk;\n  var logger = bulk._logger;\n\n  return bulk._request({\n    method : 'POST',\n    path : \"/job/\" + batch.job.id + \"/batch\",\n    headers: {\n      \"Content-Type\": \"text/csv\"\n    },\n    responseType: \"application/xml\"\n  }, function(err, res) {\n    if (err) {\n      batch.emit('error', err);\n    } else {\n      logger.debug(res.batchInfo);\n      batch.id = res.batchInfo.id;\n      batch.emit('queue', res.batchInfo);\n    }\n  }).stream();\n};\n\n/**\n * Implementation of Writable\n *\n * @override\n * @private\n */\nBatch.prototype._write = function(record, enc, cb) {\n  record = _.clone(record);\n  if (this.job.operation === \"insert\") {\n    delete record.Id;\n  } else if (this.job.operation === \"delete\") {\n    record = { Id: record.Id };\n  }\n  delete record.type;\n  delete record.attributes;\n  this._uploadStream.write(record, enc, cb);\n};\n\n/**\n * Returns duplex stream which accepts CSV data input and batch result output\n *\n * @returns {stream.Duplex}\n */\nBatch.prototype.stream = function() {\n  return this._dataStream;\n};\n\n/**\n * Execute batch operation\n *\n * @method Bulk~Batch#execute\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for batch operation. Accepts array of records, CSV string, and CSV data input stream in insert/update/upsert/delete/hardDelete operation, SOQL string in query operation.\n * @param {Callback.<Array.<RecordResult>|Array.<BatchResultInfo>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nBatch.prototype.run =\nBatch.prototype.exec =\nBatch.prototype.execute = function(input, callback) {\n  var self = this;\n\n  if (typeof input === 'function') { // if input argument is omitted\n    callback = input;\n    input = null;\n  }\n\n  // if batch is already executed\n  if (this._result) {\n    throw new Error(\"Batch already executed.\");\n  }\n\n  var rdeferred = Promise.defer();\n  this._result = rdeferred.promise;\n  this._result.then(function(res) {\n    self._deferred.resolve(res);\n  }, function(err) {\n    self._deferred.reject(err);\n  });\n  this.once('response', function(res) {\n    rdeferred.resolve(res);\n  });\n  this.once('error', function(err) {\n    rdeferred.reject(err);\n  });\n\n  if (_.isObject(input) && _.isFunction(input.pipe)) { // if input has stream.Readable interface\n    input.pipe(this._dataStream);\n  } else {\n    var data;\n    if (_.isArray(input)) {\n      _.forEach(input, function(record) {\n        Object.keys(record).forEach(function(key) {\n          if (typeof record[key] === 'boolean') {\n            record[key] = String(record[key])\n          }\n        })\n        self.write(record);\n      });\n      self.end();\n    } else if (_.isString(input)){\n      data = input;\n      this._dataStream.write(data, 'utf8');\n      this._dataStream.end();\n    }\n  }\n\n  // return Batch instance for chaining\n  return this.thenCall(callback);\n};\n\n/**\n * Promise/A+ interface\n * http://promises-aplus.github.io/promises-spec/\n *\n * Delegate to deferred promise, return promise instance for batch result\n *\n * @method Bulk~Batch#then\n */\nBatch.prototype.then = function(onResolved, onReject, onProgress) {\n  return this._deferred.promise.then(onResolved, onReject, onProgress);\n};\n\n/**\n * Promise/A+ extension\n * Call \"then\" using given node-style callback function\n *\n * @method Bulk~Batch#thenCall\n */\nBatch.prototype.thenCall = function(callback) {\n  if (_.isFunction(callback)) {\n    this.then(function(res) {\n      process.nextTick(function() {\n        callback(null, res);\n      });\n    }, function(err) {\n      process.nextTick(function() {\n        callback(err);\n      });\n    });\n  }\n  return this;\n};\n\n/**\n * @typedef {Object} Bulk~BatchInfo\n * @prop {String} id - Batch ID\n * @prop {String} jobId - Job ID\n * @prop {String} state - Batch state\n * @prop {String} stateMessage - Batch state message\n */\n\n/**\n * Check the latest batch status in server\n *\n * @method Bulk~Batch#check\n * @param {Callback.<Bulk~BatchInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~BatchInfo>}\n */\nBatch.prototype.check = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n  var jobId = this.job.id;\n  var batchId = this.id;\n\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n  return bulk._request({\n    method : 'GET',\n    path : \"/job/\" + jobId + \"/batch/\" + batchId,\n    responseType: \"application/xml\"\n  }).then(function(res) {\n    logger.debug(res.batchInfo);\n    return res.batchInfo;\n  }).thenCall(callback);\n};\n\n\n/**\n * Polling the batch result and retrieve\n *\n * @method Bulk~Batch#poll\n * @param {Number} interval - Polling interval in milliseconds\n * @param {Number} timeout - Polling timeout in milliseconds\n */\nBatch.prototype.poll = function(interval, timeout) {\n  var self = this;\n  var jobId = this.job.id;\n  var batchId = this.id;\n\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n  var startTime = new Date().getTime();\n  var poll = function() {\n    var now = new Date().getTime();\n    if (startTime + timeout < now) {\n      var err = new Error(\"Polling time out. Job Id = \" + jobId + \" , batch Id = \" + batchId);\n      err.name = 'PollingTimeout';\n      err.jobId = jobId;\n      err.batchId = batchId;\n      self.emit('error', err);\n      return;\n    }\n    self.check(function(err, res) {\n      if (err) {\n        self.emit('error', err);\n      } else {\n        if (res.state === \"Failed\") {\n          if (parseInt(res.numberRecordsProcessed, 10) > 0) {\n            self.retrieve();\n          } else {\n            self.emit('error', new Error(res.stateMessage));\n          }\n        } else if (res.state === \"Completed\") {\n          self.retrieve();\n        } else {\n          self.emit('progress', res);\n          setTimeout(poll, interval);\n        }\n      }\n    });\n  };\n  setTimeout(poll, interval);\n};\n\n/**\n * @typedef {Object} Bulk~BatchResultInfo\n * @prop {String} id - Batch result ID\n * @prop {String} batchId - Batch ID which includes this batch result.\n * @prop {String} jobId - Job ID which includes this batch result.\n */\n\n/**\n * Retrieve batch result\n *\n * @method Bulk~Batch#retrieve\n * @param {Callback.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>}\n */\nBatch.prototype.retrieve = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var jobId = this.job.id;\n  var job = this.job;\n  var batchId = this.id;\n\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n\n  return job.info().then(function(jobInfo) {\n    return bulk._request({\n      method : 'GET',\n      path : \"/job/\" + jobId + \"/batch/\" + batchId + \"/result\"\n    });\n  }).then(function(res) {\n    var results;\n    if (job.operation === 'query') {\n      var conn = bulk._conn;\n      var resultIds = res['result-list'].result;\n      results = res['result-list'].result;\n      results = _.map(_.isArray(results) ? results : [ results ], function(id) {\n        return {\n          id: id,\n          batchId: batchId,\n          jobId: jobId\n        };\n      });\n    } else {\n      results = _.map(res, function(ret) {\n        return {\n          id: ret.Id || null,\n          success: ret.Success === \"true\",\n          errors: ret.Error ? [ ret.Error ] : []\n        };\n      });\n    }\n    self.emit('response', results);\n    return results;\n  }).fail(function(err) {\n    self.emit('error', err);\n    throw err;\n  }).thenCall(callback);\n};\n\n/**\n * Fetch query result as a record stream\n * @param {String} resultId - Result id\n * @returns {RecordStream} - Record stream, convertible to CSV data stream\n */\nBatch.prototype.result = function(resultId) {\n  var jobId = this.job.id;\n  var batchId = this.id;\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n  var resultStream = new RecordStream.Parsable();\n  var resultDataStream = resultStream.stream('csv');\n  var reqStream = this._bulk._request({\n    method : 'GET',\n    path : \"/job/\" + jobId + \"/batch/\" + batchId + \"/result/\" + resultId,\n    responseType: \"application/octet-stream\"\n  }).stream().pipe(resultDataStream);\n  return resultStream;\n};\n\n/*--------------------------------------------*/\n/**\n * @private\n */\nvar BulkApi = function() {\n  BulkApi.super_.apply(this, arguments);\n};\n\ninherits(BulkApi, HttpApi);\n\nBulkApi.prototype.beforeSend = function(request) {\n  request.headers = request.headers || {};\n  request.headers[\"X-SFDC-SESSION\"] = this._conn.accessToken;\n};\n\nBulkApi.prototype.isSessionExpired = function(response) {\n  return response.statusCode === 400 &&\n    /<exceptionCode>InvalidSessionId<\\/exceptionCode>/.test(response.body);\n};\n\nBulkApi.prototype.hasErrorInResponseBody = function(body) {\n  return !!body.error;\n};\n\nBulkApi.prototype.parseError = function(body) {\n  return {\n    errorCode: body.error.exceptionCode,\n    message: body.error.exceptionMessage\n  };\n};\n\n/*--------------------------------------------*/\n\n/**\n * Class for Bulk API\n *\n * @class\n * @param {Connection} conn - Connection object\n */\nvar Bulk = function(conn) {\n  this._conn = conn;\n  this._logger = conn._logger;\n};\n\n/**\n * Polling interval in milliseconds\n * @type {Number}\n */\nBulk.prototype.pollInterval = 1000;\n\n/**\n * Polling timeout in milliseconds\n * @type {Number}\n */\nBulk.prototype.pollTimeout = 10000;\n\n/** @private **/\nBulk.prototype._request = function(request, callback) {\n  var conn = this._conn;\n  request = _.clone(request);\n  var baseUrl = [ conn.instanceUrl, \"services/async\", conn.version ].join('/');\n  request.url = baseUrl + request.path;\n  var options = { responseType: request.responseType };\n  delete request.path;\n  delete request.responseType;\n  return new BulkApi(this._conn, options).request(request).thenCall(callback);\n};\n\n/**\n * Create and start bulkload job and batch\n *\n * @param {String} type - SObject type\n * @param {String} operation - Bulk load operation ('insert', 'update', 'upsert', 'delete', or 'hardDelete')\n * @param {Object} [options] - Options for bulk loading operation\n * @param {String} [options.extIdField] - External ID field name (used when upsert operation).\n * @param {String} [options.concurrencyMode] - 'Serial' or 'Parallel'. Defaults to Parallel.\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulkload. Accepts array of records, CSV string, and CSV data input stream in insert/update/upsert/delete/hardDelete operation, SOQL string in query operation.\n * @param {Callback.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nBulk.prototype.load = function(type, operation, options, input, callback) {\n  var self = this;\n  if (!type || !operation) {\n    throw new Error(\"Insufficient arguments. At least, 'type' and 'operation' are required.\");\n  }\n  if (!_.isObject(options) || options.constructor !== Object) { // when options is not plain hash object, it is omitted\n    callback = input;\n    input = options;\n    options = null;\n  }\n  var job = this.createJob(type, operation, options);\n  job.once('error', function (error) {\n    if (batch) {\n      batch.emit('error', error); // pass job error to batch\n    }\n  });\n  var batch = job.createBatch();\n  var cleanup = function() {\n    batch = null;\n    job.close();\n  };\n  var cleanupOnError = function(err) {\n    if (err.name !== 'PollingTimeout') {\n      cleanup();\n    }\n  };\n  batch.on('response', cleanup);\n  batch.on('error', cleanupOnError);\n  batch.on('queue', function() { batch.poll(self.pollInterval, self.pollTimeout); });\n  return batch.execute(input, callback);\n};\n\n/**\n * Execute bulk query and get record stream\n *\n * @param {String} soql - SOQL to execute in bulk job\n * @returns {RecordStream.Parsable} - Record stream, convertible to CSV data stream\n */\nBulk.prototype.query = function(soql) {\n  var m = soql.replace(/\\([\\s\\S]+\\)/g, '').match(/FROM\\s+(\\w+)/i);\n  if (!m) {\n    throw new Error(\"No sobject type found in query, maybe caused by invalid SOQL.\");\n  }\n  var type = m[1];\n  var self = this;\n  var recordStream = new RecordStream.Parsable();\n  var dataStream = recordStream.stream('csv');\n  this.load(type, \"query\", soql).then(function(results) {\n    var streams = results.map(function(result) {\n      return self\n        .job(result.jobId)\n        .batch(result.batchId)\n        .result(result.id)\n        .stream();\n    });\n\n    joinStreams(streams).pipe(dataStream);\n  }).fail(function(err) {\n    recordStream.emit('error', err);\n  });\n  return recordStream;\n};\n\n\n/**\n * Create a new job instance\n *\n * @param {String} type - SObject type\n * @param {String} operation - Bulk load operation ('insert', 'update', 'upsert', 'delete', 'hardDelete', or 'query')\n * @param {Object} [options] - Options for bulk loading operation\n * @returns {Bulk~Job}\n */\nBulk.prototype.createJob = function(type, operation, options) {\n  return new Job(this, type, operation, options);\n};\n\n/**\n * Get a job instance specified by given job ID\n *\n * @param {String} jobId - Job ID\n * @returns {Bulk~Job}\n */\nBulk.prototype.job = function(jobId) {\n  return new Job(this, null, null, null, jobId);\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.bulk = new Bulk(conn);\n});\n\n\nmodule.exports = Bulk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvYnVsay5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLHNFQUFVO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLHlHQUFpQjtBQUM1QztBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHNCQUFRO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3hDLG1CQUFtQixtQkFBTyxDQUFDLHlFQUFhO0FBQ3hDLG1CQUFtQixtQkFBTyxDQUFDLG9FQUFTO0FBQ3BDLG1CQUFtQixtQkFBTyxDQUFDLHNGQUFrQjtBQUM3QyxtQkFBbUIsbUJBQU8sQ0FBQywwRUFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBYTs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUNBQXFDO0FBQ2hELFdBQVcseURBQXlEO0FBQ3BFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSCx1REFBdUQ7QUFDdkQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4REFBOEQ7QUFDekUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyw4REFBOEQ7QUFDekUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0RBQWtEO0FBQ25GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL2J1bGsuanM/MzVkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBwcm9jZXNzKi9cbi8qKlxuICogQGZpbGUgTWFuYWdlcyBTYWxlc2ZvcmNlIEJ1bGsgQVBJIHJlbGF0ZWQgb3BlcmF0aW9uc1xuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgICAgID0gcmVxdWlyZSgnaW5oZXJpdHMnKSxcbiAgICBzdHJlYW0gICAgICAgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKSxcbiAgICBEdXBsZXggICAgICAgPSBzdHJlYW0uRHVwbGV4LFxuICAgIGV2ZW50cyAgICAgICA9IHJlcXVpcmUoJ2V2ZW50cycpLFxuICAgIF8gICAgICAgICAgICA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyksXG4gICAgam9pblN0cmVhbXMgID0gcmVxdWlyZSgnbXVsdGlzdHJlYW0nKSxcbiAgICBqc2ZvcmNlICAgICAgPSByZXF1aXJlKCcuLi9jb3JlJyksXG4gICAgUmVjb3JkU3RyZWFtID0gcmVxdWlyZSgnLi4vcmVjb3JkLXN0cmVhbScpLFxuICAgIFByb21pc2UgICAgICA9IHJlcXVpcmUoJy4uL3Byb21pc2UnKSxcbiAgICBIdHRwQXBpICAgICAgPSByZXF1aXJlKCcuLi9odHRwLWFwaScpO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBDbGFzcyBmb3IgQnVsayBBUEkgSm9iXG4gKlxuICogQHByb3RlY3RlZFxuICogQGNsYXNzIEJ1bGt+Sm9iXG4gKiBAZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyXG4gKlxuICogQHBhcmFtIHtCdWxrfSBidWxrIC0gQnVsayBBUEkgb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIC0gU09iamVjdCB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wZXJhdGlvbl0gLSBCdWxrIGxvYWQgb3BlcmF0aW9uICgnaW5zZXJ0JywgJ3VwZGF0ZScsICd1cHNlcnQnLCAnZGVsZXRlJywgb3IgJ2hhcmREZWxldGUnKVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIGJ1bGsgbG9hZGluZyBvcGVyYXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5leHRJZEZpZWxkXSAtIEV4dGVybmFsIElEIGZpZWxkIG5hbWUgKHVzZWQgd2hlbiB1cHNlcnQgb3BlcmF0aW9uKS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb25jdXJyZW5jeU1vZGVdIC0gJ1NlcmlhbCcgb3IgJ1BhcmFsbGVsJy4gRGVmYXVsdHMgdG8gUGFyYWxsZWwuXG4gKiBAcGFyYW0ge1N0cmluZ30gW2pvYklkXSAtIEpvYiBJRCAoaWYgYWxyZWFkeSBhdmFpbGFibGUpXG4gKi9cbnZhciBKb2IgPSBmdW5jdGlvbihidWxrLCB0eXBlLCBvcGVyYXRpb24sIG9wdGlvbnMsIGpvYklkKSB7XG4gIHRoaXMuX2J1bGsgPSBidWxrO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5pZCA9IGpvYklkO1xuICB0aGlzLnN0YXRlID0gdGhpcy5pZCA/ICdPcGVuJyA6ICdVbmtub3duJztcbiAgdGhpcy5fYmF0Y2hlcyA9IHt9O1xufTtcblxuaW5oZXJpdHMoSm9iLCBldmVudHMuRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCdWxrfkpvYkluZm9cbiAqIEBwcm9wIHtTdHJpbmd9IGlkIC0gSm9iIElEXG4gKiBAcHJvcCB7U3RyaW5nfSBvYmplY3QgLSBPYmplY3QgdHlwZSBuYW1lXG4gKiBAcHJvcCB7U3RyaW5nfSBvcGVyYXRpb24gLSBPcGVyYXRpb24gdHlwZSBvZiB0aGUgam9iXG4gKiBAcHJvcCB7U3RyaW5nfSBzdGF0ZSAtIEpvYiBzdGF0dXNcbiAqL1xuXG4vKipcbiAqIFJldHVybiBsYXRlc3Qgam9iSW5mbyBmcm9tIGNhY2hlXG4gKlxuICogQG1ldGhvZCBCdWxrfkpvYiNpbmZvXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxCdWxrfkpvYkluZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxCdWxrfkpvYkluZm8+fVxuICovXG5Kb2IucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIC8vIGlmIGNhY2hlIGlzIG5vdCBhdmFpbGFibGUsIGNoZWNrIHRoZSBsYXRlc3RcbiAgaWYgKCF0aGlzLl9qb2JJbmZvKSB7XG4gICAgdGhpcy5fam9iSW5mbyA9IHRoaXMuY2hlY2soKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fam9iSW5mby50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIE9wZW4gbmV3IGpvYiBhbmQgZ2V0IGpvYmluZm9cbiAqXG4gKiBAbWV0aG9kIEJ1bGt+Sm9iI29wZW5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEJ1bGt+Sm9iSW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEJ1bGt+Sm9iSW5mbz59XG4gKi9cbkpvYi5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGJ1bGsgPSB0aGlzLl9idWxrO1xuICB2YXIgbG9nZ2VyID0gYnVsay5fbG9nZ2VyO1xuXG4gIC8vIGlmIG5vdCByZXF1ZXN0ZWQgb3BlbmluZyBqb2JcbiAgaWYgKCF0aGlzLl9qb2JJbmZvKSB7XG4gICAgdmFyIG9wZXJhdGlvbiA9IHRoaXMub3BlcmF0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG9wZXJhdGlvbiA9PT0gJ2hhcmRkZWxldGUnKSB7IG9wZXJhdGlvbiA9ICdoYXJkRGVsZXRlJzsgfVxuICAgIHZhciBib2R5ID0gW1xuICAgICAgJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCI/PicsXG4gICAgICAnPGpvYkluZm8gIHhtbG5zPVwiaHR0cDovL3d3dy5mb3JjZS5jb20vMjAwOS8wNi9hc3luY2FwaS9kYXRhbG9hZFwiPicsXG4gICAgICAgICc8b3BlcmF0aW9uPicgKyBvcGVyYXRpb24gKyAnPC9vcGVyYXRpb24+JyxcbiAgICAgICAgJzxvYmplY3Q+JyArIHRoaXMudHlwZSArICc8L29iamVjdD4nLFxuICAgICAgICAodGhpcy5vcHRpb25zLmV4dElkRmllbGQgP1xuICAgICAgICAgJzxleHRlcm5hbElkRmllbGROYW1lPicrdGhpcy5vcHRpb25zLmV4dElkRmllbGQrJzwvZXh0ZXJuYWxJZEZpZWxkTmFtZT4nIDpcbiAgICAgICAgICcnKSxcbiAgICAgICAgKHRoaXMub3B0aW9ucy5jb25jdXJyZW5jeU1vZGUgP1xuICAgICAgICAgJzxjb25jdXJyZW5jeU1vZGU+Jyt0aGlzLm9wdGlvbnMuY29uY3VycmVuY3lNb2RlKyc8L2NvbmN1cnJlbmN5TW9kZT4nIDpcbiAgICAgICAgICcnKSxcbiAgICAgICAgKHRoaXMub3B0aW9ucy5hc3NpZ25tZW50UnVsZUlkID9cbiAgICAgICAgICAnPGFzc2lnbm1lbnRSdWxlSWQ+JyArIHRoaXMub3B0aW9ucy5hc3NpZ25tZW50UnVsZUlkICsgJzwvYXNzaWdubWVudFJ1bGVJZD4nIDpcbiAgICAgICAgICAnJyksXG4gICAgICAgICc8Y29udGVudFR5cGU+Q1NWPC9jb250ZW50VHlwZT4nLFxuICAgICAgJzwvam9iSW5mbz4nXG4gICAgXS5qb2luKCcnKTtcblxuICAgIHRoaXMuX2pvYkluZm8gPSBidWxrLl9yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZCA6ICdQT1NUJyxcbiAgICAgIHBhdGggOiBcIi9qb2JcIixcbiAgICAgIGJvZHkgOiBib2R5LFxuICAgICAgaGVhZGVycyA6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIiA6IFwiYXBwbGljYXRpb24veG1sOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0sXG4gICAgICByZXNwb25zZVR5cGU6IFwiYXBwbGljYXRpb24veG1sXCJcbiAgICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgc2VsZi5lbWl0KFwib3BlblwiLCByZXMuam9iSW5mbyk7XG4gICAgICBzZWxmLmlkID0gcmVzLmpvYkluZm8uaWQ7XG4gICAgICBzZWxmLnN0YXRlID0gcmVzLmpvYkluZm8uc3RhdGU7XG4gICAgICByZXR1cm4gcmVzLmpvYkluZm87XG4gICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzLl9qb2JJbmZvLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGJhdGNoIGluc3RhbmNlIGluIHRoZSBqb2JcbiAqXG4gKiBAbWV0aG9kIEJ1bGt+Sm9iI2NyZWF0ZUJhdGNoXG4gKiBAcmV0dXJucyB7QnVsa35CYXRjaH1cbiAqL1xuSm9iLnByb3RvdHlwZS5jcmVhdGVCYXRjaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYmF0Y2ggPSBuZXcgQmF0Y2godGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgYmF0Y2gub24oJ3F1ZXVlJywgZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fYmF0Y2hlc1tiYXRjaC5pZF0gPSBiYXRjaDtcbiAgfSk7XG4gIHJldHVybiBiYXRjaDtcbn07XG5cbi8qKlxuICogR2V0IGEgYmF0Y2ggaW5zdGFuY2Ugc3BlY2lmaWVkIGJ5IGdpdmVuIGJhdGNoIElEXG4gKlxuICogQG1ldGhvZCBCdWxrfkpvYiNiYXRjaFxuICogQHBhcmFtIHtTdHJpbmd9IGJhdGNoSWQgLSBCYXRjaCBJRFxuICogQHJldHVybnMge0J1bGt+QmF0Y2h9XG4gKi9cbkpvYi5wcm90b3R5cGUuYmF0Y2ggPSBmdW5jdGlvbihiYXRjaElkKSB7XG4gIHZhciBiYXRjaCA9IHRoaXMuX2JhdGNoZXNbYmF0Y2hJZF07XG4gIGlmICghYmF0Y2gpIHtcbiAgICBiYXRjaCA9IG5ldyBCYXRjaCh0aGlzLCBiYXRjaElkKTtcbiAgICB0aGlzLl9iYXRjaGVzW2JhdGNoSWRdID0gYmF0Y2g7XG4gIH1cbiAgcmV0dXJuIGJhdGNoO1xufTtcblxuLyoqXG4gKiBDaGVjayB0aGUgbGF0ZXN0IGpvYiBzdGF0dXMgZnJvbSBzZXJ2ZXJcbiAqXG4gKiBAbWV0aG9kIEJ1bGt+Sm9iI2NoZWNrXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxCdWxrfkpvYkluZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxCdWxrfkpvYkluZm8+fVxuICovXG5Kb2IucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYnVsayA9IHRoaXMuX2J1bGs7XG4gIHZhciBsb2dnZXIgPSBidWxrLl9sb2dnZXI7XG5cbiAgdGhpcy5fam9iSW5mbyA9IHRoaXMuX3dhaXRBc3NpZ24oKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBidWxrLl9yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZCA6ICdHRVQnLFxuICAgICAgcGF0aCA6IFwiL2pvYi9cIiArIHNlbGYuaWQsXG4gICAgICByZXNwb25zZVR5cGU6IFwiYXBwbGljYXRpb24veG1sXCJcbiAgICB9KTtcbiAgfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICBsb2dnZXIuZGVidWcocmVzLmpvYkluZm8pO1xuICAgIHNlbGYuaWQgPSByZXMuam9iSW5mby5pZDtcbiAgICBzZWxmLnR5cGUgPSByZXMuam9iSW5mby5vYmplY3Q7XG4gICAgc2VsZi5vcGVyYXRpb24gPSByZXMuam9iSW5mby5vcGVyYXRpb247XG4gICAgc2VsZi5zdGF0ZSA9IHJlcy5qb2JJbmZvLnN0YXRlO1xuICAgIHJldHVybiByZXMuam9iSW5mbztcbiAgfSk7XG4gIHJldHVybiB0aGlzLl9qb2JJbmZvLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogV2FpdCB0aWxsIHRoZSBqb2IgaXMgYXNzaWduZWQgdG8gc2VydmVyXG4gKlxuICogQG1ldGhvZCBCdWxrfkpvYiNpbmZvXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxCdWxrfkpvYkluZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxCdWxrfkpvYkluZm8+fVxuICovXG5Kb2IucHJvdG90eXBlLl93YWl0QXNzaWduID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuICh0aGlzLmlkID8gUHJvbWlzZS5yZXNvbHZlKHsgaWQ6IHRoaXMuaWQgfSkgOiB0aGlzLm9wZW4oKSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuXG4vKipcbiAqIExpc3QgYWxsIHJlZ2lzdGVyZWQgYmF0Y2ggaW5mbyBpbiBqb2JcbiAqXG4gKiBAbWV0aG9kIEJ1bGt+Sm9iI2xpc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxCdWxrfkJhdGNoSW5mbz4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheS48QnVsa35CYXRjaEluZm8+Pn1cbiAqL1xuSm9iLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYnVsayA9IHRoaXMuX2J1bGs7XG4gIHZhciBsb2dnZXIgPSBidWxrLl9sb2dnZXI7XG5cbiAgcmV0dXJuIHRoaXMuX3dhaXRBc3NpZ24oKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBidWxrLl9yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZCA6ICdHRVQnLFxuICAgICAgcGF0aCA6IFwiL2pvYi9cIiArIHNlbGYuaWQgKyBcIi9iYXRjaFwiLFxuICAgICAgcmVzcG9uc2VUeXBlOiBcImFwcGxpY2F0aW9uL3htbFwiXG4gICAgfSk7XG4gIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgbG9nZ2VyLmRlYnVnKHJlcy5iYXRjaEluZm9MaXN0LmJhdGNoSW5mbyk7XG4gICAgdmFyIGJhdGNoSW5mb0xpc3QgPSByZXMuYmF0Y2hJbmZvTGlzdDtcbiAgICBiYXRjaEluZm9MaXN0ID0gXy5pc0FycmF5KGJhdGNoSW5mb0xpc3QuYmF0Y2hJbmZvKSA/IGJhdGNoSW5mb0xpc3QuYmF0Y2hJbmZvIDogWyBiYXRjaEluZm9MaXN0LmJhdGNoSW5mbyBdO1xuICAgIHJldHVybiBiYXRjaEluZm9MaXN0O1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG5cbn07XG5cbi8qKlxuICogQ2xvc2Ugb3BlbmVkIGpvYlxuICpcbiAqIEBtZXRob2QgQnVsa35Kb2IjY2xvc2VcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEJ1bGt+Sm9iSW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEJ1bGt+Sm9iSW5mbz59XG4gKi9cbkpvYi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gdGhpcy5fY2hhbmdlU3RhdGUoXCJDbG9zZWRcIikudGhlbihmdW5jdGlvbihqb2JJbmZvKSB7XG4gICAgc2VsZi5pZCA9IG51bGw7XG4gICAgc2VsZi5lbWl0KFwiY2xvc2VcIiwgam9iSW5mbyk7XG4gICAgcmV0dXJuIGpvYkluZm87XG4gIH0sIGZ1bmN0aW9uKGVycikge1xuICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgdGhyb3cgZXJyO1xuICB9KTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzdGF0dXMgdG8gYWJvcnRcbiAqXG4gKiBAbWV0aG9kIEJ1bGt+Sm9iI2Fib3J0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxCdWxrfkpvYkluZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxCdWxrfkpvYkluZm8+fVxuICovXG5Kb2IucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuX2NoYW5nZVN0YXRlKFwiQWJvcnRlZFwiKS50aGVuKGZ1bmN0aW9uKGpvYkluZm8pIHtcbiAgICBzZWxmLmlkID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoXCJhYm9ydFwiLCBqb2JJbmZvKTtcbiAgICByZXR1cm4gam9iSW5mbztcbiAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5Kb2IucHJvdG90eXBlLl9jaGFuZ2VTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBidWxrID0gdGhpcy5fYnVsaztcbiAgdmFyIGxvZ2dlciA9IGJ1bGsuX2xvZ2dlcjtcblxuICB0aGlzLl9qb2JJbmZvID0gdGhpcy5fd2FpdEFzc2lnbigpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJvZHkgPSBbXG4gICAgICAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+JyxcbiAgICAgICc8am9iSW5mbyB4bWxucz1cImh0dHA6Ly93d3cuZm9yY2UuY29tLzIwMDkvMDYvYXN5bmNhcGkvZGF0YWxvYWRcIj4nLFxuICAgICAgICAnPHN0YXRlPicgKyBzdGF0ZSArICc8L3N0YXRlPicsXG4gICAgICAnPC9qb2JJbmZvPidcbiAgICBdLmpvaW4oJycpO1xuICAgIHJldHVybiBidWxrLl9yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZCA6ICdQT1NUJyxcbiAgICAgIHBhdGggOiBcIi9qb2IvXCIgKyBzZWxmLmlkLFxuICAgICAgYm9keSA6IGJvZHksXG4gICAgICBoZWFkZXJzIDoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiIDogXCJhcHBsaWNhdGlvbi94bWw7IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlVHlwZTogXCJhcHBsaWNhdGlvbi94bWxcIlxuICAgIH0pO1xuICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgIGxvZ2dlci5kZWJ1ZyhyZXMuam9iSW5mbyk7XG4gICAgc2VsZi5zdGF0ZSA9IHJlcy5qb2JJbmZvLnN0YXRlO1xuICAgIHJldHVybiByZXMuam9iSW5mbztcbiAgfSk7XG4gIHJldHVybiB0aGlzLl9qb2JJbmZvLnRoZW5DYWxsKGNhbGxiYWNrKTtcblxufTtcblxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBCYXRjaCAoZXh0ZW5kcyBSZWNvcmRTdHJlYW0pXG4gKlxuICogQHByb3RlY3RlZFxuICogQGNsYXNzIEJ1bGt+QmF0Y2hcbiAqIEBleHRlbmRzIHtzdHJlYW0uV3JpdGFibGV9XG4gKiBAaW1wbGVtZW50cyB7UHJvbWlzZS48QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICogQHBhcmFtIHtCdWxrfkpvYn0gam9iIC0gQnVsayBqb2Igb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gW2JhdGNoSWRdIC0gQmF0Y2ggSUQgKGlmIGFscmVhZHkgYXZhaWxhYmxlKVxuICovXG52YXIgQmF0Y2ggPSBmdW5jdGlvbihqb2IsIGJhdGNoSWQpIHtcbiAgQmF0Y2guc3VwZXJfLmNhbGwodGhpcywgeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICB0aGlzLmpvYiA9IGpvYjtcbiAgdGhpcy5pZCA9IGJhdGNoSWQ7XG4gIHRoaXMuX2J1bGsgPSBqb2IuX2J1bGs7XG4gIHRoaXMuX2RlZmVycmVkID0gUHJvbWlzZS5kZWZlcigpO1xuICB0aGlzLl9zZXR1cERhdGFTdHJlYW1zKCk7XG59O1xuXG5pbmhlcml0cyhCYXRjaCwgc3RyZWFtLldyaXRhYmxlKTtcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkJhdGNoLnByb3RvdHlwZS5fc2V0dXBEYXRhU3RyZWFtcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYmF0Y2ggPSB0aGlzO1xuICB2YXIgY29udmVydGVyT3B0aW9ucyA9IHsgbnVsbFZhbHVlIDogJyNOL0EnIH07XG4gIHRoaXMuX3VwbG9hZFN0cmVhbSA9IG5ldyBSZWNvcmRTdHJlYW0uU2VyaWFsaXphYmxlKCk7XG4gIHRoaXMuX3VwbG9hZERhdGFTdHJlYW0gPSB0aGlzLl91cGxvYWRTdHJlYW0uc3RyZWFtKCdjc3YnLCBjb252ZXJ0ZXJPcHRpb25zKTtcbiAgdGhpcy5fZG93bmxvYWRTdHJlYW0gPSBuZXcgUmVjb3JkU3RyZWFtLlBhcnNhYmxlKCk7XG4gIHRoaXMuX2Rvd25sb2FkRGF0YVN0cmVhbSA9IHRoaXMuX2Rvd25sb2FkU3RyZWFtLnN0cmVhbSgnY3N2JywgY29udmVydGVyT3B0aW9ucyk7XG5cbiAgdGhpcy5vbignZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgYmF0Y2guX3VwbG9hZFN0cmVhbS5lbmQoKTtcbiAgfSk7XG4gIHRoaXMuX3VwbG9hZERhdGFTdHJlYW0ub25jZSgncmVhZGFibGUnLCBmdW5jdGlvbigpIHtcbiAgICBiYXRjaC5qb2Iub3BlbigpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAvLyBwaXBlIHVwbG9hZCBkYXRhIHRvIGJhdGNoIEFQSSByZXF1ZXN0IHN0cmVhbVxuICAgICAgYmF0Y2guX3VwbG9hZERhdGFTdHJlYW0ucGlwZShiYXRjaC5fY3JlYXRlUmVxdWVzdFN0cmVhbSgpKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gZHVwbGV4IGRhdGEgc3RyZWFtLCBvcGVuZWQgYWNjZXNzIHRvIEFQSSBwcm9ncmFtbWVycyBieSBCYXRjaCNzdHJlYW0oKVxuICB2YXIgZGF0YVN0cmVhbSA9IHRoaXMuX2RhdGFTdHJlYW0gPSBuZXcgRHVwbGV4KCk7XG4gIGRhdGFTdHJlYW0uX3dyaXRlID0gZnVuY3Rpb24oZGF0YSwgZW5jLCBjYikge1xuICAgIGJhdGNoLl91cGxvYWREYXRhU3RyZWFtLndyaXRlKGRhdGEsIGVuYywgY2IpO1xuICB9O1xuICBkYXRhU3RyZWFtLm9uKCdmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBiYXRjaC5fdXBsb2FkRGF0YVN0cmVhbS5lbmQoKTtcbiAgfSk7XG5cbiAgdGhpcy5fZG93bmxvYWREYXRhU3RyZWFtLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCkge1xuICAgIGRhdGFTdHJlYW0ucmVhZCgwKTtcbiAgfSk7XG4gIHRoaXMuX2Rvd25sb2FkRGF0YVN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgZGF0YVN0cmVhbS5wdXNoKG51bGwpO1xuICB9KTtcbiAgZGF0YVN0cmVhbS5fcmVhZCA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB2YXIgY2h1bms7XG4gICAgd2hpbGUgKChjaHVuayA9IGJhdGNoLl9kb3dubG9hZERhdGFTdHJlYW0ucmVhZCgpKSAhPT0gbnVsbCkge1xuICAgICAgZGF0YVN0cmVhbS5wdXNoKGNodW5rKTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIENvbm5lY3QgYmF0Y2ggQVBJIGFuZCBjcmVhdGUgc3RyZWFtIGluc3RhbmNlIG9mIHJlcXVlc3QvcmVzcG9uc2VcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge3N0cmVhbS5EdXBsZXh9XG4gKi9cbkJhdGNoLnByb3RvdHlwZS5fY3JlYXRlUmVxdWVzdFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYmF0Y2ggPSB0aGlzO1xuICB2YXIgYnVsayA9IGJhdGNoLl9idWxrO1xuICB2YXIgbG9nZ2VyID0gYnVsay5fbG9nZ2VyO1xuXG4gIHJldHVybiBidWxrLl9yZXF1ZXN0KHtcbiAgICBtZXRob2QgOiAnUE9TVCcsXG4gICAgcGF0aCA6IFwiL2pvYi9cIiArIGJhdGNoLmpvYi5pZCArIFwiL2JhdGNoXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L2NzdlwiXG4gICAgfSxcbiAgICByZXNwb25zZVR5cGU6IFwiYXBwbGljYXRpb24veG1sXCJcbiAgfSwgZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBiYXRjaC5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhyZXMuYmF0Y2hJbmZvKTtcbiAgICAgIGJhdGNoLmlkID0gcmVzLmJhdGNoSW5mby5pZDtcbiAgICAgIGJhdGNoLmVtaXQoJ3F1ZXVlJywgcmVzLmJhdGNoSW5mbyk7XG4gICAgfVxuICB9KS5zdHJlYW0oKTtcbn07XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgV3JpdGFibGVcbiAqXG4gKiBAb3ZlcnJpZGVcbiAqIEBwcml2YXRlXG4gKi9cbkJhdGNoLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihyZWNvcmQsIGVuYywgY2IpIHtcbiAgcmVjb3JkID0gXy5jbG9uZShyZWNvcmQpO1xuICBpZiAodGhpcy5qb2Iub3BlcmF0aW9uID09PSBcImluc2VydFwiKSB7XG4gICAgZGVsZXRlIHJlY29yZC5JZDtcbiAgfSBlbHNlIGlmICh0aGlzLmpvYi5vcGVyYXRpb24gPT09IFwiZGVsZXRlXCIpIHtcbiAgICByZWNvcmQgPSB7IElkOiByZWNvcmQuSWQgfTtcbiAgfVxuICBkZWxldGUgcmVjb3JkLnR5cGU7XG4gIGRlbGV0ZSByZWNvcmQuYXR0cmlidXRlcztcbiAgdGhpcy5fdXBsb2FkU3RyZWFtLndyaXRlKHJlY29yZCwgZW5jLCBjYik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZHVwbGV4IHN0cmVhbSB3aGljaCBhY2NlcHRzIENTViBkYXRhIGlucHV0IGFuZCBiYXRjaCByZXN1bHQgb3V0cHV0XG4gKlxuICogQHJldHVybnMge3N0cmVhbS5EdXBsZXh9XG4gKi9cbkJhdGNoLnByb3RvdHlwZS5zdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2RhdGFTdHJlYW07XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYmF0Y2ggb3BlcmF0aW9uXG4gKlxuICogQG1ldGhvZCBCdWxrfkJhdGNoI2V4ZWN1dGVcbiAqIEBwYXJhbSB7QXJyYXkuPFJlY29yZD58c3RyZWFtLlN0cmVhbXxTdHJpbmd9IFtpbnB1dF0gLSBJbnB1dCBzb3VyY2UgZm9yIGJhdGNoIG9wZXJhdGlvbi4gQWNjZXB0cyBhcnJheSBvZiByZWNvcmRzLCBDU1Ygc3RyaW5nLCBhbmQgQ1NWIGRhdGEgaW5wdXQgc3RyZWFtIGluIGluc2VydC91cGRhdGUvdXBzZXJ0L2RlbGV0ZS9oYXJkRGVsZXRlIG9wZXJhdGlvbiwgU09RTCBzdHJpbmcgaW4gcXVlcnkgb3BlcmF0aW9uLlxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFJlY29yZFJlc3VsdD58QXJyYXkuPEJhdGNoUmVzdWx0SW5mbz4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWxrfkJhdGNofVxuICovXG5CYXRjaC5wcm90b3R5cGUucnVuID1cbkJhdGNoLnByb3RvdHlwZS5leGVjID1cbkJhdGNoLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oaW5wdXQsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7IC8vIGlmIGlucHV0IGFyZ3VtZW50IGlzIG9taXR0ZWRcbiAgICBjYWxsYmFjayA9IGlucHV0O1xuICAgIGlucHV0ID0gbnVsbDtcbiAgfVxuXG4gIC8vIGlmIGJhdGNoIGlzIGFscmVhZHkgZXhlY3V0ZWRcbiAgaWYgKHRoaXMuX3Jlc3VsdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJhdGNoIGFscmVhZHkgZXhlY3V0ZWQuXCIpO1xuICB9XG5cbiAgdmFyIHJkZWZlcnJlZCA9IFByb21pc2UuZGVmZXIoKTtcbiAgdGhpcy5fcmVzdWx0ID0gcmRlZmVycmVkLnByb21pc2U7XG4gIHRoaXMuX3Jlc3VsdC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgIHNlbGYuX2RlZmVycmVkLnJlc29sdmUocmVzKTtcbiAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgc2VsZi5fZGVmZXJyZWQucmVqZWN0KGVycik7XG4gIH0pO1xuICB0aGlzLm9uY2UoJ3Jlc3BvbnNlJywgZnVuY3Rpb24ocmVzKSB7XG4gICAgcmRlZmVycmVkLnJlc29sdmUocmVzKTtcbiAgfSk7XG4gIHRoaXMub25jZSgnZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICByZGVmZXJyZWQucmVqZWN0KGVycik7XG4gIH0pO1xuXG4gIGlmIChfLmlzT2JqZWN0KGlucHV0KSAmJiBfLmlzRnVuY3Rpb24oaW5wdXQucGlwZSkpIHsgLy8gaWYgaW5wdXQgaGFzIHN0cmVhbS5SZWFkYWJsZSBpbnRlcmZhY2VcbiAgICBpbnB1dC5waXBlKHRoaXMuX2RhdGFTdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBkYXRhO1xuICAgIGlmIChfLmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICBfLmZvckVhY2goaW5wdXQsIGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgICBPYmplY3Qua2V5cyhyZWNvcmQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZWNvcmRba2V5XSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZWNvcmRba2V5XSA9IFN0cmluZyhyZWNvcmRba2V5XSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHNlbGYud3JpdGUocmVjb3JkKTtcbiAgICAgIH0pO1xuICAgICAgc2VsZi5lbmQoKTtcbiAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoaW5wdXQpKXtcbiAgICAgIGRhdGEgPSBpbnB1dDtcbiAgICAgIHRoaXMuX2RhdGFTdHJlYW0ud3JpdGUoZGF0YSwgJ3V0ZjgnKTtcbiAgICAgIHRoaXMuX2RhdGFTdHJlYW0uZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmV0dXJuIEJhdGNoIGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICByZXR1cm4gdGhpcy50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFByb21pc2UvQSsgaW50ZXJmYWNlXG4gKiBodHRwOi8vcHJvbWlzZXMtYXBsdXMuZ2l0aHViLmlvL3Byb21pc2VzLXNwZWMvXG4gKlxuICogRGVsZWdhdGUgdG8gZGVmZXJyZWQgcHJvbWlzZSwgcmV0dXJuIHByb21pc2UgaW5zdGFuY2UgZm9yIGJhdGNoIHJlc3VsdFxuICpcbiAqIEBtZXRob2QgQnVsa35CYXRjaCN0aGVuXG4gKi9cbkJhdGNoLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25SZXNvbHZlZCwgb25SZWplY3QsIG9uUHJvZ3Jlc3MpIHtcbiAgcmV0dXJuIHRoaXMuX2RlZmVycmVkLnByb21pc2UudGhlbihvblJlc29sdmVkLCBvblJlamVjdCwgb25Qcm9ncmVzcyk7XG59O1xuXG4vKipcbiAqIFByb21pc2UvQSsgZXh0ZW5zaW9uXG4gKiBDYWxsIFwidGhlblwiIHVzaW5nIGdpdmVuIG5vZGUtc3R5bGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqXG4gKiBAbWV0aG9kIEJ1bGt+QmF0Y2gjdGhlbkNhbGxcbiAqL1xuQmF0Y2gucHJvdG90eXBlLnRoZW5DYWxsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgaWYgKF8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICB0aGlzLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJ1bGt+QmF0Y2hJbmZvXG4gKiBAcHJvcCB7U3RyaW5nfSBpZCAtIEJhdGNoIElEXG4gKiBAcHJvcCB7U3RyaW5nfSBqb2JJZCAtIEpvYiBJRFxuICogQHByb3Age1N0cmluZ30gc3RhdGUgLSBCYXRjaCBzdGF0ZVxuICogQHByb3Age1N0cmluZ30gc3RhdGVNZXNzYWdlIC0gQmF0Y2ggc3RhdGUgbWVzc2FnZVxuICovXG5cbi8qKlxuICogQ2hlY2sgdGhlIGxhdGVzdCBiYXRjaCBzdGF0dXMgaW4gc2VydmVyXG4gKlxuICogQG1ldGhvZCBCdWxrfkJhdGNoI2NoZWNrXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxCdWxrfkJhdGNoSW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEJ1bGt+QmF0Y2hJbmZvPn1cbiAqL1xuQmF0Y2gucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYnVsayA9IHRoaXMuX2J1bGs7XG4gIHZhciBsb2dnZXIgPSBidWxrLl9sb2dnZXI7XG4gIHZhciBqb2JJZCA9IHRoaXMuam9iLmlkO1xuICB2YXIgYmF0Y2hJZCA9IHRoaXMuaWQ7XG5cbiAgaWYgKCFqb2JJZCB8fCAhYmF0Y2hJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJhdGNoIG5vdCBzdGFydGVkLlwiKTtcbiAgfVxuICByZXR1cm4gYnVsay5fcmVxdWVzdCh7XG4gICAgbWV0aG9kIDogJ0dFVCcsXG4gICAgcGF0aCA6IFwiL2pvYi9cIiArIGpvYklkICsgXCIvYmF0Y2gvXCIgKyBiYXRjaElkLFxuICAgIHJlc3BvbnNlVHlwZTogXCJhcHBsaWNhdGlvbi94bWxcIlxuICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgIGxvZ2dlci5kZWJ1ZyhyZXMuYmF0Y2hJbmZvKTtcbiAgICByZXR1cm4gcmVzLmJhdGNoSW5mbztcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuXG4vKipcbiAqIFBvbGxpbmcgdGhlIGJhdGNoIHJlc3VsdCBhbmQgcmV0cmlldmVcbiAqXG4gKiBAbWV0aG9kIEJ1bGt+QmF0Y2gjcG9sbFxuICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsIC0gUG9sbGluZyBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IC0gUG9sbGluZyB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICovXG5CYXRjaC5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uKGludGVydmFsLCB0aW1lb3V0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGpvYklkID0gdGhpcy5qb2IuaWQ7XG4gIHZhciBiYXRjaElkID0gdGhpcy5pZDtcblxuICBpZiAoIWpvYklkIHx8ICFiYXRjaElkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQmF0Y2ggbm90IHN0YXJ0ZWQuXCIpO1xuICB9XG4gIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgdmFyIHBvbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgaWYgKHN0YXJ0VGltZSArIHRpbWVvdXQgPCBub3cpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXCJQb2xsaW5nIHRpbWUgb3V0LiBKb2IgSWQgPSBcIiArIGpvYklkICsgXCIgLCBiYXRjaCBJZCA9IFwiICsgYmF0Y2hJZCk7XG4gICAgICBlcnIubmFtZSA9ICdQb2xsaW5nVGltZW91dCc7XG4gICAgICBlcnIuam9iSWQgPSBqb2JJZDtcbiAgICAgIGVyci5iYXRjaElkID0gYmF0Y2hJZDtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLmNoZWNrKGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlcy5zdGF0ZSA9PT0gXCJGYWlsZWRcIikge1xuICAgICAgICAgIGlmIChwYXJzZUludChyZXMubnVtYmVyUmVjb3Jkc1Byb2Nlc3NlZCwgMTApID4gMCkge1xuICAgICAgICAgICAgc2VsZi5yZXRyaWV2ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKHJlcy5zdGF0ZU1lc3NhZ2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVzLnN0YXRlID09PSBcIkNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgc2VsZi5yZXRyaWV2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuZW1pdCgncHJvZ3Jlc3MnLCByZXMpO1xuICAgICAgICAgIHNldFRpbWVvdXQocG9sbCwgaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHNldFRpbWVvdXQocG9sbCwgaW50ZXJ2YWwpO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCdWxrfkJhdGNoUmVzdWx0SW5mb1xuICogQHByb3Age1N0cmluZ30gaWQgLSBCYXRjaCByZXN1bHQgSURcbiAqIEBwcm9wIHtTdHJpbmd9IGJhdGNoSWQgLSBCYXRjaCBJRCB3aGljaCBpbmNsdWRlcyB0aGlzIGJhdGNoIHJlc3VsdC5cbiAqIEBwcm9wIHtTdHJpbmd9IGpvYklkIC0gSm9iIElEIHdoaWNoIGluY2x1ZGVzIHRoaXMgYmF0Y2ggcmVzdWx0LlxuICovXG5cbi8qKlxuICogUmV0cmlldmUgYmF0Y2ggcmVzdWx0XG4gKlxuICogQG1ldGhvZCBCdWxrfkJhdGNoI3JldHJpZXZlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0PnxBcnJheS48QnVsa35CYXRjaFJlc3VsdEluZm8+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXkuPFJlY29yZFJlc3VsdD58QXJyYXkuPEJ1bGt+QmF0Y2hSZXN1bHRJbmZvPj59XG4gKi9cbkJhdGNoLnByb3RvdHlwZS5yZXRyaWV2ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGJ1bGsgPSB0aGlzLl9idWxrO1xuICB2YXIgam9iSWQgPSB0aGlzLmpvYi5pZDtcbiAgdmFyIGpvYiA9IHRoaXMuam9iO1xuICB2YXIgYmF0Y2hJZCA9IHRoaXMuaWQ7XG5cbiAgaWYgKCFqb2JJZCB8fCAhYmF0Y2hJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJhdGNoIG5vdCBzdGFydGVkLlwiKTtcbiAgfVxuXG4gIHJldHVybiBqb2IuaW5mbygpLnRoZW4oZnVuY3Rpb24oam9iSW5mbykge1xuICAgIHJldHVybiBidWxrLl9yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZCA6ICdHRVQnLFxuICAgICAgcGF0aCA6IFwiL2pvYi9cIiArIGpvYklkICsgXCIvYmF0Y2gvXCIgKyBiYXRjaElkICsgXCIvcmVzdWx0XCJcbiAgICB9KTtcbiAgfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICB2YXIgcmVzdWx0cztcbiAgICBpZiAoam9iLm9wZXJhdGlvbiA9PT0gJ3F1ZXJ5Jykge1xuICAgICAgdmFyIGNvbm4gPSBidWxrLl9jb25uO1xuICAgICAgdmFyIHJlc3VsdElkcyA9IHJlc1sncmVzdWx0LWxpc3QnXS5yZXN1bHQ7XG4gICAgICByZXN1bHRzID0gcmVzWydyZXN1bHQtbGlzdCddLnJlc3VsdDtcbiAgICAgIHJlc3VsdHMgPSBfLm1hcChfLmlzQXJyYXkocmVzdWx0cykgPyByZXN1bHRzIDogWyByZXN1bHRzIF0sIGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIGJhdGNoSWQ6IGJhdGNoSWQsXG4gICAgICAgICAgam9iSWQ6IGpvYklkXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0cyA9IF8ubWFwKHJlcywgZnVuY3Rpb24ocmV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IHJldC5JZCB8fCBudWxsLFxuICAgICAgICAgIHN1Y2Nlc3M6IHJldC5TdWNjZXNzID09PSBcInRydWVcIixcbiAgICAgICAgICBlcnJvcnM6IHJldC5FcnJvciA/IFsgcmV0LkVycm9yIF0gOiBbXVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXN1bHRzKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfSkuZmFpbChmdW5jdGlvbihlcnIpIHtcbiAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRmV0Y2ggcXVlcnkgcmVzdWx0IGFzIGEgcmVjb3JkIHN0cmVhbVxuICogQHBhcmFtIHtTdHJpbmd9IHJlc3VsdElkIC0gUmVzdWx0IGlkXG4gKiBAcmV0dXJucyB7UmVjb3JkU3RyZWFtfSAtIFJlY29yZCBzdHJlYW0sIGNvbnZlcnRpYmxlIHRvIENTViBkYXRhIHN0cmVhbVxuICovXG5CYXRjaC5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24ocmVzdWx0SWQpIHtcbiAgdmFyIGpvYklkID0gdGhpcy5qb2IuaWQ7XG4gIHZhciBiYXRjaElkID0gdGhpcy5pZDtcbiAgaWYgKCFqb2JJZCB8fCAhYmF0Y2hJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJhdGNoIG5vdCBzdGFydGVkLlwiKTtcbiAgfVxuICB2YXIgcmVzdWx0U3RyZWFtID0gbmV3IFJlY29yZFN0cmVhbS5QYXJzYWJsZSgpO1xuICB2YXIgcmVzdWx0RGF0YVN0cmVhbSA9IHJlc3VsdFN0cmVhbS5zdHJlYW0oJ2NzdicpO1xuICB2YXIgcmVxU3RyZWFtID0gdGhpcy5fYnVsay5fcmVxdWVzdCh7XG4gICAgbWV0aG9kIDogJ0dFVCcsXG4gICAgcGF0aCA6IFwiL2pvYi9cIiArIGpvYklkICsgXCIvYmF0Y2gvXCIgKyBiYXRjaElkICsgXCIvcmVzdWx0L1wiICsgcmVzdWx0SWQsXG4gICAgcmVzcG9uc2VUeXBlOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG4gIH0pLnN0cmVhbSgpLnBpcGUocmVzdWx0RGF0YVN0cmVhbSk7XG4gIHJldHVybiByZXN1bHRTdHJlYW07XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIEJ1bGtBcGkgPSBmdW5jdGlvbigpIHtcbiAgQnVsa0FwaS5zdXBlcl8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbmluaGVyaXRzKEJ1bGtBcGksIEh0dHBBcGkpO1xuXG5CdWxrQXBpLnByb3RvdHlwZS5iZWZvcmVTZW5kID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICByZXF1ZXN0LmhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnMgfHwge307XG4gIHJlcXVlc3QuaGVhZGVyc1tcIlgtU0ZEQy1TRVNTSU9OXCJdID0gdGhpcy5fY29ubi5hY2Nlc3NUb2tlbjtcbn07XG5cbkJ1bGtBcGkucHJvdG90eXBlLmlzU2Vzc2lvbkV4cGlyZWQgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICByZXR1cm4gcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDAwICYmXG4gICAgLzxleGNlcHRpb25Db2RlPkludmFsaWRTZXNzaW9uSWQ8XFwvZXhjZXB0aW9uQ29kZT4vLnRlc3QocmVzcG9uc2UuYm9keSk7XG59O1xuXG5CdWxrQXBpLnByb3RvdHlwZS5oYXNFcnJvckluUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICByZXR1cm4gISFib2R5LmVycm9yO1xufTtcblxuQnVsa0FwaS5wcm90b3R5cGUucGFyc2VFcnJvciA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgcmV0dXJuIHtcbiAgICBlcnJvckNvZGU6IGJvZHkuZXJyb3IuZXhjZXB0aW9uQ29kZSxcbiAgICBtZXNzYWdlOiBib2R5LmVycm9yLmV4Y2VwdGlvbk1lc3NhZ2VcbiAgfTtcbn07XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKipcbiAqIENsYXNzIGZvciBCdWxrIEFQSVxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIC0gQ29ubmVjdGlvbiBvYmplY3RcbiAqL1xudmFyIEJ1bGsgPSBmdW5jdGlvbihjb25uKSB7XG4gIHRoaXMuX2Nvbm4gPSBjb25uO1xuICB0aGlzLl9sb2dnZXIgPSBjb25uLl9sb2dnZXI7XG59O1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5CdWxrLnByb3RvdHlwZS5wb2xsSW50ZXJ2YWwgPSAxMDAwO1xuXG4vKipcbiAqIFBvbGxpbmcgdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbkJ1bGsucHJvdG90eXBlLnBvbGxUaW1lb3V0ID0gMTAwMDA7XG5cbi8qKiBAcHJpdmF0ZSAqKi9cbkJ1bGsucHJvdG90eXBlLl9yZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdCwgY2FsbGJhY2spIHtcbiAgdmFyIGNvbm4gPSB0aGlzLl9jb25uO1xuICByZXF1ZXN0ID0gXy5jbG9uZShyZXF1ZXN0KTtcbiAgdmFyIGJhc2VVcmwgPSBbIGNvbm4uaW5zdGFuY2VVcmwsIFwic2VydmljZXMvYXN5bmNcIiwgY29ubi52ZXJzaW9uIF0uam9pbignLycpO1xuICByZXF1ZXN0LnVybCA9IGJhc2VVcmwgKyByZXF1ZXN0LnBhdGg7XG4gIHZhciBvcHRpb25zID0geyByZXNwb25zZVR5cGU6IHJlcXVlc3QucmVzcG9uc2VUeXBlIH07XG4gIGRlbGV0ZSByZXF1ZXN0LnBhdGg7XG4gIGRlbGV0ZSByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcbiAgcmV0dXJuIG5ldyBCdWxrQXBpKHRoaXMuX2Nvbm4sIG9wdGlvbnMpLnJlcXVlc3QocmVxdWVzdCkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHN0YXJ0IGJ1bGtsb2FkIGpvYiBhbmQgYmF0Y2hcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdGlvbiAtIEJ1bGsgbG9hZCBvcGVyYXRpb24gKCdpbnNlcnQnLCAndXBkYXRlJywgJ3Vwc2VydCcsICdkZWxldGUnLCBvciAnaGFyZERlbGV0ZScpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgYnVsayBsb2FkaW5nIG9wZXJhdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmV4dElkRmllbGRdIC0gRXh0ZXJuYWwgSUQgZmllbGQgbmFtZSAodXNlZCB3aGVuIHVwc2VydCBvcGVyYXRpb24pLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbmN1cnJlbmN5TW9kZV0gLSAnU2VyaWFsJyBvciAnUGFyYWxsZWwnLiBEZWZhdWx0cyB0byBQYXJhbGxlbC5cbiAqIEBwYXJhbSB7QXJyYXkuPFJlY29yZD58c3RyZWFtLlN0cmVhbXxTdHJpbmd9IFtpbnB1dF0gLSBJbnB1dCBzb3VyY2UgZm9yIGJ1bGtsb2FkLiBBY2NlcHRzIGFycmF5IG9mIHJlY29yZHMsIENTViBzdHJpbmcsIGFuZCBDU1YgZGF0YSBpbnB1dCBzdHJlYW0gaW4gaW5zZXJ0L3VwZGF0ZS91cHNlcnQvZGVsZXRlL2hhcmREZWxldGUgb3BlcmF0aW9uLCBTT1FMIHN0cmluZyBpbiBxdWVyeSBvcGVyYXRpb24uXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0PnxBcnJheS48QnVsa35CYXRjaFJlc3VsdEluZm8+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVsa35CYXRjaH1cbiAqL1xuQnVsay5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKHR5cGUsIG9wZXJhdGlvbiwgb3B0aW9ucywgaW5wdXQsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKCF0eXBlIHx8ICFvcGVyYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnN1ZmZpY2llbnQgYXJndW1lbnRzLiBBdCBsZWFzdCwgJ3R5cGUnIGFuZCAnb3BlcmF0aW9uJyBhcmUgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghXy5pc09iamVjdChvcHRpb25zKSB8fCBvcHRpb25zLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHsgLy8gd2hlbiBvcHRpb25zIGlzIG5vdCBwbGFpbiBoYXNoIG9iamVjdCwgaXQgaXMgb21pdHRlZFxuICAgIGNhbGxiYWNrID0gaW5wdXQ7XG4gICAgaW5wdXQgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIHZhciBqb2IgPSB0aGlzLmNyZWF0ZUpvYih0eXBlLCBvcGVyYXRpb24sIG9wdGlvbnMpO1xuICBqb2Iub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBpZiAoYmF0Y2gpIHtcbiAgICAgIGJhdGNoLmVtaXQoJ2Vycm9yJywgZXJyb3IpOyAvLyBwYXNzIGpvYiBlcnJvciB0byBiYXRjaFxuICAgIH1cbiAgfSk7XG4gIHZhciBiYXRjaCA9IGpvYi5jcmVhdGVCYXRjaCgpO1xuICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgIGJhdGNoID0gbnVsbDtcbiAgICBqb2IuY2xvc2UoKTtcbiAgfTtcbiAgdmFyIGNsZWFudXBPbkVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGVyci5uYW1lICE9PSAnUG9sbGluZ1RpbWVvdXQnKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9O1xuICBiYXRjaC5vbigncmVzcG9uc2UnLCBjbGVhbnVwKTtcbiAgYmF0Y2gub24oJ2Vycm9yJywgY2xlYW51cE9uRXJyb3IpO1xuICBiYXRjaC5vbigncXVldWUnLCBmdW5jdGlvbigpIHsgYmF0Y2gucG9sbChzZWxmLnBvbGxJbnRlcnZhbCwgc2VsZi5wb2xsVGltZW91dCk7IH0pO1xuICByZXR1cm4gYmF0Y2guZXhlY3V0ZShpbnB1dCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGJ1bGsgcXVlcnkgYW5kIGdldCByZWNvcmQgc3RyZWFtXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNvcWwgLSBTT1FMIHRvIGV4ZWN1dGUgaW4gYnVsayBqb2JcbiAqIEByZXR1cm5zIHtSZWNvcmRTdHJlYW0uUGFyc2FibGV9IC0gUmVjb3JkIHN0cmVhbSwgY29udmVydGlibGUgdG8gQ1NWIGRhdGEgc3RyZWFtXG4gKi9cbkJ1bGsucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24oc29xbCkge1xuICB2YXIgbSA9IHNvcWwucmVwbGFjZSgvXFwoW1xcc1xcU10rXFwpL2csICcnKS5tYXRjaCgvRlJPTVxccysoXFx3KykvaSk7XG4gIGlmICghbSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNvYmplY3QgdHlwZSBmb3VuZCBpbiBxdWVyeSwgbWF5YmUgY2F1c2VkIGJ5IGludmFsaWQgU09RTC5cIik7XG4gIH1cbiAgdmFyIHR5cGUgPSBtWzFdO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZWNvcmRTdHJlYW0gPSBuZXcgUmVjb3JkU3RyZWFtLlBhcnNhYmxlKCk7XG4gIHZhciBkYXRhU3RyZWFtID0gcmVjb3JkU3RyZWFtLnN0cmVhbSgnY3N2Jyk7XG4gIHRoaXMubG9hZCh0eXBlLCBcInF1ZXJ5XCIsIHNvcWwpLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgIHZhciBzdHJlYW1zID0gcmVzdWx0cy5tYXAoZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICByZXR1cm4gc2VsZlxuICAgICAgICAuam9iKHJlc3VsdC5qb2JJZClcbiAgICAgICAgLmJhdGNoKHJlc3VsdC5iYXRjaElkKVxuICAgICAgICAucmVzdWx0KHJlc3VsdC5pZClcbiAgICAgICAgLnN0cmVhbSgpO1xuICAgIH0pO1xuXG4gICAgam9pblN0cmVhbXMoc3RyZWFtcykucGlwZShkYXRhU3RyZWFtKTtcbiAgfSkuZmFpbChmdW5jdGlvbihlcnIpIHtcbiAgICByZWNvcmRTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgcmV0dXJuIHJlY29yZFN0cmVhbTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgam9iIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRpb24gLSBCdWxrIGxvYWQgb3BlcmF0aW9uICgnaW5zZXJ0JywgJ3VwZGF0ZScsICd1cHNlcnQnLCAnZGVsZXRlJywgJ2hhcmREZWxldGUnLCBvciAncXVlcnknKVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIGJ1bGsgbG9hZGluZyBvcGVyYXRpb25cbiAqIEByZXR1cm5zIHtCdWxrfkpvYn1cbiAqL1xuQnVsay5wcm90b3R5cGUuY3JlYXRlSm9iID0gZnVuY3Rpb24odHlwZSwgb3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgSm9iKHRoaXMsIHR5cGUsIG9wZXJhdGlvbiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEdldCBhIGpvYiBpbnN0YW5jZSBzcGVjaWZpZWQgYnkgZ2l2ZW4gam9iIElEXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGpvYklkIC0gSm9iIElEXG4gKiBAcmV0dXJucyB7QnVsa35Kb2J9XG4gKi9cbkJ1bGsucHJvdG90eXBlLmpvYiA9IGZ1bmN0aW9uKGpvYklkKSB7XG4gIHJldHVybiBuZXcgSm9iKHRoaXMsIG51bGwsIG51bGwsIG51bGwsIGpvYklkKTtcbn07XG5cblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKlxuICogUmVnaXN0ZXIgaG9vayBpbiBjb25uZWN0aW9uIGluc3RhbnRpYXRpb24gZm9yIGR5bmFtaWNhbGx5IGFkZGluZyB0aGlzIEFQSSBtb2R1bGUgZmVhdHVyZXNcbiAqL1xuanNmb3JjZS5vbignY29ubmVjdGlvbjpuZXcnLCBmdW5jdGlvbihjb25uKSB7XG4gIGNvbm4uYnVsayA9IG5ldyBCdWxrKGNvbm4pO1xufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCdWxrO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/api/bulk.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/api/bulk.js":
/*!**********************************************!*\
  !*** ./node_modules/jsforce/lib/api/bulk.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global process*/\n/**\n * @file Manages Salesforce Bulk API related operations\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar inherits     = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\"),\n    stream       = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/readable.js\"),\n    Duplex       = stream.Duplex,\n    events       = __webpack_require__(/*! events */ \"events\"),\n    _            = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    joinStreams  = __webpack_require__(/*! multistream */ \"(rsc)/./node_modules/multistream/index.js\"),\n    jsforce      = __webpack_require__(/*! ../core */ \"(rsc)/./node_modules/jsforce/lib/core.js\"),\n    RecordStream = __webpack_require__(/*! ../record-stream */ \"(rsc)/./node_modules/jsforce/lib/record-stream.js\"),\n    Promise      = __webpack_require__(/*! ../promise */ \"(rsc)/./node_modules/jsforce/lib/promise.js\"),\n    HttpApi      = __webpack_require__(/*! ../http-api */ \"(rsc)/./node_modules/jsforce/lib/http-api.js\");\n\n/*--------------------------------------------*/\n\n/**\n * Class for Bulk API Job\n *\n * @protected\n * @class Bulk~Job\n * @extends events.EventEmitter\n *\n * @param {Bulk} bulk - Bulk API object\n * @param {String} [type] - SObject type\n * @param {String} [operation] - Bulk load operation ('insert', 'update', 'upsert', 'delete', or 'hardDelete')\n * @param {Object} [options] - Options for bulk loading operation\n * @param {String} [options.extIdField] - External ID field name (used when upsert operation).\n * @param {String} [options.concurrencyMode] - 'Serial' or 'Parallel'. Defaults to Parallel.\n * @param {String} [jobId] - Job ID (if already available)\n */\nvar Job = function(bulk, type, operation, options, jobId) {\n  this._bulk = bulk;\n  this.type = type;\n  this.operation = operation;\n  this.options = options || {};\n  this.id = jobId;\n  this.state = this.id ? 'Open' : 'Unknown';\n  this._batches = {};\n};\n\ninherits(Job, events.EventEmitter);\n\n/**\n * @typedef {Object} Bulk~JobInfo\n * @prop {String} id - Job ID\n * @prop {String} object - Object type name\n * @prop {String} operation - Operation type of the job\n * @prop {String} state - Job status\n */\n\n/**\n * Return latest jobInfo from cache\n *\n * @method Bulk~Job#info\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.info = function(callback) {\n  var self = this;\n  // if cache is not available, check the latest\n  if (!this._jobInfo) {\n    this._jobInfo = this.check();\n  }\n  return this._jobInfo.thenCall(callback);\n};\n\n/**\n * Open new job and get jobinfo\n *\n * @method Bulk~Job#open\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.open = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  // if not requested opening job\n  if (!this._jobInfo) {\n    var operation = this.operation.toLowerCase();\n    if (operation === 'harddelete') { operation = 'hardDelete'; }\n    var body = [\n      '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n      '<jobInfo  xmlns=\"http://www.force.com/2009/06/asyncapi/dataload\">',\n        '<operation>' + operation + '</operation>',\n        '<object>' + this.type + '</object>',\n        (this.options.extIdField ?\n         '<externalIdFieldName>'+this.options.extIdField+'</externalIdFieldName>' :\n         ''),\n        (this.options.concurrencyMode ?\n         '<concurrencyMode>'+this.options.concurrencyMode+'</concurrencyMode>' :\n         ''),\n        (this.options.assignmentRuleId ?\n          '<assignmentRuleId>' + this.options.assignmentRuleId + '</assignmentRuleId>' :\n          ''),\n        '<contentType>CSV</contentType>',\n      '</jobInfo>'\n    ].join('');\n\n    this._jobInfo = bulk._request({\n      method : 'POST',\n      path : \"/job\",\n      body : body,\n      headers : {\n        \"Content-Type\" : \"application/xml; charset=utf-8\"\n      },\n      responseType: \"application/xml\"\n    }).then(function(res) {\n      self.emit(\"open\", res.jobInfo);\n      self.id = res.jobInfo.id;\n      self.state = res.jobInfo.state;\n      return res.jobInfo;\n    }, function(err) {\n      self.emit(\"error\", err);\n      throw err;\n    });\n  }\n  return this._jobInfo.thenCall(callback);\n};\n\n/**\n * Create a new batch instance in the job\n *\n * @method Bulk~Job#createBatch\n * @returns {Bulk~Batch}\n */\nJob.prototype.createBatch = function() {\n  var batch = new Batch(this);\n  var self = this;\n  batch.on('queue', function() {\n    self._batches[batch.id] = batch;\n  });\n  return batch;\n};\n\n/**\n * Get a batch instance specified by given batch ID\n *\n * @method Bulk~Job#batch\n * @param {String} batchId - Batch ID\n * @returns {Bulk~Batch}\n */\nJob.prototype.batch = function(batchId) {\n  var batch = this._batches[batchId];\n  if (!batch) {\n    batch = new Batch(this, batchId);\n    this._batches[batchId] = batch;\n  }\n  return batch;\n};\n\n/**\n * Check the latest job status from server\n *\n * @method Bulk~Job#check\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.check = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  this._jobInfo = this._waitAssign().then(function() {\n    return bulk._request({\n      method : 'GET',\n      path : \"/job/\" + self.id,\n      responseType: \"application/xml\"\n    });\n  }).then(function(res) {\n    logger.debug(res.jobInfo);\n    self.id = res.jobInfo.id;\n    self.type = res.jobInfo.object;\n    self.operation = res.jobInfo.operation;\n    self.state = res.jobInfo.state;\n    return res.jobInfo;\n  });\n  return this._jobInfo.thenCall(callback);\n};\n\n/**\n * Wait till the job is assigned to server\n *\n * @method Bulk~Job#info\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype._waitAssign = function(callback) {\n  return (this.id ? Promise.resolve({ id: this.id }) : this.open()).thenCall(callback);\n};\n\n\n/**\n * List all registered batch info in job\n *\n * @method Bulk~Job#list\n * @param {Callback.<Array.<Bulk~BatchInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<Bulk~BatchInfo>>}\n */\nJob.prototype.list = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  return this._waitAssign().then(function() {\n    return bulk._request({\n      method : 'GET',\n      path : \"/job/\" + self.id + \"/batch\",\n      responseType: \"application/xml\"\n    });\n  }).then(function(res) {\n    logger.debug(res.batchInfoList.batchInfo);\n    var batchInfoList = res.batchInfoList;\n    batchInfoList = _.isArray(batchInfoList.batchInfo) ? batchInfoList.batchInfo : [ batchInfoList.batchInfo ];\n    return batchInfoList;\n  }).thenCall(callback);\n\n};\n\n/**\n * Close opened job\n *\n * @method Bulk~Job#close\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.close = function() {\n  var self = this;\n  return this._changeState(\"Closed\").then(function(jobInfo) {\n    self.id = null;\n    self.emit(\"close\", jobInfo);\n    return jobInfo;\n  }, function(err) {\n    self.emit(\"error\", err);\n    throw err;\n  });\n};\n\n/**\n * Set the status to abort\n *\n * @method Bulk~Job#abort\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~JobInfo>}\n */\nJob.prototype.abort = function() {\n  var self = this;\n  return this._changeState(\"Aborted\").then(function(jobInfo) {\n    self.id = null;\n    self.emit(\"abort\", jobInfo);\n    return jobInfo;\n  }, function(err) {\n    self.emit(\"error\", err);\n    throw err;\n  });\n};\n\n/**\n * @private\n */\nJob.prototype._changeState = function(state, callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n\n  this._jobInfo = this._waitAssign().then(function() {\n    var body = [\n      '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n      '<jobInfo xmlns=\"http://www.force.com/2009/06/asyncapi/dataload\">',\n        '<state>' + state + '</state>',\n      '</jobInfo>'\n    ].join('');\n    return bulk._request({\n      method : 'POST',\n      path : \"/job/\" + self.id,\n      body : body,\n      headers : {\n        \"Content-Type\" : \"application/xml; charset=utf-8\"\n      },\n      responseType: \"application/xml\"\n    });\n  }).then(function(res) {\n    logger.debug(res.jobInfo);\n    self.state = res.jobInfo.state;\n    return res.jobInfo;\n  });\n  return this._jobInfo.thenCall(callback);\n\n};\n\n\n/*--------------------------------------------*/\n\n/**\n * Batch (extends RecordStream)\n *\n * @protected\n * @class Bulk~Batch\n * @extends {stream.Writable}\n * @implements {Promise.<Array.<RecordResult>>}\n * @param {Bulk~Job} job - Bulk job object\n * @param {String} [batchId] - Batch ID (if already available)\n */\nvar Batch = function(job, batchId) {\n  Batch.super_.call(this, { objectMode: true });\n  this.job = job;\n  this.id = batchId;\n  this._bulk = job._bulk;\n  this._deferred = Promise.defer();\n  this._setupDataStreams();\n};\n\ninherits(Batch, stream.Writable);\n\n\n/**\n * @private\n */\nBatch.prototype._setupDataStreams = function() {\n  var batch = this;\n  var converterOptions = { nullValue : '#N/A' };\n  this._uploadStream = new RecordStream.Serializable();\n  this._uploadDataStream = this._uploadStream.stream('csv', converterOptions);\n  this._downloadStream = new RecordStream.Parsable();\n  this._downloadDataStream = this._downloadStream.stream('csv', converterOptions);\n\n  this.on('finish', function() {\n    batch._uploadStream.end();\n  });\n  this._uploadDataStream.once('readable', function() {\n    batch.job.open().then(function() {\n      // pipe upload data to batch API request stream\n      batch._uploadDataStream.pipe(batch._createRequestStream());\n    });\n  });\n\n  // duplex data stream, opened access to API programmers by Batch#stream()\n  var dataStream = this._dataStream = new Duplex();\n  dataStream._write = function(data, enc, cb) {\n    batch._uploadDataStream.write(data, enc, cb);\n  };\n  dataStream.on('finish', function() {\n    batch._uploadDataStream.end();\n  });\n\n  this._downloadDataStream.on('readable', function() {\n    dataStream.read(0);\n  });\n  this._downloadDataStream.on('end', function() {\n    dataStream.push(null);\n  });\n  dataStream._read = function(size) {\n    var chunk;\n    while ((chunk = batch._downloadDataStream.read()) !== null) {\n      dataStream.push(chunk);\n    }\n  };\n};\n\n/**\n * Connect batch API and create stream instance of request/response\n *\n * @private\n * @returns {stream.Duplex}\n */\nBatch.prototype._createRequestStream = function() {\n  var batch = this;\n  var bulk = batch._bulk;\n  var logger = bulk._logger;\n\n  return bulk._request({\n    method : 'POST',\n    path : \"/job/\" + batch.job.id + \"/batch\",\n    headers: {\n      \"Content-Type\": \"text/csv\"\n    },\n    responseType: \"application/xml\"\n  }, function(err, res) {\n    if (err) {\n      batch.emit('error', err);\n    } else {\n      logger.debug(res.batchInfo);\n      batch.id = res.batchInfo.id;\n      batch.emit('queue', res.batchInfo);\n    }\n  }).stream();\n};\n\n/**\n * Implementation of Writable\n *\n * @override\n * @private\n */\nBatch.prototype._write = function(record, enc, cb) {\n  record = _.clone(record);\n  if (this.job.operation === \"insert\") {\n    delete record.Id;\n  } else if (this.job.operation === \"delete\") {\n    record = { Id: record.Id };\n  }\n  delete record.type;\n  delete record.attributes;\n  this._uploadStream.write(record, enc, cb);\n};\n\n/**\n * Returns duplex stream which accepts CSV data input and batch result output\n *\n * @returns {stream.Duplex}\n */\nBatch.prototype.stream = function() {\n  return this._dataStream;\n};\n\n/**\n * Execute batch operation\n *\n * @method Bulk~Batch#execute\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for batch operation. Accepts array of records, CSV string, and CSV data input stream in insert/update/upsert/delete/hardDelete operation, SOQL string in query operation.\n * @param {Callback.<Array.<RecordResult>|Array.<BatchResultInfo>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nBatch.prototype.run =\nBatch.prototype.exec =\nBatch.prototype.execute = function(input, callback) {\n  var self = this;\n\n  if (typeof input === 'function') { // if input argument is omitted\n    callback = input;\n    input = null;\n  }\n\n  // if batch is already executed\n  if (this._result) {\n    throw new Error(\"Batch already executed.\");\n  }\n\n  var rdeferred = Promise.defer();\n  this._result = rdeferred.promise;\n  this._result.then(function(res) {\n    self._deferred.resolve(res);\n  }, function(err) {\n    self._deferred.reject(err);\n  });\n  this.once('response', function(res) {\n    rdeferred.resolve(res);\n  });\n  this.once('error', function(err) {\n    rdeferred.reject(err);\n  });\n\n  if (_.isObject(input) && _.isFunction(input.pipe)) { // if input has stream.Readable interface\n    input.pipe(this._dataStream);\n  } else {\n    var data;\n    if (_.isArray(input)) {\n      _.forEach(input, function(record) {\n        Object.keys(record).forEach(function(key) {\n          if (typeof record[key] === 'boolean') {\n            record[key] = String(record[key])\n          }\n        })\n        self.write(record);\n      });\n      self.end();\n    } else if (_.isString(input)){\n      data = input;\n      this._dataStream.write(data, 'utf8');\n      this._dataStream.end();\n    }\n  }\n\n  // return Batch instance for chaining\n  return this.thenCall(callback);\n};\n\n/**\n * Promise/A+ interface\n * http://promises-aplus.github.io/promises-spec/\n *\n * Delegate to deferred promise, return promise instance for batch result\n *\n * @method Bulk~Batch#then\n */\nBatch.prototype.then = function(onResolved, onReject, onProgress) {\n  return this._deferred.promise.then(onResolved, onReject, onProgress);\n};\n\n/**\n * Promise/A+ extension\n * Call \"then\" using given node-style callback function\n *\n * @method Bulk~Batch#thenCall\n */\nBatch.prototype.thenCall = function(callback) {\n  if (_.isFunction(callback)) {\n    this.then(function(res) {\n      process.nextTick(function() {\n        callback(null, res);\n      });\n    }, function(err) {\n      process.nextTick(function() {\n        callback(err);\n      });\n    });\n  }\n  return this;\n};\n\n/**\n * @typedef {Object} Bulk~BatchInfo\n * @prop {String} id - Batch ID\n * @prop {String} jobId - Job ID\n * @prop {String} state - Batch state\n * @prop {String} stateMessage - Batch state message\n */\n\n/**\n * Check the latest batch status in server\n *\n * @method Bulk~Batch#check\n * @param {Callback.<Bulk~BatchInfo>} [callback] - Callback function\n * @returns {Promise.<Bulk~BatchInfo>}\n */\nBatch.prototype.check = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var logger = bulk._logger;\n  var jobId = this.job.id;\n  var batchId = this.id;\n\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n  return bulk._request({\n    method : 'GET',\n    path : \"/job/\" + jobId + \"/batch/\" + batchId,\n    responseType: \"application/xml\"\n  }).then(function(res) {\n    logger.debug(res.batchInfo);\n    return res.batchInfo;\n  }).thenCall(callback);\n};\n\n\n/**\n * Polling the batch result and retrieve\n *\n * @method Bulk~Batch#poll\n * @param {Number} interval - Polling interval in milliseconds\n * @param {Number} timeout - Polling timeout in milliseconds\n */\nBatch.prototype.poll = function(interval, timeout) {\n  var self = this;\n  var jobId = this.job.id;\n  var batchId = this.id;\n\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n  var startTime = new Date().getTime();\n  var poll = function() {\n    var now = new Date().getTime();\n    if (startTime + timeout < now) {\n      var err = new Error(\"Polling time out. Job Id = \" + jobId + \" , batch Id = \" + batchId);\n      err.name = 'PollingTimeout';\n      err.jobId = jobId;\n      err.batchId = batchId;\n      self.emit('error', err);\n      return;\n    }\n    self.check(function(err, res) {\n      if (err) {\n        self.emit('error', err);\n      } else {\n        if (res.state === \"Failed\") {\n          if (parseInt(res.numberRecordsProcessed, 10) > 0) {\n            self.retrieve();\n          } else {\n            self.emit('error', new Error(res.stateMessage));\n          }\n        } else if (res.state === \"Completed\") {\n          self.retrieve();\n        } else {\n          self.emit('progress', res);\n          setTimeout(poll, interval);\n        }\n      }\n    });\n  };\n  setTimeout(poll, interval);\n};\n\n/**\n * @typedef {Object} Bulk~BatchResultInfo\n * @prop {String} id - Batch result ID\n * @prop {String} batchId - Batch ID which includes this batch result.\n * @prop {String} jobId - Job ID which includes this batch result.\n */\n\n/**\n * Retrieve batch result\n *\n * @method Bulk~Batch#retrieve\n * @param {Callback.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>}\n */\nBatch.prototype.retrieve = function(callback) {\n  var self = this;\n  var bulk = this._bulk;\n  var jobId = this.job.id;\n  var job = this.job;\n  var batchId = this.id;\n\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n\n  return job.info().then(function(jobInfo) {\n    return bulk._request({\n      method : 'GET',\n      path : \"/job/\" + jobId + \"/batch/\" + batchId + \"/result\"\n    });\n  }).then(function(res) {\n    var results;\n    if (job.operation === 'query') {\n      var conn = bulk._conn;\n      var resultIds = res['result-list'].result;\n      results = res['result-list'].result;\n      results = _.map(_.isArray(results) ? results : [ results ], function(id) {\n        return {\n          id: id,\n          batchId: batchId,\n          jobId: jobId\n        };\n      });\n    } else {\n      results = _.map(res, function(ret) {\n        return {\n          id: ret.Id || null,\n          success: ret.Success === \"true\",\n          errors: ret.Error ? [ ret.Error ] : []\n        };\n      });\n    }\n    self.emit('response', results);\n    return results;\n  }).fail(function(err) {\n    self.emit('error', err);\n    throw err;\n  }).thenCall(callback);\n};\n\n/**\n * Fetch query result as a record stream\n * @param {String} resultId - Result id\n * @returns {RecordStream} - Record stream, convertible to CSV data stream\n */\nBatch.prototype.result = function(resultId) {\n  var jobId = this.job.id;\n  var batchId = this.id;\n  if (!jobId || !batchId) {\n    throw new Error(\"Batch not started.\");\n  }\n  var resultStream = new RecordStream.Parsable();\n  var resultDataStream = resultStream.stream('csv');\n  var reqStream = this._bulk._request({\n    method : 'GET',\n    path : \"/job/\" + jobId + \"/batch/\" + batchId + \"/result/\" + resultId,\n    responseType: \"application/octet-stream\"\n  }).stream().pipe(resultDataStream);\n  return resultStream;\n};\n\n/*--------------------------------------------*/\n/**\n * @private\n */\nvar BulkApi = function() {\n  BulkApi.super_.apply(this, arguments);\n};\n\ninherits(BulkApi, HttpApi);\n\nBulkApi.prototype.beforeSend = function(request) {\n  request.headers = request.headers || {};\n  request.headers[\"X-SFDC-SESSION\"] = this._conn.accessToken;\n};\n\nBulkApi.prototype.isSessionExpired = function(response) {\n  return response.statusCode === 400 &&\n    /<exceptionCode>InvalidSessionId<\\/exceptionCode>/.test(response.body);\n};\n\nBulkApi.prototype.hasErrorInResponseBody = function(body) {\n  return !!body.error;\n};\n\nBulkApi.prototype.parseError = function(body) {\n  return {\n    errorCode: body.error.exceptionCode,\n    message: body.error.exceptionMessage\n  };\n};\n\n/*--------------------------------------------*/\n\n/**\n * Class for Bulk API\n *\n * @class\n * @param {Connection} conn - Connection object\n */\nvar Bulk = function(conn) {\n  this._conn = conn;\n  this._logger = conn._logger;\n};\n\n/**\n * Polling interval in milliseconds\n * @type {Number}\n */\nBulk.prototype.pollInterval = 1000;\n\n/**\n * Polling timeout in milliseconds\n * @type {Number}\n */\nBulk.prototype.pollTimeout = 10000;\n\n/** @private **/\nBulk.prototype._request = function(request, callback) {\n  var conn = this._conn;\n  request = _.clone(request);\n  var baseUrl = [ conn.instanceUrl, \"services/async\", conn.version ].join('/');\n  request.url = baseUrl + request.path;\n  var options = { responseType: request.responseType };\n  delete request.path;\n  delete request.responseType;\n  return new BulkApi(this._conn, options).request(request).thenCall(callback);\n};\n\n/**\n * Create and start bulkload job and batch\n *\n * @param {String} type - SObject type\n * @param {String} operation - Bulk load operation ('insert', 'update', 'upsert', 'delete', or 'hardDelete')\n * @param {Object} [options] - Options for bulk loading operation\n * @param {String} [options.extIdField] - External ID field name (used when upsert operation).\n * @param {String} [options.concurrencyMode] - 'Serial' or 'Parallel'. Defaults to Parallel.\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulkload. Accepts array of records, CSV string, and CSV data input stream in insert/update/upsert/delete/hardDelete operation, SOQL string in query operation.\n * @param {Callback.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nBulk.prototype.load = function(type, operation, options, input, callback) {\n  var self = this;\n  if (!type || !operation) {\n    throw new Error(\"Insufficient arguments. At least, 'type' and 'operation' are required.\");\n  }\n  if (!_.isObject(options) || options.constructor !== Object) { // when options is not plain hash object, it is omitted\n    callback = input;\n    input = options;\n    options = null;\n  }\n  var job = this.createJob(type, operation, options);\n  job.once('error', function (error) {\n    if (batch) {\n      batch.emit('error', error); // pass job error to batch\n    }\n  });\n  var batch = job.createBatch();\n  var cleanup = function() {\n    batch = null;\n    job.close();\n  };\n  var cleanupOnError = function(err) {\n    if (err.name !== 'PollingTimeout') {\n      cleanup();\n    }\n  };\n  batch.on('response', cleanup);\n  batch.on('error', cleanupOnError);\n  batch.on('queue', function() { batch.poll(self.pollInterval, self.pollTimeout); });\n  return batch.execute(input, callback);\n};\n\n/**\n * Execute bulk query and get record stream\n *\n * @param {String} soql - SOQL to execute in bulk job\n * @returns {RecordStream.Parsable} - Record stream, convertible to CSV data stream\n */\nBulk.prototype.query = function(soql) {\n  var m = soql.replace(/\\([\\s\\S]+\\)/g, '').match(/FROM\\s+(\\w+)/i);\n  if (!m) {\n    throw new Error(\"No sobject type found in query, maybe caused by invalid SOQL.\");\n  }\n  var type = m[1];\n  var self = this;\n  var recordStream = new RecordStream.Parsable();\n  var dataStream = recordStream.stream('csv');\n  this.load(type, \"query\", soql).then(function(results) {\n    var streams = results.map(function(result) {\n      return self\n        .job(result.jobId)\n        .batch(result.batchId)\n        .result(result.id)\n        .stream();\n    });\n\n    joinStreams(streams).pipe(dataStream);\n  }).fail(function(err) {\n    recordStream.emit('error', err);\n  });\n  return recordStream;\n};\n\n\n/**\n * Create a new job instance\n *\n * @param {String} type - SObject type\n * @param {String} operation - Bulk load operation ('insert', 'update', 'upsert', 'delete', 'hardDelete', or 'query')\n * @param {Object} [options] - Options for bulk loading operation\n * @returns {Bulk~Job}\n */\nBulk.prototype.createJob = function(type, operation, options) {\n  return new Job(this, type, operation, options);\n};\n\n/**\n * Get a job instance specified by given job ID\n *\n * @param {String} jobId - Job ID\n * @returns {Bulk~Job}\n */\nBulk.prototype.job = function(jobId) {\n  return new Job(this, null, null, null, jobId);\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.bulk = new Bulk(conn);\n});\n\n\nmodule.exports = Bulk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL2J1bGsuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQywyREFBVTtBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyw4RkFBaUI7QUFDNUM7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyx3REFBYTtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQyw4REFBYTtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQyx5REFBUztBQUNwQyxtQkFBbUIsbUJBQU8sQ0FBQywyRUFBa0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsK0RBQVk7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsaUVBQWE7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFDQUFxQztBQUNoRCxXQUFXLHlEQUF5RDtBQUNwRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUgsdURBQXVEO0FBQ3ZEO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOERBQThEO0FBQ3pFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUNBQXFDO0FBQ2hELFdBQVcsOERBQThEO0FBQ3pFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtEQUFrRDtBQUNuRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2FwaS9idWxrLmpzPzUzMTAiXSwic291cmNlc0NvbnRlbnQiOlsiLypnbG9iYWwgcHJvY2VzcyovXG4vKipcbiAqIEBmaWxlIE1hbmFnZXMgU2FsZXNmb3JjZSBCdWxrIEFQSSByZWxhdGVkIG9wZXJhdGlvbnNcbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzICAgICA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgc3RyZWFtICAgICAgID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJyksXG4gICAgRHVwbGV4ICAgICAgID0gc3RyZWFtLkR1cGxleCxcbiAgICBldmVudHMgICAgICAgPSByZXF1aXJlKCdldmVudHMnKSxcbiAgICBfICAgICAgICAgICAgPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpLFxuICAgIGpvaW5TdHJlYW1zICA9IHJlcXVpcmUoJ211bHRpc3RyZWFtJyksXG4gICAganNmb3JjZSAgICAgID0gcmVxdWlyZSgnLi4vY29yZScpLFxuICAgIFJlY29yZFN0cmVhbSA9IHJlcXVpcmUoJy4uL3JlY29yZC1zdHJlYW0nKSxcbiAgICBQcm9taXNlICAgICAgPSByZXF1aXJlKCcuLi9wcm9taXNlJyksXG4gICAgSHR0cEFwaSAgICAgID0gcmVxdWlyZSgnLi4vaHR0cC1hcGknKTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKlxuICogQ2xhc3MgZm9yIEJ1bGsgQVBJIEpvYlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBjbGFzcyBCdWxrfkpvYlxuICogQGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlclxuICpcbiAqIEBwYXJhbSB7QnVsa30gYnVsayAtIEJ1bGsgQVBJIG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAtIFNPYmplY3QgdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcGVyYXRpb25dIC0gQnVsayBsb2FkIG9wZXJhdGlvbiAoJ2luc2VydCcsICd1cGRhdGUnLCAndXBzZXJ0JywgJ2RlbGV0ZScsIG9yICdoYXJkRGVsZXRlJylcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciBidWxrIGxvYWRpbmcgb3BlcmF0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZXh0SWRGaWVsZF0gLSBFeHRlcm5hbCBJRCBmaWVsZCBuYW1lICh1c2VkIHdoZW4gdXBzZXJ0IG9wZXJhdGlvbikuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY29uY3VycmVuY3lNb2RlXSAtICdTZXJpYWwnIG9yICdQYXJhbGxlbCcuIERlZmF1bHRzIHRvIFBhcmFsbGVsLlxuICogQHBhcmFtIHtTdHJpbmd9IFtqb2JJZF0gLSBKb2IgSUQgKGlmIGFscmVhZHkgYXZhaWxhYmxlKVxuICovXG52YXIgSm9iID0gZnVuY3Rpb24oYnVsaywgdHlwZSwgb3BlcmF0aW9uLCBvcHRpb25zLCBqb2JJZCkge1xuICB0aGlzLl9idWxrID0gYnVsaztcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuaWQgPSBqb2JJZDtcbiAgdGhpcy5zdGF0ZSA9IHRoaXMuaWQgPyAnT3BlbicgOiAnVW5rbm93bic7XG4gIHRoaXMuX2JhdGNoZXMgPSB7fTtcbn07XG5cbmluaGVyaXRzKEpvYiwgZXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQnVsa35Kb2JJbmZvXG4gKiBAcHJvcCB7U3RyaW5nfSBpZCAtIEpvYiBJRFxuICogQHByb3Age1N0cmluZ30gb2JqZWN0IC0gT2JqZWN0IHR5cGUgbmFtZVxuICogQHByb3Age1N0cmluZ30gb3BlcmF0aW9uIC0gT3BlcmF0aW9uIHR5cGUgb2YgdGhlIGpvYlxuICogQHByb3Age1N0cmluZ30gc3RhdGUgLSBKb2Igc3RhdHVzXG4gKi9cblxuLyoqXG4gKiBSZXR1cm4gbGF0ZXN0IGpvYkluZm8gZnJvbSBjYWNoZVxuICpcbiAqIEBtZXRob2QgQnVsa35Kb2IjaW5mb1xuICogQHBhcmFtIHtDYWxsYmFjay48QnVsa35Kb2JJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QnVsa35Kb2JJbmZvPn1cbiAqL1xuSm9iLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBpZiBjYWNoZSBpcyBub3QgYXZhaWxhYmxlLCBjaGVjayB0aGUgbGF0ZXN0XG4gIGlmICghdGhpcy5fam9iSW5mbykge1xuICAgIHRoaXMuX2pvYkluZm8gPSB0aGlzLmNoZWNrKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2pvYkluZm8udGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBPcGVuIG5ldyBqb2IgYW5kIGdldCBqb2JpbmZvXG4gKlxuICogQG1ldGhvZCBCdWxrfkpvYiNvcGVuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxCdWxrfkpvYkluZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxCdWxrfkpvYkluZm8+fVxuICovXG5Kb2IucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBidWxrID0gdGhpcy5fYnVsaztcbiAgdmFyIGxvZ2dlciA9IGJ1bGsuX2xvZ2dlcjtcblxuICAvLyBpZiBub3QgcmVxdWVzdGVkIG9wZW5pbmcgam9iXG4gIGlmICghdGhpcy5fam9iSW5mbykge1xuICAgIHZhciBvcGVyYXRpb24gPSB0aGlzLm9wZXJhdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChvcGVyYXRpb24gPT09ICdoYXJkZGVsZXRlJykgeyBvcGVyYXRpb24gPSAnaGFyZERlbGV0ZSc7IH1cbiAgICB2YXIgYm9keSA9IFtcbiAgICAgICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiPz4nLFxuICAgICAgJzxqb2JJbmZvICB4bWxucz1cImh0dHA6Ly93d3cuZm9yY2UuY29tLzIwMDkvMDYvYXN5bmNhcGkvZGF0YWxvYWRcIj4nLFxuICAgICAgICAnPG9wZXJhdGlvbj4nICsgb3BlcmF0aW9uICsgJzwvb3BlcmF0aW9uPicsXG4gICAgICAgICc8b2JqZWN0PicgKyB0aGlzLnR5cGUgKyAnPC9vYmplY3Q+JyxcbiAgICAgICAgKHRoaXMub3B0aW9ucy5leHRJZEZpZWxkID9cbiAgICAgICAgICc8ZXh0ZXJuYWxJZEZpZWxkTmFtZT4nK3RoaXMub3B0aW9ucy5leHRJZEZpZWxkKyc8L2V4dGVybmFsSWRGaWVsZE5hbWU+JyA6XG4gICAgICAgICAnJyksXG4gICAgICAgICh0aGlzLm9wdGlvbnMuY29uY3VycmVuY3lNb2RlID9cbiAgICAgICAgICc8Y29uY3VycmVuY3lNb2RlPicrdGhpcy5vcHRpb25zLmNvbmN1cnJlbmN5TW9kZSsnPC9jb25jdXJyZW5jeU1vZGU+JyA6XG4gICAgICAgICAnJyksXG4gICAgICAgICh0aGlzLm9wdGlvbnMuYXNzaWdubWVudFJ1bGVJZCA/XG4gICAgICAgICAgJzxhc3NpZ25tZW50UnVsZUlkPicgKyB0aGlzLm9wdGlvbnMuYXNzaWdubWVudFJ1bGVJZCArICc8L2Fzc2lnbm1lbnRSdWxlSWQ+JyA6XG4gICAgICAgICAgJycpLFxuICAgICAgICAnPGNvbnRlbnRUeXBlPkNTVjwvY29udGVudFR5cGU+JyxcbiAgICAgICc8L2pvYkluZm8+J1xuICAgIF0uam9pbignJyk7XG5cbiAgICB0aGlzLl9qb2JJbmZvID0gYnVsay5fcmVxdWVzdCh7XG4gICAgICBtZXRob2QgOiAnUE9TVCcsXG4gICAgICBwYXRoIDogXCIvam9iXCIsXG4gICAgICBib2R5IDogYm9keSxcbiAgICAgIGhlYWRlcnMgOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCIgOiBcImFwcGxpY2F0aW9uL3htbDsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VUeXBlOiBcImFwcGxpY2F0aW9uL3htbFwiXG4gICAgfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgIHNlbGYuZW1pdChcIm9wZW5cIiwgcmVzLmpvYkluZm8pO1xuICAgICAgc2VsZi5pZCA9IHJlcy5qb2JJbmZvLmlkO1xuICAgICAgc2VsZi5zdGF0ZSA9IHJlcy5qb2JJbmZvLnN0YXRlO1xuICAgICAgcmV0dXJuIHJlcy5qb2JJbmZvO1xuICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcy5fam9iSW5mby50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBiYXRjaCBpbnN0YW5jZSBpbiB0aGUgam9iXG4gKlxuICogQG1ldGhvZCBCdWxrfkpvYiNjcmVhdGVCYXRjaFxuICogQHJldHVybnMge0J1bGt+QmF0Y2h9XG4gKi9cbkpvYi5wcm90b3R5cGUuY3JlYXRlQmF0Y2ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJhdGNoID0gbmV3IEJhdGNoKHRoaXMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGJhdGNoLm9uKCdxdWV1ZScsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2JhdGNoZXNbYmF0Y2guaWRdID0gYmF0Y2g7XG4gIH0pO1xuICByZXR1cm4gYmF0Y2g7XG59O1xuXG4vKipcbiAqIEdldCBhIGJhdGNoIGluc3RhbmNlIHNwZWNpZmllZCBieSBnaXZlbiBiYXRjaCBJRFxuICpcbiAqIEBtZXRob2QgQnVsa35Kb2IjYmF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXRjaElkIC0gQmF0Y2ggSURcbiAqIEByZXR1cm5zIHtCdWxrfkJhdGNofVxuICovXG5Kb2IucHJvdG90eXBlLmJhdGNoID0gZnVuY3Rpb24oYmF0Y2hJZCkge1xuICB2YXIgYmF0Y2ggPSB0aGlzLl9iYXRjaGVzW2JhdGNoSWRdO1xuICBpZiAoIWJhdGNoKSB7XG4gICAgYmF0Y2ggPSBuZXcgQmF0Y2godGhpcywgYmF0Y2hJZCk7XG4gICAgdGhpcy5fYmF0Y2hlc1tiYXRjaElkXSA9IGJhdGNoO1xuICB9XG4gIHJldHVybiBiYXRjaDtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIGxhdGVzdCBqb2Igc3RhdHVzIGZyb20gc2VydmVyXG4gKlxuICogQG1ldGhvZCBCdWxrfkpvYiNjaGVja1xuICogQHBhcmFtIHtDYWxsYmFjay48QnVsa35Kb2JJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QnVsa35Kb2JJbmZvPn1cbiAqL1xuSm9iLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGJ1bGsgPSB0aGlzLl9idWxrO1xuICB2YXIgbG9nZ2VyID0gYnVsay5fbG9nZ2VyO1xuXG4gIHRoaXMuX2pvYkluZm8gPSB0aGlzLl93YWl0QXNzaWduKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYnVsay5fcmVxdWVzdCh7XG4gICAgICBtZXRob2QgOiAnR0VUJyxcbiAgICAgIHBhdGggOiBcIi9qb2IvXCIgKyBzZWxmLmlkLFxuICAgICAgcmVzcG9uc2VUeXBlOiBcImFwcGxpY2F0aW9uL3htbFwiXG4gICAgfSk7XG4gIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgbG9nZ2VyLmRlYnVnKHJlcy5qb2JJbmZvKTtcbiAgICBzZWxmLmlkID0gcmVzLmpvYkluZm8uaWQ7XG4gICAgc2VsZi50eXBlID0gcmVzLmpvYkluZm8ub2JqZWN0O1xuICAgIHNlbGYub3BlcmF0aW9uID0gcmVzLmpvYkluZm8ub3BlcmF0aW9uO1xuICAgIHNlbGYuc3RhdGUgPSByZXMuam9iSW5mby5zdGF0ZTtcbiAgICByZXR1cm4gcmVzLmpvYkluZm87XG4gIH0pO1xuICByZXR1cm4gdGhpcy5fam9iSW5mby50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFdhaXQgdGlsbCB0aGUgam9iIGlzIGFzc2lnbmVkIHRvIHNlcnZlclxuICpcbiAqIEBtZXRob2QgQnVsa35Kb2IjaW5mb1xuICogQHBhcmFtIHtDYWxsYmFjay48QnVsa35Kb2JJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QnVsa35Kb2JJbmZvPn1cbiAqL1xuSm9iLnByb3RvdHlwZS5fd2FpdEFzc2lnbiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiAodGhpcy5pZCA/IFByb21pc2UucmVzb2x2ZSh7IGlkOiB0aGlzLmlkIH0pIDogdGhpcy5vcGVuKCkpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cblxuLyoqXG4gKiBMaXN0IGFsbCByZWdpc3RlcmVkIGJhdGNoIGluZm8gaW4gam9iXG4gKlxuICogQG1ldGhvZCBCdWxrfkpvYiNsaXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48QnVsa35CYXRjaEluZm8+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXkuPEJ1bGt+QmF0Y2hJbmZvPj59XG4gKi9cbkpvYi5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGJ1bGsgPSB0aGlzLl9idWxrO1xuICB2YXIgbG9nZ2VyID0gYnVsay5fbG9nZ2VyO1xuXG4gIHJldHVybiB0aGlzLl93YWl0QXNzaWduKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYnVsay5fcmVxdWVzdCh7XG4gICAgICBtZXRob2QgOiAnR0VUJyxcbiAgICAgIHBhdGggOiBcIi9qb2IvXCIgKyBzZWxmLmlkICsgXCIvYmF0Y2hcIixcbiAgICAgIHJlc3BvbnNlVHlwZTogXCJhcHBsaWNhdGlvbi94bWxcIlxuICAgIH0pO1xuICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgIGxvZ2dlci5kZWJ1ZyhyZXMuYmF0Y2hJbmZvTGlzdC5iYXRjaEluZm8pO1xuICAgIHZhciBiYXRjaEluZm9MaXN0ID0gcmVzLmJhdGNoSW5mb0xpc3Q7XG4gICAgYmF0Y2hJbmZvTGlzdCA9IF8uaXNBcnJheShiYXRjaEluZm9MaXN0LmJhdGNoSW5mbykgPyBiYXRjaEluZm9MaXN0LmJhdGNoSW5mbyA6IFsgYmF0Y2hJbmZvTGlzdC5iYXRjaEluZm8gXTtcbiAgICByZXR1cm4gYmF0Y2hJbmZvTGlzdDtcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xuXG59O1xuXG4vKipcbiAqIENsb3NlIG9wZW5lZCBqb2JcbiAqXG4gKiBAbWV0aG9kIEJ1bGt+Sm9iI2Nsb3NlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxCdWxrfkpvYkluZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxCdWxrfkpvYkluZm8+fVxuICovXG5Kb2IucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuX2NoYW5nZVN0YXRlKFwiQ2xvc2VkXCIpLnRoZW4oZnVuY3Rpb24oam9iSW5mbykge1xuICAgIHNlbGYuaWQgPSBudWxsO1xuICAgIHNlbGYuZW1pdChcImNsb3NlXCIsIGpvYkluZm8pO1xuICAgIHJldHVybiBqb2JJbmZvO1xuICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgIHRocm93IGVycjtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3RhdHVzIHRvIGFib3J0XG4gKlxuICogQG1ldGhvZCBCdWxrfkpvYiNhYm9ydFxuICogQHBhcmFtIHtDYWxsYmFjay48QnVsa35Kb2JJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QnVsa35Kb2JJbmZvPn1cbiAqL1xuSm9iLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLl9jaGFuZ2VTdGF0ZShcIkFib3J0ZWRcIikudGhlbihmdW5jdGlvbihqb2JJbmZvKSB7XG4gICAgc2VsZi5pZCA9IG51bGw7XG4gICAgc2VsZi5lbWl0KFwiYWJvcnRcIiwgam9iSW5mbyk7XG4gICAgcmV0dXJuIGpvYkluZm87XG4gIH0sIGZ1bmN0aW9uKGVycikge1xuICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgdGhyb3cgZXJyO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuSm9iLnByb3RvdHlwZS5fY2hhbmdlU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYnVsayA9IHRoaXMuX2J1bGs7XG4gIHZhciBsb2dnZXIgPSBidWxrLl9sb2dnZXI7XG5cbiAgdGhpcy5fam9iSW5mbyA9IHRoaXMuX3dhaXRBc3NpZ24oKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIHZhciBib2R5ID0gW1xuICAgICAgJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCI/PicsXG4gICAgICAnPGpvYkluZm8geG1sbnM9XCJodHRwOi8vd3d3LmZvcmNlLmNvbS8yMDA5LzA2L2FzeW5jYXBpL2RhdGFsb2FkXCI+JyxcbiAgICAgICAgJzxzdGF0ZT4nICsgc3RhdGUgKyAnPC9zdGF0ZT4nLFxuICAgICAgJzwvam9iSW5mbz4nXG4gICAgXS5qb2luKCcnKTtcbiAgICByZXR1cm4gYnVsay5fcmVxdWVzdCh7XG4gICAgICBtZXRob2QgOiAnUE9TVCcsXG4gICAgICBwYXRoIDogXCIvam9iL1wiICsgc2VsZi5pZCxcbiAgICAgIGJvZHkgOiBib2R5LFxuICAgICAgaGVhZGVycyA6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIiA6IFwiYXBwbGljYXRpb24veG1sOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0sXG4gICAgICByZXNwb25zZVR5cGU6IFwiYXBwbGljYXRpb24veG1sXCJcbiAgICB9KTtcbiAgfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICBsb2dnZXIuZGVidWcocmVzLmpvYkluZm8pO1xuICAgIHNlbGYuc3RhdGUgPSByZXMuam9iSW5mby5zdGF0ZTtcbiAgICByZXR1cm4gcmVzLmpvYkluZm87XG4gIH0pO1xuICByZXR1cm4gdGhpcy5fam9iSW5mby50aGVuQ2FsbChjYWxsYmFjayk7XG5cbn07XG5cblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKlxuICogQmF0Y2ggKGV4dGVuZHMgUmVjb3JkU3RyZWFtKVxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBjbGFzcyBCdWxrfkJhdGNoXG4gKiBAZXh0ZW5kcyB7c3RyZWFtLldyaXRhYmxlfVxuICogQGltcGxlbWVudHMge1Byb21pc2UuPEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqIEBwYXJhbSB7QnVsa35Kb2J9IGpvYiAtIEJ1bGsgam9iIG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IFtiYXRjaElkXSAtIEJhdGNoIElEIChpZiBhbHJlYWR5IGF2YWlsYWJsZSlcbiAqL1xudmFyIEJhdGNoID0gZnVuY3Rpb24oam9iLCBiYXRjaElkKSB7XG4gIEJhdGNoLnN1cGVyXy5jYWxsKHRoaXMsIHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgdGhpcy5qb2IgPSBqb2I7XG4gIHRoaXMuaWQgPSBiYXRjaElkO1xuICB0aGlzLl9idWxrID0gam9iLl9idWxrO1xuICB0aGlzLl9kZWZlcnJlZCA9IFByb21pc2UuZGVmZXIoKTtcbiAgdGhpcy5fc2V0dXBEYXRhU3RyZWFtcygpO1xufTtcblxuaW5oZXJpdHMoQmF0Y2gsIHN0cmVhbS5Xcml0YWJsZSk7XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5CYXRjaC5wcm90b3R5cGUuX3NldHVwRGF0YVN0cmVhbXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJhdGNoID0gdGhpcztcbiAgdmFyIGNvbnZlcnRlck9wdGlvbnMgPSB7IG51bGxWYWx1ZSA6ICcjTi9BJyB9O1xuICB0aGlzLl91cGxvYWRTdHJlYW0gPSBuZXcgUmVjb3JkU3RyZWFtLlNlcmlhbGl6YWJsZSgpO1xuICB0aGlzLl91cGxvYWREYXRhU3RyZWFtID0gdGhpcy5fdXBsb2FkU3RyZWFtLnN0cmVhbSgnY3N2JywgY29udmVydGVyT3B0aW9ucyk7XG4gIHRoaXMuX2Rvd25sb2FkU3RyZWFtID0gbmV3IFJlY29yZFN0cmVhbS5QYXJzYWJsZSgpO1xuICB0aGlzLl9kb3dubG9hZERhdGFTdHJlYW0gPSB0aGlzLl9kb3dubG9hZFN0cmVhbS5zdHJlYW0oJ2NzdicsIGNvbnZlcnRlck9wdGlvbnMpO1xuXG4gIHRoaXMub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgIGJhdGNoLl91cGxvYWRTdHJlYW0uZW5kKCk7XG4gIH0pO1xuICB0aGlzLl91cGxvYWREYXRhU3RyZWFtLm9uY2UoJ3JlYWRhYmxlJywgZnVuY3Rpb24oKSB7XG4gICAgYmF0Y2guam9iLm9wZW4oKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gcGlwZSB1cGxvYWQgZGF0YSB0byBiYXRjaCBBUEkgcmVxdWVzdCBzdHJlYW1cbiAgICAgIGJhdGNoLl91cGxvYWREYXRhU3RyZWFtLnBpcGUoYmF0Y2guX2NyZWF0ZVJlcXVlc3RTdHJlYW0oKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGR1cGxleCBkYXRhIHN0cmVhbSwgb3BlbmVkIGFjY2VzcyB0byBBUEkgcHJvZ3JhbW1lcnMgYnkgQmF0Y2gjc3RyZWFtKClcbiAgdmFyIGRhdGFTdHJlYW0gPSB0aGlzLl9kYXRhU3RyZWFtID0gbmV3IER1cGxleCgpO1xuICBkYXRhU3RyZWFtLl93cml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGVuYywgY2IpIHtcbiAgICBiYXRjaC5fdXBsb2FkRGF0YVN0cmVhbS53cml0ZShkYXRhLCBlbmMsIGNiKTtcbiAgfTtcbiAgZGF0YVN0cmVhbS5vbignZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgYmF0Y2guX3VwbG9hZERhdGFTdHJlYW0uZW5kKCk7XG4gIH0pO1xuXG4gIHRoaXMuX2Rvd25sb2FkRGF0YVN0cmVhbS5vbigncmVhZGFibGUnLCBmdW5jdGlvbigpIHtcbiAgICBkYXRhU3RyZWFtLnJlYWQoMCk7XG4gIH0pO1xuICB0aGlzLl9kb3dubG9hZERhdGFTdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIGRhdGFTdHJlYW0ucHVzaChudWxsKTtcbiAgfSk7XG4gIGRhdGFTdHJlYW0uX3JlYWQgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdmFyIGNodW5rO1xuICAgIHdoaWxlICgoY2h1bmsgPSBiYXRjaC5fZG93bmxvYWREYXRhU3RyZWFtLnJlYWQoKSkgIT09IG51bGwpIHtcbiAgICAgIGRhdGFTdHJlYW0ucHVzaChjaHVuayk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBDb25uZWN0IGJhdGNoIEFQSSBhbmQgY3JlYXRlIHN0cmVhbSBpbnN0YW5jZSBvZiByZXF1ZXN0L3Jlc3BvbnNlXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm5zIHtzdHJlYW0uRHVwbGV4fVxuICovXG5CYXRjaC5wcm90b3R5cGUuX2NyZWF0ZVJlcXVlc3RTdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJhdGNoID0gdGhpcztcbiAgdmFyIGJ1bGsgPSBiYXRjaC5fYnVsaztcbiAgdmFyIGxvZ2dlciA9IGJ1bGsuX2xvZ2dlcjtcblxuICByZXR1cm4gYnVsay5fcmVxdWVzdCh7XG4gICAgbWV0aG9kIDogJ1BPU1QnLFxuICAgIHBhdGggOiBcIi9qb2IvXCIgKyBiYXRjaC5qb2IuaWQgKyBcIi9iYXRjaFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9jc3ZcIlxuICAgIH0sXG4gICAgcmVzcG9uc2VUeXBlOiBcImFwcGxpY2F0aW9uL3htbFwiXG4gIH0sIGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgYmF0Y2guZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcocmVzLmJhdGNoSW5mbyk7XG4gICAgICBiYXRjaC5pZCA9IHJlcy5iYXRjaEluZm8uaWQ7XG4gICAgICBiYXRjaC5lbWl0KCdxdWV1ZScsIHJlcy5iYXRjaEluZm8pO1xuICAgIH1cbiAgfSkuc3RyZWFtKCk7XG59O1xuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIFdyaXRhYmxlXG4gKlxuICogQG92ZXJyaWRlXG4gKiBAcHJpdmF0ZVxuICovXG5CYXRjaC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24ocmVjb3JkLCBlbmMsIGNiKSB7XG4gIHJlY29yZCA9IF8uY2xvbmUocmVjb3JkKTtcbiAgaWYgKHRoaXMuam9iLm9wZXJhdGlvbiA9PT0gXCJpbnNlcnRcIikge1xuICAgIGRlbGV0ZSByZWNvcmQuSWQ7XG4gIH0gZWxzZSBpZiAodGhpcy5qb2Iub3BlcmF0aW9uID09PSBcImRlbGV0ZVwiKSB7XG4gICAgcmVjb3JkID0geyBJZDogcmVjb3JkLklkIH07XG4gIH1cbiAgZGVsZXRlIHJlY29yZC50eXBlO1xuICBkZWxldGUgcmVjb3JkLmF0dHJpYnV0ZXM7XG4gIHRoaXMuX3VwbG9hZFN0cmVhbS53cml0ZShyZWNvcmQsIGVuYywgY2IpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGR1cGxleCBzdHJlYW0gd2hpY2ggYWNjZXB0cyBDU1YgZGF0YSBpbnB1dCBhbmQgYmF0Y2ggcmVzdWx0IG91dHB1dFxuICpcbiAqIEByZXR1cm5zIHtzdHJlYW0uRHVwbGV4fVxuICovXG5CYXRjaC5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9kYXRhU3RyZWFtO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGJhdGNoIG9wZXJhdGlvblxuICpcbiAqIEBtZXRob2QgQnVsa35CYXRjaCNleGVjdXRlXG4gKiBAcGFyYW0ge0FycmF5LjxSZWNvcmQ+fHN0cmVhbS5TdHJlYW18U3RyaW5nfSBbaW5wdXRdIC0gSW5wdXQgc291cmNlIGZvciBiYXRjaCBvcGVyYXRpb24uIEFjY2VwdHMgYXJyYXkgb2YgcmVjb3JkcywgQ1NWIHN0cmluZywgYW5kIENTViBkYXRhIGlucHV0IHN0cmVhbSBpbiBpbnNlcnQvdXBkYXRlL3Vwc2VydC9kZWxldGUvaGFyZERlbGV0ZSBvcGVyYXRpb24sIFNPUUwgc3RyaW5nIGluIHF1ZXJ5IG9wZXJhdGlvbi5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxSZWNvcmRSZXN1bHQ+fEFycmF5LjxCYXRjaFJlc3VsdEluZm8+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVsa35CYXRjaH1cbiAqL1xuQmF0Y2gucHJvdG90eXBlLnJ1biA9XG5CYXRjaC5wcm90b3R5cGUuZXhlYyA9XG5CYXRjaC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGlucHV0LCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBpZiBpbnB1dCBhcmd1bWVudCBpcyBvbWl0dGVkXG4gICAgY2FsbGJhY2sgPSBpbnB1dDtcbiAgICBpbnB1dCA9IG51bGw7XG4gIH1cblxuICAvLyBpZiBiYXRjaCBpcyBhbHJlYWR5IGV4ZWN1dGVkXG4gIGlmICh0aGlzLl9yZXN1bHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaCBhbHJlYWR5IGV4ZWN1dGVkLlwiKTtcbiAgfVxuXG4gIHZhciByZGVmZXJyZWQgPSBQcm9taXNlLmRlZmVyKCk7XG4gIHRoaXMuX3Jlc3VsdCA9IHJkZWZlcnJlZC5wcm9taXNlO1xuICB0aGlzLl9yZXN1bHQudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICBzZWxmLl9kZWZlcnJlZC5yZXNvbHZlKHJlcyk7XG4gIH0sIGZ1bmN0aW9uKGVycikge1xuICAgIHNlbGYuX2RlZmVycmVkLnJlamVjdChlcnIpO1xuICB9KTtcbiAgdGhpcy5vbmNlKCdyZXNwb25zZScsIGZ1bmN0aW9uKHJlcykge1xuICAgIHJkZWZlcnJlZC5yZXNvbHZlKHJlcyk7XG4gIH0pO1xuICB0aGlzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgcmRlZmVycmVkLnJlamVjdChlcnIpO1xuICB9KTtcblxuICBpZiAoXy5pc09iamVjdChpbnB1dCkgJiYgXy5pc0Z1bmN0aW9uKGlucHV0LnBpcGUpKSB7IC8vIGlmIGlucHV0IGhhcyBzdHJlYW0uUmVhZGFibGUgaW50ZXJmYWNlXG4gICAgaW5wdXQucGlwZSh0aGlzLl9kYXRhU3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGF0YTtcbiAgICBpZiAoXy5pc0FycmF5KGlucHV0KSkge1xuICAgICAgXy5mb3JFYWNoKGlucHV0LCBmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocmVjb3JkKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVjb3JkW2tleV0gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmVjb3JkW2tleV0gPSBTdHJpbmcocmVjb3JkW2tleV0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBzZWxmLndyaXRlKHJlY29yZCk7XG4gICAgICB9KTtcbiAgICAgIHNlbGYuZW5kKCk7XG4gICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGlucHV0KSl7XG4gICAgICBkYXRhID0gaW5wdXQ7XG4gICAgICB0aGlzLl9kYXRhU3RyZWFtLndyaXRlKGRhdGEsICd1dGY4Jyk7XG4gICAgICB0aGlzLl9kYXRhU3RyZWFtLmVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJldHVybiBCYXRjaCBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgcmV0dXJuIHRoaXMudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBQcm9taXNlL0ErIGludGVyZmFjZVxuICogaHR0cDovL3Byb21pc2VzLWFwbHVzLmdpdGh1Yi5pby9wcm9taXNlcy1zcGVjL1xuICpcbiAqIERlbGVnYXRlIHRvIGRlZmVycmVkIHByb21pc2UsIHJldHVybiBwcm9taXNlIGluc3RhbmNlIGZvciBiYXRjaCByZXN1bHRcbiAqXG4gKiBAbWV0aG9kIEJ1bGt+QmF0Y2gjdGhlblxuICovXG5CYXRjaC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uUmVzb2x2ZWQsIG9uUmVqZWN0LCBvblByb2dyZXNzKSB7XG4gIHJldHVybiB0aGlzLl9kZWZlcnJlZC5wcm9taXNlLnRoZW4ob25SZXNvbHZlZCwgb25SZWplY3QsIG9uUHJvZ3Jlc3MpO1xufTtcblxuLyoqXG4gKiBQcm9taXNlL0ErIGV4dGVuc2lvblxuICogQ2FsbCBcInRoZW5cIiB1c2luZyBnaXZlbiBub2RlLXN0eWxlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCBCdWxrfkJhdGNoI3RoZW5DYWxsXG4gKi9cbkJhdGNoLnByb3RvdHlwZS50aGVuQ2FsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIGlmIChfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgdGhpcy50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCdWxrfkJhdGNoSW5mb1xuICogQHByb3Age1N0cmluZ30gaWQgLSBCYXRjaCBJRFxuICogQHByb3Age1N0cmluZ30gam9iSWQgLSBKb2IgSURcbiAqIEBwcm9wIHtTdHJpbmd9IHN0YXRlIC0gQmF0Y2ggc3RhdGVcbiAqIEBwcm9wIHtTdHJpbmd9IHN0YXRlTWVzc2FnZSAtIEJhdGNoIHN0YXRlIG1lc3NhZ2VcbiAqL1xuXG4vKipcbiAqIENoZWNrIHRoZSBsYXRlc3QgYmF0Y2ggc3RhdHVzIGluIHNlcnZlclxuICpcbiAqIEBtZXRob2QgQnVsa35CYXRjaCNjaGVja1xuICogQHBhcmFtIHtDYWxsYmFjay48QnVsa35CYXRjaEluZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxCdWxrfkJhdGNoSW5mbz59XG4gKi9cbkJhdGNoLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGJ1bGsgPSB0aGlzLl9idWxrO1xuICB2YXIgbG9nZ2VyID0gYnVsay5fbG9nZ2VyO1xuICB2YXIgam9iSWQgPSB0aGlzLmpvYi5pZDtcbiAgdmFyIGJhdGNoSWQgPSB0aGlzLmlkO1xuXG4gIGlmICgham9iSWQgfHwgIWJhdGNoSWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaCBub3Qgc3RhcnRlZC5cIik7XG4gIH1cbiAgcmV0dXJuIGJ1bGsuX3JlcXVlc3Qoe1xuICAgIG1ldGhvZCA6ICdHRVQnLFxuICAgIHBhdGggOiBcIi9qb2IvXCIgKyBqb2JJZCArIFwiL2JhdGNoL1wiICsgYmF0Y2hJZCxcbiAgICByZXNwb25zZVR5cGU6IFwiYXBwbGljYXRpb24veG1sXCJcbiAgfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICBsb2dnZXIuZGVidWcocmVzLmJhdGNoSW5mbyk7XG4gICAgcmV0dXJuIHJlcy5iYXRjaEluZm87XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cblxuLyoqXG4gKiBQb2xsaW5nIHRoZSBiYXRjaCByZXN1bHQgYW5kIHJldHJpZXZlXG4gKlxuICogQG1ldGhvZCBCdWxrfkJhdGNoI3BvbGxcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbCAtIFBvbGxpbmcgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCAtIFBvbGxpbmcgdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAqL1xuQmF0Y2gucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbihpbnRlcnZhbCwgdGltZW91dCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBqb2JJZCA9IHRoaXMuam9iLmlkO1xuICB2YXIgYmF0Y2hJZCA9IHRoaXMuaWQ7XG5cbiAgaWYgKCFqb2JJZCB8fCAhYmF0Y2hJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJhdGNoIG5vdCBzdGFydGVkLlwiKTtcbiAgfVxuICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIHZhciBwb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGlmIChzdGFydFRpbWUgKyB0aW1lb3V0IDwgbm93KSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFwiUG9sbGluZyB0aW1lIG91dC4gSm9iIElkID0gXCIgKyBqb2JJZCArIFwiICwgYmF0Y2ggSWQgPSBcIiArIGJhdGNoSWQpO1xuICAgICAgZXJyLm5hbWUgPSAnUG9sbGluZ1RpbWVvdXQnO1xuICAgICAgZXJyLmpvYklkID0gam9iSWQ7XG4gICAgICBlcnIuYmF0Y2hJZCA9IGJhdGNoSWQ7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5jaGVjayhmdW5jdGlvbihlcnIsIHJlcykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZXMuc3RhdGUgPT09IFwiRmFpbGVkXCIpIHtcbiAgICAgICAgICBpZiAocGFyc2VJbnQocmVzLm51bWJlclJlY29yZHNQcm9jZXNzZWQsIDEwKSA+IDApIHtcbiAgICAgICAgICAgIHNlbGYucmV0cmlldmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihyZXMuc3RhdGVNZXNzYWdlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlcy5zdGF0ZSA9PT0gXCJDb21wbGV0ZWRcIikge1xuICAgICAgICAgIHNlbGYucmV0cmlldmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJywgcmVzKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KHBvbGwsIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBzZXRUaW1lb3V0KHBvbGwsIGludGVydmFsKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQnVsa35CYXRjaFJlc3VsdEluZm9cbiAqIEBwcm9wIHtTdHJpbmd9IGlkIC0gQmF0Y2ggcmVzdWx0IElEXG4gKiBAcHJvcCB7U3RyaW5nfSBiYXRjaElkIC0gQmF0Y2ggSUQgd2hpY2ggaW5jbHVkZXMgdGhpcyBiYXRjaCByZXN1bHQuXG4gKiBAcHJvcCB7U3RyaW5nfSBqb2JJZCAtIEpvYiBJRCB3aGljaCBpbmNsdWRlcyB0aGlzIGJhdGNoIHJlc3VsdC5cbiAqL1xuXG4vKipcbiAqIFJldHJpZXZlIGJhdGNoIHJlc3VsdFxuICpcbiAqIEBtZXRob2QgQnVsa35CYXRjaCNyZXRyaWV2ZVxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFJlY29yZFJlc3VsdD58QXJyYXkuPEJ1bGt+QmF0Y2hSZXN1bHRJbmZvPj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxSZWNvcmRSZXN1bHQ+fEFycmF5LjxCdWxrfkJhdGNoUmVzdWx0SW5mbz4+fVxuICovXG5CYXRjaC5wcm90b3R5cGUucmV0cmlldmUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBidWxrID0gdGhpcy5fYnVsaztcbiAgdmFyIGpvYklkID0gdGhpcy5qb2IuaWQ7XG4gIHZhciBqb2IgPSB0aGlzLmpvYjtcbiAgdmFyIGJhdGNoSWQgPSB0aGlzLmlkO1xuXG4gIGlmICgham9iSWQgfHwgIWJhdGNoSWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaCBub3Qgc3RhcnRlZC5cIik7XG4gIH1cblxuICByZXR1cm4gam9iLmluZm8oKS50aGVuKGZ1bmN0aW9uKGpvYkluZm8pIHtcbiAgICByZXR1cm4gYnVsay5fcmVxdWVzdCh7XG4gICAgICBtZXRob2QgOiAnR0VUJyxcbiAgICAgIHBhdGggOiBcIi9qb2IvXCIgKyBqb2JJZCArIFwiL2JhdGNoL1wiICsgYmF0Y2hJZCArIFwiL3Jlc3VsdFwiXG4gICAgfSk7XG4gIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgdmFyIHJlc3VsdHM7XG4gICAgaWYgKGpvYi5vcGVyYXRpb24gPT09ICdxdWVyeScpIHtcbiAgICAgIHZhciBjb25uID0gYnVsay5fY29ubjtcbiAgICAgIHZhciByZXN1bHRJZHMgPSByZXNbJ3Jlc3VsdC1saXN0J10ucmVzdWx0O1xuICAgICAgcmVzdWx0cyA9IHJlc1sncmVzdWx0LWxpc3QnXS5yZXN1bHQ7XG4gICAgICByZXN1bHRzID0gXy5tYXAoXy5pc0FycmF5KHJlc3VsdHMpID8gcmVzdWx0cyA6IFsgcmVzdWx0cyBdLCBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBiYXRjaElkOiBiYXRjaElkLFxuICAgICAgICAgIGpvYklkOiBqb2JJZFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHMgPSBfLm1hcChyZXMsIGZ1bmN0aW9uKHJldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiByZXQuSWQgfHwgbnVsbCxcbiAgICAgICAgICBzdWNjZXNzOiByZXQuU3VjY2VzcyA9PT0gXCJ0cnVlXCIsXG4gICAgICAgICAgZXJyb3JzOiByZXQuRXJyb3IgPyBbIHJldC5FcnJvciBdIDogW11cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVzdWx0cyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0pLmZhaWwoZnVuY3Rpb24oZXJyKSB7XG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgdGhyb3cgZXJyO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEZldGNoIHF1ZXJ5IHJlc3VsdCBhcyBhIHJlY29yZCBzdHJlYW1cbiAqIEBwYXJhbSB7U3RyaW5nfSByZXN1bHRJZCAtIFJlc3VsdCBpZFxuICogQHJldHVybnMge1JlY29yZFN0cmVhbX0gLSBSZWNvcmQgc3RyZWFtLCBjb252ZXJ0aWJsZSB0byBDU1YgZGF0YSBzdHJlYW1cbiAqL1xuQmF0Y2gucHJvdG90eXBlLnJlc3VsdCA9IGZ1bmN0aW9uKHJlc3VsdElkKSB7XG4gIHZhciBqb2JJZCA9IHRoaXMuam9iLmlkO1xuICB2YXIgYmF0Y2hJZCA9IHRoaXMuaWQ7XG4gIGlmICgham9iSWQgfHwgIWJhdGNoSWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaCBub3Qgc3RhcnRlZC5cIik7XG4gIH1cbiAgdmFyIHJlc3VsdFN0cmVhbSA9IG5ldyBSZWNvcmRTdHJlYW0uUGFyc2FibGUoKTtcbiAgdmFyIHJlc3VsdERhdGFTdHJlYW0gPSByZXN1bHRTdHJlYW0uc3RyZWFtKCdjc3YnKTtcbiAgdmFyIHJlcVN0cmVhbSA9IHRoaXMuX2J1bGsuX3JlcXVlc3Qoe1xuICAgIG1ldGhvZCA6ICdHRVQnLFxuICAgIHBhdGggOiBcIi9qb2IvXCIgKyBqb2JJZCArIFwiL2JhdGNoL1wiICsgYmF0Y2hJZCArIFwiL3Jlc3VsdC9cIiArIHJlc3VsdElkLFxuICAgIHJlc3BvbnNlVHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICB9KS5zdHJlYW0oKS5waXBlKHJlc3VsdERhdGFTdHJlYW0pO1xuICByZXR1cm4gcmVzdWx0U3RyZWFtO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBCdWxrQXBpID0gZnVuY3Rpb24oKSB7XG4gIEJ1bGtBcGkuc3VwZXJfLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5pbmhlcml0cyhCdWxrQXBpLCBIdHRwQXBpKTtcblxuQnVsa0FwaS5wcm90b3R5cGUuYmVmb3JlU2VuZCA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgcmVxdWVzdC5oZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzIHx8IHt9O1xuICByZXF1ZXN0LmhlYWRlcnNbXCJYLVNGREMtU0VTU0lPTlwiXSA9IHRoaXMuX2Nvbm4uYWNjZXNzVG9rZW47XG59O1xuXG5CdWxrQXBpLnByb3RvdHlwZS5pc1Nlc3Npb25FeHBpcmVkID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwMCAmJlxuICAgIC88ZXhjZXB0aW9uQ29kZT5JbnZhbGlkU2Vzc2lvbklkPFxcL2V4Y2VwdGlvbkNvZGU+Ly50ZXN0KHJlc3BvbnNlLmJvZHkpO1xufTtcblxuQnVsa0FwaS5wcm90b3R5cGUuaGFzRXJyb3JJblJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgcmV0dXJuICEhYm9keS5lcnJvcjtcbn07XG5cbkJ1bGtBcGkucHJvdG90eXBlLnBhcnNlRXJyb3IgPSBmdW5jdGlvbihib2R5KSB7XG4gIHJldHVybiB7XG4gICAgZXJyb3JDb2RlOiBib2R5LmVycm9yLmV4Y2VwdGlvbkNvZGUsXG4gICAgbWVzc2FnZTogYm9keS5lcnJvci5leGNlcHRpb25NZXNzYWdlXG4gIH07XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBDbGFzcyBmb3IgQnVsayBBUElcbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiAtIENvbm5lY3Rpb24gb2JqZWN0XG4gKi9cbnZhciBCdWxrID0gZnVuY3Rpb24oY29ubikge1xuICB0aGlzLl9jb25uID0gY29ubjtcbiAgdGhpcy5fbG9nZ2VyID0gY29ubi5fbG9nZ2VyO1xufTtcblxuLyoqXG4gKiBQb2xsaW5nIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICogQHR5cGUge051bWJlcn1cbiAqL1xuQnVsay5wcm90b3R5cGUucG9sbEludGVydmFsID0gMTAwMDtcblxuLyoqXG4gKiBQb2xsaW5nIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5CdWxrLnByb3RvdHlwZS5wb2xsVGltZW91dCA9IDEwMDAwO1xuXG4vKiogQHByaXZhdGUgKiovXG5CdWxrLnByb3RvdHlwZS5fcmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3QsIGNhbGxiYWNrKSB7XG4gIHZhciBjb25uID0gdGhpcy5fY29ubjtcbiAgcmVxdWVzdCA9IF8uY2xvbmUocmVxdWVzdCk7XG4gIHZhciBiYXNlVXJsID0gWyBjb25uLmluc3RhbmNlVXJsLCBcInNlcnZpY2VzL2FzeW5jXCIsIGNvbm4udmVyc2lvbiBdLmpvaW4oJy8nKTtcbiAgcmVxdWVzdC51cmwgPSBiYXNlVXJsICsgcmVxdWVzdC5wYXRoO1xuICB2YXIgb3B0aW9ucyA9IHsgcmVzcG9uc2VUeXBlOiByZXF1ZXN0LnJlc3BvbnNlVHlwZSB9O1xuICBkZWxldGUgcmVxdWVzdC5wYXRoO1xuICBkZWxldGUgcmVxdWVzdC5yZXNwb25zZVR5cGU7XG4gIHJldHVybiBuZXcgQnVsa0FwaSh0aGlzLl9jb25uLCBvcHRpb25zKS5yZXF1ZXN0KHJlcXVlc3QpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCBzdGFydCBidWxrbG9hZCBqb2IgYW5kIGJhdGNoXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRpb24gLSBCdWxrIGxvYWQgb3BlcmF0aW9uICgnaW5zZXJ0JywgJ3VwZGF0ZScsICd1cHNlcnQnLCAnZGVsZXRlJywgb3IgJ2hhcmREZWxldGUnKVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIGJ1bGsgbG9hZGluZyBvcGVyYXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5leHRJZEZpZWxkXSAtIEV4dGVybmFsIElEIGZpZWxkIG5hbWUgKHVzZWQgd2hlbiB1cHNlcnQgb3BlcmF0aW9uKS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb25jdXJyZW5jeU1vZGVdIC0gJ1NlcmlhbCcgb3IgJ1BhcmFsbGVsJy4gRGVmYXVsdHMgdG8gUGFyYWxsZWwuXG4gKiBAcGFyYW0ge0FycmF5LjxSZWNvcmQ+fHN0cmVhbS5TdHJlYW18U3RyaW5nfSBbaW5wdXRdIC0gSW5wdXQgc291cmNlIGZvciBidWxrbG9hZC4gQWNjZXB0cyBhcnJheSBvZiByZWNvcmRzLCBDU1Ygc3RyaW5nLCBhbmQgQ1NWIGRhdGEgaW5wdXQgc3RyZWFtIGluIGluc2VydC91cGRhdGUvdXBzZXJ0L2RlbGV0ZS9oYXJkRGVsZXRlIG9wZXJhdGlvbiwgU09RTCBzdHJpbmcgaW4gcXVlcnkgb3BlcmF0aW9uLlxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFJlY29yZFJlc3VsdD58QXJyYXkuPEJ1bGt+QmF0Y2hSZXN1bHRJbmZvPj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0J1bGt+QmF0Y2h9XG4gKi9cbkJ1bGsucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbih0eXBlLCBvcGVyYXRpb24sIG9wdGlvbnMsIGlucHV0LCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICghdHlwZSB8fCAhb3BlcmF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW5zdWZmaWNpZW50IGFyZ3VtZW50cy4gQXQgbGVhc3QsICd0eXBlJyBhbmQgJ29wZXJhdGlvbicgYXJlIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIV8uaXNPYmplY3Qob3B0aW9ucykgfHwgb3B0aW9ucy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7IC8vIHdoZW4gb3B0aW9ucyBpcyBub3QgcGxhaW4gaGFzaCBvYmplY3QsIGl0IGlzIG9taXR0ZWRcbiAgICBjYWxsYmFjayA9IGlucHV0O1xuICAgIGlucHV0ID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICB2YXIgam9iID0gdGhpcy5jcmVhdGVKb2IodHlwZSwgb3BlcmF0aW9uLCBvcHRpb25zKTtcbiAgam9iLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgaWYgKGJhdGNoKSB7XG4gICAgICBiYXRjaC5lbWl0KCdlcnJvcicsIGVycm9yKTsgLy8gcGFzcyBqb2IgZXJyb3IgdG8gYmF0Y2hcbiAgICB9XG4gIH0pO1xuICB2YXIgYmF0Y2ggPSBqb2IuY3JlYXRlQmF0Y2goKTtcbiAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICBiYXRjaCA9IG51bGw7XG4gICAgam9iLmNsb3NlKCk7XG4gIH07XG4gIHZhciBjbGVhbnVwT25FcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIubmFtZSAhPT0gJ1BvbGxpbmdUaW1lb3V0Jykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfTtcbiAgYmF0Y2gub24oJ3Jlc3BvbnNlJywgY2xlYW51cCk7XG4gIGJhdGNoLm9uKCdlcnJvcicsIGNsZWFudXBPbkVycm9yKTtcbiAgYmF0Y2gub24oJ3F1ZXVlJywgZnVuY3Rpb24oKSB7IGJhdGNoLnBvbGwoc2VsZi5wb2xsSW50ZXJ2YWwsIHNlbGYucG9sbFRpbWVvdXQpOyB9KTtcbiAgcmV0dXJuIGJhdGNoLmV4ZWN1dGUoaW5wdXQsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBidWxrIHF1ZXJ5IGFuZCBnZXQgcmVjb3JkIHN0cmVhbVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzb3FsIC0gU09RTCB0byBleGVjdXRlIGluIGJ1bGsgam9iXG4gKiBAcmV0dXJucyB7UmVjb3JkU3RyZWFtLlBhcnNhYmxlfSAtIFJlY29yZCBzdHJlYW0sIGNvbnZlcnRpYmxlIHRvIENTViBkYXRhIHN0cmVhbVxuICovXG5CdWxrLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHNvcWwpIHtcbiAgdmFyIG0gPSBzb3FsLnJlcGxhY2UoL1xcKFtcXHNcXFNdK1xcKS9nLCAnJykubWF0Y2goL0ZST01cXHMrKFxcdyspL2kpO1xuICBpZiAoIW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzb2JqZWN0IHR5cGUgZm91bmQgaW4gcXVlcnksIG1heWJlIGNhdXNlZCBieSBpbnZhbGlkIFNPUUwuXCIpO1xuICB9XG4gIHZhciB0eXBlID0gbVsxXTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcmVjb3JkU3RyZWFtID0gbmV3IFJlY29yZFN0cmVhbS5QYXJzYWJsZSgpO1xuICB2YXIgZGF0YVN0cmVhbSA9IHJlY29yZFN0cmVhbS5zdHJlYW0oJ2NzdicpO1xuICB0aGlzLmxvYWQodHlwZSwgXCJxdWVyeVwiLCBzb3FsKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICB2YXIgc3RyZWFtcyA9IHJlc3VsdHMubWFwKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHNlbGZcbiAgICAgICAgLmpvYihyZXN1bHQuam9iSWQpXG4gICAgICAgIC5iYXRjaChyZXN1bHQuYmF0Y2hJZClcbiAgICAgICAgLnJlc3VsdChyZXN1bHQuaWQpXG4gICAgICAgIC5zdHJlYW0oKTtcbiAgICB9KTtcblxuICAgIGpvaW5TdHJlYW1zKHN0cmVhbXMpLnBpcGUoZGF0YVN0cmVhbSk7XG4gIH0pLmZhaWwoZnVuY3Rpb24oZXJyKSB7XG4gICAgcmVjb3JkU3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfSk7XG4gIHJldHVybiByZWNvcmRTdHJlYW07XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGpvYiBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gU09iamVjdCB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0aW9uIC0gQnVsayBsb2FkIG9wZXJhdGlvbiAoJ2luc2VydCcsICd1cGRhdGUnLCAndXBzZXJ0JywgJ2RlbGV0ZScsICdoYXJkRGVsZXRlJywgb3IgJ3F1ZXJ5JylcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciBidWxrIGxvYWRpbmcgb3BlcmF0aW9uXG4gKiBAcmV0dXJucyB7QnVsa35Kb2J9XG4gKi9cbkJ1bGsucHJvdG90eXBlLmNyZWF0ZUpvYiA9IGZ1bmN0aW9uKHR5cGUsIG9wZXJhdGlvbiwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IEpvYih0aGlzLCB0eXBlLCBvcGVyYXRpb24sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBqb2IgaW5zdGFuY2Ugc3BlY2lmaWVkIGJ5IGdpdmVuIGpvYiBJRFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBqb2JJZCAtIEpvYiBJRFxuICogQHJldHVybnMge0J1bGt+Sm9ifVxuICovXG5CdWxrLnByb3RvdHlwZS5qb2IgPSBmdW5jdGlvbihqb2JJZCkge1xuICByZXR1cm4gbmV3IEpvYih0aGlzLCBudWxsLCBudWxsLCBudWxsLCBqb2JJZCk7XG59O1xuXG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLypcbiAqIFJlZ2lzdGVyIGhvb2sgaW4gY29ubmVjdGlvbiBpbnN0YW50aWF0aW9uIGZvciBkeW5hbWljYWxseSBhZGRpbmcgdGhpcyBBUEkgbW9kdWxlIGZlYXR1cmVzXG4gKi9cbmpzZm9yY2Uub24oJ2Nvbm5lY3Rpb246bmV3JywgZnVuY3Rpb24oY29ubikge1xuICBjb25uLmJ1bGsgPSBuZXcgQnVsayhjb25uKTtcbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQnVsaztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/api/bulk.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/api/chatter.js":
/*!*************************************************!*\
  !*** ./node_modules/jsforce/lib/api/chatter.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages Salesforce Chatter REST API calls\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\"),\n    _       = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    jsforce = __webpack_require__(/*! ../core */ \"(action-browser)/./node_modules/jsforce/lib/core.js\"),\n    Promise = __webpack_require__(/*! ../promise */ \"(action-browser)/./node_modules/jsforce/lib/promise.js\");\n\n/**\n * API class for Chatter REST API call\n *\n * @class\n * @param {Connection} conn Connection\n */\nvar Chatter = module.exports = function(conn) {\n  this._conn = conn;\n};\n\n/**\n * Sending request to API endpoint\n * @private\n */\nChatter.prototype._request = function(params, callback) {\n  if (/^(put|post|patch)$/i.test(params.method)) {\n    if (_.isObject(params.body)) {\n      params.headers = {\n        \"Content-Type\": \"application/json\"\n      };\n      params.body = JSON.stringify(params.body);\n    }\n  }\n  params.url = this._normalizeUrl(params.url);\n  return this._conn.request(params, callback);\n};\n\n/**\n * Convert path to site root relative url\n * @private\n */\nChatter.prototype._normalizeUrl = function(url) {\n  if (url.indexOf('/chatter/') === 0 || url.indexOf('/connect/') === 0) {\n    return '/services/data/v' + this._conn.version + url;\n  } else if (/^\\/v[\\d]+\\.[\\d]+\\//.test(url)) {\n    return '/services/data' + url;\n  } else if (url.indexOf('/services/') !== 0 && url[0] === '/') {\n    return '/services/data/v' + this._conn.version + '/chatter' + url;\n  } else {\n    return url;\n  }\n};\n\n/**\n * @typedef {Object} Chatter~RequestParams\n * @prop {String} method - HTTP method\n * @prop {String} url - Resource URL\n * @prop {String} [body] - HTTP body (in POST/PUT/PATCH methods)\n */\n\n/**\n * @typedef {Object} Chatter~RequestResult\n */\n\n/**\n * Make a request for chatter API resource\n *\n * @param {Chatter~RequestParams} params - Paramters representing HTTP request\n * @param {Callback.<Chatter~RequestResult>} [callback] - Callback func\n * @returns {Chatter~Request}\n */\nChatter.prototype.request = function(params, callback) {\n  return new Request(this, params).thenCall(callback);\n};\n\n/**\n * Make a resource request to chatter API\n *\n * @param {String} url - Resource URL\n * @param {Object} [queryParams] - Query parameters (in hash object)\n * @returns {Chatter~Resource}\n */\nChatter.prototype.resource = function(url, queryParams) {\n  return new Resource(this, url, queryParams);\n};\n\n/**\n * @typedef {Object} Chatter~BatchRequestResult\n * @prop {Boolean} hasError - Flag if the batch has one or more errors\n * @prop {Array.<Object>} results - Batch request results in array\n * @prop {Number} results.statusCode - HTTP response status code\n * @prop {Chatter~RequestResult} results.result - Parsed HTTP response body\n */\n\n/**\n * Make a batch request to chatter API\n *\n * @params {Array.<Chatter~Request>} requests - Chatter API requests\n * @param {Callback.<Chatter~BatchRequestResult>} [callback] - Callback func\n * @returns {Promise.<Chatter~BatchRequestResult>}\n */\nChatter.prototype.batch = function(requests, callback) {\n  var self = this;\n  var batchRequests = [], batchDeferreds = [];\n  _.forEach(requests, function(request) {\n    var deferred = Promise.defer();\n    request._promise = deferred.promise;\n    batchRequests.push(request.batchParams());\n    batchDeferreds.push(deferred);\n  });\n  var params = {\n    method: 'POST',\n    url: this._normalizeUrl('/connect/batch'),\n    body: {\n      batchRequests: batchRequests\n    }\n  };\n  return this.request(params).then(function(res) {\n    _.forEach(res.results, function(result, i) {\n      var deferred = batchDeferreds[i];\n      if (result.statusCode >= 400) {\n        deferred.reject(result.result);\n      } else {\n        deferred.resolve(result.result);\n      }\n    });\n    return res;\n  }).thenCall(callback);\n};\n\n\n/*--------------------------------------------*/\n/**\n * A class representing chatter API request\n *\n * @protected\n * @class Chatter~Request\n * @implements {Promise.<Chatter~RequestResult>}\n * @param {Chatter} chatter - Chatter API object\n * @param {Chatter~RequestParams} params - Paramters representing HTTP request\n */\nvar Request = function(chatter, params) {\n  this._chatter = chatter;\n  this._params = params;\n  this._promise = null;\n};\n\n/**\n * @typedef {Object} Chatter~BatchRequestParams\n * @prop {String} method - HTTP method\n * @prop {String} url - Resource URL\n * @prop {String} [richInput] - HTTP body (in POST/PUT/PATCH methods)\n */\n\n/**\n * Retrieve parameters in batch request form\n *\n * @method Chatter~Request#batchParams\n * @returns {Chatter~BatchRequestParams}\n */\nRequest.prototype.batchParams = function() {\n  var params = this._params;\n  var batchParams = {\n    method: params.method,\n    url: this._chatter._normalizeUrl(params.url)\n  };\n  if (this._params.body) {\n    batchParams.richInput = this._params.body;\n  }\n  return batchParams;\n};\n\n/**\n * Retrieve parameters in batch request form\n *\n * @method Chatter~Request#promise\n * @returns {Promise.<Chatter~RequestResult>}\n */\nRequest.prototype.promise = function() {\n  return this._promise || this._chatter._request(this._params);\n};\n\n/**\n * Returns Node.js Stream object for request\n *\n * @method Chatter~Request#stream\n * @returns {stream.Stream}\n */\nRequest.prototype.stream = function() {\n  return this._chatter._request(this._params).stream();\n};\n\n/**\n * Promise/A+ interface\n * http://promises-aplus.github.io/promises-spec/\n *\n * Delegate to deferred promise, return promise instance for batch result\n *\n * @method Chatter~Request#then\n */\nRequest.prototype.then = function(onResolve, onReject) {\n  return this.promise().then(onResolve, onReject);\n};\n\n/**\n * Promise/A+ extension\n * Call \"then\" using given node-style callback function\n *\n * @method Chatter~Request#thenCall\n */\nRequest.prototype.thenCall = function(callback) {\n  return _.isFunction(callback) ? this.promise().thenCall(callback) : this;\n};\n\n\n/*--------------------------------------------*/\n/**\n * A class representing chatter API resource\n *\n * @protected\n * @class Chatter~Resource\n * @extends Chatter~Request\n * @param {Chatter} chatter - Chatter API object\n * @param {String} url - Resource URL\n * @param {Object} [queryParams] - Query parameters (in hash object)\n */\nvar Resource = function(chatter, url, queryParams) {\n  if (queryParams) {\n    var qstring = _.map(_.keys(queryParams), function(name) {\n      return name + \"=\" + encodeURIComponent(queryParams[name]);\n    }).join('&');\n    url += (url.indexOf('?') > 0 ? '&' : '?') + qstring;\n  }\n  Resource.super_.call(this, chatter, { method: 'GET', url: url });\n  this._url = url;\n};\n\ninherits(Resource, Request);\n\n/**\n * Create a new resource\n *\n * @method Chatter~Resource#create\n * @param {Object} data - Data to newly post\n * @param {Callback.<Chatter~RequestResult>} [callback] - Callback function\n * @returns {Chatter~Request}\n */\nResource.prototype.create = function(data, callback) {\n  return this._chatter.request({\n    method: 'POST',\n    url: this._url,\n    body: data\n  }).thenCall(callback);\n};\n\n/**\n * Retrieve resource content\n *\n * @method Chatter~Resource#retrieve\n * @param {Callback.<Chatter~RequestResult>} [callback] - Callback function\n * @returns {Chatter~Request}\n */\nResource.prototype.retrieve = function(callback) {\n  return this.thenCall(callback);\n};\n\n/**\n * Update specified resource\n *\n * @method Chatter~Resource#update\n * @param {Object} data - Data to update\n * @param {Callback.<Chatter~RequestResult>} [callback] - Callback function\n * @returns {Chatter~Request}\n */\nResource.prototype.update = function(data, callback) {\n  return this._chatter.request({\n    method: 'PATCH',\n    url: this._url,\n    body: data\n  }).thenCall(callback);\n};\n\n/**\n * Synonym of Resource#delete()\n *\n * @method Chatter~Resource#del\n * @param {Callback.<Chatter~RequestResult>} [callback] - Callback function\n * @returns {Chatter~Request}\n */\n/**\n * Delete specified resource\n *\n * @method Chatter~Resource#delete\n * @param {Callback.<Chatter~RequestResult>} [callback] - Callback function\n * @returns {Chatter~Request}\n */\nResource.prototype.del =\nResource.prototype[\"delete\"] = function(callback) {\n  return this._chatter.request({\n    method: 'DELETE',\n    url: this._url\n  }).thenCall(callback);\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.chatter = new Chatter(conn);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvY2hhdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsc0VBQVU7QUFDakMsY0FBYyxtQkFBTyxDQUFDLG1FQUFhO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyxvRUFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsMEVBQVk7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLGtDQUFrQztBQUM3QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsUUFBUTtBQUNsQixVQUFVLHVCQUF1QjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQyxXQUFXLHVDQUF1QztBQUNsRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXdDLHlCQUF5QjtBQUNqRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsa0NBQWtDO0FBQzdDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtDQUFrQztBQUM3QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxrQ0FBa0M7QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQ0FBa0M7QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL2NoYXR0ZXIuanM/MTdjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIE1hbmFnZXMgU2FsZXNmb3JjZSBDaGF0dGVyIFJFU1QgQVBJIGNhbGxzXG4gKiBAYXV0aG9yIFNoaW5pY2hpIFRvbWl0YSA8c2hpbmljaGkudG9taXRhQGdtYWlsLmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgXyAgICAgICA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyksXG4gICAganNmb3JjZSA9IHJlcXVpcmUoJy4uL2NvcmUnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi4vcHJvbWlzZScpO1xuXG4vKipcbiAqIEFQSSBjbGFzcyBmb3IgQ2hhdHRlciBSRVNUIEFQSSBjYWxsXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gQ29ubmVjdGlvblxuICovXG52YXIgQ2hhdHRlciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29ubikge1xuICB0aGlzLl9jb25uID0gY29ubjtcbn07XG5cbi8qKlxuICogU2VuZGluZyByZXF1ZXN0IHRvIEFQSSBlbmRwb2ludFxuICogQHByaXZhdGVcbiAqL1xuQ2hhdHRlci5wcm90b3R5cGUuX3JlcXVlc3QgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIGlmICgvXihwdXR8cG9zdHxwYXRjaCkkL2kudGVzdChwYXJhbXMubWV0aG9kKSkge1xuICAgIGlmIChfLmlzT2JqZWN0KHBhcmFtcy5ib2R5KSkge1xuICAgICAgcGFyYW1zLmhlYWRlcnMgPSB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9O1xuICAgICAgcGFyYW1zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShwYXJhbXMuYm9keSk7XG4gICAgfVxuICB9XG4gIHBhcmFtcy51cmwgPSB0aGlzLl9ub3JtYWxpemVVcmwocGFyYW1zLnVybCk7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QocGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgcGF0aCB0byBzaXRlIHJvb3QgcmVsYXRpdmUgdXJsXG4gKiBAcHJpdmF0ZVxuICovXG5DaGF0dGVyLnByb3RvdHlwZS5fbm9ybWFsaXplVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gIGlmICh1cmwuaW5kZXhPZignL2NoYXR0ZXIvJykgPT09IDAgfHwgdXJsLmluZGV4T2YoJy9jb25uZWN0LycpID09PSAwKSB7XG4gICAgcmV0dXJuICcvc2VydmljZXMvZGF0YS92JyArIHRoaXMuX2Nvbm4udmVyc2lvbiArIHVybDtcbiAgfSBlbHNlIGlmICgvXlxcL3ZbXFxkXStcXC5bXFxkXStcXC8vLnRlc3QodXJsKSkge1xuICAgIHJldHVybiAnL3NlcnZpY2VzL2RhdGEnICsgdXJsO1xuICB9IGVsc2UgaWYgKHVybC5pbmRleE9mKCcvc2VydmljZXMvJykgIT09IDAgJiYgdXJsWzBdID09PSAnLycpIHtcbiAgICByZXR1cm4gJy9zZXJ2aWNlcy9kYXRhL3YnICsgdGhpcy5fY29ubi52ZXJzaW9uICsgJy9jaGF0dGVyJyArIHVybDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENoYXR0ZXJ+UmVxdWVzdFBhcmFtc1xuICogQHByb3Age1N0cmluZ30gbWV0aG9kIC0gSFRUUCBtZXRob2RcbiAqIEBwcm9wIHtTdHJpbmd9IHVybCAtIFJlc291cmNlIFVSTFxuICogQHByb3Age1N0cmluZ30gW2JvZHldIC0gSFRUUCBib2R5IChpbiBQT1NUL1BVVC9QQVRDSCBtZXRob2RzKVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2hhdHRlcn5SZXF1ZXN0UmVzdWx0XG4gKi9cblxuLyoqXG4gKiBNYWtlIGEgcmVxdWVzdCBmb3IgY2hhdHRlciBBUEkgcmVzb3VyY2VcbiAqXG4gKiBAcGFyYW0ge0NoYXR0ZXJ+UmVxdWVzdFBhcmFtc30gcGFyYW1zIC0gUGFyYW10ZXJzIHJlcHJlc2VudGluZyBIVFRQIHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPENoYXR0ZXJ+UmVxdWVzdFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jXG4gKiBAcmV0dXJucyB7Q2hhdHRlcn5SZXF1ZXN0fVxuICovXG5DaGF0dGVyLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywgcGFyYW1zKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSByZXNvdXJjZSByZXF1ZXN0IHRvIGNoYXR0ZXIgQVBJXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIFJlc291cmNlIFVSTFxuICogQHBhcmFtIHtPYmplY3R9IFtxdWVyeVBhcmFtc10gLSBRdWVyeSBwYXJhbWV0ZXJzIChpbiBoYXNoIG9iamVjdClcbiAqIEByZXR1cm5zIHtDaGF0dGVyflJlc291cmNlfVxuICovXG5DaGF0dGVyLnByb3RvdHlwZS5yZXNvdXJjZSA9IGZ1bmN0aW9uKHVybCwgcXVlcnlQYXJhbXMpIHtcbiAgcmV0dXJuIG5ldyBSZXNvdXJjZSh0aGlzLCB1cmwsIHF1ZXJ5UGFyYW1zKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2hhdHRlcn5CYXRjaFJlcXVlc3RSZXN1bHRcbiAqIEBwcm9wIHtCb29sZWFufSBoYXNFcnJvciAtIEZsYWcgaWYgdGhlIGJhdGNoIGhhcyBvbmUgb3IgbW9yZSBlcnJvcnNcbiAqIEBwcm9wIHtBcnJheS48T2JqZWN0Pn0gcmVzdWx0cyAtIEJhdGNoIHJlcXVlc3QgcmVzdWx0cyBpbiBhcnJheVxuICogQHByb3Age051bWJlcn0gcmVzdWx0cy5zdGF0dXNDb2RlIC0gSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZVxuICogQHByb3Age0NoYXR0ZXJ+UmVxdWVzdFJlc3VsdH0gcmVzdWx0cy5yZXN1bHQgLSBQYXJzZWQgSFRUUCByZXNwb25zZSBib2R5XG4gKi9cblxuLyoqXG4gKiBNYWtlIGEgYmF0Y2ggcmVxdWVzdCB0byBjaGF0dGVyIEFQSVxuICpcbiAqIEBwYXJhbXMge0FycmF5LjxDaGF0dGVyflJlcXVlc3Q+fSByZXF1ZXN0cyAtIENoYXR0ZXIgQVBJIHJlcXVlc3RzXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxDaGF0dGVyfkJhdGNoUmVxdWVzdFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48Q2hhdHRlcn5CYXRjaFJlcXVlc3RSZXN1bHQ+fVxuICovXG5DaGF0dGVyLnByb3RvdHlwZS5iYXRjaCA9IGZ1bmN0aW9uKHJlcXVlc3RzLCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBiYXRjaFJlcXVlc3RzID0gW10sIGJhdGNoRGVmZXJyZWRzID0gW107XG4gIF8uZm9yRWFjaChyZXF1ZXN0cywgZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHZhciBkZWZlcnJlZCA9IFByb21pc2UuZGVmZXIoKTtcbiAgICByZXF1ZXN0Ll9wcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZTtcbiAgICBiYXRjaFJlcXVlc3RzLnB1c2gocmVxdWVzdC5iYXRjaFBhcmFtcygpKTtcbiAgICBiYXRjaERlZmVycmVkcy5wdXNoKGRlZmVycmVkKTtcbiAgfSk7XG4gIHZhciBwYXJhbXMgPSB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiB0aGlzLl9ub3JtYWxpemVVcmwoJy9jb25uZWN0L2JhdGNoJyksXG4gICAgYm9keToge1xuICAgICAgYmF0Y2hSZXF1ZXN0czogYmF0Y2hSZXF1ZXN0c1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRoaXMucmVxdWVzdChwYXJhbXMpLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgXy5mb3JFYWNoKHJlcy5yZXN1bHRzLCBmdW5jdGlvbihyZXN1bHQsIGkpIHtcbiAgICAgIHZhciBkZWZlcnJlZCA9IGJhdGNoRGVmZXJyZWRzW2ldO1xuICAgICAgaWYgKHJlc3VsdC5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QocmVzdWx0LnJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdC5yZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGNoYXR0ZXIgQVBJIHJlcXVlc3RcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAY2xhc3MgQ2hhdHRlcn5SZXF1ZXN0XG4gKiBAaW1wbGVtZW50cyB7UHJvbWlzZS48Q2hhdHRlcn5SZXF1ZXN0UmVzdWx0Pn1cbiAqIEBwYXJhbSB7Q2hhdHRlcn0gY2hhdHRlciAtIENoYXR0ZXIgQVBJIG9iamVjdFxuICogQHBhcmFtIHtDaGF0dGVyflJlcXVlc3RQYXJhbXN9IHBhcmFtcyAtIFBhcmFtdGVycyByZXByZXNlbnRpbmcgSFRUUCByZXF1ZXN0XG4gKi9cbnZhciBSZXF1ZXN0ID0gZnVuY3Rpb24oY2hhdHRlciwgcGFyYW1zKSB7XG4gIHRoaXMuX2NoYXR0ZXIgPSBjaGF0dGVyO1xuICB0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XG4gIHRoaXMuX3Byb21pc2UgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDaGF0dGVyfkJhdGNoUmVxdWVzdFBhcmFtc1xuICogQHByb3Age1N0cmluZ30gbWV0aG9kIC0gSFRUUCBtZXRob2RcbiAqIEBwcm9wIHtTdHJpbmd9IHVybCAtIFJlc291cmNlIFVSTFxuICogQHByb3Age1N0cmluZ30gW3JpY2hJbnB1dF0gLSBIVFRQIGJvZHkgKGluIFBPU1QvUFVUL1BBVENIIG1ldGhvZHMpXG4gKi9cblxuLyoqXG4gKiBSZXRyaWV2ZSBwYXJhbWV0ZXJzIGluIGJhdGNoIHJlcXVlc3QgZm9ybVxuICpcbiAqIEBtZXRob2QgQ2hhdHRlcn5SZXF1ZXN0I2JhdGNoUGFyYW1zXG4gKiBAcmV0dXJucyB7Q2hhdHRlcn5CYXRjaFJlcXVlc3RQYXJhbXN9XG4gKi9cblJlcXVlc3QucHJvdG90eXBlLmJhdGNoUGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gIHZhciBiYXRjaFBhcmFtcyA9IHtcbiAgICBtZXRob2Q6IHBhcmFtcy5tZXRob2QsXG4gICAgdXJsOiB0aGlzLl9jaGF0dGVyLl9ub3JtYWxpemVVcmwocGFyYW1zLnVybClcbiAgfTtcbiAgaWYgKHRoaXMuX3BhcmFtcy5ib2R5KSB7XG4gICAgYmF0Y2hQYXJhbXMucmljaElucHV0ID0gdGhpcy5fcGFyYW1zLmJvZHk7XG4gIH1cbiAgcmV0dXJuIGJhdGNoUGFyYW1zO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBwYXJhbWV0ZXJzIGluIGJhdGNoIHJlcXVlc3QgZm9ybVxuICpcbiAqIEBtZXRob2QgQ2hhdHRlcn5SZXF1ZXN0I3Byb21pc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlLjxDaGF0dGVyflJlcXVlc3RSZXN1bHQ+fVxuICovXG5SZXF1ZXN0LnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9wcm9taXNlIHx8IHRoaXMuX2NoYXR0ZXIuX3JlcXVlc3QodGhpcy5fcGFyYW1zKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBOb2RlLmpzIFN0cmVhbSBvYmplY3QgZm9yIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIENoYXR0ZXJ+UmVxdWVzdCNzdHJlYW1cbiAqIEByZXR1cm5zIHtzdHJlYW0uU3RyZWFtfVxuICovXG5SZXF1ZXN0LnByb3RvdHlwZS5zdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NoYXR0ZXIuX3JlcXVlc3QodGhpcy5fcGFyYW1zKS5zdHJlYW0oKTtcbn07XG5cbi8qKlxuICogUHJvbWlzZS9BKyBpbnRlcmZhY2VcbiAqIGh0dHA6Ly9wcm9taXNlcy1hcGx1cy5naXRodWIuaW8vcHJvbWlzZXMtc3BlYy9cbiAqXG4gKiBEZWxlZ2F0ZSB0byBkZWZlcnJlZCBwcm9taXNlLCByZXR1cm4gcHJvbWlzZSBpbnN0YW5jZSBmb3IgYmF0Y2ggcmVzdWx0XG4gKlxuICogQG1ldGhvZCBDaGF0dGVyflJlcXVlc3QjdGhlblxuICovXG5SZXF1ZXN0LnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25SZXNvbHZlLCBvblJlamVjdCkge1xuICByZXR1cm4gdGhpcy5wcm9taXNlKCkudGhlbihvblJlc29sdmUsIG9uUmVqZWN0KTtcbn07XG5cbi8qKlxuICogUHJvbWlzZS9BKyBleHRlbnNpb25cbiAqIENhbGwgXCJ0aGVuXCIgdXNpbmcgZ2l2ZW4gbm9kZS1zdHlsZSBjYWxsYmFjayBmdW5jdGlvblxuICpcbiAqIEBtZXRob2QgQ2hhdHRlcn5SZXF1ZXN0I3RoZW5DYWxsXG4gKi9cblJlcXVlc3QucHJvdG90eXBlLnRoZW5DYWxsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuIF8uaXNGdW5jdGlvbihjYWxsYmFjaykgPyB0aGlzLnByb21pc2UoKS50aGVuQ2FsbChjYWxsYmFjaykgOiB0aGlzO1xufTtcblxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogQSBjbGFzcyByZXByZXNlbnRpbmcgY2hhdHRlciBBUEkgcmVzb3VyY2VcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAY2xhc3MgQ2hhdHRlcn5SZXNvdXJjZVxuICogQGV4dGVuZHMgQ2hhdHRlcn5SZXF1ZXN0XG4gKiBAcGFyYW0ge0NoYXR0ZXJ9IGNoYXR0ZXIgLSBDaGF0dGVyIEFQSSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBSZXNvdXJjZSBVUkxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcXVlcnlQYXJhbXNdIC0gUXVlcnkgcGFyYW1ldGVycyAoaW4gaGFzaCBvYmplY3QpXG4gKi9cbnZhciBSZXNvdXJjZSA9IGZ1bmN0aW9uKGNoYXR0ZXIsIHVybCwgcXVlcnlQYXJhbXMpIHtcbiAgaWYgKHF1ZXJ5UGFyYW1zKSB7XG4gICAgdmFyIHFzdHJpbmcgPSBfLm1hcChfLmtleXMocXVlcnlQYXJhbXMpLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5UGFyYW1zW25hbWVdKTtcbiAgICB9KS5qb2luKCcmJyk7XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID4gMCA/ICcmJyA6ICc/JykgKyBxc3RyaW5nO1xuICB9XG4gIFJlc291cmNlLnN1cGVyXy5jYWxsKHRoaXMsIGNoYXR0ZXIsIHsgbWV0aG9kOiAnR0VUJywgdXJsOiB1cmwgfSk7XG4gIHRoaXMuX3VybCA9IHVybDtcbn07XG5cbmluaGVyaXRzKFJlc291cmNlLCBSZXF1ZXN0KTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgcmVzb3VyY2VcbiAqXG4gKiBAbWV0aG9kIENoYXR0ZXJ+UmVzb3VyY2UjY3JlYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIERhdGEgdG8gbmV3bHkgcG9zdFxuICogQHBhcmFtIHtDYWxsYmFjay48Q2hhdHRlcn5SZXF1ZXN0UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7Q2hhdHRlcn5SZXF1ZXN0fVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2NoYXR0ZXIucmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiB0aGlzLl91cmwsXG4gICAgYm9keTogZGF0YVxuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHJlc291cmNlIGNvbnRlbnRcbiAqXG4gKiBAbWV0aG9kIENoYXR0ZXJ+UmVzb3VyY2UjcmV0cmlldmVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPENoYXR0ZXJ+UmVxdWVzdFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0NoYXR0ZXJ+UmVxdWVzdH1cbiAqL1xuUmVzb3VyY2UucHJvdG90eXBlLnJldHJpZXZlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgc3BlY2lmaWVkIHJlc291cmNlXG4gKlxuICogQG1ldGhvZCBDaGF0dGVyflJlc291cmNlI3VwZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBEYXRhIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48Q2hhdHRlcn5SZXF1ZXN0UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7Q2hhdHRlcn5SZXF1ZXN0fVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2NoYXR0ZXIucmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgIHVybDogdGhpcy5fdXJsLFxuICAgIGJvZHk6IGRhdGFcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTeW5vbnltIG9mIFJlc291cmNlI2RlbGV0ZSgpXG4gKlxuICogQG1ldGhvZCBDaGF0dGVyflJlc291cmNlI2RlbFxuICogQHBhcmFtIHtDYWxsYmFjay48Q2hhdHRlcn5SZXF1ZXN0UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7Q2hhdHRlcn5SZXF1ZXN0fVxuICovXG4vKipcbiAqIERlbGV0ZSBzcGVjaWZpZWQgcmVzb3VyY2VcbiAqXG4gKiBAbWV0aG9kIENoYXR0ZXJ+UmVzb3VyY2UjZGVsZXRlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxDaGF0dGVyflJlcXVlc3RSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtDaGF0dGVyflJlcXVlc3R9XG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5kZWwgPVxuUmVzb3VyY2UucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2NoYXR0ZXIucmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICB1cmw6IHRoaXMuX3VybFxuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLypcbiAqIFJlZ2lzdGVyIGhvb2sgaW4gY29ubmVjdGlvbiBpbnN0YW50aWF0aW9uIGZvciBkeW5hbWljYWxseSBhZGRpbmcgdGhpcyBBUEkgbW9kdWxlIGZlYXR1cmVzXG4gKi9cbmpzZm9yY2Uub24oJ2Nvbm5lY3Rpb246bmV3JywgZnVuY3Rpb24oY29ubikge1xuICBjb25uLmNoYXR0ZXIgPSBuZXcgQ2hhdHRlcihjb25uKTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/api/chatter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/api/chatter.js":
/*!*************************************************!*\
  !*** ./node_modules/jsforce/lib/api/chatter.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages Salesforce Chatter REST API calls\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\"),\n    _       = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    jsforce = __webpack_require__(/*! ../core */ \"(rsc)/./node_modules/jsforce/lib/core.js\"),\n    Promise = __webpack_require__(/*! ../promise */ \"(rsc)/./node_modules/jsforce/lib/promise.js\");\n\n/**\n * API class for Chatter REST API call\n *\n * @class\n * @param {Connection} conn Connection\n */\nvar Chatter = module.exports = function(conn) {\n  this._conn = conn;\n};\n\n/**\n * Sending request to API endpoint\n * @private\n */\nChatter.prototype._request = function(params, callback) {\n  if (/^(put|post|patch)$/i.test(params.method)) {\n    if (_.isObject(params.body)) {\n      params.headers = {\n        \"Content-Type\": \"application/json\"\n      };\n      params.body = JSON.stringify(params.body);\n    }\n  }\n  params.url = this._normalizeUrl(params.url);\n  return this._conn.request(params, callback);\n};\n\n/**\n * Convert path to site root relative url\n * @private\n */\nChatter.prototype._normalizeUrl = function(url) {\n  if (url.indexOf('/chatter/') === 0 || url.indexOf('/connect/') === 0) {\n    return '/services/data/v' + this._conn.version + url;\n  } else if (/^\\/v[\\d]+\\.[\\d]+\\//.test(url)) {\n    return '/services/data' + url;\n  } else if (url.indexOf('/services/') !== 0 && url[0] === '/') {\n    return '/services/data/v' + this._conn.version + '/chatter' + url;\n  } else {\n    return url;\n  }\n};\n\n/**\n * @typedef {Object} Chatter~RequestParams\n * @prop {String} method - HTTP method\n * @prop {String} url - Resource URL\n * @prop {String} [body] - HTTP body (in POST/PUT/PATCH methods)\n */\n\n/**\n * @typedef {Object} Chatter~RequestResult\n */\n\n/**\n * Make a request for chatter API resource\n *\n * @param {Chatter~RequestParams} params - Paramters representing HTTP request\n * @param {Callback.<Chatter~RequestResult>} [callback] - Callback func\n * @returns {Chatter~Request}\n */\nChatter.prototype.request = function(params, callback) {\n  return new Request(this, params).thenCall(callback);\n};\n\n/**\n * Make a resource request to chatter API\n *\n * @param {String} url - Resource URL\n * @param {Object} [queryParams] - Query parameters (in hash object)\n * @returns {Chatter~Resource}\n */\nChatter.prototype.resource = function(url, queryParams) {\n  return new Resource(this, url, queryParams);\n};\n\n/**\n * @typedef {Object} Chatter~BatchRequestResult\n * @prop {Boolean} hasError - Flag if the batch has one or more errors\n * @prop {Array.<Object>} results - Batch request results in array\n * @prop {Number} results.statusCode - HTTP response status code\n * @prop {Chatter~RequestResult} results.result - Parsed HTTP response body\n */\n\n/**\n * Make a batch request to chatter API\n *\n * @params {Array.<Chatter~Request>} requests - Chatter API requests\n * @param {Callback.<Chatter~BatchRequestResult>} [callback] - Callback func\n * @returns {Promise.<Chatter~BatchRequestResult>}\n */\nChatter.prototype.batch = function(requests, callback) {\n  var self = this;\n  var batchRequests = [], batchDeferreds = [];\n  _.forEach(requests, function(request) {\n    var deferred = Promise.defer();\n    request._promise = deferred.promise;\n    batchRequests.push(request.batchParams());\n    batchDeferreds.push(deferred);\n  });\n  var params = {\n    method: 'POST',\n    url: this._normalizeUrl('/connect/batch'),\n    body: {\n      batchRequests: batchRequests\n    }\n  };\n  return this.request(params).then(function(res) {\n    _.forEach(res.results, function(result, i) {\n      var deferred = batchDeferreds[i];\n      if (result.statusCode >= 400) {\n        deferred.reject(result.result);\n      } else {\n        deferred.resolve(result.result);\n      }\n    });\n    return res;\n  }).thenCall(callback);\n};\n\n\n/*--------------------------------------------*/\n/**\n * A class representing chatter API request\n *\n * @protected\n * @class Chatter~Request\n * @implements {Promise.<Chatter~RequestResult>}\n * @param {Chatter} chatter - Chatter API object\n * @param {Chatter~RequestParams} params - Paramters representing HTTP request\n */\nvar Request = function(chatter, params) {\n  this._chatter = chatter;\n  this._params = params;\n  this._promise = null;\n};\n\n/**\n * @typedef {Object} Chatter~BatchRequestParams\n * @prop {String} method - HTTP method\n * @prop {String} url - Resource URL\n * @prop {String} [richInput] - HTTP body (in POST/PUT/PATCH methods)\n */\n\n/**\n * Retrieve parameters in batch request form\n *\n * @method Chatter~Request#batchParams\n * @returns {Chatter~BatchRequestParams}\n */\nRequest.prototype.batchParams = function() {\n  var params = this._params;\n  var batchParams = {\n    method: params.method,\n    url: this._chatter._normalizeUrl(params.url)\n  };\n  if (this._params.body) {\n    batchParams.richInput = this._params.body;\n  }\n  return batchParams;\n};\n\n/**\n * Retrieve parameters in batch request form\n *\n * @method Chatter~Request#promise\n * @returns {Promise.<Chatter~RequestResult>}\n */\nRequest.prototype.promise = function() {\n  return this._promise || this._chatter._request(this._params);\n};\n\n/**\n * Returns Node.js Stream object for request\n *\n * @method Chatter~Request#stream\n * @returns {stream.Stream}\n */\nRequest.prototype.stream = function() {\n  return this._chatter._request(this._params).stream();\n};\n\n/**\n * Promise/A+ interface\n * http://promises-aplus.github.io/promises-spec/\n *\n * Delegate to deferred promise, return promise instance for batch result\n *\n * @method Chatter~Request#then\n */\nRequest.prototype.then = function(onResolve, onReject) {\n  return this.promise().then(onResolve, onReject);\n};\n\n/**\n * Promise/A+ extension\n * Call \"then\" using given node-style callback function\n *\n * @method Chatter~Request#thenCall\n */\nRequest.prototype.thenCall = function(callback) {\n  return _.isFunction(callback) ? this.promise().thenCall(callback) : this;\n};\n\n\n/*--------------------------------------------*/\n/**\n * A class representing chatter API resource\n *\n * @protected\n * @class Chatter~Resource\n * @extends Chatter~Request\n * @param {Chatter} chatter - Chatter API object\n * @param {String} url - Resource URL\n * @param {Object} [queryParams] - Query parameters (in hash object)\n */\nvar Resource = function(chatter, url, queryParams) {\n  if (queryParams) {\n    var qstring = _.map(_.keys(queryParams), function(name) {\n      return name + \"=\" + encodeURIComponent(queryParams[name]);\n    }).join('&');\n    url += (url.indexOf('?') > 0 ? '&' : '?') + qstring;\n  }\n  Resource.super_.call(this, chatter, { method: 'GET', url: url });\n  this._url = url;\n};\n\ninherits(Resource, Request);\n\n/**\n * Create a new resource\n *\n * @method Chatter~Resource#create\n * @param {Object} data - Data to newly post\n * @param {Callback.<Chatter~RequestResult>} [callback] - Callback function\n * @returns {Chatter~Request}\n */\nResource.prototype.create = function(data, callback) {\n  return this._chatter.request({\n    method: 'POST',\n    url: this._url,\n    body: data\n  }).thenCall(callback);\n};\n\n/**\n * Retrieve resource content\n *\n * @method Chatter~Resource#retrieve\n * @param {Callback.<Chatter~RequestResult>} [callback] - Callback function\n * @returns {Chatter~Request}\n */\nResource.prototype.retrieve = function(callback) {\n  return this.thenCall(callback);\n};\n\n/**\n * Update specified resource\n *\n * @method Chatter~Resource#update\n * @param {Object} data - Data to update\n * @param {Callback.<Chatter~RequestResult>} [callback] - Callback function\n * @returns {Chatter~Request}\n */\nResource.prototype.update = function(data, callback) {\n  return this._chatter.request({\n    method: 'PATCH',\n    url: this._url,\n    body: data\n  }).thenCall(callback);\n};\n\n/**\n * Synonym of Resource#delete()\n *\n * @method Chatter~Resource#del\n * @param {Callback.<Chatter~RequestResult>} [callback] - Callback function\n * @returns {Chatter~Request}\n */\n/**\n * Delete specified resource\n *\n * @method Chatter~Resource#delete\n * @param {Callback.<Chatter~RequestResult>} [callback] - Callback function\n * @returns {Chatter~Request}\n */\nResource.prototype.del =\nResource.prototype[\"delete\"] = function(callback) {\n  return this._chatter.request({\n    method: 'DELETE',\n    url: this._url\n  }).thenCall(callback);\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.chatter = new Chatter(conn);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL2NoYXR0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDJEQUFVO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyx3REFBYTtBQUNuQyxjQUFjLG1CQUFPLENBQUMseURBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLCtEQUFZOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxrQ0FBa0M7QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsU0FBUztBQUNuQixVQUFVLGdCQUFnQjtBQUMxQixVQUFVLFFBQVE7QUFDbEIsVUFBVSx1QkFBdUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsV0FBVyx1Q0FBdUM7QUFDbEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLFdBQVcsU0FBUztBQUNwQixXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdDQUF3Qyx5QkFBeUI7QUFDakU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtDQUFrQztBQUM3QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQ0FBa0M7QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsa0NBQWtDO0FBQzdDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtDQUFrQztBQUM3QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2FwaS9jaGF0dGVyLmpzPzU1MmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBNYW5hZ2VzIFNhbGVzZm9yY2UgQ2hhdHRlciBSRVNUIEFQSSBjYWxsc1xuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgIF8gICAgICAgPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpLFxuICAgIGpzZm9yY2UgPSByZXF1aXJlKCcuLi9jb3JlJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4uL3Byb21pc2UnKTtcblxuLyoqXG4gKiBBUEkgY2xhc3MgZm9yIENoYXR0ZXIgUkVTVCBBUEkgY2FsbFxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIENvbm5lY3Rpb25cbiAqL1xudmFyIENoYXR0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbm4pIHtcbiAgdGhpcy5fY29ubiA9IGNvbm47XG59O1xuXG4vKipcbiAqIFNlbmRpbmcgcmVxdWVzdCB0byBBUEkgZW5kcG9pbnRcbiAqIEBwcml2YXRlXG4gKi9cbkNoYXR0ZXIucHJvdG90eXBlLl9yZXF1ZXN0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBpZiAoL14ocHV0fHBvc3R8cGF0Y2gpJC9pLnRlc3QocGFyYW1zLm1ldGhvZCkpIHtcbiAgICBpZiAoXy5pc09iamVjdChwYXJhbXMuYm9keSkpIHtcbiAgICAgIHBhcmFtcy5oZWFkZXJzID0ge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfTtcbiAgICAgIHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zLmJvZHkpO1xuICAgIH1cbiAgfVxuICBwYXJhbXMudXJsID0gdGhpcy5fbm9ybWFsaXplVXJsKHBhcmFtcy51cmwpO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHBhdGggdG8gc2l0ZSByb290IHJlbGF0aXZlIHVybFxuICogQHByaXZhdGVcbiAqL1xuQ2hhdHRlci5wcm90b3R5cGUuX25vcm1hbGl6ZVVybCA9IGZ1bmN0aW9uKHVybCkge1xuICBpZiAodXJsLmluZGV4T2YoJy9jaGF0dGVyLycpID09PSAwIHx8IHVybC5pbmRleE9mKCcvY29ubmVjdC8nKSA9PT0gMCkge1xuICAgIHJldHVybiAnL3NlcnZpY2VzL2RhdGEvdicgKyB0aGlzLl9jb25uLnZlcnNpb24gKyB1cmw7XG4gIH0gZWxzZSBpZiAoL15cXC92W1xcZF0rXFwuW1xcZF0rXFwvLy50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gJy9zZXJ2aWNlcy9kYXRhJyArIHVybDtcbiAgfSBlbHNlIGlmICh1cmwuaW5kZXhPZignL3NlcnZpY2VzLycpICE9PSAwICYmIHVybFswXSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuICcvc2VydmljZXMvZGF0YS92JyArIHRoaXMuX2Nvbm4udmVyc2lvbiArICcvY2hhdHRlcicgKyB1cmw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDaGF0dGVyflJlcXVlc3RQYXJhbXNcbiAqIEBwcm9wIHtTdHJpbmd9IG1ldGhvZCAtIEhUVFAgbWV0aG9kXG4gKiBAcHJvcCB7U3RyaW5nfSB1cmwgLSBSZXNvdXJjZSBVUkxcbiAqIEBwcm9wIHtTdHJpbmd9IFtib2R5XSAtIEhUVFAgYm9keSAoaW4gUE9TVC9QVVQvUEFUQ0ggbWV0aG9kcylcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENoYXR0ZXJ+UmVxdWVzdFJlc3VsdFxuICovXG5cbi8qKlxuICogTWFrZSBhIHJlcXVlc3QgZm9yIGNoYXR0ZXIgQVBJIHJlc291cmNlXG4gKlxuICogQHBhcmFtIHtDaGF0dGVyflJlcXVlc3RQYXJhbXN9IHBhcmFtcyAtIFBhcmFtdGVycyByZXByZXNlbnRpbmcgSFRUUCByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxDaGF0dGVyflJlcXVlc3RSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY1xuICogQHJldHVybnMge0NoYXR0ZXJ+UmVxdWVzdH1cbiAqL1xuQ2hhdHRlci5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHBhcmFtcykudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgcmVzb3VyY2UgcmVxdWVzdCB0byBjaGF0dGVyIEFQSVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBSZXNvdXJjZSBVUkxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcXVlcnlQYXJhbXNdIC0gUXVlcnkgcGFyYW1ldGVycyAoaW4gaGFzaCBvYmplY3QpXG4gKiBAcmV0dXJucyB7Q2hhdHRlcn5SZXNvdXJjZX1cbiAqL1xuQ2hhdHRlci5wcm90b3R5cGUucmVzb3VyY2UgPSBmdW5jdGlvbih1cmwsIHF1ZXJ5UGFyYW1zKSB7XG4gIHJldHVybiBuZXcgUmVzb3VyY2UodGhpcywgdXJsLCBxdWVyeVBhcmFtcyk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENoYXR0ZXJ+QmF0Y2hSZXF1ZXN0UmVzdWx0XG4gKiBAcHJvcCB7Qm9vbGVhbn0gaGFzRXJyb3IgLSBGbGFnIGlmIHRoZSBiYXRjaCBoYXMgb25lIG9yIG1vcmUgZXJyb3JzXG4gKiBAcHJvcCB7QXJyYXkuPE9iamVjdD59IHJlc3VsdHMgLSBCYXRjaCByZXF1ZXN0IHJlc3VsdHMgaW4gYXJyYXlcbiAqIEBwcm9wIHtOdW1iZXJ9IHJlc3VsdHMuc3RhdHVzQ29kZSAtIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwcm9wIHtDaGF0dGVyflJlcXVlc3RSZXN1bHR9IHJlc3VsdHMucmVzdWx0IC0gUGFyc2VkIEhUVFAgcmVzcG9uc2UgYm9keVxuICovXG5cbi8qKlxuICogTWFrZSBhIGJhdGNoIHJlcXVlc3QgdG8gY2hhdHRlciBBUElcbiAqXG4gKiBAcGFyYW1zIHtBcnJheS48Q2hhdHRlcn5SZXF1ZXN0Pn0gcmVxdWVzdHMgLSBDaGF0dGVyIEFQSSByZXF1ZXN0c1xuICogQHBhcmFtIHtDYWxsYmFjay48Q2hhdHRlcn5CYXRjaFJlcXVlc3RSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY1xuICogQHJldHVybnMge1Byb21pc2UuPENoYXR0ZXJ+QmF0Y2hSZXF1ZXN0UmVzdWx0Pn1cbiAqL1xuQ2hhdHRlci5wcm90b3R5cGUuYmF0Y2ggPSBmdW5jdGlvbihyZXF1ZXN0cywgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYmF0Y2hSZXF1ZXN0cyA9IFtdLCBiYXRjaERlZmVycmVkcyA9IFtdO1xuICBfLmZvckVhY2gocmVxdWVzdHMsIGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBQcm9taXNlLmRlZmVyKCk7XG4gICAgcmVxdWVzdC5fcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2U7XG4gICAgYmF0Y2hSZXF1ZXN0cy5wdXNoKHJlcXVlc3QuYmF0Y2hQYXJhbXMoKSk7XG4gICAgYmF0Y2hEZWZlcnJlZHMucHVzaChkZWZlcnJlZCk7XG4gIH0pO1xuICB2YXIgcGFyYW1zID0ge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogdGhpcy5fbm9ybWFsaXplVXJsKCcvY29ubmVjdC9iYXRjaCcpLFxuICAgIGJvZHk6IHtcbiAgICAgIGJhdGNoUmVxdWVzdHM6IGJhdGNoUmVxdWVzdHNcbiAgICB9XG4gIH07XG4gIHJldHVybiB0aGlzLnJlcXVlc3QocGFyYW1zKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgIF8uZm9yRWFjaChyZXMucmVzdWx0cywgZnVuY3Rpb24ocmVzdWx0LCBpKSB7XG4gICAgICB2YXIgZGVmZXJyZWQgPSBiYXRjaERlZmVycmVkc1tpXTtcbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KHJlc3VsdC5yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQucmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBjaGF0dGVyIEFQSSByZXF1ZXN0XG4gKlxuICogQHByb3RlY3RlZFxuICogQGNsYXNzIENoYXR0ZXJ+UmVxdWVzdFxuICogQGltcGxlbWVudHMge1Byb21pc2UuPENoYXR0ZXJ+UmVxdWVzdFJlc3VsdD59XG4gKiBAcGFyYW0ge0NoYXR0ZXJ9IGNoYXR0ZXIgLSBDaGF0dGVyIEFQSSBvYmplY3RcbiAqIEBwYXJhbSB7Q2hhdHRlcn5SZXF1ZXN0UGFyYW1zfSBwYXJhbXMgLSBQYXJhbXRlcnMgcmVwcmVzZW50aW5nIEhUVFAgcmVxdWVzdFxuICovXG52YXIgUmVxdWVzdCA9IGZ1bmN0aW9uKGNoYXR0ZXIsIHBhcmFtcykge1xuICB0aGlzLl9jaGF0dGVyID0gY2hhdHRlcjtcbiAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuICB0aGlzLl9wcm9taXNlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2hhdHRlcn5CYXRjaFJlcXVlc3RQYXJhbXNcbiAqIEBwcm9wIHtTdHJpbmd9IG1ldGhvZCAtIEhUVFAgbWV0aG9kXG4gKiBAcHJvcCB7U3RyaW5nfSB1cmwgLSBSZXNvdXJjZSBVUkxcbiAqIEBwcm9wIHtTdHJpbmd9IFtyaWNoSW5wdXRdIC0gSFRUUCBib2R5IChpbiBQT1NUL1BVVC9QQVRDSCBtZXRob2RzKVxuICovXG5cbi8qKlxuICogUmV0cmlldmUgcGFyYW1ldGVycyBpbiBiYXRjaCByZXF1ZXN0IGZvcm1cbiAqXG4gKiBAbWV0aG9kIENoYXR0ZXJ+UmVxdWVzdCNiYXRjaFBhcmFtc1xuICogQHJldHVybnMge0NoYXR0ZXJ+QmF0Y2hSZXF1ZXN0UGFyYW1zfVxuICovXG5SZXF1ZXN0LnByb3RvdHlwZS5iYXRjaFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyYW1zID0gdGhpcy5fcGFyYW1zO1xuICB2YXIgYmF0Y2hQYXJhbXMgPSB7XG4gICAgbWV0aG9kOiBwYXJhbXMubWV0aG9kLFxuICAgIHVybDogdGhpcy5fY2hhdHRlci5fbm9ybWFsaXplVXJsKHBhcmFtcy51cmwpXG4gIH07XG4gIGlmICh0aGlzLl9wYXJhbXMuYm9keSkge1xuICAgIGJhdGNoUGFyYW1zLnJpY2hJbnB1dCA9IHRoaXMuX3BhcmFtcy5ib2R5O1xuICB9XG4gIHJldHVybiBiYXRjaFBhcmFtcztcbn07XG5cbi8qKlxuICogUmV0cmlldmUgcGFyYW1ldGVycyBpbiBiYXRjaCByZXF1ZXN0IGZvcm1cbiAqXG4gKiBAbWV0aG9kIENoYXR0ZXJ+UmVxdWVzdCNwcm9taXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48Q2hhdHRlcn5SZXF1ZXN0UmVzdWx0Pn1cbiAqL1xuUmVxdWVzdC5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcHJvbWlzZSB8fCB0aGlzLl9jaGF0dGVyLl9yZXF1ZXN0KHRoaXMuX3BhcmFtcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgTm9kZS5qcyBTdHJlYW0gb2JqZWN0IGZvciByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBDaGF0dGVyflJlcXVlc3Qjc3RyZWFtXG4gKiBAcmV0dXJucyB7c3RyZWFtLlN0cmVhbX1cbiAqL1xuUmVxdWVzdC5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jaGF0dGVyLl9yZXF1ZXN0KHRoaXMuX3BhcmFtcykuc3RyZWFtKCk7XG59O1xuXG4vKipcbiAqIFByb21pc2UvQSsgaW50ZXJmYWNlXG4gKiBodHRwOi8vcHJvbWlzZXMtYXBsdXMuZ2l0aHViLmlvL3Byb21pc2VzLXNwZWMvXG4gKlxuICogRGVsZWdhdGUgdG8gZGVmZXJyZWQgcHJvbWlzZSwgcmV0dXJuIHByb21pc2UgaW5zdGFuY2UgZm9yIGJhdGNoIHJlc3VsdFxuICpcbiAqIEBtZXRob2QgQ2hhdHRlcn5SZXF1ZXN0I3RoZW5cbiAqL1xuUmVxdWVzdC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uUmVzb2x2ZSwgb25SZWplY3QpIHtcbiAgcmV0dXJuIHRoaXMucHJvbWlzZSgpLnRoZW4ob25SZXNvbHZlLCBvblJlamVjdCk7XG59O1xuXG4vKipcbiAqIFByb21pc2UvQSsgZXh0ZW5zaW9uXG4gKiBDYWxsIFwidGhlblwiIHVzaW5nIGdpdmVuIG5vZGUtc3R5bGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqXG4gKiBAbWV0aG9kIENoYXR0ZXJ+UmVxdWVzdCN0aGVuQ2FsbFxuICovXG5SZXF1ZXN0LnByb3RvdHlwZS50aGVuQ2FsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiBfLmlzRnVuY3Rpb24oY2FsbGJhY2spID8gdGhpcy5wcm9taXNlKCkudGhlbkNhbGwoY2FsbGJhY2spIDogdGhpcztcbn07XG5cblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGNoYXR0ZXIgQVBJIHJlc291cmNlXG4gKlxuICogQHByb3RlY3RlZFxuICogQGNsYXNzIENoYXR0ZXJ+UmVzb3VyY2VcbiAqIEBleHRlbmRzIENoYXR0ZXJ+UmVxdWVzdFxuICogQHBhcmFtIHtDaGF0dGVyfSBjaGF0dGVyIC0gQ2hhdHRlciBBUEkgb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gUmVzb3VyY2UgVVJMXG4gKiBAcGFyYW0ge09iamVjdH0gW3F1ZXJ5UGFyYW1zXSAtIFF1ZXJ5IHBhcmFtZXRlcnMgKGluIGhhc2ggb2JqZWN0KVxuICovXG52YXIgUmVzb3VyY2UgPSBmdW5jdGlvbihjaGF0dGVyLCB1cmwsIHF1ZXJ5UGFyYW1zKSB7XG4gIGlmIChxdWVyeVBhcmFtcykge1xuICAgIHZhciBxc3RyaW5nID0gXy5tYXAoXy5rZXlzKHF1ZXJ5UGFyYW1zKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWUgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChxdWVyeVBhcmFtc1tuYW1lXSk7XG4gICAgfSkuam9pbignJicpO1xuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA+IDAgPyAnJicgOiAnPycpICsgcXN0cmluZztcbiAgfVxuICBSZXNvdXJjZS5zdXBlcl8uY2FsbCh0aGlzLCBjaGF0dGVyLCB7IG1ldGhvZDogJ0dFVCcsIHVybDogdXJsIH0pO1xuICB0aGlzLl91cmwgPSB1cmw7XG59O1xuXG5pbmhlcml0cyhSZXNvdXJjZSwgUmVxdWVzdCk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHJlc291cmNlXG4gKlxuICogQG1ldGhvZCBDaGF0dGVyflJlc291cmNlI2NyZWF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBEYXRhIHRvIG5ld2x5IHBvc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPENoYXR0ZXJ+UmVxdWVzdFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0NoYXR0ZXJ+UmVxdWVzdH1cbiAqL1xuUmVzb3VyY2UucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jaGF0dGVyLnJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogdGhpcy5fdXJsLFxuICAgIGJvZHk6IGRhdGFcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSByZXNvdXJjZSBjb250ZW50XG4gKlxuICogQG1ldGhvZCBDaGF0dGVyflJlc291cmNlI3JldHJpZXZlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxDaGF0dGVyflJlcXVlc3RSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtDaGF0dGVyflJlcXVlc3R9XG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5yZXRyaWV2ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHNwZWNpZmllZCByZXNvdXJjZVxuICpcbiAqIEBtZXRob2QgQ2hhdHRlcn5SZXNvdXJjZSN1cGRhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byB1cGRhdGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPENoYXR0ZXJ+UmVxdWVzdFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0NoYXR0ZXJ+UmVxdWVzdH1cbiAqL1xuUmVzb3VyY2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jaGF0dGVyLnJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICB1cmw6IHRoaXMuX3VybCxcbiAgICBib2R5OiBkYXRhXG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU3lub255bSBvZiBSZXNvdXJjZSNkZWxldGUoKVxuICpcbiAqIEBtZXRob2QgQ2hhdHRlcn5SZXNvdXJjZSNkZWxcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPENoYXR0ZXJ+UmVxdWVzdFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0NoYXR0ZXJ+UmVxdWVzdH1cbiAqL1xuLyoqXG4gKiBEZWxldGUgc3BlY2lmaWVkIHJlc291cmNlXG4gKlxuICogQG1ldGhvZCBDaGF0dGVyflJlc291cmNlI2RlbGV0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48Q2hhdHRlcn5SZXF1ZXN0UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7Q2hhdHRlcn5SZXF1ZXN0fVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuZGVsID1cblJlc291cmNlLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jaGF0dGVyLnJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgdXJsOiB0aGlzLl91cmxcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qXG4gKiBSZWdpc3RlciBob29rIGluIGNvbm5lY3Rpb24gaW5zdGFudGlhdGlvbiBmb3IgZHluYW1pY2FsbHkgYWRkaW5nIHRoaXMgQVBJIG1vZHVsZSBmZWF0dXJlc1xuICovXG5qc2ZvcmNlLm9uKCdjb25uZWN0aW9uOm5ldycsIGZ1bmN0aW9uKGNvbm4pIHtcbiAgY29ubi5jaGF0dGVyID0gbmV3IENoYXR0ZXIoY29ubik7XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/api/chatter.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/api/index.js":
/*!***********************************************!*\
  !*** ./node_modules/jsforce/lib/api/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! ./analytics */ \"(action-browser)/./node_modules/jsforce/lib/api/analytics.js\");\n__webpack_require__(/*! ./apex */ \"(action-browser)/./node_modules/jsforce/lib/api/apex.js\");\n__webpack_require__(/*! ./bulk */ \"(action-browser)/./node_modules/jsforce/lib/api/bulk.js\");\n__webpack_require__(/*! ./chatter */ \"(action-browser)/./node_modules/jsforce/lib/api/chatter.js\");\n__webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/jsforce/lib/api/metadata.js\");\n__webpack_require__(/*! ./soap */ \"(action-browser)/./node_modules/jsforce/lib/api/soap.js\");\n__webpack_require__(/*! ./streaming */ \"(action-browser)/./node_modules/jsforce/lib/api/streaming.js\");\n__webpack_require__(/*! ./tooling */ \"(action-browser)/./node_modules/jsforce/lib/api/tooling.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsbUJBQU8sQ0FBQyxpRkFBYTtBQUNyQixtQkFBTyxDQUFDLHVFQUFRO0FBQ2hCLG1CQUFPLENBQUMsdUVBQVE7QUFDaEIsbUJBQU8sQ0FBQyw2RUFBVztBQUNuQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3BCLG1CQUFPLENBQUMsdUVBQVE7QUFDaEIsbUJBQU8sQ0FBQyxpRkFBYTtBQUNyQixtQkFBTyxDQUFDLDZFQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvaW5kZXguanM/OGMzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL2FuYWx5dGljcycpO1xucmVxdWlyZSgnLi9hcGV4Jyk7XG5yZXF1aXJlKCcuL2J1bGsnKTtcbnJlcXVpcmUoJy4vY2hhdHRlcicpO1xucmVxdWlyZSgnLi9tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9zb2FwJyk7XG5yZXF1aXJlKCcuL3N0cmVhbWluZycpO1xucmVxdWlyZSgnLi90b29saW5nJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/api/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/api/index.js":
/*!***********************************************!*\
  !*** ./node_modules/jsforce/lib/api/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! ./analytics */ \"(rsc)/./node_modules/jsforce/lib/api/analytics.js\");\n__webpack_require__(/*! ./apex */ \"(rsc)/./node_modules/jsforce/lib/api/apex.js\");\n__webpack_require__(/*! ./bulk */ \"(rsc)/./node_modules/jsforce/lib/api/bulk.js\");\n__webpack_require__(/*! ./chatter */ \"(rsc)/./node_modules/jsforce/lib/api/chatter.js\");\n__webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/jsforce/lib/api/metadata.js\");\n__webpack_require__(/*! ./soap */ \"(rsc)/./node_modules/jsforce/lib/api/soap.js\");\n__webpack_require__(/*! ./streaming */ \"(rsc)/./node_modules/jsforce/lib/api/streaming.js\");\n__webpack_require__(/*! ./tooling */ \"(rsc)/./node_modules/jsforce/lib/api/tooling.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFPLENBQUMsc0VBQWE7QUFDckIsbUJBQU8sQ0FBQyw0REFBUTtBQUNoQixtQkFBTyxDQUFDLDREQUFRO0FBQ2hCLG1CQUFPLENBQUMsa0VBQVc7QUFDbkIsbUJBQU8sQ0FBQyxvRUFBWTtBQUNwQixtQkFBTyxDQUFDLDREQUFRO0FBQ2hCLG1CQUFPLENBQUMsc0VBQWE7QUFDckIsbUJBQU8sQ0FBQyxrRUFBVyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL2luZGV4LmpzPzM4Y2QiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9hbmFseXRpY3MnKTtcbnJlcXVpcmUoJy4vYXBleCcpO1xucmVxdWlyZSgnLi9idWxrJyk7XG5yZXF1aXJlKCcuL2NoYXR0ZXInKTtcbnJlcXVpcmUoJy4vbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vc29hcCcpO1xucmVxdWlyZSgnLi9zdHJlYW1pbmcnKTtcbnJlcXVpcmUoJy4vdG9vbGluZycpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/api/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/api/metadata.js":
/*!**************************************************!*\
  !*** ./node_modules/jsforce/lib/api/metadata.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global process, Buffer */\n/**\n * @file Manages Salesforce Metadata API\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\"),\n    events  = __webpack_require__(/*! events */ \"events\"),\n    stream  = __webpack_require__(/*! readable-stream */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/readable.js\"),\n    _       = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    jsforce = __webpack_require__(/*! ../core */ \"(action-browser)/./node_modules/jsforce/lib/core.js\"),\n    Promise = __webpack_require__(/*! ../promise */ \"(action-browser)/./node_modules/jsforce/lib/promise.js\"),\n    SOAP    = __webpack_require__(/*! ../soap */ \"(action-browser)/./node_modules/jsforce/lib/soap.js\");\n\n/*--------------------------------------------*/\n/**\n * Class for Salesforce Metadata API\n *\n * @class\n * @param {Connection} conn - Connection object\n */\nvar Metadata = module.exports = function(conn) {\n  this._conn = conn;\n};\n\n\n/**\n * Polling interval in milliseconds\n * @type {Number}\n */\nMetadata.prototype.pollInterval = 1000;\n\n/**\n * Polling timeout in milliseconds\n * @type {Number}\n */\nMetadata.prototype.pollTimeout = 10000;\n\n\n/**\n * Call Metadata API SOAP endpoint\n *\n * @private\n */\nMetadata.prototype._invoke = function(method, message, callback) {\n  var soapEndpoint = new SOAP(this._conn, {\n    xmlns: \"http://soap.sforce.com/2006/04/metadata\",\n    endpointUrl: this._conn.instanceUrl + \"/services/Soap/m/\" + this._conn.version\n  });\n  return soapEndpoint.invoke(method, message).then(function(res) {\n    return res.result;\n  }).thenCall(callback);\n};\n\n\n/**\n * @typedef {Object} Metadata~MetadataInfo\n * @prop {String} fullName - The name of the component\n */\n\n/**\n * Asynchronously adds one or more new metadata components to the organization.\n *\n * @param {String} type - The type of metadata to create\n * @param {Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>} metadata - Metadata to create\n * @param {Callback.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} [callback] - Callback function\n * @returns {Metadata~AsyncResultLocator}\n */\nMetadata.prototype.createAsync = function(type, metadata, callback) {\n  if (Number(this._conn.version) > 30) {\n    throw new Error(\"Async metadata CRUD calls are not supported on ver 31.0 or later.\");\n  }\n  var convert = function(md) {\n    md[\"@xsi:type\"] = type;\n    return md;\n  };\n  var isArray = _.isArray(metadata);\n  metadata = isArray ? _.map(metadata, convert) : convert(metadata);\n  var res = this._invoke(\"create\", { metadata: metadata });\n  return new AsyncResultLocator(this, res, isArray).thenCall(callback);\n};\n\n/**\n * @typedef {Object} Metadata~SaveResult\n * @prop {Boolean} success - True if metadata is successfully saved\n * @prop {String} fullName - Full name of metadata object\n */\n\n/**\n * @private\n */\nfunction convertToSaveResult(result) {\n  var saveResult = _.clone(result);\n  saveResult.success = saveResult.success === 'true';\n  return saveResult;\n}\n\n/**\n * @typedef {Object} Metadata~UpsertResult\n * @prop {Boolean} success - True if metadata is successfully saved\n * @prop {String} fullName - Full name of metadata object\n * @prop {Boolean} created - True if metadata is newly created\n */\n\n/**\n * @private\n */\nfunction convertToUpsertResult(result) {\n  var upsertResult = convertToSaveResult(result);\n  upsertResult.created = upsertResult.created === 'true';\n  return upsertResult;\n}\n\n/**\n * Synonym of Metadata#create().\n *\n * @method Metadata#createSync\n * @param {String} type - The type of metadata to create\n * @param {Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>} metadata - Metadata to create\n * @param {Callback.<Metadata~SaveResult|Array.<Metadata~SaveResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~SaveResult|Array.<Metadata~SaveResult>>}\n */\n/**\n * Synchronously adds one or more new metadata components to the organization.\n *\n * @method Metadata#create\n * @param {String} type - The type of metadata to create\n * @param {Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>} metadata - Metadata to create\n * @param {Callback.<Metadata~SaveResult|Array.<Metadata~SaveResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~SaveResult|Array.<Metadata~SaveResult>>}\n */\nMetadata.prototype.createSync =\nMetadata.prototype.create = function(type, metadata, callback) {\n  var convert = function(md) {\n    md[\"@xsi:type\"] = type;\n    return md;\n  };\n  var isArray = _.isArray(metadata);\n  metadata = isArray ? _.map(metadata, convert) : convert(metadata);\n  return this._invoke(\"createMetadata\", { metadata: metadata }).then(function(results) {\n    return _.isArray(results) ? _.map(results, convertToSaveResult) : convertToSaveResult(results);\n  }).thenCall(callback);\n};\n\n/**\n * @private\n */\nfunction convertToMetadataInfo(rec) {\n  var metadataInfo = _.clone(rec);\n  delete metadataInfo.$;\n  return metadataInfo;\n}\n\n/**\n * Synonym of Metadata#read()\n *\n * @method Metadata#readSync\n * @param {String} type - The type of metadata to read\n * @param {String|Array.<String>} fullNames - full name(s) of metadata objects to read\n * @param {Callback.<Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>>>}\n */\n/**\n * Synchronously read specified metadata components in the organization.\n *\n * @method Metadata#read\n * @param {String} type - The type of metadata to read\n * @param {String|Array.<String>} fullNames - full name(s) of metadata objects to read\n * @param {Callback.<Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>>>}\n */\nMetadata.prototype.readSync =\nMetadata.prototype.read = function(type, fullNames, callback) {\n  return this._invoke(\"readMetadata\", { type: type, fullNames: fullNames }).then(function(res) {\n    return _.isArray(res.records) ? _.map(res.records, convertToMetadataInfo) : convertToMetadataInfo(res.records);\n  }).thenCall(callback);\n};\n\n/**\n * @typedef {Object} Metadata~UpdateMetadataInfo\n * @prop {String} currentName - The API name of the component or field before the update\n * @prop {Metadata~MetadataInfo} metadata - Full specification of the component or field you wish to update\n */\n\n/**\n * Asynchronously updates one or more metadata components in the organization.\n *\n * @param {String} type - The type of metadata to update\n * @param {Metadata~UpdateMetadataInfo|Array.<Metadata~UpdateMetadataInfo>} updateMetadata - Updating metadata\n * @param {Callback.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} [callback] - Callback function\n * @returns {Metadata~AsyncResultLocator}\n */\nMetadata.prototype.updateAsync = function(type, updateMetadata, callback) {\n  if (Number(this._conn.version) > 30) {\n    throw new Error(\"Async metadata CRUD calls are not supported on ver 31.0 or later.\");\n  }\n  var convert = function(umd) {\n    umd.metadata[\"@xsi:type\"] = type;\n    return umd;\n  };\n  var isArray = _.isArray(updateMetadata);\n  updateMetadata = isArray ? _.map(updateMetadata, convert) : convert(updateMetadata);\n  var res = this._invoke(\"update\", { updateMetadata: updateMetadata });\n  return new AsyncResultLocator(this, res, isArray).thenCall(callback);\n};\n\n/**\n * Synonym of Metadata#update().\n *\n * @method Metadata#updateSync\n * @param {String} type - The type of metadata to update\n * @param {Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>} updateMetadata - Updating metadata\n * @param {Callback.<Metadata~SaveResult|Array.<Metadata~SaveResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~SaveResult|Array.<Metadata~SaveResult>>}\n */\n/**\n * Synchronously updates one or more metadata components in the organization.\n *\n * @method Metadata#update\n * @param {String} type - The type of metadata to update\n * @param {Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>} updateMetadata - Updating metadata\n * @param {Callback.<Metadata~SaveResult|Array.<Metadata~SaveResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~SaveResult|Array.<Metadata~SaveResult>>}\n */\nMetadata.prototype.updateSync =\nMetadata.prototype.update = function(type, metadata, callback) {\n  var convert = function(md) {\n    md[\"@xsi:type\"] = type;\n    return md;\n  };\n  var isArray = _.isArray(metadata);\n  metadata = isArray ? _.map(metadata, convert) : convert(metadata);\n  return this._invoke(\"updateMetadata\", { metadata: metadata }).then(function(results) {\n    return _.isArray(results) ? _.map(results, convertToSaveResult) : convertToSaveResult(results);\n  }).thenCall(callback);\n};\n\n/**\n * Synonym of Metadata#upsert().\n *\n * @method Metadata#upsertSync\n * @param {String} type - The type of metadata to upsert\n * @param {Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>} metadata - Upserting metadata\n * @param {Callback.<Metadata~UpsertResult|Array.<Metadata~UpsertResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~UpsertResult|Array.<Metadata~UpsertResult>>}\n */\n/**\n * Upserts one or more components in your organization's data.\n *\n * @method Metadata#upsert\n * @param {String} type - The type of metadata to upsert\n * @param {Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>} metadata - Upserting metadata\n * @param {Callback.<Metadata~UpsertResult|Array.<Metadata~UpsertResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~UpsertResult|Array.<Metadata~UpsertResult>>}\n */\nMetadata.prototype.upsertSync =\nMetadata.prototype.upsert = function(type, metadata, callback) {\n  var convert = function(md) {\n    md[\"@xsi:type\"] = type;\n    return md;\n  };\n  var isArray = _.isArray(metadata);\n  metadata = isArray ? _.map(metadata, convert) : convert(metadata);\n  return this._invoke(\"upsertMetadata\", { metadata: metadata }).then(function(results) {\n    return _.isArray(results) ? _.map(results, convertToUpsertResult) : convertToUpsertResult(results);\n  }).thenCall(callback);\n};\n\n/**\n * Asynchronously deletes specified metadata components in the organization.\n *\n * @param {String} type - The type of metadata to delete\n * @param {String|Metadata~MetadataInfo|Array.<String>|Array.<Metadata~MetadataInfo>} metadata - The fullName of metadata or metadata info to delete. If it is passed in fullName, the type parameter should not be empty.\n * @param {Callback.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} [callback] - Callback function\n * @returns {Metadata~AsyncResultLocator}\n */\nMetadata.prototype.deleteAsync = function(type, metadata, callback) {\n  if (Number(this._conn.version) > 30) {\n    throw new Error(\"Async metadata CRUD calls are not supported on ver 31.0 or later.\");\n  }\n  var convert = function(md) {\n    if (_.isString(md)) {\n      md = { fullName : md };\n    }\n    md[\"@xsi:type\"] = type;\n    return md;\n  };\n  var isArray = _.isArray(metadata);\n  metadata = isArray ? _.map(metadata, convert) : convert(metadata);\n  var res = this._invoke(\"delete\", { metadata: metadata });\n  return new AsyncResultLocator(this, res, isArray).thenCall(callback);\n};\n\n/**\n * Synonym of Metadata#delete().\n *\n * @deprecated\n * @method Metadata#del\n * @param {String} [type] - The type of metadata to delete\n * @param {String|Metadata~MetadataInfo|Array.<String>|Array.<Metadata~MetadataInfo>} metadata - The fullName of metadata or metadata info to delete. If it is passed in fullName, the type parameter should not be empty.\n * @param {Callback.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} [callback] - Callback function\n * @returns {Metadata~AsyncResultLocator}\n */\n/**\n * Synonym of Metadata#delete().\n *\n * @method Metadata#deleteSync\n * @param {String} type - The type of metadata to delete\n * @param {String|Array.<String>} fullNames - The fullName of metadata to delete.\n * @param {Callback.<Metadata~SaveResult|Array.<Metadata~SaveResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~SaveResult|Array.<Metadata~SaveResult>>}\n */\n\n/**\n * Synchronously deletes specified metadata components in the organization.\n *\n * @method Metadata#delete\n * @param {String} type - The type of metadata to delete\n * @param {String|Array.<String>} fullNames - The fullName of metadata to delete.\n * @param {Callback.<Metadata~SaveResult|Array.<Metadata~SaveResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~SaveResult|Array.<Metadata~SaveResult>>}\n */\nMetadata.prototype.del =\nMetadata.prototype.deleteSync =\nMetadata.prototype[\"delete\"] = function(type, fullNames, callback) {\n  return this._invoke(\"deleteMetadata\", { type: type, fullNames: fullNames }).then(function(results) {\n    return _.isArray(results) ? _.map(results, convertToSaveResult) : convertToSaveResult(results);\n  }).thenCall(callback);\n};\n\n/**\n * Rename fullname of a metadata component in the organization\n *\n * @param {String} type - The type of metadata to delete\n * @param {String} oldFullName - The original fullName of metadata\n * @param {String} newFullName - The new fullName of metadata\n * @param {Callback.<Metadata~SaveResult>} [callback] - Callback function\n * @returns {Promise.<Metadata~SaveResult>}\n */\nMetadata.prototype.rename = function(type, oldFullName, newFullName, callback) {\n  return this._invoke(\"renameMetadata\", { type: type, oldFullName: oldFullName, newFullName: newFullName }).then(function(result) {\n    return convertToSaveResult(result);\n  }).thenCall(callback);\n};\n\n/**\n * Checks the status of asynchronous metadata calls\n *\n * @param {String|Array.<String>} ids - The asynchronous process ID(s)\n * @param {Callback.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} [callback] - Callback function\n * @returns {Metadata~AsyncResultLocator}\n */\nMetadata.prototype.checkStatus = function(ids, callback) {\n  var isArray = _.isArray(ids);\n  var res = this._invoke(\"checkStatus\", { asyncProcessId: ids });\n  return new AsyncResultLocator(this, res, isArray).thenCall(callback);\n};\n\n/**\n * @typedef {Object} Metadata~DescribeMetadataResult\n * @prop {Array.<Object>} metadataObjects - One or more metadata components and their attributes\n * @prop {Array.<String>} metadataObjects.childXmlNames - List of child sub-components for this component\n * @prop {String} metadataObjects.directoryName - The name of the directory in the .zip file that contains this component\n * @prop {Boolean} metadataObjects.inFolder - Indicates whether the component is in a folder or not\n * @prop {Boolean} metadataObjects.metaFile - Indicates whether the component requires an accompanying metadata file\n * @prop {String} metadataObjects.suffix - The file suffix for this component\n * @prop {String} metadataObjects.xmlName - The name of the root element in the metadata file for this component\n * @prop {String} organizationNamespace - The namespace of the organization\n * @prop {Boolean} partialSaveAllowed - Indicates whether rollbackOnError is allowed or not\n * @prop {Boolean} testRequired - Indicates whether tests are required or not\n */\n\n/**\n * Retrieves the metadata which describes your organization, including Apex classes and triggers,\n * custom objects, custom fields on standard objects, tab sets that define an app,\n * and many other components.\n *\n * @param {String} [version] - The API version for which you want metadata; for example, 29.0\n * @param {Callback.<Metadata~DescribeMetadataResult>} [callback] - Callback function\n * @returns {Promise.<Metadata~DescribeMetadataResult>}\n */\nMetadata.prototype.describe = function(version, callback) {\n  if (!_.isString(version)) {\n    callback = version;\n    version = this._conn.version;\n  }\n  return this._invoke(\"describeMetadata\", { asOfVersion: version }).then(function(res) {\n    res.metadataObjects = _.isArray(res.metadataObjects) ? res.metadataObjects : [ res.metadataObjects ];\n    res.metadataObjects = _.map(res.metadataObjects, function(mo) {\n      if (mo.childXmlNames) {\n        mo.childXmlNames = _.isArray(mo.childXmlNames) ? mo.childXmlNames: [ mo.childXmlNames ];\n      }\n      mo.inFolder = mo.inFolder === 'true';\n      mo.metaFile = mo.metaFile === 'true';\n      return mo;\n    });\n    res.partialSaveAllowed = res.partialSaveAllowed === 'true';\n    res.testRequired = res.testRequired === 'true';\n    return res;\n  }).thenCall(callback);\n};\n\n/**\n * @typedef {Object} Metadata~ListMetadataQuery\n * @prop {String} type - The metadata type, such as CustomObject, CustomField, or ApexClass\n * @prop {String} [folder] - The folder associated with the component.\n */\n\n/**\n * @typedef {Object} Metadata~FileProperties\n * @prop {String} type - The metadata type, such as CustomObject, CustomField, or ApexClass\n * @prop {String} createdById - ID of the user who created the file\n * @prop {String} createdByName - Name of the user who created the file\n * @prop {String} createdDate - Date and time when the file was created\n * @prop {String} fileName - Name of the file\n * @prop {String} fullName - The file developer name used as a unique identifier for API access\n * @prop {String} id - ID of the file\n * @prop {String} lastModifiedById - ID of the user who last modified the file\n * @prop {String} lastModifiedByName - Name of the user who last modified the file\n * @prop {String} lastModifiedDate - Date and time that the file was last modified\n * @prop {String} [manageableState] - Indicates the manageable state of the specified component if it is contained in a package\n * @prop {String} [namespacePrefix] - The namespace prefix of the component\n */\n\n/**\n * Retrieves property information about metadata components in your organization\n *\n * @param {Metadata~ListMetadataQuery|Array.<Metadata~ListMetadataQuery>} queries - The criteria object(s) specifing metadata to list\n * @param {String} [version] - The API version for which you want metadata; for example, 29.0\n * @param {Callback.<Array.<Metadata~FileProperties>>} [callback] - Callback function\n * @returns {Promise.<Array.<Metadata~FileProperties>>}\n */\nMetadata.prototype.list = function(queries, version, callback) {\n  if (!_.isString(version)) {\n    callback = version;\n    version = this._conn.version;\n  }\n  if (!_.isArray(queries)) {\n    queries = [ queries ];\n  }\n  return this._invoke(\"listMetadata\", { queries: queries, asOfVersion: version }, callback);\n};\n\n/**\n * @typedef {Object} Metadata~RetrieveRequest\n */\n\n/**\n * Retrieves XML file representations of components in an organization\n *\n * @param {Metadata~RetrieveRequest} request - Options for determining which packages or files are retrieved\n * @param {Callback.<Metadata~AsyncResult>} [callback] - Callback function\n * @returns {Metadata~RetrieveResultLocator}\n */\nMetadata.prototype.retrieve = function(request, callback) {\n  var res = this._invoke(\"retrieve\", { request: request });\n  return new RetrieveResultLocator(this, res).thenCall(callback);\n};\n\n/**\n * Checks the status of declarative metadata call retrieve() and returns the zip file contents\n *\n * @param {String} id - Async process id returned from previous retrieve request\n * @param {Callback.<Metadata~RetrieveResult>} [callback] - Callback function\n * @returns {Promise.<Metadata~RetrieveResult>}\n */\nMetadata.prototype.checkRetrieveStatus = function(id, callback) {\n  return this._invoke(\"checkRetrieveStatus\", { asyncProcessId: id }, callback);\n};\n\n/**\n * Deploy components into an organization using zipped file representations\n *\n * @param {stream.Stream|Buffer|String} zipInput - Zipped file input source in readable stream, binary buffer or Base64-encoded string\n * @param {Object} [options] - Options used in deployment\n * @param {Boolean} [options.allowMissingFiles] - Specifies whether a deploy succeeds even if files that are specified in package.xml but are not in the .zip file or not.\n * @param {Boolean} [options.autoUpdatePackage] - If a file is in the .zip file but not specified in package.xml, specifies whether the file should be automatically added to the package or not.\n * @param {Boolean} [options.checkOnly] - Indicates whether Apex classes and triggers are saved to the organization as part of the deployment (false) or not (true).\n * @param {Boolean} [options.ignoreWarnings] - Indicates whether a warning should allow a deployment to complete successfully (true) or not (false). Defaults to false.\n * @param {Boolean} [options.performRetrieve] - Indicates whether a retrieve() call is performed immediately after the deployment (true) or not (false).\n * @param {Boolean} [options.purgeOnDelete] - If true, the deleted components in the destructiveChanges.xml manifest file aren't stored in the Recycle Bin.\n * @param {Boolean} [options.rollbackOnError] - Indicates whether any failure causes a complete rollback (true) or not (false).\n * @param {Boolean} [options.runAllTests] - If true, all Apex tests defined in the organization are run.\n * @param {Array.<String>} [options.runTests] - A list of Apex tests to be run during deployment.\n * @param {Boolean} [options.singlePackage] - Indicates whether the specified .zip file points to a directory structure with a single package (true) or a set of packages (false).\n * @param {Callback.<Metadata~AsyncResult>} [callback] - Callback function\n * @returns {Metadata~DeployResultLocator}\n */\nMetadata.prototype.deploy = function(zipInput, options, callback) {\n  if (!options || _.isFunction(options)) {\n    callback = options;\n    options = {};\n  }\n  var deferred = Promise.defer();\n  if (_.isObject(zipInput) && _.isFunction(zipInput.pipe)) {\n    var bufs = [];\n    zipInput.on('data', function(d) {\n      bufs.push(d);\n    });\n    zipInput.on('end', function() {\n      deferred.resolve(Buffer.concat(bufs).toString('base64'));\n    });\n    // zipInput.resume();\n  } else if (zipInput instanceof Buffer) {\n    deferred.resolve(zipInput.toString('base64'));\n  } else if (zipInput instanceof String || typeof zipInput === 'string') {\n    deferred.resolve(zipInput);\n  } else {\n    throw \"Unexpected zipInput type\";\n  }\n\n  var self = this;\n  var res = deferred.promise.then(function(zipContentB64) {\n    return self._invoke(\"deploy\", {\n      ZipFile: zipContentB64,\n      DeployOptions: options\n    }, callback);\n  });\n  return new DeployResultLocator(this, res).thenCall(callback);\n};\n\n/**\n * Checks the status of declarative metadata call deploy()\n *\n * @param {String} id - Async process id returned from previous deploy request\n * @param {Boolean} [includeDetails] - Sets the DeployResult object to include details information (default: false)\n * @param {Callback.<Metadata~DeployResult>} [callback] - Callback function\n * @returns {Promise.<Metadata~DeployResult>}\n */\nMetadata.prototype.checkDeployStatus = function(id, includeDetails, callback) {\n  if (_.isObject(includeDetails) || _.isBoolean(includeDetails)) {\n    includeDetails = !!includeDetails;\n  } else {\n    callback = includeDetails;\n    includeDetails = false;\n  }\n  return this._invoke(\"checkDeployStatus\", {\n    asyncProcessId: id,\n    includeDetails : includeDetails\n  }).then(function(res) {\n    res.done = res.done === 'true';\n    res.success = res.success === 'true';\n    res.checkOnly = res.checkOnly === 'true';\n    res.runTestsEnabled = res.runTestsEnabled === 'true';\n    if (res.ignoreWarnings) {\n      res.ignoreWarnings = res.ignoreWarnings === 'true';\n    }\n    if (res.rollbackOnError) {\n      res.rollbackOnError = res.rollbackOnError === 'true';\n    }\n    res.numberComponentErrors = Number(res.numberComponentErrors);\n    res.numberComponentsDeployed = Number(res.numberComponentsDeployed);\n    res.numberComponentsTotal = Number(res.numberComponentsTotal);\n    res.numberTestErrors = Number(res.numberTestErrors);\n    res.numberTestsCompleted = Number(res.numberTestsCompleted);\n    res.numberTestsTotal = Number(res.numberTestsTotal);\n\n    return res;\n  }).thenCall(callback);\n};\n\n\n/*--------------------------------------------*/\n\n/**\n * @typedef {Object} Metadata~AsyncResult\n * @prop {Boolean} done - Indicates whether the call has completed or not\n * @prop {String} id - ID of the component being created, updated, deleted, deployed, or retrieved\n * @prop {String} state - The state four possible values: Queued, InProgress, Completed, and Error.\n * @prop {String} [statusCode] - If an error occurred during the create(), update(), or delete() call, a status code is returned\n * @prop {String} [message] - Message corresponding to the statusCode field returned\n */\n\n/**\n * The locator class for Metadata API asynchronous call result\n *\n * @protected\n * @class Metadata~AsyncResultLocator\n * @extends events.EventEmitter\n * @implements Promise.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>\n * @param {Metadata} meta - Metadata API object\n * @param {Promise.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} results - Promise object for async result info\n * @param {Boolean} [isArray] - Indicates whether the async request is given in array or single object\n */\nvar AsyncResultLocator = function(meta, results, isArray) {\n  this._meta = meta;\n  this._results = results;\n  this._isArray = isArray;\n};\n\ninherits(AsyncResultLocator, events.EventEmitter);\n\n/**\n * Promise/A+ interface\n * http://promises-aplus.github.io/promises-spec/\n *\n * Delegate to deferred promise, return promise instance for batch result\n *\n * @method Metadata~AsyncResultLocator#then\n */\nAsyncResultLocator.prototype.then = function(onResolve, onReject) {\n  var self = this;\n  return this._results.then(function(results) {\n    var convertType = function(res) {\n      if (res.$ && res.$[\"xsi:nil\"] === 'true') {\n        return null;\n      }\n      res.done = res.done === 'true';\n      return res;\n    };\n    results = _.isArray(results) ? _.map(results, convertType) : convertType(results);\n    if (self._isArray && !_.isArray(results)) {\n      results = [ results ];\n    }\n    return onResolve(results);\n  }, onReject);\n};\n\n/**\n * Promise/A+ extension\n * Call \"then\" using given node-style callback function\n *\n * @method Metadata~AsyncResultLocator#thenCall\n */\nAsyncResultLocator.prototype.thenCall = function(callback) {\n  return _.isFunction(callback) ? this.then(function(res) {\n    process.nextTick(function() {\n      callback(null, res);\n    });\n  }, function(err) {\n    process.nextTick(function() {\n      callback(err);\n    });\n  }) : this;\n};\n\n/**\n * Check the status of async request\n *\n * @method Metadata~AsyncResultLocator#check\n * @param {Callback.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>}\n */\nAsyncResultLocator.prototype.check = function(callback) {\n  var self = this;\n  var meta = this._meta;\n  return this.then(function(results) {\n    var ids = _.isArray(results) ? _.map(results, function(res){ return res.id; }) : results.id;\n    self._ids = ids;\n    return meta.checkStatus(ids);\n  }).thenCall(callback);\n};\n\n/**\n * Polling until async call status becomes complete or error\n *\n * @method Metadata~AsyncResultLocator#poll\n * @param {Number} interval - Polling interval in milliseconds\n * @param {Number} timeout - Polling timeout in milliseconds\n */\nAsyncResultLocator.prototype.poll = function(interval, timeout) {\n  var self = this;\n  var startTime = new Date().getTime();\n  var poll = function() {\n    var now = new Date().getTime();\n    if (startTime + timeout < now) {\n      var errMsg = \"Polling time out.\";\n      if (self._ids) {\n        errMsg += \" Process Id = \" + self._ids;\n      }\n      self.emit('error', new Error(errMsg));\n      return;\n    }\n    self.check().then(function(results) {\n      var done = true;\n      var resultArr = _.isArray(results) ? results : [ results ];\n      for (var i=0, len=resultArr.length; i<len; i++) {\n        var result = resultArr[i];\n        if (result && !result.done) {\n          self.emit('progress', result);\n          done = false;\n        }\n      }\n      if (done) {\n        self.emit('complete', results);\n      } else {\n        setTimeout(poll, interval);\n      }\n    }, function(err) {\n      self.emit('error', err);\n    });\n  };\n  setTimeout(poll, interval);\n};\n\n/**\n * Check and wait until the async requests become in completed status\n *\n * @method Metadata~AsyncResultLocator#complete\n * @param {Callback.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>}\n */\nAsyncResultLocator.prototype.complete = function(callback) {\n  var deferred = Promise.defer();\n  this.on('complete', function(results) {\n    deferred.resolve(results);\n  });\n  this.on('error', function(err) {\n    deferred.reject(err);\n  });\n  var meta = this._meta;\n  this.poll(meta.pollInterval, meta.pollTimeout);\n  return deferred.promise.thenCall(callback);\n};\n\n/*--------------------------------------------*/\n/**\n * The locator class to track retreive() Metadata API call result\n *\n * @protected\n * @class Metadata~RetrieveResultLocator\n * @extends Metadata~AsyncResultLocator\n * @param {Metadata} meta - Metadata API object\n * @param {Promise.<Metadata~AsyncResult>} result - Promise object for async result of retrieve call()\n */\nvar RetrieveResultLocator = function(meta, result) {\n  RetrieveResultLocator.super_.call(this, meta, result);\n};\n\ninherits(RetrieveResultLocator, AsyncResultLocator);\n\n/**\n * @typedef {Object} Metadata~RetrieveResult\n * @prop {Array.<Metadata~FileProperties>} fileProperties - Contains information about the properties of each component in the .zip file, and the manifest file package.xml\n * @prop {String} id - ID of the component being retrieved\n * @prop {Array.<Object>} messages - Contains information about the success or failure of the retrieve() call\n * @prop {String} zipFile - The zip file returned by the retrieve request. Base 64-encoded binary data\n */\n\n/**\n * Check and wait until the async request becomes in completed status,\n * and retrieve the result data.\n *\n * @memthod Metadata~RetrieveResultLocator#complete\n * @param {Callback.<Metadata~RetrieveResult>} [callback] - Callback function\n * @returns {Promise.<Metadata~RetrieveResult>}\n */\nRetrieveResultLocator.prototype.complete = function(callback) {\n  var meta = this._meta;\n  return RetrieveResultLocator.super_.prototype.complete.call(this).then(function(result) {\n    return meta.checkRetrieveStatus(result.id);\n  }).thenCall(callback);\n};\n\n/**\n * Change the retrieved result to Node.js readable stream\n *\n * @method Metadata~RetrieveResultLocator#stream\n * @returns {stream.Readable}\n */\nRetrieveResultLocator.prototype.stream = function() {\n  var self = this;\n  var resultStream = new stream.Readable();\n  var reading = false;\n  resultStream._read = function() {\n    if (reading) { return; }\n    reading = true;\n    self.complete(function(err, result) {\n      if (err) {\n        resultStream.emit('error', err);\n      } else {\n        resultStream.push(Buffer.from(result.zipFile, 'base64'));\n        resultStream.push(null);\n      }\n    });\n  };\n  return resultStream;\n};\n\n/*--------------------------------------------*/\n/**\n * The locator class to track deploy() Metadata API call result\n *\n * @protected\n * @class Metadata~DeployResultLocator\n * @extends Metadata~AsyncResultLocator\n * @param {Metadata} meta - Metadata API object\n * @param {Promise.<Metadata~AsyncResult>} result - Promise object for async result of deploy() call\n */\nvar DeployResultLocator = function(meta, result) {\n  DeployResultLocator.super_.call(this, meta, result);\n};\n\ninherits(DeployResultLocator, AsyncResultLocator);\n\n/**\n * @typedef {Object} Metadata~DeployResult\n * @prop {String} id - ID of the component being deployed\n * @prop {Boolean} checkOnly - Indicates whether this deployment is being used to check the validity of the deployed files without making any changes in the organization or not\n * @prop {String} completedDate - Timestamp for when the deployment process ended\n * @prop {String} createdDate - Timestamp for when the deploy() call was received\n * @prop {Array.<Object>} [details] - Provides the details of a deployment that is in-progress or ended, if includeDetails is set to true in checkDeployStatus() call\n * @prop {Boolean} done - Indicates whether the server finished processing the deploy() call for the specified id\n * @prop {String} [errorMessage] - Message corresponding to the values in the errorStatusCode field\n * @prop {String} [errorStatusCode] - If an error occurred during the deploy() call, a status code is returned, and the message corresponding to the status code is returned in the errorMessagefield\n * @prop {Boolean} [ignoreWarnings] - Specifies whether a deployment should continue even if the deployment generates warnings\n * @prop {String} lastModifiedDate - Timestamp of the last update for the deployment process\n * @prop {Number} numberComponentErrors - The number of components that generated errors during this deployment\n * @prop {Number} numberComponentsDeployed - The number of components deployed in the deployment process\n * @prop {Number} numberComponentsTotal - The total number of components in the deployment\n * @prop {Number} numberTestErrors - The number of Apex tests that have generated errors during this deployment\n * @prop {Number} numberTestsCompleted - The number of completedApex tests for this deployment\n * @prop {Number} numberTestsTotal - The total number of Apex tests for this deployment\n * @prop {Boolean} [rollbackOnError] - Indicates whether any failure causes a complete rollback or not. Default is true.\n * @prop {String} startDate - Timestamp for when the deployment process began\n * @prop {String} status - Indicates the current state of the deployment\n * @prop {Boolean} success - Indicates whether the deployment was successful or not\n */\n\n/**\n * Check and wait until the async request becomes in completed status,\n * and retrieve the result data.\n *\n * @method Metadata~DeployResultLocator#complete\n * @param {Callback.<Metadata~DeployResult>} [callback] - Callback function\n * @returns {Promise.<Metadata~DeployResult>}\n */\nDeployResultLocator.prototype.complete = function(includeDetails, callback) {\n  if (_.isFunction(includeDetails)) {\n    callback = includeDetails;\n    includeDetails = false;\n  }\n  var meta = this._meta;\n  return DeployResultLocator.super_.prototype.complete.call(this).then(function(result) {\n    return meta.checkDeployStatus(result.id, includeDetails);\n  }).thenCall(callback);\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.metadata = new Metadata(conn);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvbWV0YWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsc0VBQVU7QUFDakMsY0FBYyxtQkFBTyxDQUFDLHNCQUFRO0FBQzlCLGNBQWMsbUJBQU8sQ0FBQyx5R0FBaUI7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLG1FQUFhO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyxvRUFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsMEVBQVk7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLG9FQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxRQUFRO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFEQUFxRDtBQUNoRSxXQUFXLDhEQUE4RDtBQUN6RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvQkFBb0I7QUFDekQ7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxRQUFRO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsUUFBUTtBQUNsQixVQUFVLFNBQVM7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFEQUFxRDtBQUNoRSxXQUFXLDREQUE0RDtBQUN2RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFEQUFxRDtBQUNoRSxXQUFXLDREQUE0RDtBQUN2RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9CQUFvQjtBQUM5RDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsZ0VBQWdFO0FBQzNFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsZ0VBQWdFO0FBQzNFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0NBQWtDO0FBQzFFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsUUFBUTtBQUNsQixVQUFVLHVCQUF1QjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpRUFBaUU7QUFDNUUsV0FBVyw4REFBOEQ7QUFDekUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0NBQWdDO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxREFBcUQ7QUFDaEUsV0FBVyw0REFBNEQ7QUFDdkUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxREFBcUQ7QUFDaEUsV0FBVyw0REFBNEQ7QUFDdkUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQkFBb0I7QUFDOUQ7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxREFBcUQ7QUFDaEUsV0FBVyxnRUFBZ0U7QUFDM0UsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxREFBcUQ7QUFDaEUsV0FBVyxnRUFBZ0U7QUFDM0UsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQkFBb0I7QUFDOUQ7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsMkVBQTJFO0FBQ3RGLFdBQVcsOERBQThEO0FBQ3pFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0JBQW9CO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLDJFQUEyRTtBQUN0RixXQUFXLDhEQUE4RDtBQUN6RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLDREQUE0RDtBQUN2RSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyw0REFBNEQ7QUFDdkUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtDQUFrQztBQUM1RTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdDQUFnQztBQUMzQyxhQUFhO0FBQ2I7QUFDQTtBQUNBLDBDQUEwQyxnRUFBZ0U7QUFDMUc7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyw4REFBOEQ7QUFDekUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLGdCQUFnQjtBQUMxQixVQUFVLGdCQUFnQjtBQUMxQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsU0FBUztBQUNuQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxTQUFTO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVEseURBQXlEO0FBQzVFLFdBQVcsNENBQTRDO0FBQ3ZELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVywrREFBK0Q7QUFDMUUsV0FBVyxRQUFRLHlEQUF5RDtBQUM1RSxXQUFXLDRDQUE0QztBQUN2RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdDQUF3QztBQUNoRjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVDQUF1QyxrQkFBa0I7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxvQ0FBb0M7QUFDL0MsYUFBYTtBQUNiO0FBQ0E7QUFDQSwrQ0FBK0Msb0JBQW9CO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsU0FBUztBQUNwQixXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsa0NBQWtDO0FBQzdDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7OztBQUdBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsU0FBUztBQUNuQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyw2REFBNkQ7QUFDeEUsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOERBQThEO0FBQ3pFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGdCQUFnQjtBQUNqRjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOERBQThEO0FBQ3pFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxpQ0FBaUM7QUFDM0MsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsUUFBUTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQ0FBb0M7QUFDL0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsU0FBUztBQUNuQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxTQUFTO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtDQUFrQztBQUM3QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvbWV0YWRhdGEuanM/YmE2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBwcm9jZXNzLCBCdWZmZXIgKi9cbi8qKlxuICogQGZpbGUgTWFuYWdlcyBTYWxlc2ZvcmNlIE1ldGFkYXRhIEFQSVxuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgIGV2ZW50cyAgPSByZXF1aXJlKCdldmVudHMnKSxcbiAgICBzdHJlYW0gID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJyksXG4gICAgXyAgICAgICA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyksXG4gICAganNmb3JjZSA9IHJlcXVpcmUoJy4uL2NvcmUnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi4vcHJvbWlzZScpLFxuICAgIFNPQVAgICAgPSByZXF1aXJlKCcuLi9zb2FwJyk7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBDbGFzcyBmb3IgU2FsZXNmb3JjZSBNZXRhZGF0YSBBUElcbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiAtIENvbm5lY3Rpb24gb2JqZWN0XG4gKi9cbnZhciBNZXRhZGF0YSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29ubikge1xuICB0aGlzLl9jb25uID0gY29ubjtcbn07XG5cblxuLyoqXG4gKiBQb2xsaW5nIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICogQHR5cGUge051bWJlcn1cbiAqL1xuTWV0YWRhdGEucHJvdG90eXBlLnBvbGxJbnRlcnZhbCA9IDEwMDA7XG5cbi8qKlxuICogUG9sbGluZyB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICogQHR5cGUge051bWJlcn1cbiAqL1xuTWV0YWRhdGEucHJvdG90eXBlLnBvbGxUaW1lb3V0ID0gMTAwMDA7XG5cblxuLyoqXG4gKiBDYWxsIE1ldGFkYXRhIEFQSSBTT0FQIGVuZHBvaW50XG4gKlxuICogQHByaXZhdGVcbiAqL1xuTWV0YWRhdGEucHJvdG90eXBlLl9pbnZva2UgPSBmdW5jdGlvbihtZXRob2QsIG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gIHZhciBzb2FwRW5kcG9pbnQgPSBuZXcgU09BUCh0aGlzLl9jb25uLCB7XG4gICAgeG1sbnM6IFwiaHR0cDovL3NvYXAuc2ZvcmNlLmNvbS8yMDA2LzA0L21ldGFkYXRhXCIsXG4gICAgZW5kcG9pbnRVcmw6IHRoaXMuX2Nvbm4uaW5zdGFuY2VVcmwgKyBcIi9zZXJ2aWNlcy9Tb2FwL20vXCIgKyB0aGlzLl9jb25uLnZlcnNpb25cbiAgfSk7XG4gIHJldHVybiBzb2FwRW5kcG9pbnQuaW52b2tlKG1ldGhvZCwgbWVzc2FnZSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFkYXRhfk1ldGFkYXRhSW5mb1xuICogQHByb3Age1N0cmluZ30gZnVsbE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50XG4gKi9cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBhZGRzIG9uZSBvciBtb3JlIG5ldyBtZXRhZGF0YSBjb21wb25lbnRzIHRvIHRoZSBvcmdhbml6YXRpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBtZXRhZGF0YSB0byBjcmVhdGVcbiAqIEBwYXJhbSB7TWV0YWRhdGF+TWV0YWRhdGFJbmZvfEFycmF5LjxNZXRhZGF0YX5NZXRhZGF0YUluZm8+fSBtZXRhZGF0YSAtIE1ldGFkYXRhIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48TWV0YWRhdGF+QXN5bmNSZXN1bHR8QXJyYXkuPE1ldGFkYXRhfkFzeW5jUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge01ldGFkYXRhfkFzeW5jUmVzdWx0TG9jYXRvcn1cbiAqL1xuTWV0YWRhdGEucHJvdG90eXBlLmNyZWF0ZUFzeW5jID0gZnVuY3Rpb24odHlwZSwgbWV0YWRhdGEsIGNhbGxiYWNrKSB7XG4gIGlmIChOdW1iZXIodGhpcy5fY29ubi52ZXJzaW9uKSA+IDMwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmMgbWV0YWRhdGEgQ1JVRCBjYWxscyBhcmUgbm90IHN1cHBvcnRlZCBvbiB2ZXIgMzEuMCBvciBsYXRlci5cIik7XG4gIH1cbiAgdmFyIGNvbnZlcnQgPSBmdW5jdGlvbihtZCkge1xuICAgIG1kW1wiQHhzaTp0eXBlXCJdID0gdHlwZTtcbiAgICByZXR1cm4gbWQ7XG4gIH07XG4gIHZhciBpc0FycmF5ID0gXy5pc0FycmF5KG1ldGFkYXRhKTtcbiAgbWV0YWRhdGEgPSBpc0FycmF5ID8gXy5tYXAobWV0YWRhdGEsIGNvbnZlcnQpIDogY29udmVydChtZXRhZGF0YSk7XG4gIHZhciByZXMgPSB0aGlzLl9pbnZva2UoXCJjcmVhdGVcIiwgeyBtZXRhZGF0YTogbWV0YWRhdGEgfSk7XG4gIHJldHVybiBuZXcgQXN5bmNSZXN1bHRMb2NhdG9yKHRoaXMsIHJlcywgaXNBcnJheSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhZGF0YX5TYXZlUmVzdWx0XG4gKiBAcHJvcCB7Qm9vbGVhbn0gc3VjY2VzcyAtIFRydWUgaWYgbWV0YWRhdGEgaXMgc3VjY2Vzc2Z1bGx5IHNhdmVkXG4gKiBAcHJvcCB7U3RyaW5nfSBmdWxsTmFtZSAtIEZ1bGwgbmFtZSBvZiBtZXRhZGF0YSBvYmplY3RcbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb1NhdmVSZXN1bHQocmVzdWx0KSB7XG4gIHZhciBzYXZlUmVzdWx0ID0gXy5jbG9uZShyZXN1bHQpO1xuICBzYXZlUmVzdWx0LnN1Y2Nlc3MgPSBzYXZlUmVzdWx0LnN1Y2Nlc3MgPT09ICd0cnVlJztcbiAgcmV0dXJuIHNhdmVSZXN1bHQ7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0YWRhdGF+VXBzZXJ0UmVzdWx0XG4gKiBAcHJvcCB7Qm9vbGVhbn0gc3VjY2VzcyAtIFRydWUgaWYgbWV0YWRhdGEgaXMgc3VjY2Vzc2Z1bGx5IHNhdmVkXG4gKiBAcHJvcCB7U3RyaW5nfSBmdWxsTmFtZSAtIEZ1bGwgbmFtZSBvZiBtZXRhZGF0YSBvYmplY3RcbiAqIEBwcm9wIHtCb29sZWFufSBjcmVhdGVkIC0gVHJ1ZSBpZiBtZXRhZGF0YSBpcyBuZXdseSBjcmVhdGVkXG4gKi9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9VcHNlcnRSZXN1bHQocmVzdWx0KSB7XG4gIHZhciB1cHNlcnRSZXN1bHQgPSBjb252ZXJ0VG9TYXZlUmVzdWx0KHJlc3VsdCk7XG4gIHVwc2VydFJlc3VsdC5jcmVhdGVkID0gdXBzZXJ0UmVzdWx0LmNyZWF0ZWQgPT09ICd0cnVlJztcbiAgcmV0dXJuIHVwc2VydFJlc3VsdDtcbn1cblxuLyoqXG4gKiBTeW5vbnltIG9mIE1ldGFkYXRhI2NyZWF0ZSgpLlxuICpcbiAqIEBtZXRob2QgTWV0YWRhdGEjY3JlYXRlU3luY1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBtZXRhZGF0YSB0byBjcmVhdGVcbiAqIEBwYXJhbSB7TWV0YWRhdGF+TWV0YWRhdGFJbmZvfEFycmF5LjxNZXRhZGF0YX5NZXRhZGF0YUluZm8+fSBtZXRhZGF0YSAtIE1ldGFkYXRhIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48TWV0YWRhdGF+U2F2ZVJlc3VsdHxBcnJheS48TWV0YWRhdGF+U2F2ZVJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxNZXRhZGF0YX5TYXZlUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5TYXZlUmVzdWx0Pj59XG4gKi9cbi8qKlxuICogU3luY2hyb25vdXNseSBhZGRzIG9uZSBvciBtb3JlIG5ldyBtZXRhZGF0YSBjb21wb25lbnRzIHRvIHRoZSBvcmdhbml6YXRpb24uXG4gKlxuICogQG1ldGhvZCBNZXRhZGF0YSNjcmVhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgbWV0YWRhdGEgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge01ldGFkYXRhfk1ldGFkYXRhSW5mb3xBcnJheS48TWV0YWRhdGF+TWV0YWRhdGFJbmZvPn0gbWV0YWRhdGEgLSBNZXRhZGF0YSB0byBjcmVhdGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhflNhdmVSZXN1bHR8QXJyYXkuPE1ldGFkYXRhflNhdmVSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TWV0YWRhdGF+U2F2ZVJlc3VsdHxBcnJheS48TWV0YWRhdGF+U2F2ZVJlc3VsdD4+fVxuICovXG5NZXRhZGF0YS5wcm90b3R5cGUuY3JlYXRlU3luYyA9XG5NZXRhZGF0YS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24odHlwZSwgbWV0YWRhdGEsIGNhbGxiYWNrKSB7XG4gIHZhciBjb252ZXJ0ID0gZnVuY3Rpb24obWQpIHtcbiAgICBtZFtcIkB4c2k6dHlwZVwiXSA9IHR5cGU7XG4gICAgcmV0dXJuIG1kO1xuICB9O1xuICB2YXIgaXNBcnJheSA9IF8uaXNBcnJheShtZXRhZGF0YSk7XG4gIG1ldGFkYXRhID0gaXNBcnJheSA/IF8ubWFwKG1ldGFkYXRhLCBjb252ZXJ0KSA6IGNvbnZlcnQobWV0YWRhdGEpO1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwiY3JlYXRlTWV0YWRhdGFcIiwgeyBtZXRhZGF0YTogbWV0YWRhdGEgfSkudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgcmV0dXJuIF8uaXNBcnJheShyZXN1bHRzKSA/IF8ubWFwKHJlc3VsdHMsIGNvbnZlcnRUb1NhdmVSZXN1bHQpIDogY29udmVydFRvU2F2ZVJlc3VsdChyZXN1bHRzKTtcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9NZXRhZGF0YUluZm8ocmVjKSB7XG4gIHZhciBtZXRhZGF0YUluZm8gPSBfLmNsb25lKHJlYyk7XG4gIGRlbGV0ZSBtZXRhZGF0YUluZm8uJDtcbiAgcmV0dXJuIG1ldGFkYXRhSW5mbztcbn1cblxuLyoqXG4gKiBTeW5vbnltIG9mIE1ldGFkYXRhI3JlYWQoKVxuICpcbiAqIEBtZXRob2QgTWV0YWRhdGEjcmVhZFN5bmNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgbWV0YWRhdGEgdG8gcmVhZFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGZ1bGxOYW1lcyAtIGZ1bGwgbmFtZShzKSBvZiBtZXRhZGF0YSBvYmplY3RzIHRvIHJlYWRcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhfk1ldGFkYXRhSW5mb3xBcnJheS48TWV0YWRhdGF+TWV0YWRhdGFJbmZvPj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxNZXRhZGF0YX5NZXRhZGF0YUluZm98QXJyYXkuPE1ldGFkYXRhfk1ldGFkYXRhSW5mbz4+Pn1cbiAqL1xuLyoqXG4gKiBTeW5jaHJvbm91c2x5IHJlYWQgc3BlY2lmaWVkIG1ldGFkYXRhIGNvbXBvbmVudHMgaW4gdGhlIG9yZ2FuaXphdGlvbi5cbiAqXG4gKiBAbWV0aG9kIE1ldGFkYXRhI3JlYWRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgbWV0YWRhdGEgdG8gcmVhZFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGZ1bGxOYW1lcyAtIGZ1bGwgbmFtZShzKSBvZiBtZXRhZGF0YSBvYmplY3RzIHRvIHJlYWRcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhfk1ldGFkYXRhSW5mb3xBcnJheS48TWV0YWRhdGF+TWV0YWRhdGFJbmZvPj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxNZXRhZGF0YX5NZXRhZGF0YUluZm98QXJyYXkuPE1ldGFkYXRhfk1ldGFkYXRhSW5mbz4+Pn1cbiAqL1xuTWV0YWRhdGEucHJvdG90eXBlLnJlYWRTeW5jID1cbk1ldGFkYXRhLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24odHlwZSwgZnVsbE5hbWVzLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwicmVhZE1ldGFkYXRhXCIsIHsgdHlwZTogdHlwZSwgZnVsbE5hbWVzOiBmdWxsTmFtZXMgfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICByZXR1cm4gXy5pc0FycmF5KHJlcy5yZWNvcmRzKSA/IF8ubWFwKHJlcy5yZWNvcmRzLCBjb252ZXJ0VG9NZXRhZGF0YUluZm8pIDogY29udmVydFRvTWV0YWRhdGFJbmZvKHJlcy5yZWNvcmRzKTtcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhZGF0YX5VcGRhdGVNZXRhZGF0YUluZm9cbiAqIEBwcm9wIHtTdHJpbmd9IGN1cnJlbnROYW1lIC0gVGhlIEFQSSBuYW1lIG9mIHRoZSBjb21wb25lbnQgb3IgZmllbGQgYmVmb3JlIHRoZSB1cGRhdGVcbiAqIEBwcm9wIHtNZXRhZGF0YX5NZXRhZGF0YUluZm99IG1ldGFkYXRhIC0gRnVsbCBzcGVjaWZpY2F0aW9uIG9mIHRoZSBjb21wb25lbnQgb3IgZmllbGQgeW91IHdpc2ggdG8gdXBkYXRlXG4gKi9cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSB1cGRhdGVzIG9uZSBvciBtb3JlIG1ldGFkYXRhIGNvbXBvbmVudHMgaW4gdGhlIG9yZ2FuaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIG1ldGFkYXRhIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtNZXRhZGF0YX5VcGRhdGVNZXRhZGF0YUluZm98QXJyYXkuPE1ldGFkYXRhflVwZGF0ZU1ldGFkYXRhSW5mbz59IHVwZGF0ZU1ldGFkYXRhIC0gVXBkYXRpbmcgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhfkFzeW5jUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5Bc3luY1Jlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtNZXRhZGF0YX5Bc3luY1Jlc3VsdExvY2F0b3J9XG4gKi9cbk1ldGFkYXRhLnByb3RvdHlwZS51cGRhdGVBc3luYyA9IGZ1bmN0aW9uKHR5cGUsIHVwZGF0ZU1ldGFkYXRhLCBjYWxsYmFjaykge1xuICBpZiAoTnVtYmVyKHRoaXMuX2Nvbm4udmVyc2lvbikgPiAzMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIG1ldGFkYXRhIENSVUQgY2FsbHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gdmVyIDMxLjAgb3IgbGF0ZXIuXCIpO1xuICB9XG4gIHZhciBjb252ZXJ0ID0gZnVuY3Rpb24odW1kKSB7XG4gICAgdW1kLm1ldGFkYXRhW1wiQHhzaTp0eXBlXCJdID0gdHlwZTtcbiAgICByZXR1cm4gdW1kO1xuICB9O1xuICB2YXIgaXNBcnJheSA9IF8uaXNBcnJheSh1cGRhdGVNZXRhZGF0YSk7XG4gIHVwZGF0ZU1ldGFkYXRhID0gaXNBcnJheSA/IF8ubWFwKHVwZGF0ZU1ldGFkYXRhLCBjb252ZXJ0KSA6IGNvbnZlcnQodXBkYXRlTWV0YWRhdGEpO1xuICB2YXIgcmVzID0gdGhpcy5faW52b2tlKFwidXBkYXRlXCIsIHsgdXBkYXRlTWV0YWRhdGE6IHVwZGF0ZU1ldGFkYXRhIH0pO1xuICByZXR1cm4gbmV3IEFzeW5jUmVzdWx0TG9jYXRvcih0aGlzLCByZXMsIGlzQXJyYXkpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU3lub255bSBvZiBNZXRhZGF0YSN1cGRhdGUoKS5cbiAqXG4gKiBAbWV0aG9kIE1ldGFkYXRhI3VwZGF0ZVN5bmNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgbWV0YWRhdGEgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge01ldGFkYXRhfk1ldGFkYXRhSW5mb3xBcnJheS48TWV0YWRhdGF+TWV0YWRhdGFJbmZvPn0gdXBkYXRlTWV0YWRhdGEgLSBVcGRhdGluZyBtZXRhZGF0YVxuICogQHBhcmFtIHtDYWxsYmFjay48TWV0YWRhdGF+U2F2ZVJlc3VsdHxBcnJheS48TWV0YWRhdGF+U2F2ZVJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxNZXRhZGF0YX5TYXZlUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5TYXZlUmVzdWx0Pj59XG4gKi9cbi8qKlxuICogU3luY2hyb25vdXNseSB1cGRhdGVzIG9uZSBvciBtb3JlIG1ldGFkYXRhIGNvbXBvbmVudHMgaW4gdGhlIG9yZ2FuaXphdGlvbi5cbiAqXG4gKiBAbWV0aG9kIE1ldGFkYXRhI3VwZGF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBtZXRhZGF0YSB0byB1cGRhdGVcbiAqIEBwYXJhbSB7TWV0YWRhdGF+TWV0YWRhdGFJbmZvfEFycmF5LjxNZXRhZGF0YX5NZXRhZGF0YUluZm8+fSB1cGRhdGVNZXRhZGF0YSAtIFVwZGF0aW5nIG1ldGFkYXRhXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5TYXZlUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5TYXZlUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE1ldGFkYXRhflNhdmVSZXN1bHR8QXJyYXkuPE1ldGFkYXRhflNhdmVSZXN1bHQ+Pn1cbiAqL1xuTWV0YWRhdGEucHJvdG90eXBlLnVwZGF0ZVN5bmMgPVxuTWV0YWRhdGEucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHR5cGUsIG1ldGFkYXRhLCBjYWxsYmFjaykge1xuICB2YXIgY29udmVydCA9IGZ1bmN0aW9uKG1kKSB7XG4gICAgbWRbXCJAeHNpOnR5cGVcIl0gPSB0eXBlO1xuICAgIHJldHVybiBtZDtcbiAgfTtcbiAgdmFyIGlzQXJyYXkgPSBfLmlzQXJyYXkobWV0YWRhdGEpO1xuICBtZXRhZGF0YSA9IGlzQXJyYXkgPyBfLm1hcChtZXRhZGF0YSwgY29udmVydCkgOiBjb252ZXJ0KG1ldGFkYXRhKTtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcInVwZGF0ZU1ldGFkYXRhXCIsIHsgbWV0YWRhdGE6IG1ldGFkYXRhIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgIHJldHVybiBfLmlzQXJyYXkocmVzdWx0cykgPyBfLm1hcChyZXN1bHRzLCBjb252ZXJ0VG9TYXZlUmVzdWx0KSA6IGNvbnZlcnRUb1NhdmVSZXN1bHQocmVzdWx0cyk7XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU3lub255bSBvZiBNZXRhZGF0YSN1cHNlcnQoKS5cbiAqXG4gKiBAbWV0aG9kIE1ldGFkYXRhI3Vwc2VydFN5bmNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgbWV0YWRhdGEgdG8gdXBzZXJ0XG4gKiBAcGFyYW0ge01ldGFkYXRhfk1ldGFkYXRhSW5mb3xBcnJheS48TWV0YWRhdGF+TWV0YWRhdGFJbmZvPn0gbWV0YWRhdGEgLSBVcHNlcnRpbmcgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhflVwc2VydFJlc3VsdHxBcnJheS48TWV0YWRhdGF+VXBzZXJ0UmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE1ldGFkYXRhflVwc2VydFJlc3VsdHxBcnJheS48TWV0YWRhdGF+VXBzZXJ0UmVzdWx0Pj59XG4gKi9cbi8qKlxuICogVXBzZXJ0cyBvbmUgb3IgbW9yZSBjb21wb25lbnRzIGluIHlvdXIgb3JnYW5pemF0aW9uJ3MgZGF0YS5cbiAqXG4gKiBAbWV0aG9kIE1ldGFkYXRhI3Vwc2VydFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBtZXRhZGF0YSB0byB1cHNlcnRcbiAqIEBwYXJhbSB7TWV0YWRhdGF+TWV0YWRhdGFJbmZvfEFycmF5LjxNZXRhZGF0YX5NZXRhZGF0YUluZm8+fSBtZXRhZGF0YSAtIFVwc2VydGluZyBtZXRhZGF0YVxuICogQHBhcmFtIHtDYWxsYmFjay48TWV0YWRhdGF+VXBzZXJ0UmVzdWx0fEFycmF5LjxNZXRhZGF0YX5VcHNlcnRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TWV0YWRhdGF+VXBzZXJ0UmVzdWx0fEFycmF5LjxNZXRhZGF0YX5VcHNlcnRSZXN1bHQ+Pn1cbiAqL1xuTWV0YWRhdGEucHJvdG90eXBlLnVwc2VydFN5bmMgPVxuTWV0YWRhdGEucHJvdG90eXBlLnVwc2VydCA9IGZ1bmN0aW9uKHR5cGUsIG1ldGFkYXRhLCBjYWxsYmFjaykge1xuICB2YXIgY29udmVydCA9IGZ1bmN0aW9uKG1kKSB7XG4gICAgbWRbXCJAeHNpOnR5cGVcIl0gPSB0eXBlO1xuICAgIHJldHVybiBtZDtcbiAgfTtcbiAgdmFyIGlzQXJyYXkgPSBfLmlzQXJyYXkobWV0YWRhdGEpO1xuICBtZXRhZGF0YSA9IGlzQXJyYXkgPyBfLm1hcChtZXRhZGF0YSwgY29udmVydCkgOiBjb252ZXJ0KG1ldGFkYXRhKTtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcInVwc2VydE1ldGFkYXRhXCIsIHsgbWV0YWRhdGE6IG1ldGFkYXRhIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgIHJldHVybiBfLmlzQXJyYXkocmVzdWx0cykgPyBfLm1hcChyZXN1bHRzLCBjb252ZXJ0VG9VcHNlcnRSZXN1bHQpIDogY29udmVydFRvVXBzZXJ0UmVzdWx0KHJlc3VsdHMpO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IGRlbGV0ZXMgc3BlY2lmaWVkIG1ldGFkYXRhIGNvbXBvbmVudHMgaW4gdGhlIG9yZ2FuaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIG1ldGFkYXRhIHRvIGRlbGV0ZVxuICogQHBhcmFtIHtTdHJpbmd8TWV0YWRhdGF+TWV0YWRhdGFJbmZvfEFycmF5LjxTdHJpbmc+fEFycmF5LjxNZXRhZGF0YX5NZXRhZGF0YUluZm8+fSBtZXRhZGF0YSAtIFRoZSBmdWxsTmFtZSBvZiBtZXRhZGF0YSBvciBtZXRhZGF0YSBpbmZvIHRvIGRlbGV0ZS4gSWYgaXQgaXMgcGFzc2VkIGluIGZ1bGxOYW1lLCB0aGUgdHlwZSBwYXJhbWV0ZXIgc2hvdWxkIG5vdCBiZSBlbXB0eS5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhfkFzeW5jUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5Bc3luY1Jlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtNZXRhZGF0YX5Bc3luY1Jlc3VsdExvY2F0b3J9XG4gKi9cbk1ldGFkYXRhLnByb3RvdHlwZS5kZWxldGVBc3luYyA9IGZ1bmN0aW9uKHR5cGUsIG1ldGFkYXRhLCBjYWxsYmFjaykge1xuICBpZiAoTnVtYmVyKHRoaXMuX2Nvbm4udmVyc2lvbikgPiAzMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIG1ldGFkYXRhIENSVUQgY2FsbHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gdmVyIDMxLjAgb3IgbGF0ZXIuXCIpO1xuICB9XG4gIHZhciBjb252ZXJ0ID0gZnVuY3Rpb24obWQpIHtcbiAgICBpZiAoXy5pc1N0cmluZyhtZCkpIHtcbiAgICAgIG1kID0geyBmdWxsTmFtZSA6IG1kIH07XG4gICAgfVxuICAgIG1kW1wiQHhzaTp0eXBlXCJdID0gdHlwZTtcbiAgICByZXR1cm4gbWQ7XG4gIH07XG4gIHZhciBpc0FycmF5ID0gXy5pc0FycmF5KG1ldGFkYXRhKTtcbiAgbWV0YWRhdGEgPSBpc0FycmF5ID8gXy5tYXAobWV0YWRhdGEsIGNvbnZlcnQpIDogY29udmVydChtZXRhZGF0YSk7XG4gIHZhciByZXMgPSB0aGlzLl9pbnZva2UoXCJkZWxldGVcIiwgeyBtZXRhZGF0YTogbWV0YWRhdGEgfSk7XG4gIHJldHVybiBuZXcgQXN5bmNSZXN1bHRMb2NhdG9yKHRoaXMsIHJlcywgaXNBcnJheSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTeW5vbnltIG9mIE1ldGFkYXRhI2RlbGV0ZSgpLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKiBAbWV0aG9kIE1ldGFkYXRhI2RlbFxuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAtIFRoZSB0eXBlIG9mIG1ldGFkYXRhIHRvIGRlbGV0ZVxuICogQHBhcmFtIHtTdHJpbmd8TWV0YWRhdGF+TWV0YWRhdGFJbmZvfEFycmF5LjxTdHJpbmc+fEFycmF5LjxNZXRhZGF0YX5NZXRhZGF0YUluZm8+fSBtZXRhZGF0YSAtIFRoZSBmdWxsTmFtZSBvZiBtZXRhZGF0YSBvciBtZXRhZGF0YSBpbmZvIHRvIGRlbGV0ZS4gSWYgaXQgaXMgcGFzc2VkIGluIGZ1bGxOYW1lLCB0aGUgdHlwZSBwYXJhbWV0ZXIgc2hvdWxkIG5vdCBiZSBlbXB0eS5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhfkFzeW5jUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5Bc3luY1Jlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtNZXRhZGF0YX5Bc3luY1Jlc3VsdExvY2F0b3J9XG4gKi9cbi8qKlxuICogU3lub255bSBvZiBNZXRhZGF0YSNkZWxldGUoKS5cbiAqXG4gKiBAbWV0aG9kIE1ldGFkYXRhI2RlbGV0ZVN5bmNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgbWV0YWRhdGEgdG8gZGVsZXRlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gZnVsbE5hbWVzIC0gVGhlIGZ1bGxOYW1lIG9mIG1ldGFkYXRhIHRvIGRlbGV0ZS5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhflNhdmVSZXN1bHR8QXJyYXkuPE1ldGFkYXRhflNhdmVSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TWV0YWRhdGF+U2F2ZVJlc3VsdHxBcnJheS48TWV0YWRhdGF+U2F2ZVJlc3VsdD4+fVxuICovXG5cbi8qKlxuICogU3luY2hyb25vdXNseSBkZWxldGVzIHNwZWNpZmllZCBtZXRhZGF0YSBjb21wb25lbnRzIGluIHRoZSBvcmdhbml6YXRpb24uXG4gKlxuICogQG1ldGhvZCBNZXRhZGF0YSNkZWxldGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgbWV0YWRhdGEgdG8gZGVsZXRlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gZnVsbE5hbWVzIC0gVGhlIGZ1bGxOYW1lIG9mIG1ldGFkYXRhIHRvIGRlbGV0ZS5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhflNhdmVSZXN1bHR8QXJyYXkuPE1ldGFkYXRhflNhdmVSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TWV0YWRhdGF+U2F2ZVJlc3VsdHxBcnJheS48TWV0YWRhdGF+U2F2ZVJlc3VsdD4+fVxuICovXG5NZXRhZGF0YS5wcm90b3R5cGUuZGVsID1cbk1ldGFkYXRhLnByb3RvdHlwZS5kZWxldGVTeW5jID1cbk1ldGFkYXRhLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uKHR5cGUsIGZ1bGxOYW1lcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcImRlbGV0ZU1ldGFkYXRhXCIsIHsgdHlwZTogdHlwZSwgZnVsbE5hbWVzOiBmdWxsTmFtZXMgfSkudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgcmV0dXJuIF8uaXNBcnJheShyZXN1bHRzKSA/IF8ubWFwKHJlc3VsdHMsIGNvbnZlcnRUb1NhdmVSZXN1bHQpIDogY29udmVydFRvU2F2ZVJlc3VsdChyZXN1bHRzKTtcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZW5hbWUgZnVsbG5hbWUgb2YgYSBtZXRhZGF0YSBjb21wb25lbnQgaW4gdGhlIG9yZ2FuaXphdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgbWV0YWRhdGEgdG8gZGVsZXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gb2xkRnVsbE5hbWUgLSBUaGUgb3JpZ2luYWwgZnVsbE5hbWUgb2YgbWV0YWRhdGFcbiAqIEBwYXJhbSB7U3RyaW5nfSBuZXdGdWxsTmFtZSAtIFRoZSBuZXcgZnVsbE5hbWUgb2YgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhflNhdmVSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxNZXRhZGF0YX5TYXZlUmVzdWx0Pn1cbiAqL1xuTWV0YWRhdGEucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKHR5cGUsIG9sZEZ1bGxOYW1lLCBuZXdGdWxsTmFtZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcInJlbmFtZU1ldGFkYXRhXCIsIHsgdHlwZTogdHlwZSwgb2xkRnVsbE5hbWU6IG9sZEZ1bGxOYW1lLCBuZXdGdWxsTmFtZTogbmV3RnVsbE5hbWUgfSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICByZXR1cm4gY29udmVydFRvU2F2ZVJlc3VsdChyZXN1bHQpO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIENoZWNrcyB0aGUgc3RhdHVzIG9mIGFzeW5jaHJvbm91cyBtZXRhZGF0YSBjYWxsc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBpZHMgLSBUaGUgYXN5bmNocm9ub3VzIHByb2Nlc3MgSUQocylcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhfkFzeW5jUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5Bc3luY1Jlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtNZXRhZGF0YX5Bc3luY1Jlc3VsdExvY2F0b3J9XG4gKi9cbk1ldGFkYXRhLnByb3RvdHlwZS5jaGVja1N0YXR1cyA9IGZ1bmN0aW9uKGlkcywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSBfLmlzQXJyYXkoaWRzKTtcbiAgdmFyIHJlcyA9IHRoaXMuX2ludm9rZShcImNoZWNrU3RhdHVzXCIsIHsgYXN5bmNQcm9jZXNzSWQ6IGlkcyB9KTtcbiAgcmV0dXJuIG5ldyBBc3luY1Jlc3VsdExvY2F0b3IodGhpcywgcmVzLCBpc0FycmF5KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFkYXRhfkRlc2NyaWJlTWV0YWRhdGFSZXN1bHRcbiAqIEBwcm9wIHtBcnJheS48T2JqZWN0Pn0gbWV0YWRhdGFPYmplY3RzIC0gT25lIG9yIG1vcmUgbWV0YWRhdGEgY29tcG9uZW50cyBhbmQgdGhlaXIgYXR0cmlidXRlc1xuICogQHByb3Age0FycmF5LjxTdHJpbmc+fSBtZXRhZGF0YU9iamVjdHMuY2hpbGRYbWxOYW1lcyAtIExpc3Qgb2YgY2hpbGQgc3ViLWNvbXBvbmVudHMgZm9yIHRoaXMgY29tcG9uZW50XG4gKiBAcHJvcCB7U3RyaW5nfSBtZXRhZGF0YU9iamVjdHMuZGlyZWN0b3J5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgaW4gdGhlIC56aXAgZmlsZSB0aGF0IGNvbnRhaW5zIHRoaXMgY29tcG9uZW50XG4gKiBAcHJvcCB7Qm9vbGVhbn0gbWV0YWRhdGFPYmplY3RzLmluRm9sZGVyIC0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBpbiBhIGZvbGRlciBvciBub3RcbiAqIEBwcm9wIHtCb29sZWFufSBtZXRhZGF0YU9iamVjdHMubWV0YUZpbGUgLSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY29tcG9uZW50IHJlcXVpcmVzIGFuIGFjY29tcGFueWluZyBtZXRhZGF0YSBmaWxlXG4gKiBAcHJvcCB7U3RyaW5nfSBtZXRhZGF0YU9iamVjdHMuc3VmZml4IC0gVGhlIGZpbGUgc3VmZml4IGZvciB0aGlzIGNvbXBvbmVudFxuICogQHByb3Age1N0cmluZ30gbWV0YWRhdGFPYmplY3RzLnhtbE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcm9vdCBlbGVtZW50IGluIHRoZSBtZXRhZGF0YSBmaWxlIGZvciB0aGlzIGNvbXBvbmVudFxuICogQHByb3Age1N0cmluZ30gb3JnYW5pemF0aW9uTmFtZXNwYWNlIC0gVGhlIG5hbWVzcGFjZSBvZiB0aGUgb3JnYW5pemF0aW9uXG4gKiBAcHJvcCB7Qm9vbGVhbn0gcGFydGlhbFNhdmVBbGxvd2VkIC0gSW5kaWNhdGVzIHdoZXRoZXIgcm9sbGJhY2tPbkVycm9yIGlzIGFsbG93ZWQgb3Igbm90XG4gKiBAcHJvcCB7Qm9vbGVhbn0gdGVzdFJlcXVpcmVkIC0gSW5kaWNhdGVzIHdoZXRoZXIgdGVzdHMgYXJlIHJlcXVpcmVkIG9yIG5vdFxuICovXG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBtZXRhZGF0YSB3aGljaCBkZXNjcmliZXMgeW91ciBvcmdhbml6YXRpb24sIGluY2x1ZGluZyBBcGV4IGNsYXNzZXMgYW5kIHRyaWdnZXJzLFxuICogY3VzdG9tIG9iamVjdHMsIGN1c3RvbSBmaWVsZHMgb24gc3RhbmRhcmQgb2JqZWN0cywgdGFiIHNldHMgdGhhdCBkZWZpbmUgYW4gYXBwLFxuICogYW5kIG1hbnkgb3RoZXIgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3ZlcnNpb25dIC0gVGhlIEFQSSB2ZXJzaW9uIGZvciB3aGljaCB5b3Ugd2FudCBtZXRhZGF0YTsgZm9yIGV4YW1wbGUsIDI5LjBcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhfkRlc2NyaWJlTWV0YWRhdGFSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxNZXRhZGF0YX5EZXNjcmliZU1ldGFkYXRhUmVzdWx0Pn1cbiAqL1xuTWV0YWRhdGEucHJvdG90eXBlLmRlc2NyaWJlID0gZnVuY3Rpb24odmVyc2lvbiwgY2FsbGJhY2spIHtcbiAgaWYgKCFfLmlzU3RyaW5nKHZlcnNpb24pKSB7XG4gICAgY2FsbGJhY2sgPSB2ZXJzaW9uO1xuICAgIHZlcnNpb24gPSB0aGlzLl9jb25uLnZlcnNpb247XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcImRlc2NyaWJlTWV0YWRhdGFcIiwgeyBhc09mVmVyc2lvbjogdmVyc2lvbiB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgIHJlcy5tZXRhZGF0YU9iamVjdHMgPSBfLmlzQXJyYXkocmVzLm1ldGFkYXRhT2JqZWN0cykgPyByZXMubWV0YWRhdGFPYmplY3RzIDogWyByZXMubWV0YWRhdGFPYmplY3RzIF07XG4gICAgcmVzLm1ldGFkYXRhT2JqZWN0cyA9IF8ubWFwKHJlcy5tZXRhZGF0YU9iamVjdHMsIGZ1bmN0aW9uKG1vKSB7XG4gICAgICBpZiAobW8uY2hpbGRYbWxOYW1lcykge1xuICAgICAgICBtby5jaGlsZFhtbE5hbWVzID0gXy5pc0FycmF5KG1vLmNoaWxkWG1sTmFtZXMpID8gbW8uY2hpbGRYbWxOYW1lczogWyBtby5jaGlsZFhtbE5hbWVzIF07XG4gICAgICB9XG4gICAgICBtby5pbkZvbGRlciA9IG1vLmluRm9sZGVyID09PSAndHJ1ZSc7XG4gICAgICBtby5tZXRhRmlsZSA9IG1vLm1ldGFGaWxlID09PSAndHJ1ZSc7XG4gICAgICByZXR1cm4gbW87XG4gICAgfSk7XG4gICAgcmVzLnBhcnRpYWxTYXZlQWxsb3dlZCA9IHJlcy5wYXJ0aWFsU2F2ZUFsbG93ZWQgPT09ICd0cnVlJztcbiAgICByZXMudGVzdFJlcXVpcmVkID0gcmVzLnRlc3RSZXF1aXJlZCA9PT0gJ3RydWUnO1xuICAgIHJldHVybiByZXM7XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0YWRhdGF+TGlzdE1ldGFkYXRhUXVlcnlcbiAqIEBwcm9wIHtTdHJpbmd9IHR5cGUgLSBUaGUgbWV0YWRhdGEgdHlwZSwgc3VjaCBhcyBDdXN0b21PYmplY3QsIEN1c3RvbUZpZWxkLCBvciBBcGV4Q2xhc3NcbiAqIEBwcm9wIHtTdHJpbmd9IFtmb2xkZXJdIC0gVGhlIGZvbGRlciBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbXBvbmVudC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFkYXRhfkZpbGVQcm9wZXJ0aWVzXG4gKiBAcHJvcCB7U3RyaW5nfSB0eXBlIC0gVGhlIG1ldGFkYXRhIHR5cGUsIHN1Y2ggYXMgQ3VzdG9tT2JqZWN0LCBDdXN0b21GaWVsZCwgb3IgQXBleENsYXNzXG4gKiBAcHJvcCB7U3RyaW5nfSBjcmVhdGVkQnlJZCAtIElEIG9mIHRoZSB1c2VyIHdobyBjcmVhdGVkIHRoZSBmaWxlXG4gKiBAcHJvcCB7U3RyaW5nfSBjcmVhdGVkQnlOYW1lIC0gTmFtZSBvZiB0aGUgdXNlciB3aG8gY3JlYXRlZCB0aGUgZmlsZVxuICogQHByb3Age1N0cmluZ30gY3JlYXRlZERhdGUgLSBEYXRlIGFuZCB0aW1lIHdoZW4gdGhlIGZpbGUgd2FzIGNyZWF0ZWRcbiAqIEBwcm9wIHtTdHJpbmd9IGZpbGVOYW1lIC0gTmFtZSBvZiB0aGUgZmlsZVxuICogQHByb3Age1N0cmluZ30gZnVsbE5hbWUgLSBUaGUgZmlsZSBkZXZlbG9wZXIgbmFtZSB1c2VkIGFzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIEFQSSBhY2Nlc3NcbiAqIEBwcm9wIHtTdHJpbmd9IGlkIC0gSUQgb2YgdGhlIGZpbGVcbiAqIEBwcm9wIHtTdHJpbmd9IGxhc3RNb2RpZmllZEJ5SWQgLSBJRCBvZiB0aGUgdXNlciB3aG8gbGFzdCBtb2RpZmllZCB0aGUgZmlsZVxuICogQHByb3Age1N0cmluZ30gbGFzdE1vZGlmaWVkQnlOYW1lIC0gTmFtZSBvZiB0aGUgdXNlciB3aG8gbGFzdCBtb2RpZmllZCB0aGUgZmlsZVxuICogQHByb3Age1N0cmluZ30gbGFzdE1vZGlmaWVkRGF0ZSAtIERhdGUgYW5kIHRpbWUgdGhhdCB0aGUgZmlsZSB3YXMgbGFzdCBtb2RpZmllZFxuICogQHByb3Age1N0cmluZ30gW21hbmFnZWFibGVTdGF0ZV0gLSBJbmRpY2F0ZXMgdGhlIG1hbmFnZWFibGUgc3RhdGUgb2YgdGhlIHNwZWNpZmllZCBjb21wb25lbnQgaWYgaXQgaXMgY29udGFpbmVkIGluIGEgcGFja2FnZVxuICogQHByb3Age1N0cmluZ30gW25hbWVzcGFjZVByZWZpeF0gLSBUaGUgbmFtZXNwYWNlIHByZWZpeCBvZiB0aGUgY29tcG9uZW50XG4gKi9cblxuLyoqXG4gKiBSZXRyaWV2ZXMgcHJvcGVydHkgaW5mb3JtYXRpb24gYWJvdXQgbWV0YWRhdGEgY29tcG9uZW50cyBpbiB5b3VyIG9yZ2FuaXphdGlvblxuICpcbiAqIEBwYXJhbSB7TWV0YWRhdGF+TGlzdE1ldGFkYXRhUXVlcnl8QXJyYXkuPE1ldGFkYXRhfkxpc3RNZXRhZGF0YVF1ZXJ5Pn0gcXVlcmllcyAtIFRoZSBjcml0ZXJpYSBvYmplY3Qocykgc3BlY2lmaW5nIG1ldGFkYXRhIHRvIGxpc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdmVyc2lvbl0gLSBUaGUgQVBJIHZlcnNpb24gZm9yIHdoaWNoIHlvdSB3YW50IG1ldGFkYXRhOyBmb3IgZXhhbXBsZSwgMjkuMFxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPE1ldGFkYXRhfkZpbGVQcm9wZXJ0aWVzPj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxNZXRhZGF0YX5GaWxlUHJvcGVydGllcz4+fVxuICovXG5NZXRhZGF0YS5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKHF1ZXJpZXMsIHZlcnNpb24sIGNhbGxiYWNrKSB7XG4gIGlmICghXy5pc1N0cmluZyh2ZXJzaW9uKSkge1xuICAgIGNhbGxiYWNrID0gdmVyc2lvbjtcbiAgICB2ZXJzaW9uID0gdGhpcy5fY29ubi52ZXJzaW9uO1xuICB9XG4gIGlmICghXy5pc0FycmF5KHF1ZXJpZXMpKSB7XG4gICAgcXVlcmllcyA9IFsgcXVlcmllcyBdO1xuICB9XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJsaXN0TWV0YWRhdGFcIiwgeyBxdWVyaWVzOiBxdWVyaWVzLCBhc09mVmVyc2lvbjogdmVyc2lvbiB9LCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFkYXRhflJldHJpZXZlUmVxdWVzdFxuICovXG5cbi8qKlxuICogUmV0cmlldmVzIFhNTCBmaWxlIHJlcHJlc2VudGF0aW9ucyBvZiBjb21wb25lbnRzIGluIGFuIG9yZ2FuaXphdGlvblxuICpcbiAqIEBwYXJhbSB7TWV0YWRhdGF+UmV0cmlldmVSZXF1ZXN0fSByZXF1ZXN0IC0gT3B0aW9ucyBmb3IgZGV0ZXJtaW5pbmcgd2hpY2ggcGFja2FnZXMgb3IgZmlsZXMgYXJlIHJldHJpZXZlZFxuICogQHBhcmFtIHtDYWxsYmFjay48TWV0YWRhdGF+QXN5bmNSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtNZXRhZGF0YX5SZXRyaWV2ZVJlc3VsdExvY2F0b3J9XG4gKi9cbk1ldGFkYXRhLnByb3RvdHlwZS5yZXRyaWV2ZSA9IGZ1bmN0aW9uKHJlcXVlc3QsIGNhbGxiYWNrKSB7XG4gIHZhciByZXMgPSB0aGlzLl9pbnZva2UoXCJyZXRyaWV2ZVwiLCB7IHJlcXVlc3Q6IHJlcXVlc3QgfSk7XG4gIHJldHVybiBuZXcgUmV0cmlldmVSZXN1bHRMb2NhdG9yKHRoaXMsIHJlcykudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDaGVja3MgdGhlIHN0YXR1cyBvZiBkZWNsYXJhdGl2ZSBtZXRhZGF0YSBjYWxsIHJldHJpZXZlKCkgYW5kIHJldHVybnMgdGhlIHppcCBmaWxlIGNvbnRlbnRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gQXN5bmMgcHJvY2VzcyBpZCByZXR1cm5lZCBmcm9tIHByZXZpb3VzIHJldHJpZXZlIHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhflJldHJpZXZlUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TWV0YWRhdGF+UmV0cmlldmVSZXN1bHQ+fVxuICovXG5NZXRhZGF0YS5wcm90b3R5cGUuY2hlY2tSZXRyaWV2ZVN0YXR1cyA9IGZ1bmN0aW9uKGlkLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwiY2hlY2tSZXRyaWV2ZVN0YXR1c1wiLCB7IGFzeW5jUHJvY2Vzc0lkOiBpZCB9LCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIERlcGxveSBjb21wb25lbnRzIGludG8gYW4gb3JnYW5pemF0aW9uIHVzaW5nIHppcHBlZCBmaWxlIHJlcHJlc2VudGF0aW9uc1xuICpcbiAqIEBwYXJhbSB7c3RyZWFtLlN0cmVhbXxCdWZmZXJ8U3RyaW5nfSB6aXBJbnB1dCAtIFppcHBlZCBmaWxlIGlucHV0IHNvdXJjZSBpbiByZWFkYWJsZSBzdHJlYW0sIGJpbmFyeSBidWZmZXIgb3IgQmFzZTY0LWVuY29kZWQgc3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyB1c2VkIGluIGRlcGxveW1lbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dNaXNzaW5nRmlsZXNdIC0gU3BlY2lmaWVzIHdoZXRoZXIgYSBkZXBsb3kgc3VjY2VlZHMgZXZlbiBpZiBmaWxlcyB0aGF0IGFyZSBzcGVjaWZpZWQgaW4gcGFja2FnZS54bWwgYnV0IGFyZSBub3QgaW4gdGhlIC56aXAgZmlsZSBvciBub3QuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9VcGRhdGVQYWNrYWdlXSAtIElmIGEgZmlsZSBpcyBpbiB0aGUgLnppcCBmaWxlIGJ1dCBub3Qgc3BlY2lmaWVkIGluIHBhY2thZ2UueG1sLCBzcGVjaWZpZXMgd2hldGhlciB0aGUgZmlsZSBzaG91bGQgYmUgYXV0b21hdGljYWxseSBhZGRlZCB0byB0aGUgcGFja2FnZSBvciBub3QuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNoZWNrT25seV0gLSBJbmRpY2F0ZXMgd2hldGhlciBBcGV4IGNsYXNzZXMgYW5kIHRyaWdnZXJzIGFyZSBzYXZlZCB0byB0aGUgb3JnYW5pemF0aW9uIGFzIHBhcnQgb2YgdGhlIGRlcGxveW1lbnQgKGZhbHNlKSBvciBub3QgKHRydWUpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pZ25vcmVXYXJuaW5nc10gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHdhcm5pbmcgc2hvdWxkIGFsbG93IGEgZGVwbG95bWVudCB0byBjb21wbGV0ZSBzdWNjZXNzZnVsbHkgKHRydWUpIG9yIG5vdCAoZmFsc2UpLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucGVyZm9ybVJldHJpZXZlXSAtIEluZGljYXRlcyB3aGV0aGVyIGEgcmV0cmlldmUoKSBjYWxsIGlzIHBlcmZvcm1lZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgZGVwbG95bWVudCAodHJ1ZSkgb3Igbm90IChmYWxzZSkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnB1cmdlT25EZWxldGVdIC0gSWYgdHJ1ZSwgdGhlIGRlbGV0ZWQgY29tcG9uZW50cyBpbiB0aGUgZGVzdHJ1Y3RpdmVDaGFuZ2VzLnhtbCBtYW5pZmVzdCBmaWxlIGFyZW4ndCBzdG9yZWQgaW4gdGhlIFJlY3ljbGUgQmluLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yb2xsYmFja09uRXJyb3JdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYW55IGZhaWx1cmUgY2F1c2VzIGEgY29tcGxldGUgcm9sbGJhY2sgKHRydWUpIG9yIG5vdCAoZmFsc2UpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ydW5BbGxUZXN0c10gLSBJZiB0cnVlLCBhbGwgQXBleCB0ZXN0cyBkZWZpbmVkIGluIHRoZSBvcmdhbml6YXRpb24gYXJlIHJ1bi5cbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IFtvcHRpb25zLnJ1blRlc3RzXSAtIEEgbGlzdCBvZiBBcGV4IHRlc3RzIHRvIGJlIHJ1biBkdXJpbmcgZGVwbG95bWVudC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2luZ2xlUGFja2FnZV0gLSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIC56aXAgZmlsZSBwb2ludHMgdG8gYSBkaXJlY3Rvcnkgc3RydWN0dXJlIHdpdGggYSBzaW5nbGUgcGFja2FnZSAodHJ1ZSkgb3IgYSBzZXQgb2YgcGFja2FnZXMgKGZhbHNlKS5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhfkFzeW5jUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TWV0YWRhdGF+RGVwbG95UmVzdWx0TG9jYXRvcn1cbiAqL1xuTWV0YWRhdGEucHJvdG90eXBlLmRlcGxveSA9IGZ1bmN0aW9uKHppcElucHV0LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoIW9wdGlvbnMgfHwgXy5pc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICB2YXIgZGVmZXJyZWQgPSBQcm9taXNlLmRlZmVyKCk7XG4gIGlmIChfLmlzT2JqZWN0KHppcElucHV0KSAmJiBfLmlzRnVuY3Rpb24oemlwSW5wdXQucGlwZSkpIHtcbiAgICB2YXIgYnVmcyA9IFtdO1xuICAgIHppcElucHV0Lm9uKCdkYXRhJywgZnVuY3Rpb24oZCkge1xuICAgICAgYnVmcy5wdXNoKGQpO1xuICAgIH0pO1xuICAgIHppcElucHV0Lm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoQnVmZmVyLmNvbmNhdChidWZzKS50b1N0cmluZygnYmFzZTY0JykpO1xuICAgIH0pO1xuICAgIC8vIHppcElucHV0LnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKHppcElucHV0IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSh6aXBJbnB1dC50b1N0cmluZygnYmFzZTY0JykpO1xuICB9IGVsc2UgaWYgKHppcElucHV0IGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiB6aXBJbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICBkZWZlcnJlZC5yZXNvbHZlKHppcElucHV0KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgemlwSW5wdXQgdHlwZVwiO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcmVzID0gZGVmZXJyZWQucHJvbWlzZS50aGVuKGZ1bmN0aW9uKHppcENvbnRlbnRCNjQpIHtcbiAgICByZXR1cm4gc2VsZi5faW52b2tlKFwiZGVwbG95XCIsIHtcbiAgICAgIFppcEZpbGU6IHppcENvbnRlbnRCNjQsXG4gICAgICBEZXBsb3lPcHRpb25zOiBvcHRpb25zXG4gICAgfSwgY2FsbGJhY2spO1xuICB9KTtcbiAgcmV0dXJuIG5ldyBEZXBsb3lSZXN1bHRMb2NhdG9yKHRoaXMsIHJlcykudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDaGVja3MgdGhlIHN0YXR1cyBvZiBkZWNsYXJhdGl2ZSBtZXRhZGF0YSBjYWxsIGRlcGxveSgpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gQXN5bmMgcHJvY2VzcyBpZCByZXR1cm5lZCBmcm9tIHByZXZpb3VzIGRlcGxveSByZXF1ZXN0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtpbmNsdWRlRGV0YWlsc10gLSBTZXRzIHRoZSBEZXBsb3lSZXN1bHQgb2JqZWN0IHRvIGluY2x1ZGUgZGV0YWlscyBpbmZvcm1hdGlvbiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5EZXBsb3lSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxNZXRhZGF0YX5EZXBsb3lSZXN1bHQ+fVxuICovXG5NZXRhZGF0YS5wcm90b3R5cGUuY2hlY2tEZXBsb3lTdGF0dXMgPSBmdW5jdGlvbihpZCwgaW5jbHVkZURldGFpbHMsIGNhbGxiYWNrKSB7XG4gIGlmIChfLmlzT2JqZWN0KGluY2x1ZGVEZXRhaWxzKSB8fCBfLmlzQm9vbGVhbihpbmNsdWRlRGV0YWlscykpIHtcbiAgICBpbmNsdWRlRGV0YWlscyA9ICEhaW5jbHVkZURldGFpbHM7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2sgPSBpbmNsdWRlRGV0YWlscztcbiAgICBpbmNsdWRlRGV0YWlscyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJjaGVja0RlcGxveVN0YXR1c1wiLCB7XG4gICAgYXN5bmNQcm9jZXNzSWQ6IGlkLFxuICAgIGluY2x1ZGVEZXRhaWxzIDogaW5jbHVkZURldGFpbHNcbiAgfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICByZXMuZG9uZSA9IHJlcy5kb25lID09PSAndHJ1ZSc7XG4gICAgcmVzLnN1Y2Nlc3MgPSByZXMuc3VjY2VzcyA9PT0gJ3RydWUnO1xuICAgIHJlcy5jaGVja09ubHkgPSByZXMuY2hlY2tPbmx5ID09PSAndHJ1ZSc7XG4gICAgcmVzLnJ1blRlc3RzRW5hYmxlZCA9IHJlcy5ydW5UZXN0c0VuYWJsZWQgPT09ICd0cnVlJztcbiAgICBpZiAocmVzLmlnbm9yZVdhcm5pbmdzKSB7XG4gICAgICByZXMuaWdub3JlV2FybmluZ3MgPSByZXMuaWdub3JlV2FybmluZ3MgPT09ICd0cnVlJztcbiAgICB9XG4gICAgaWYgKHJlcy5yb2xsYmFja09uRXJyb3IpIHtcbiAgICAgIHJlcy5yb2xsYmFja09uRXJyb3IgPSByZXMucm9sbGJhY2tPbkVycm9yID09PSAndHJ1ZSc7XG4gICAgfVxuICAgIHJlcy5udW1iZXJDb21wb25lbnRFcnJvcnMgPSBOdW1iZXIocmVzLm51bWJlckNvbXBvbmVudEVycm9ycyk7XG4gICAgcmVzLm51bWJlckNvbXBvbmVudHNEZXBsb3llZCA9IE51bWJlcihyZXMubnVtYmVyQ29tcG9uZW50c0RlcGxveWVkKTtcbiAgICByZXMubnVtYmVyQ29tcG9uZW50c1RvdGFsID0gTnVtYmVyKHJlcy5udW1iZXJDb21wb25lbnRzVG90YWwpO1xuICAgIHJlcy5udW1iZXJUZXN0RXJyb3JzID0gTnVtYmVyKHJlcy5udW1iZXJUZXN0RXJyb3JzKTtcbiAgICByZXMubnVtYmVyVGVzdHNDb21wbGV0ZWQgPSBOdW1iZXIocmVzLm51bWJlclRlc3RzQ29tcGxldGVkKTtcbiAgICByZXMubnVtYmVyVGVzdHNUb3RhbCA9IE51bWJlcihyZXMubnVtYmVyVGVzdHNUb3RhbCk7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFkYXRhfkFzeW5jUmVzdWx0XG4gKiBAcHJvcCB7Qm9vbGVhbn0gZG9uZSAtIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjYWxsIGhhcyBjb21wbGV0ZWQgb3Igbm90XG4gKiBAcHJvcCB7U3RyaW5nfSBpZCAtIElEIG9mIHRoZSBjb21wb25lbnQgYmVpbmcgY3JlYXRlZCwgdXBkYXRlZCwgZGVsZXRlZCwgZGVwbG95ZWQsIG9yIHJldHJpZXZlZFxuICogQHByb3Age1N0cmluZ30gc3RhdGUgLSBUaGUgc3RhdGUgZm91ciBwb3NzaWJsZSB2YWx1ZXM6IFF1ZXVlZCwgSW5Qcm9ncmVzcywgQ29tcGxldGVkLCBhbmQgRXJyb3IuXG4gKiBAcHJvcCB7U3RyaW5nfSBbc3RhdHVzQ29kZV0gLSBJZiBhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIGNyZWF0ZSgpLCB1cGRhdGUoKSwgb3IgZGVsZXRlKCkgY2FsbCwgYSBzdGF0dXMgY29kZSBpcyByZXR1cm5lZFxuICogQHByb3Age1N0cmluZ30gW21lc3NhZ2VdIC0gTWVzc2FnZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBzdGF0dXNDb2RlIGZpZWxkIHJldHVybmVkXG4gKi9cblxuLyoqXG4gKiBUaGUgbG9jYXRvciBjbGFzcyBmb3IgTWV0YWRhdGEgQVBJIGFzeW5jaHJvbm91cyBjYWxsIHJlc3VsdFxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBjbGFzcyBNZXRhZGF0YX5Bc3luY1Jlc3VsdExvY2F0b3JcbiAqIEBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXJcbiAqIEBpbXBsZW1lbnRzIFByb21pc2UuPE1ldGFkYXRhfkFzeW5jUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5Bc3luY1Jlc3VsdD4+XG4gKiBAcGFyYW0ge01ldGFkYXRhfSBtZXRhIC0gTWV0YWRhdGEgQVBJIG9iamVjdFxuICogQHBhcmFtIHtQcm9taXNlLjxNZXRhZGF0YX5Bc3luY1Jlc3VsdHxBcnJheS48TWV0YWRhdGF+QXN5bmNSZXN1bHQ+Pn0gcmVzdWx0cyAtIFByb21pc2Ugb2JqZWN0IGZvciBhc3luYyByZXN1bHQgaW5mb1xuICogQHBhcmFtIHtCb29sZWFufSBbaXNBcnJheV0gLSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYXN5bmMgcmVxdWVzdCBpcyBnaXZlbiBpbiBhcnJheSBvciBzaW5nbGUgb2JqZWN0XG4gKi9cbnZhciBBc3luY1Jlc3VsdExvY2F0b3IgPSBmdW5jdGlvbihtZXRhLCByZXN1bHRzLCBpc0FycmF5KSB7XG4gIHRoaXMuX21ldGEgPSBtZXRhO1xuICB0aGlzLl9yZXN1bHRzID0gcmVzdWx0cztcbiAgdGhpcy5faXNBcnJheSA9IGlzQXJyYXk7XG59O1xuXG5pbmhlcml0cyhBc3luY1Jlc3VsdExvY2F0b3IsIGV2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIFByb21pc2UvQSsgaW50ZXJmYWNlXG4gKiBodHRwOi8vcHJvbWlzZXMtYXBsdXMuZ2l0aHViLmlvL3Byb21pc2VzLXNwZWMvXG4gKlxuICogRGVsZWdhdGUgdG8gZGVmZXJyZWQgcHJvbWlzZSwgcmV0dXJuIHByb21pc2UgaW5zdGFuY2UgZm9yIGJhdGNoIHJlc3VsdFxuICpcbiAqIEBtZXRob2QgTWV0YWRhdGF+QXN5bmNSZXN1bHRMb2NhdG9yI3RoZW5cbiAqL1xuQXN5bmNSZXN1bHRMb2NhdG9yLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25SZXNvbHZlLCBvblJlamVjdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLl9yZXN1bHRzLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgIHZhciBjb252ZXJ0VHlwZSA9IGZ1bmN0aW9uKHJlcykge1xuICAgICAgaWYgKHJlcy4kICYmIHJlcy4kW1wieHNpOm5pbFwiXSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmVzLmRvbmUgPSByZXMuZG9uZSA9PT0gJ3RydWUnO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJlc3VsdHMgPSBfLmlzQXJyYXkocmVzdWx0cykgPyBfLm1hcChyZXN1bHRzLCBjb252ZXJ0VHlwZSkgOiBjb252ZXJ0VHlwZShyZXN1bHRzKTtcbiAgICBpZiAoc2VsZi5faXNBcnJheSAmJiAhXy5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICByZXN1bHRzID0gWyByZXN1bHRzIF07XG4gICAgfVxuICAgIHJldHVybiBvblJlc29sdmUocmVzdWx0cyk7XG4gIH0sIG9uUmVqZWN0KTtcbn07XG5cbi8qKlxuICogUHJvbWlzZS9BKyBleHRlbnNpb25cbiAqIENhbGwgXCJ0aGVuXCIgdXNpbmcgZ2l2ZW4gbm9kZS1zdHlsZSBjYWxsYmFjayBmdW5jdGlvblxuICpcbiAqIEBtZXRob2QgTWV0YWRhdGF+QXN5bmNSZXN1bHRMb2NhdG9yI3RoZW5DYWxsXG4gKi9cbkFzeW5jUmVzdWx0TG9jYXRvci5wcm90b3R5cGUudGhlbkNhbGwgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSA/IHRoaXMudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICB9KTtcbiAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gIH0pIDogdGhpcztcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIHN0YXR1cyBvZiBhc3luYyByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBNZXRhZGF0YX5Bc3luY1Jlc3VsdExvY2F0b3IjY2hlY2tcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhfkFzeW5jUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5Bc3luY1Jlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxNZXRhZGF0YX5Bc3luY1Jlc3VsdHxBcnJheS48TWV0YWRhdGF+QXN5bmNSZXN1bHQ+Pn1cbiAqL1xuQXN5bmNSZXN1bHRMb2NhdG9yLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG1ldGEgPSB0aGlzLl9tZXRhO1xuICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICB2YXIgaWRzID0gXy5pc0FycmF5KHJlc3VsdHMpID8gXy5tYXAocmVzdWx0cywgZnVuY3Rpb24ocmVzKXsgcmV0dXJuIHJlcy5pZDsgfSkgOiByZXN1bHRzLmlkO1xuICAgIHNlbGYuX2lkcyA9IGlkcztcbiAgICByZXR1cm4gbWV0YS5jaGVja1N0YXR1cyhpZHMpO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFBvbGxpbmcgdW50aWwgYXN5bmMgY2FsbCBzdGF0dXMgYmVjb21lcyBjb21wbGV0ZSBvciBlcnJvclxuICpcbiAqIEBtZXRob2QgTWV0YWRhdGF+QXN5bmNSZXN1bHRMb2NhdG9yI3BvbGxcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbCAtIFBvbGxpbmcgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCAtIFBvbGxpbmcgdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAqL1xuQXN5bmNSZXN1bHRMb2NhdG9yLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHRpbWVvdXQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIHZhciBwb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGlmIChzdGFydFRpbWUgKyB0aW1lb3V0IDwgbm93KSB7XG4gICAgICB2YXIgZXJyTXNnID0gXCJQb2xsaW5nIHRpbWUgb3V0LlwiO1xuICAgICAgaWYgKHNlbGYuX2lkcykge1xuICAgICAgICBlcnJNc2cgKz0gXCIgUHJvY2VzcyBJZCA9IFwiICsgc2VsZi5faWRzO1xuICAgICAgfVxuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihlcnJNc2cpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5jaGVjaygpLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgdmFyIGRvbmUgPSB0cnVlO1xuICAgICAgdmFyIHJlc3VsdEFyciA9IF8uaXNBcnJheShyZXN1bHRzKSA/IHJlc3VsdHMgOiBbIHJlc3VsdHMgXTtcbiAgICAgIGZvciAodmFyIGk9MCwgbGVuPXJlc3VsdEFyci5sZW5ndGg7IGk8bGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdEFycltpXTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiAhcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJywgcmVzdWx0KTtcbiAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnY29tcGxldGUnLCByZXN1bHRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQocG9sbCwgaW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG4gIH07XG4gIHNldFRpbWVvdXQocG9sbCwgaW50ZXJ2YWwpO1xufTtcblxuLyoqXG4gKiBDaGVjayBhbmQgd2FpdCB1bnRpbCB0aGUgYXN5bmMgcmVxdWVzdHMgYmVjb21lIGluIGNvbXBsZXRlZCBzdGF0dXNcbiAqXG4gKiBAbWV0aG9kIE1ldGFkYXRhfkFzeW5jUmVzdWx0TG9jYXRvciNjb21wbGV0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48TWV0YWRhdGF+QXN5bmNSZXN1bHR8QXJyYXkuPE1ldGFkYXRhfkFzeW5jUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE1ldGFkYXRhfkFzeW5jUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5Bc3luY1Jlc3VsdD4+fVxuICovXG5Bc3luY1Jlc3VsdExvY2F0b3IucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIGRlZmVycmVkID0gUHJvbWlzZS5kZWZlcigpO1xuICB0aGlzLm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdHMpO1xuICB9KTtcbiAgdGhpcy5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgfSk7XG4gIHZhciBtZXRhID0gdGhpcy5fbWV0YTtcbiAgdGhpcy5wb2xsKG1ldGEucG9sbEludGVydmFsLCBtZXRhLnBvbGxUaW1lb3V0KTtcbiAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIFRoZSBsb2NhdG9yIGNsYXNzIHRvIHRyYWNrIHJldHJlaXZlKCkgTWV0YWRhdGEgQVBJIGNhbGwgcmVzdWx0XG4gKlxuICogQHByb3RlY3RlZFxuICogQGNsYXNzIE1ldGFkYXRhflJldHJpZXZlUmVzdWx0TG9jYXRvclxuICogQGV4dGVuZHMgTWV0YWRhdGF+QXN5bmNSZXN1bHRMb2NhdG9yXG4gKiBAcGFyYW0ge01ldGFkYXRhfSBtZXRhIC0gTWV0YWRhdGEgQVBJIG9iamVjdFxuICogQHBhcmFtIHtQcm9taXNlLjxNZXRhZGF0YX5Bc3luY1Jlc3VsdD59IHJlc3VsdCAtIFByb21pc2Ugb2JqZWN0IGZvciBhc3luYyByZXN1bHQgb2YgcmV0cmlldmUgY2FsbCgpXG4gKi9cbnZhciBSZXRyaWV2ZVJlc3VsdExvY2F0b3IgPSBmdW5jdGlvbihtZXRhLCByZXN1bHQpIHtcbiAgUmV0cmlldmVSZXN1bHRMb2NhdG9yLnN1cGVyXy5jYWxsKHRoaXMsIG1ldGEsIHJlc3VsdCk7XG59O1xuXG5pbmhlcml0cyhSZXRyaWV2ZVJlc3VsdExvY2F0b3IsIEFzeW5jUmVzdWx0TG9jYXRvcik7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0YWRhdGF+UmV0cmlldmVSZXN1bHRcbiAqIEBwcm9wIHtBcnJheS48TWV0YWRhdGF+RmlsZVByb3BlcnRpZXM+fSBmaWxlUHJvcGVydGllcyAtIENvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggY29tcG9uZW50IGluIHRoZSAuemlwIGZpbGUsIGFuZCB0aGUgbWFuaWZlc3QgZmlsZSBwYWNrYWdlLnhtbFxuICogQHByb3Age1N0cmluZ30gaWQgLSBJRCBvZiB0aGUgY29tcG9uZW50IGJlaW5nIHJldHJpZXZlZFxuICogQHByb3Age0FycmF5LjxPYmplY3Q+fSBtZXNzYWdlcyAtIENvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzdWNjZXNzIG9yIGZhaWx1cmUgb2YgdGhlIHJldHJpZXZlKCkgY2FsbFxuICogQHByb3Age1N0cmluZ30gemlwRmlsZSAtIFRoZSB6aXAgZmlsZSByZXR1cm5lZCBieSB0aGUgcmV0cmlldmUgcmVxdWVzdC4gQmFzZSA2NC1lbmNvZGVkIGJpbmFyeSBkYXRhXG4gKi9cblxuLyoqXG4gKiBDaGVjayBhbmQgd2FpdCB1bnRpbCB0aGUgYXN5bmMgcmVxdWVzdCBiZWNvbWVzIGluIGNvbXBsZXRlZCBzdGF0dXMsXG4gKiBhbmQgcmV0cmlldmUgdGhlIHJlc3VsdCBkYXRhLlxuICpcbiAqIEBtZW10aG9kIE1ldGFkYXRhflJldHJpZXZlUmVzdWx0TG9jYXRvciNjb21wbGV0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48TWV0YWRhdGF+UmV0cmlldmVSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxNZXRhZGF0YX5SZXRyaWV2ZVJlc3VsdD59XG4gKi9cblJldHJpZXZlUmVzdWx0TG9jYXRvci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgbWV0YSA9IHRoaXMuX21ldGE7XG4gIHJldHVybiBSZXRyaWV2ZVJlc3VsdExvY2F0b3Iuc3VwZXJfLnByb3RvdHlwZS5jb21wbGV0ZS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgcmV0dXJuIG1ldGEuY2hlY2tSZXRyaWV2ZVN0YXR1cyhyZXN1bHQuaWQpO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIENoYW5nZSB0aGUgcmV0cmlldmVkIHJlc3VsdCB0byBOb2RlLmpzIHJlYWRhYmxlIHN0cmVhbVxuICpcbiAqIEBtZXRob2QgTWV0YWRhdGF+UmV0cmlldmVSZXN1bHRMb2NhdG9yI3N0cmVhbVxuICogQHJldHVybnMge3N0cmVhbS5SZWFkYWJsZX1cbiAqL1xuUmV0cmlldmVSZXN1bHRMb2NhdG9yLnByb3RvdHlwZS5zdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcmVzdWx0U3RyZWFtID0gbmV3IHN0cmVhbS5SZWFkYWJsZSgpO1xuICB2YXIgcmVhZGluZyA9IGZhbHNlO1xuICByZXN1bHRTdHJlYW0uX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAocmVhZGluZykgeyByZXR1cm47IH1cbiAgICByZWFkaW5nID0gdHJ1ZTtcbiAgICBzZWxmLmNvbXBsZXRlKGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlc3VsdFN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRTdHJlYW0ucHVzaChCdWZmZXIuZnJvbShyZXN1bHQuemlwRmlsZSwgJ2Jhc2U2NCcpKTtcbiAgICAgICAgcmVzdWx0U3RyZWFtLnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiByZXN1bHRTdHJlYW07XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogVGhlIGxvY2F0b3IgY2xhc3MgdG8gdHJhY2sgZGVwbG95KCkgTWV0YWRhdGEgQVBJIGNhbGwgcmVzdWx0XG4gKlxuICogQHByb3RlY3RlZFxuICogQGNsYXNzIE1ldGFkYXRhfkRlcGxveVJlc3VsdExvY2F0b3JcbiAqIEBleHRlbmRzIE1ldGFkYXRhfkFzeW5jUmVzdWx0TG9jYXRvclxuICogQHBhcmFtIHtNZXRhZGF0YX0gbWV0YSAtIE1ldGFkYXRhIEFQSSBvYmplY3RcbiAqIEBwYXJhbSB7UHJvbWlzZS48TWV0YWRhdGF+QXN5bmNSZXN1bHQ+fSByZXN1bHQgLSBQcm9taXNlIG9iamVjdCBmb3IgYXN5bmMgcmVzdWx0IG9mIGRlcGxveSgpIGNhbGxcbiAqL1xudmFyIERlcGxveVJlc3VsdExvY2F0b3IgPSBmdW5jdGlvbihtZXRhLCByZXN1bHQpIHtcbiAgRGVwbG95UmVzdWx0TG9jYXRvci5zdXBlcl8uY2FsbCh0aGlzLCBtZXRhLCByZXN1bHQpO1xufTtcblxuaW5oZXJpdHMoRGVwbG95UmVzdWx0TG9jYXRvciwgQXN5bmNSZXN1bHRMb2NhdG9yKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhZGF0YX5EZXBsb3lSZXN1bHRcbiAqIEBwcm9wIHtTdHJpbmd9IGlkIC0gSUQgb2YgdGhlIGNvbXBvbmVudCBiZWluZyBkZXBsb3llZFxuICogQHByb3Age0Jvb2xlYW59IGNoZWNrT25seSAtIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgZGVwbG95bWVudCBpcyBiZWluZyB1c2VkIHRvIGNoZWNrIHRoZSB2YWxpZGl0eSBvZiB0aGUgZGVwbG95ZWQgZmlsZXMgd2l0aG91dCBtYWtpbmcgYW55IGNoYW5nZXMgaW4gdGhlIG9yZ2FuaXphdGlvbiBvciBub3RcbiAqIEBwcm9wIHtTdHJpbmd9IGNvbXBsZXRlZERhdGUgLSBUaW1lc3RhbXAgZm9yIHdoZW4gdGhlIGRlcGxveW1lbnQgcHJvY2VzcyBlbmRlZFxuICogQHByb3Age1N0cmluZ30gY3JlYXRlZERhdGUgLSBUaW1lc3RhbXAgZm9yIHdoZW4gdGhlIGRlcGxveSgpIGNhbGwgd2FzIHJlY2VpdmVkXG4gKiBAcHJvcCB7QXJyYXkuPE9iamVjdD59IFtkZXRhaWxzXSAtIFByb3ZpZGVzIHRoZSBkZXRhaWxzIG9mIGEgZGVwbG95bWVudCB0aGF0IGlzIGluLXByb2dyZXNzIG9yIGVuZGVkLCBpZiBpbmNsdWRlRGV0YWlscyBpcyBzZXQgdG8gdHJ1ZSBpbiBjaGVja0RlcGxveVN0YXR1cygpIGNhbGxcbiAqIEBwcm9wIHtCb29sZWFufSBkb25lIC0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNlcnZlciBmaW5pc2hlZCBwcm9jZXNzaW5nIHRoZSBkZXBsb3koKSBjYWxsIGZvciB0aGUgc3BlY2lmaWVkIGlkXG4gKiBAcHJvcCB7U3RyaW5nfSBbZXJyb3JNZXNzYWdlXSAtIE1lc3NhZ2UgY29ycmVzcG9uZGluZyB0byB0aGUgdmFsdWVzIGluIHRoZSBlcnJvclN0YXR1c0NvZGUgZmllbGRcbiAqIEBwcm9wIHtTdHJpbmd9IFtlcnJvclN0YXR1c0NvZGVdIC0gSWYgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBkZXBsb3koKSBjYWxsLCBhIHN0YXR1cyBjb2RlIGlzIHJldHVybmVkLCBhbmQgdGhlIG1lc3NhZ2UgY29ycmVzcG9uZGluZyB0byB0aGUgc3RhdHVzIGNvZGUgaXMgcmV0dXJuZWQgaW4gdGhlIGVycm9yTWVzc2FnZWZpZWxkXG4gKiBAcHJvcCB7Qm9vbGVhbn0gW2lnbm9yZVdhcm5pbmdzXSAtIFNwZWNpZmllcyB3aGV0aGVyIGEgZGVwbG95bWVudCBzaG91bGQgY29udGludWUgZXZlbiBpZiB0aGUgZGVwbG95bWVudCBnZW5lcmF0ZXMgd2FybmluZ3NcbiAqIEBwcm9wIHtTdHJpbmd9IGxhc3RNb2RpZmllZERhdGUgLSBUaW1lc3RhbXAgb2YgdGhlIGxhc3QgdXBkYXRlIGZvciB0aGUgZGVwbG95bWVudCBwcm9jZXNzXG4gKiBAcHJvcCB7TnVtYmVyfSBudW1iZXJDb21wb25lbnRFcnJvcnMgLSBUaGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgdGhhdCBnZW5lcmF0ZWQgZXJyb3JzIGR1cmluZyB0aGlzIGRlcGxveW1lbnRcbiAqIEBwcm9wIHtOdW1iZXJ9IG51bWJlckNvbXBvbmVudHNEZXBsb3llZCAtIFRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBkZXBsb3llZCBpbiB0aGUgZGVwbG95bWVudCBwcm9jZXNzXG4gKiBAcHJvcCB7TnVtYmVyfSBudW1iZXJDb21wb25lbnRzVG90YWwgLSBUaGUgdG90YWwgbnVtYmVyIG9mIGNvbXBvbmVudHMgaW4gdGhlIGRlcGxveW1lbnRcbiAqIEBwcm9wIHtOdW1iZXJ9IG51bWJlclRlc3RFcnJvcnMgLSBUaGUgbnVtYmVyIG9mIEFwZXggdGVzdHMgdGhhdCBoYXZlIGdlbmVyYXRlZCBlcnJvcnMgZHVyaW5nIHRoaXMgZGVwbG95bWVudFxuICogQHByb3Age051bWJlcn0gbnVtYmVyVGVzdHNDb21wbGV0ZWQgLSBUaGUgbnVtYmVyIG9mIGNvbXBsZXRlZEFwZXggdGVzdHMgZm9yIHRoaXMgZGVwbG95bWVudFxuICogQHByb3Age051bWJlcn0gbnVtYmVyVGVzdHNUb3RhbCAtIFRoZSB0b3RhbCBudW1iZXIgb2YgQXBleCB0ZXN0cyBmb3IgdGhpcyBkZXBsb3ltZW50XG4gKiBAcHJvcCB7Qm9vbGVhbn0gW3JvbGxiYWNrT25FcnJvcl0gLSBJbmRpY2F0ZXMgd2hldGhlciBhbnkgZmFpbHVyZSBjYXVzZXMgYSBjb21wbGV0ZSByb2xsYmFjayBvciBub3QuIERlZmF1bHQgaXMgdHJ1ZS5cbiAqIEBwcm9wIHtTdHJpbmd9IHN0YXJ0RGF0ZSAtIFRpbWVzdGFtcCBmb3Igd2hlbiB0aGUgZGVwbG95bWVudCBwcm9jZXNzIGJlZ2FuXG4gKiBAcHJvcCB7U3RyaW5nfSBzdGF0dXMgLSBJbmRpY2F0ZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGRlcGxveW1lbnRcbiAqIEBwcm9wIHtCb29sZWFufSBzdWNjZXNzIC0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlcGxveW1lbnQgd2FzIHN1Y2Nlc3NmdWwgb3Igbm90XG4gKi9cblxuLyoqXG4gKiBDaGVjayBhbmQgd2FpdCB1bnRpbCB0aGUgYXN5bmMgcmVxdWVzdCBiZWNvbWVzIGluIGNvbXBsZXRlZCBzdGF0dXMsXG4gKiBhbmQgcmV0cmlldmUgdGhlIHJlc3VsdCBkYXRhLlxuICpcbiAqIEBtZXRob2QgTWV0YWRhdGF+RGVwbG95UmVzdWx0TG9jYXRvciNjb21wbGV0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48TWV0YWRhdGF+RGVwbG95UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TWV0YWRhdGF+RGVwbG95UmVzdWx0Pn1cbiAqL1xuRGVwbG95UmVzdWx0TG9jYXRvci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbihpbmNsdWRlRGV0YWlscywgY2FsbGJhY2spIHtcbiAgaWYgKF8uaXNGdW5jdGlvbihpbmNsdWRlRGV0YWlscykpIHtcbiAgICBjYWxsYmFjayA9IGluY2x1ZGVEZXRhaWxzO1xuICAgIGluY2x1ZGVEZXRhaWxzID0gZmFsc2U7XG4gIH1cbiAgdmFyIG1ldGEgPSB0aGlzLl9tZXRhO1xuICByZXR1cm4gRGVwbG95UmVzdWx0TG9jYXRvci5zdXBlcl8ucHJvdG90eXBlLmNvbXBsZXRlLmNhbGwodGhpcykudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICByZXR1cm4gbWV0YS5jaGVja0RlcGxveVN0YXR1cyhyZXN1bHQuaWQsIGluY2x1ZGVEZXRhaWxzKTtcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qXG4gKiBSZWdpc3RlciBob29rIGluIGNvbm5lY3Rpb24gaW5zdGFudGlhdGlvbiBmb3IgZHluYW1pY2FsbHkgYWRkaW5nIHRoaXMgQVBJIG1vZHVsZSBmZWF0dXJlc1xuICovXG5qc2ZvcmNlLm9uKCdjb25uZWN0aW9uOm5ldycsIGZ1bmN0aW9uKGNvbm4pIHtcbiAgY29ubi5tZXRhZGF0YSA9IG5ldyBNZXRhZGF0YShjb25uKTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/api/metadata.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/api/metadata.js":
/*!**************************************************!*\
  !*** ./node_modules/jsforce/lib/api/metadata.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global process, Buffer */\n/**\n * @file Manages Salesforce Metadata API\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\"),\n    events  = __webpack_require__(/*! events */ \"events\"),\n    stream  = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/readable.js\"),\n    _       = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    jsforce = __webpack_require__(/*! ../core */ \"(rsc)/./node_modules/jsforce/lib/core.js\"),\n    Promise = __webpack_require__(/*! ../promise */ \"(rsc)/./node_modules/jsforce/lib/promise.js\"),\n    SOAP    = __webpack_require__(/*! ../soap */ \"(rsc)/./node_modules/jsforce/lib/soap.js\");\n\n/*--------------------------------------------*/\n/**\n * Class for Salesforce Metadata API\n *\n * @class\n * @param {Connection} conn - Connection object\n */\nvar Metadata = module.exports = function(conn) {\n  this._conn = conn;\n};\n\n\n/**\n * Polling interval in milliseconds\n * @type {Number}\n */\nMetadata.prototype.pollInterval = 1000;\n\n/**\n * Polling timeout in milliseconds\n * @type {Number}\n */\nMetadata.prototype.pollTimeout = 10000;\n\n\n/**\n * Call Metadata API SOAP endpoint\n *\n * @private\n */\nMetadata.prototype._invoke = function(method, message, callback) {\n  var soapEndpoint = new SOAP(this._conn, {\n    xmlns: \"http://soap.sforce.com/2006/04/metadata\",\n    endpointUrl: this._conn.instanceUrl + \"/services/Soap/m/\" + this._conn.version\n  });\n  return soapEndpoint.invoke(method, message).then(function(res) {\n    return res.result;\n  }).thenCall(callback);\n};\n\n\n/**\n * @typedef {Object} Metadata~MetadataInfo\n * @prop {String} fullName - The name of the component\n */\n\n/**\n * Asynchronously adds one or more new metadata components to the organization.\n *\n * @param {String} type - The type of metadata to create\n * @param {Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>} metadata - Metadata to create\n * @param {Callback.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} [callback] - Callback function\n * @returns {Metadata~AsyncResultLocator}\n */\nMetadata.prototype.createAsync = function(type, metadata, callback) {\n  if (Number(this._conn.version) > 30) {\n    throw new Error(\"Async metadata CRUD calls are not supported on ver 31.0 or later.\");\n  }\n  var convert = function(md) {\n    md[\"@xsi:type\"] = type;\n    return md;\n  };\n  var isArray = _.isArray(metadata);\n  metadata = isArray ? _.map(metadata, convert) : convert(metadata);\n  var res = this._invoke(\"create\", { metadata: metadata });\n  return new AsyncResultLocator(this, res, isArray).thenCall(callback);\n};\n\n/**\n * @typedef {Object} Metadata~SaveResult\n * @prop {Boolean} success - True if metadata is successfully saved\n * @prop {String} fullName - Full name of metadata object\n */\n\n/**\n * @private\n */\nfunction convertToSaveResult(result) {\n  var saveResult = _.clone(result);\n  saveResult.success = saveResult.success === 'true';\n  return saveResult;\n}\n\n/**\n * @typedef {Object} Metadata~UpsertResult\n * @prop {Boolean} success - True if metadata is successfully saved\n * @prop {String} fullName - Full name of metadata object\n * @prop {Boolean} created - True if metadata is newly created\n */\n\n/**\n * @private\n */\nfunction convertToUpsertResult(result) {\n  var upsertResult = convertToSaveResult(result);\n  upsertResult.created = upsertResult.created === 'true';\n  return upsertResult;\n}\n\n/**\n * Synonym of Metadata#create().\n *\n * @method Metadata#createSync\n * @param {String} type - The type of metadata to create\n * @param {Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>} metadata - Metadata to create\n * @param {Callback.<Metadata~SaveResult|Array.<Metadata~SaveResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~SaveResult|Array.<Metadata~SaveResult>>}\n */\n/**\n * Synchronously adds one or more new metadata components to the organization.\n *\n * @method Metadata#create\n * @param {String} type - The type of metadata to create\n * @param {Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>} metadata - Metadata to create\n * @param {Callback.<Metadata~SaveResult|Array.<Metadata~SaveResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~SaveResult|Array.<Metadata~SaveResult>>}\n */\nMetadata.prototype.createSync =\nMetadata.prototype.create = function(type, metadata, callback) {\n  var convert = function(md) {\n    md[\"@xsi:type\"] = type;\n    return md;\n  };\n  var isArray = _.isArray(metadata);\n  metadata = isArray ? _.map(metadata, convert) : convert(metadata);\n  return this._invoke(\"createMetadata\", { metadata: metadata }).then(function(results) {\n    return _.isArray(results) ? _.map(results, convertToSaveResult) : convertToSaveResult(results);\n  }).thenCall(callback);\n};\n\n/**\n * @private\n */\nfunction convertToMetadataInfo(rec) {\n  var metadataInfo = _.clone(rec);\n  delete metadataInfo.$;\n  return metadataInfo;\n}\n\n/**\n * Synonym of Metadata#read()\n *\n * @method Metadata#readSync\n * @param {String} type - The type of metadata to read\n * @param {String|Array.<String>} fullNames - full name(s) of metadata objects to read\n * @param {Callback.<Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>>>}\n */\n/**\n * Synchronously read specified metadata components in the organization.\n *\n * @method Metadata#read\n * @param {String} type - The type of metadata to read\n * @param {String|Array.<String>} fullNames - full name(s) of metadata objects to read\n * @param {Callback.<Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>>>}\n */\nMetadata.prototype.readSync =\nMetadata.prototype.read = function(type, fullNames, callback) {\n  return this._invoke(\"readMetadata\", { type: type, fullNames: fullNames }).then(function(res) {\n    return _.isArray(res.records) ? _.map(res.records, convertToMetadataInfo) : convertToMetadataInfo(res.records);\n  }).thenCall(callback);\n};\n\n/**\n * @typedef {Object} Metadata~UpdateMetadataInfo\n * @prop {String} currentName - The API name of the component or field before the update\n * @prop {Metadata~MetadataInfo} metadata - Full specification of the component or field you wish to update\n */\n\n/**\n * Asynchronously updates one or more metadata components in the organization.\n *\n * @param {String} type - The type of metadata to update\n * @param {Metadata~UpdateMetadataInfo|Array.<Metadata~UpdateMetadataInfo>} updateMetadata - Updating metadata\n * @param {Callback.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} [callback] - Callback function\n * @returns {Metadata~AsyncResultLocator}\n */\nMetadata.prototype.updateAsync = function(type, updateMetadata, callback) {\n  if (Number(this._conn.version) > 30) {\n    throw new Error(\"Async metadata CRUD calls are not supported on ver 31.0 or later.\");\n  }\n  var convert = function(umd) {\n    umd.metadata[\"@xsi:type\"] = type;\n    return umd;\n  };\n  var isArray = _.isArray(updateMetadata);\n  updateMetadata = isArray ? _.map(updateMetadata, convert) : convert(updateMetadata);\n  var res = this._invoke(\"update\", { updateMetadata: updateMetadata });\n  return new AsyncResultLocator(this, res, isArray).thenCall(callback);\n};\n\n/**\n * Synonym of Metadata#update().\n *\n * @method Metadata#updateSync\n * @param {String} type - The type of metadata to update\n * @param {Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>} updateMetadata - Updating metadata\n * @param {Callback.<Metadata~SaveResult|Array.<Metadata~SaveResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~SaveResult|Array.<Metadata~SaveResult>>}\n */\n/**\n * Synchronously updates one or more metadata components in the organization.\n *\n * @method Metadata#update\n * @param {String} type - The type of metadata to update\n * @param {Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>} updateMetadata - Updating metadata\n * @param {Callback.<Metadata~SaveResult|Array.<Metadata~SaveResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~SaveResult|Array.<Metadata~SaveResult>>}\n */\nMetadata.prototype.updateSync =\nMetadata.prototype.update = function(type, metadata, callback) {\n  var convert = function(md) {\n    md[\"@xsi:type\"] = type;\n    return md;\n  };\n  var isArray = _.isArray(metadata);\n  metadata = isArray ? _.map(metadata, convert) : convert(metadata);\n  return this._invoke(\"updateMetadata\", { metadata: metadata }).then(function(results) {\n    return _.isArray(results) ? _.map(results, convertToSaveResult) : convertToSaveResult(results);\n  }).thenCall(callback);\n};\n\n/**\n * Synonym of Metadata#upsert().\n *\n * @method Metadata#upsertSync\n * @param {String} type - The type of metadata to upsert\n * @param {Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>} metadata - Upserting metadata\n * @param {Callback.<Metadata~UpsertResult|Array.<Metadata~UpsertResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~UpsertResult|Array.<Metadata~UpsertResult>>}\n */\n/**\n * Upserts one or more components in your organization's data.\n *\n * @method Metadata#upsert\n * @param {String} type - The type of metadata to upsert\n * @param {Metadata~MetadataInfo|Array.<Metadata~MetadataInfo>} metadata - Upserting metadata\n * @param {Callback.<Metadata~UpsertResult|Array.<Metadata~UpsertResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~UpsertResult|Array.<Metadata~UpsertResult>>}\n */\nMetadata.prototype.upsertSync =\nMetadata.prototype.upsert = function(type, metadata, callback) {\n  var convert = function(md) {\n    md[\"@xsi:type\"] = type;\n    return md;\n  };\n  var isArray = _.isArray(metadata);\n  metadata = isArray ? _.map(metadata, convert) : convert(metadata);\n  return this._invoke(\"upsertMetadata\", { metadata: metadata }).then(function(results) {\n    return _.isArray(results) ? _.map(results, convertToUpsertResult) : convertToUpsertResult(results);\n  }).thenCall(callback);\n};\n\n/**\n * Asynchronously deletes specified metadata components in the organization.\n *\n * @param {String} type - The type of metadata to delete\n * @param {String|Metadata~MetadataInfo|Array.<String>|Array.<Metadata~MetadataInfo>} metadata - The fullName of metadata or metadata info to delete. If it is passed in fullName, the type parameter should not be empty.\n * @param {Callback.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} [callback] - Callback function\n * @returns {Metadata~AsyncResultLocator}\n */\nMetadata.prototype.deleteAsync = function(type, metadata, callback) {\n  if (Number(this._conn.version) > 30) {\n    throw new Error(\"Async metadata CRUD calls are not supported on ver 31.0 or later.\");\n  }\n  var convert = function(md) {\n    if (_.isString(md)) {\n      md = { fullName : md };\n    }\n    md[\"@xsi:type\"] = type;\n    return md;\n  };\n  var isArray = _.isArray(metadata);\n  metadata = isArray ? _.map(metadata, convert) : convert(metadata);\n  var res = this._invoke(\"delete\", { metadata: metadata });\n  return new AsyncResultLocator(this, res, isArray).thenCall(callback);\n};\n\n/**\n * Synonym of Metadata#delete().\n *\n * @deprecated\n * @method Metadata#del\n * @param {String} [type] - The type of metadata to delete\n * @param {String|Metadata~MetadataInfo|Array.<String>|Array.<Metadata~MetadataInfo>} metadata - The fullName of metadata or metadata info to delete. If it is passed in fullName, the type parameter should not be empty.\n * @param {Callback.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} [callback] - Callback function\n * @returns {Metadata~AsyncResultLocator}\n */\n/**\n * Synonym of Metadata#delete().\n *\n * @method Metadata#deleteSync\n * @param {String} type - The type of metadata to delete\n * @param {String|Array.<String>} fullNames - The fullName of metadata to delete.\n * @param {Callback.<Metadata~SaveResult|Array.<Metadata~SaveResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~SaveResult|Array.<Metadata~SaveResult>>}\n */\n\n/**\n * Synchronously deletes specified metadata components in the organization.\n *\n * @method Metadata#delete\n * @param {String} type - The type of metadata to delete\n * @param {String|Array.<String>} fullNames - The fullName of metadata to delete.\n * @param {Callback.<Metadata~SaveResult|Array.<Metadata~SaveResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~SaveResult|Array.<Metadata~SaveResult>>}\n */\nMetadata.prototype.del =\nMetadata.prototype.deleteSync =\nMetadata.prototype[\"delete\"] = function(type, fullNames, callback) {\n  return this._invoke(\"deleteMetadata\", { type: type, fullNames: fullNames }).then(function(results) {\n    return _.isArray(results) ? _.map(results, convertToSaveResult) : convertToSaveResult(results);\n  }).thenCall(callback);\n};\n\n/**\n * Rename fullname of a metadata component in the organization\n *\n * @param {String} type - The type of metadata to delete\n * @param {String} oldFullName - The original fullName of metadata\n * @param {String} newFullName - The new fullName of metadata\n * @param {Callback.<Metadata~SaveResult>} [callback] - Callback function\n * @returns {Promise.<Metadata~SaveResult>}\n */\nMetadata.prototype.rename = function(type, oldFullName, newFullName, callback) {\n  return this._invoke(\"renameMetadata\", { type: type, oldFullName: oldFullName, newFullName: newFullName }).then(function(result) {\n    return convertToSaveResult(result);\n  }).thenCall(callback);\n};\n\n/**\n * Checks the status of asynchronous metadata calls\n *\n * @param {String|Array.<String>} ids - The asynchronous process ID(s)\n * @param {Callback.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} [callback] - Callback function\n * @returns {Metadata~AsyncResultLocator}\n */\nMetadata.prototype.checkStatus = function(ids, callback) {\n  var isArray = _.isArray(ids);\n  var res = this._invoke(\"checkStatus\", { asyncProcessId: ids });\n  return new AsyncResultLocator(this, res, isArray).thenCall(callback);\n};\n\n/**\n * @typedef {Object} Metadata~DescribeMetadataResult\n * @prop {Array.<Object>} metadataObjects - One or more metadata components and their attributes\n * @prop {Array.<String>} metadataObjects.childXmlNames - List of child sub-components for this component\n * @prop {String} metadataObjects.directoryName - The name of the directory in the .zip file that contains this component\n * @prop {Boolean} metadataObjects.inFolder - Indicates whether the component is in a folder or not\n * @prop {Boolean} metadataObjects.metaFile - Indicates whether the component requires an accompanying metadata file\n * @prop {String} metadataObjects.suffix - The file suffix for this component\n * @prop {String} metadataObjects.xmlName - The name of the root element in the metadata file for this component\n * @prop {String} organizationNamespace - The namespace of the organization\n * @prop {Boolean} partialSaveAllowed - Indicates whether rollbackOnError is allowed or not\n * @prop {Boolean} testRequired - Indicates whether tests are required or not\n */\n\n/**\n * Retrieves the metadata which describes your organization, including Apex classes and triggers,\n * custom objects, custom fields on standard objects, tab sets that define an app,\n * and many other components.\n *\n * @param {String} [version] - The API version for which you want metadata; for example, 29.0\n * @param {Callback.<Metadata~DescribeMetadataResult>} [callback] - Callback function\n * @returns {Promise.<Metadata~DescribeMetadataResult>}\n */\nMetadata.prototype.describe = function(version, callback) {\n  if (!_.isString(version)) {\n    callback = version;\n    version = this._conn.version;\n  }\n  return this._invoke(\"describeMetadata\", { asOfVersion: version }).then(function(res) {\n    res.metadataObjects = _.isArray(res.metadataObjects) ? res.metadataObjects : [ res.metadataObjects ];\n    res.metadataObjects = _.map(res.metadataObjects, function(mo) {\n      if (mo.childXmlNames) {\n        mo.childXmlNames = _.isArray(mo.childXmlNames) ? mo.childXmlNames: [ mo.childXmlNames ];\n      }\n      mo.inFolder = mo.inFolder === 'true';\n      mo.metaFile = mo.metaFile === 'true';\n      return mo;\n    });\n    res.partialSaveAllowed = res.partialSaveAllowed === 'true';\n    res.testRequired = res.testRequired === 'true';\n    return res;\n  }).thenCall(callback);\n};\n\n/**\n * @typedef {Object} Metadata~ListMetadataQuery\n * @prop {String} type - The metadata type, such as CustomObject, CustomField, or ApexClass\n * @prop {String} [folder] - The folder associated with the component.\n */\n\n/**\n * @typedef {Object} Metadata~FileProperties\n * @prop {String} type - The metadata type, such as CustomObject, CustomField, or ApexClass\n * @prop {String} createdById - ID of the user who created the file\n * @prop {String} createdByName - Name of the user who created the file\n * @prop {String} createdDate - Date and time when the file was created\n * @prop {String} fileName - Name of the file\n * @prop {String} fullName - The file developer name used as a unique identifier for API access\n * @prop {String} id - ID of the file\n * @prop {String} lastModifiedById - ID of the user who last modified the file\n * @prop {String} lastModifiedByName - Name of the user who last modified the file\n * @prop {String} lastModifiedDate - Date and time that the file was last modified\n * @prop {String} [manageableState] - Indicates the manageable state of the specified component if it is contained in a package\n * @prop {String} [namespacePrefix] - The namespace prefix of the component\n */\n\n/**\n * Retrieves property information about metadata components in your organization\n *\n * @param {Metadata~ListMetadataQuery|Array.<Metadata~ListMetadataQuery>} queries - The criteria object(s) specifing metadata to list\n * @param {String} [version] - The API version for which you want metadata; for example, 29.0\n * @param {Callback.<Array.<Metadata~FileProperties>>} [callback] - Callback function\n * @returns {Promise.<Array.<Metadata~FileProperties>>}\n */\nMetadata.prototype.list = function(queries, version, callback) {\n  if (!_.isString(version)) {\n    callback = version;\n    version = this._conn.version;\n  }\n  if (!_.isArray(queries)) {\n    queries = [ queries ];\n  }\n  return this._invoke(\"listMetadata\", { queries: queries, asOfVersion: version }, callback);\n};\n\n/**\n * @typedef {Object} Metadata~RetrieveRequest\n */\n\n/**\n * Retrieves XML file representations of components in an organization\n *\n * @param {Metadata~RetrieveRequest} request - Options for determining which packages or files are retrieved\n * @param {Callback.<Metadata~AsyncResult>} [callback] - Callback function\n * @returns {Metadata~RetrieveResultLocator}\n */\nMetadata.prototype.retrieve = function(request, callback) {\n  var res = this._invoke(\"retrieve\", { request: request });\n  return new RetrieveResultLocator(this, res).thenCall(callback);\n};\n\n/**\n * Checks the status of declarative metadata call retrieve() and returns the zip file contents\n *\n * @param {String} id - Async process id returned from previous retrieve request\n * @param {Callback.<Metadata~RetrieveResult>} [callback] - Callback function\n * @returns {Promise.<Metadata~RetrieveResult>}\n */\nMetadata.prototype.checkRetrieveStatus = function(id, callback) {\n  return this._invoke(\"checkRetrieveStatus\", { asyncProcessId: id }, callback);\n};\n\n/**\n * Deploy components into an organization using zipped file representations\n *\n * @param {stream.Stream|Buffer|String} zipInput - Zipped file input source in readable stream, binary buffer or Base64-encoded string\n * @param {Object} [options] - Options used in deployment\n * @param {Boolean} [options.allowMissingFiles] - Specifies whether a deploy succeeds even if files that are specified in package.xml but are not in the .zip file or not.\n * @param {Boolean} [options.autoUpdatePackage] - If a file is in the .zip file but not specified in package.xml, specifies whether the file should be automatically added to the package or not.\n * @param {Boolean} [options.checkOnly] - Indicates whether Apex classes and triggers are saved to the organization as part of the deployment (false) or not (true).\n * @param {Boolean} [options.ignoreWarnings] - Indicates whether a warning should allow a deployment to complete successfully (true) or not (false). Defaults to false.\n * @param {Boolean} [options.performRetrieve] - Indicates whether a retrieve() call is performed immediately after the deployment (true) or not (false).\n * @param {Boolean} [options.purgeOnDelete] - If true, the deleted components in the destructiveChanges.xml manifest file aren't stored in the Recycle Bin.\n * @param {Boolean} [options.rollbackOnError] - Indicates whether any failure causes a complete rollback (true) or not (false).\n * @param {Boolean} [options.runAllTests] - If true, all Apex tests defined in the organization are run.\n * @param {Array.<String>} [options.runTests] - A list of Apex tests to be run during deployment.\n * @param {Boolean} [options.singlePackage] - Indicates whether the specified .zip file points to a directory structure with a single package (true) or a set of packages (false).\n * @param {Callback.<Metadata~AsyncResult>} [callback] - Callback function\n * @returns {Metadata~DeployResultLocator}\n */\nMetadata.prototype.deploy = function(zipInput, options, callback) {\n  if (!options || _.isFunction(options)) {\n    callback = options;\n    options = {};\n  }\n  var deferred = Promise.defer();\n  if (_.isObject(zipInput) && _.isFunction(zipInput.pipe)) {\n    var bufs = [];\n    zipInput.on('data', function(d) {\n      bufs.push(d);\n    });\n    zipInput.on('end', function() {\n      deferred.resolve(Buffer.concat(bufs).toString('base64'));\n    });\n    // zipInput.resume();\n  } else if (zipInput instanceof Buffer) {\n    deferred.resolve(zipInput.toString('base64'));\n  } else if (zipInput instanceof String || typeof zipInput === 'string') {\n    deferred.resolve(zipInput);\n  } else {\n    throw \"Unexpected zipInput type\";\n  }\n\n  var self = this;\n  var res = deferred.promise.then(function(zipContentB64) {\n    return self._invoke(\"deploy\", {\n      ZipFile: zipContentB64,\n      DeployOptions: options\n    }, callback);\n  });\n  return new DeployResultLocator(this, res).thenCall(callback);\n};\n\n/**\n * Checks the status of declarative metadata call deploy()\n *\n * @param {String} id - Async process id returned from previous deploy request\n * @param {Boolean} [includeDetails] - Sets the DeployResult object to include details information (default: false)\n * @param {Callback.<Metadata~DeployResult>} [callback] - Callback function\n * @returns {Promise.<Metadata~DeployResult>}\n */\nMetadata.prototype.checkDeployStatus = function(id, includeDetails, callback) {\n  if (_.isObject(includeDetails) || _.isBoolean(includeDetails)) {\n    includeDetails = !!includeDetails;\n  } else {\n    callback = includeDetails;\n    includeDetails = false;\n  }\n  return this._invoke(\"checkDeployStatus\", {\n    asyncProcessId: id,\n    includeDetails : includeDetails\n  }).then(function(res) {\n    res.done = res.done === 'true';\n    res.success = res.success === 'true';\n    res.checkOnly = res.checkOnly === 'true';\n    res.runTestsEnabled = res.runTestsEnabled === 'true';\n    if (res.ignoreWarnings) {\n      res.ignoreWarnings = res.ignoreWarnings === 'true';\n    }\n    if (res.rollbackOnError) {\n      res.rollbackOnError = res.rollbackOnError === 'true';\n    }\n    res.numberComponentErrors = Number(res.numberComponentErrors);\n    res.numberComponentsDeployed = Number(res.numberComponentsDeployed);\n    res.numberComponentsTotal = Number(res.numberComponentsTotal);\n    res.numberTestErrors = Number(res.numberTestErrors);\n    res.numberTestsCompleted = Number(res.numberTestsCompleted);\n    res.numberTestsTotal = Number(res.numberTestsTotal);\n\n    return res;\n  }).thenCall(callback);\n};\n\n\n/*--------------------------------------------*/\n\n/**\n * @typedef {Object} Metadata~AsyncResult\n * @prop {Boolean} done - Indicates whether the call has completed or not\n * @prop {String} id - ID of the component being created, updated, deleted, deployed, or retrieved\n * @prop {String} state - The state four possible values: Queued, InProgress, Completed, and Error.\n * @prop {String} [statusCode] - If an error occurred during the create(), update(), or delete() call, a status code is returned\n * @prop {String} [message] - Message corresponding to the statusCode field returned\n */\n\n/**\n * The locator class for Metadata API asynchronous call result\n *\n * @protected\n * @class Metadata~AsyncResultLocator\n * @extends events.EventEmitter\n * @implements Promise.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>\n * @param {Metadata} meta - Metadata API object\n * @param {Promise.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} results - Promise object for async result info\n * @param {Boolean} [isArray] - Indicates whether the async request is given in array or single object\n */\nvar AsyncResultLocator = function(meta, results, isArray) {\n  this._meta = meta;\n  this._results = results;\n  this._isArray = isArray;\n};\n\ninherits(AsyncResultLocator, events.EventEmitter);\n\n/**\n * Promise/A+ interface\n * http://promises-aplus.github.io/promises-spec/\n *\n * Delegate to deferred promise, return promise instance for batch result\n *\n * @method Metadata~AsyncResultLocator#then\n */\nAsyncResultLocator.prototype.then = function(onResolve, onReject) {\n  var self = this;\n  return this._results.then(function(results) {\n    var convertType = function(res) {\n      if (res.$ && res.$[\"xsi:nil\"] === 'true') {\n        return null;\n      }\n      res.done = res.done === 'true';\n      return res;\n    };\n    results = _.isArray(results) ? _.map(results, convertType) : convertType(results);\n    if (self._isArray && !_.isArray(results)) {\n      results = [ results ];\n    }\n    return onResolve(results);\n  }, onReject);\n};\n\n/**\n * Promise/A+ extension\n * Call \"then\" using given node-style callback function\n *\n * @method Metadata~AsyncResultLocator#thenCall\n */\nAsyncResultLocator.prototype.thenCall = function(callback) {\n  return _.isFunction(callback) ? this.then(function(res) {\n    process.nextTick(function() {\n      callback(null, res);\n    });\n  }, function(err) {\n    process.nextTick(function() {\n      callback(err);\n    });\n  }) : this;\n};\n\n/**\n * Check the status of async request\n *\n * @method Metadata~AsyncResultLocator#check\n * @param {Callback.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>}\n */\nAsyncResultLocator.prototype.check = function(callback) {\n  var self = this;\n  var meta = this._meta;\n  return this.then(function(results) {\n    var ids = _.isArray(results) ? _.map(results, function(res){ return res.id; }) : results.id;\n    self._ids = ids;\n    return meta.checkStatus(ids);\n  }).thenCall(callback);\n};\n\n/**\n * Polling until async call status becomes complete or error\n *\n * @method Metadata~AsyncResultLocator#poll\n * @param {Number} interval - Polling interval in milliseconds\n * @param {Number} timeout - Polling timeout in milliseconds\n */\nAsyncResultLocator.prototype.poll = function(interval, timeout) {\n  var self = this;\n  var startTime = new Date().getTime();\n  var poll = function() {\n    var now = new Date().getTime();\n    if (startTime + timeout < now) {\n      var errMsg = \"Polling time out.\";\n      if (self._ids) {\n        errMsg += \" Process Id = \" + self._ids;\n      }\n      self.emit('error', new Error(errMsg));\n      return;\n    }\n    self.check().then(function(results) {\n      var done = true;\n      var resultArr = _.isArray(results) ? results : [ results ];\n      for (var i=0, len=resultArr.length; i<len; i++) {\n        var result = resultArr[i];\n        if (result && !result.done) {\n          self.emit('progress', result);\n          done = false;\n        }\n      }\n      if (done) {\n        self.emit('complete', results);\n      } else {\n        setTimeout(poll, interval);\n      }\n    }, function(err) {\n      self.emit('error', err);\n    });\n  };\n  setTimeout(poll, interval);\n};\n\n/**\n * Check and wait until the async requests become in completed status\n *\n * @method Metadata~AsyncResultLocator#complete\n * @param {Callback.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>} [callback] - Callback function\n * @returns {Promise.<Metadata~AsyncResult|Array.<Metadata~AsyncResult>>}\n */\nAsyncResultLocator.prototype.complete = function(callback) {\n  var deferred = Promise.defer();\n  this.on('complete', function(results) {\n    deferred.resolve(results);\n  });\n  this.on('error', function(err) {\n    deferred.reject(err);\n  });\n  var meta = this._meta;\n  this.poll(meta.pollInterval, meta.pollTimeout);\n  return deferred.promise.thenCall(callback);\n};\n\n/*--------------------------------------------*/\n/**\n * The locator class to track retreive() Metadata API call result\n *\n * @protected\n * @class Metadata~RetrieveResultLocator\n * @extends Metadata~AsyncResultLocator\n * @param {Metadata} meta - Metadata API object\n * @param {Promise.<Metadata~AsyncResult>} result - Promise object for async result of retrieve call()\n */\nvar RetrieveResultLocator = function(meta, result) {\n  RetrieveResultLocator.super_.call(this, meta, result);\n};\n\ninherits(RetrieveResultLocator, AsyncResultLocator);\n\n/**\n * @typedef {Object} Metadata~RetrieveResult\n * @prop {Array.<Metadata~FileProperties>} fileProperties - Contains information about the properties of each component in the .zip file, and the manifest file package.xml\n * @prop {String} id - ID of the component being retrieved\n * @prop {Array.<Object>} messages - Contains information about the success or failure of the retrieve() call\n * @prop {String} zipFile - The zip file returned by the retrieve request. Base 64-encoded binary data\n */\n\n/**\n * Check and wait until the async request becomes in completed status,\n * and retrieve the result data.\n *\n * @memthod Metadata~RetrieveResultLocator#complete\n * @param {Callback.<Metadata~RetrieveResult>} [callback] - Callback function\n * @returns {Promise.<Metadata~RetrieveResult>}\n */\nRetrieveResultLocator.prototype.complete = function(callback) {\n  var meta = this._meta;\n  return RetrieveResultLocator.super_.prototype.complete.call(this).then(function(result) {\n    return meta.checkRetrieveStatus(result.id);\n  }).thenCall(callback);\n};\n\n/**\n * Change the retrieved result to Node.js readable stream\n *\n * @method Metadata~RetrieveResultLocator#stream\n * @returns {stream.Readable}\n */\nRetrieveResultLocator.prototype.stream = function() {\n  var self = this;\n  var resultStream = new stream.Readable();\n  var reading = false;\n  resultStream._read = function() {\n    if (reading) { return; }\n    reading = true;\n    self.complete(function(err, result) {\n      if (err) {\n        resultStream.emit('error', err);\n      } else {\n        resultStream.push(Buffer.from(result.zipFile, 'base64'));\n        resultStream.push(null);\n      }\n    });\n  };\n  return resultStream;\n};\n\n/*--------------------------------------------*/\n/**\n * The locator class to track deploy() Metadata API call result\n *\n * @protected\n * @class Metadata~DeployResultLocator\n * @extends Metadata~AsyncResultLocator\n * @param {Metadata} meta - Metadata API object\n * @param {Promise.<Metadata~AsyncResult>} result - Promise object for async result of deploy() call\n */\nvar DeployResultLocator = function(meta, result) {\n  DeployResultLocator.super_.call(this, meta, result);\n};\n\ninherits(DeployResultLocator, AsyncResultLocator);\n\n/**\n * @typedef {Object} Metadata~DeployResult\n * @prop {String} id - ID of the component being deployed\n * @prop {Boolean} checkOnly - Indicates whether this deployment is being used to check the validity of the deployed files without making any changes in the organization or not\n * @prop {String} completedDate - Timestamp for when the deployment process ended\n * @prop {String} createdDate - Timestamp for when the deploy() call was received\n * @prop {Array.<Object>} [details] - Provides the details of a deployment that is in-progress or ended, if includeDetails is set to true in checkDeployStatus() call\n * @prop {Boolean} done - Indicates whether the server finished processing the deploy() call for the specified id\n * @prop {String} [errorMessage] - Message corresponding to the values in the errorStatusCode field\n * @prop {String} [errorStatusCode] - If an error occurred during the deploy() call, a status code is returned, and the message corresponding to the status code is returned in the errorMessagefield\n * @prop {Boolean} [ignoreWarnings] - Specifies whether a deployment should continue even if the deployment generates warnings\n * @prop {String} lastModifiedDate - Timestamp of the last update for the deployment process\n * @prop {Number} numberComponentErrors - The number of components that generated errors during this deployment\n * @prop {Number} numberComponentsDeployed - The number of components deployed in the deployment process\n * @prop {Number} numberComponentsTotal - The total number of components in the deployment\n * @prop {Number} numberTestErrors - The number of Apex tests that have generated errors during this deployment\n * @prop {Number} numberTestsCompleted - The number of completedApex tests for this deployment\n * @prop {Number} numberTestsTotal - The total number of Apex tests for this deployment\n * @prop {Boolean} [rollbackOnError] - Indicates whether any failure causes a complete rollback or not. Default is true.\n * @prop {String} startDate - Timestamp for when the deployment process began\n * @prop {String} status - Indicates the current state of the deployment\n * @prop {Boolean} success - Indicates whether the deployment was successful or not\n */\n\n/**\n * Check and wait until the async request becomes in completed status,\n * and retrieve the result data.\n *\n * @method Metadata~DeployResultLocator#complete\n * @param {Callback.<Metadata~DeployResult>} [callback] - Callback function\n * @returns {Promise.<Metadata~DeployResult>}\n */\nDeployResultLocator.prototype.complete = function(includeDetails, callback) {\n  if (_.isFunction(includeDetails)) {\n    callback = includeDetails;\n    includeDetails = false;\n  }\n  var meta = this._meta;\n  return DeployResultLocator.super_.prototype.complete.call(this).then(function(result) {\n    return meta.checkDeployStatus(result.id, includeDetails);\n  }).thenCall(callback);\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.metadata = new Metadata(conn);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL21ldGFkYXRhLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDJEQUFVO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxzQkFBUTtBQUM5QixjQUFjLG1CQUFPLENBQUMsOEZBQWlCO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyx3REFBYTtBQUNuQyxjQUFjLG1CQUFPLENBQUMseURBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLCtEQUFZO0FBQ2xDLGNBQWMsbUJBQU8sQ0FBQyx5REFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsUUFBUTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxREFBcUQ7QUFDaEUsV0FBVyw4REFBOEQ7QUFDekUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0JBQW9CO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsUUFBUTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsU0FBUztBQUNuQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxTQUFTO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxREFBcUQ7QUFDaEUsV0FBVyw0REFBNEQ7QUFDdkUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxREFBcUQ7QUFDaEUsV0FBVyw0REFBNEQ7QUFDdkUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQkFBb0I7QUFDOUQ7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLGdFQUFnRTtBQUMzRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLGdFQUFnRTtBQUMzRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtDQUFrQztBQUMxRTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFFBQVE7QUFDbEIsVUFBVSx1QkFBdUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUVBQWlFO0FBQzVFLFdBQVcsOERBQThEO0FBQ3pFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdDQUFnQztBQUNyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcscURBQXFEO0FBQ2hFLFdBQVcsNERBQTREO0FBQ3ZFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcscURBQXFEO0FBQ2hFLFdBQVcsNERBQTREO0FBQ3ZFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlEO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcscURBQXFEO0FBQ2hFLFdBQVcsZ0VBQWdFO0FBQzNFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcscURBQXFEO0FBQ2hFLFdBQVcsZ0VBQWdFO0FBQzNFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlEO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLDJFQUEyRTtBQUN0RixXQUFXLDhEQUE4RDtBQUN6RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVywyRUFBMkU7QUFDdEYsV0FBVyw4REFBOEQ7QUFDekUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyw0REFBNEQ7QUFDdkUsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsNERBQTREO0FBQ3ZFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQ0FBa0M7QUFDNUU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQ0FBZ0M7QUFDM0MsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwQ0FBMEMsZ0VBQWdFO0FBQzFHO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsOERBQThEO0FBQ3pFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxnQkFBZ0I7QUFDMUIsVUFBVSxnQkFBZ0I7QUFDMUIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsU0FBUztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLHlEQUF5RDtBQUM1RSxXQUFXLDRDQUE0QztBQUN2RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0RBQStEO0FBQzFFLFdBQVcsUUFBUSx5REFBeUQ7QUFDNUUsV0FBVyw0Q0FBNEM7QUFDdkQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3Q0FBd0M7QUFDaEY7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckMsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQSx1Q0FBdUMsa0JBQWtCO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsb0NBQW9DO0FBQy9DLGFBQWE7QUFDYjtBQUNBO0FBQ0EsK0NBQStDLG9CQUFvQjtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLGtDQUFrQztBQUM3QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsNkRBQTZEO0FBQ3hFLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhEQUE4RDtBQUN6RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxnQkFBZ0I7QUFDakY7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhEQUE4RDtBQUN6RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsaUNBQWlDO0FBQzNDLFVBQVUsUUFBUTtBQUNsQixVQUFVLGdCQUFnQjtBQUMxQixVQUFVLFFBQVE7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0NBQW9DO0FBQy9DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLGdCQUFnQjtBQUMxQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQ0FBa0M7QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL21ldGFkYXRhLmpzP2M5ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiLypnbG9iYWwgcHJvY2VzcywgQnVmZmVyICovXG4vKipcbiAqIEBmaWxlIE1hbmFnZXMgU2FsZXNmb3JjZSBNZXRhZGF0YSBBUElcbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKSxcbiAgICBldmVudHMgID0gcmVxdWlyZSgnZXZlbnRzJyksXG4gICAgc3RyZWFtICA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLFxuICAgIF8gICAgICAgPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpLFxuICAgIGpzZm9yY2UgPSByZXF1aXJlKCcuLi9jb3JlJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4uL3Byb21pc2UnKSxcbiAgICBTT0FQICAgID0gcmVxdWlyZSgnLi4vc29hcCcpO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogQ2xhc3MgZm9yIFNhbGVzZm9yY2UgTWV0YWRhdGEgQVBJXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gLSBDb25uZWN0aW9uIG9iamVjdFxuICovXG52YXIgTWV0YWRhdGEgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbm4pIHtcbiAgdGhpcy5fY29ubiA9IGNvbm47XG59O1xuXG5cbi8qKlxuICogUG9sbGluZyBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbk1ldGFkYXRhLnByb3RvdHlwZS5wb2xsSW50ZXJ2YWwgPSAxMDAwO1xuXG4vKipcbiAqIFBvbGxpbmcgdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbk1ldGFkYXRhLnByb3RvdHlwZS5wb2xsVGltZW91dCA9IDEwMDAwO1xuXG5cbi8qKlxuICogQ2FsbCBNZXRhZGF0YSBBUEkgU09BUCBlbmRwb2ludFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbk1ldGFkYXRhLnByb3RvdHlwZS5faW52b2tlID0gZnVuY3Rpb24obWV0aG9kLCBtZXNzYWdlLCBjYWxsYmFjaykge1xuICB2YXIgc29hcEVuZHBvaW50ID0gbmV3IFNPQVAodGhpcy5fY29ubiwge1xuICAgIHhtbG5zOiBcImh0dHA6Ly9zb2FwLnNmb3JjZS5jb20vMjAwNi8wNC9tZXRhZGF0YVwiLFxuICAgIGVuZHBvaW50VXJsOiB0aGlzLl9jb25uLmluc3RhbmNlVXJsICsgXCIvc2VydmljZXMvU29hcC9tL1wiICsgdGhpcy5fY29ubi52ZXJzaW9uXG4gIH0pO1xuICByZXR1cm4gc29hcEVuZHBvaW50Lmludm9rZShtZXRob2QsIG1lc3NhZ2UpLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhZGF0YX5NZXRhZGF0YUluZm9cbiAqIEBwcm9wIHtTdHJpbmd9IGZ1bGxOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudFxuICovXG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgYWRkcyBvbmUgb3IgbW9yZSBuZXcgbWV0YWRhdGEgY29tcG9uZW50cyB0byB0aGUgb3JnYW5pemF0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgbWV0YWRhdGEgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge01ldGFkYXRhfk1ldGFkYXRhSW5mb3xBcnJheS48TWV0YWRhdGF+TWV0YWRhdGFJbmZvPn0gbWV0YWRhdGEgLSBNZXRhZGF0YSB0byBjcmVhdGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhfkFzeW5jUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5Bc3luY1Jlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtNZXRhZGF0YX5Bc3luY1Jlc3VsdExvY2F0b3J9XG4gKi9cbk1ldGFkYXRhLnByb3RvdHlwZS5jcmVhdGVBc3luYyA9IGZ1bmN0aW9uKHR5cGUsIG1ldGFkYXRhLCBjYWxsYmFjaykge1xuICBpZiAoTnVtYmVyKHRoaXMuX2Nvbm4udmVyc2lvbikgPiAzMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIG1ldGFkYXRhIENSVUQgY2FsbHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gdmVyIDMxLjAgb3IgbGF0ZXIuXCIpO1xuICB9XG4gIHZhciBjb252ZXJ0ID0gZnVuY3Rpb24obWQpIHtcbiAgICBtZFtcIkB4c2k6dHlwZVwiXSA9IHR5cGU7XG4gICAgcmV0dXJuIG1kO1xuICB9O1xuICB2YXIgaXNBcnJheSA9IF8uaXNBcnJheShtZXRhZGF0YSk7XG4gIG1ldGFkYXRhID0gaXNBcnJheSA/IF8ubWFwKG1ldGFkYXRhLCBjb252ZXJ0KSA6IGNvbnZlcnQobWV0YWRhdGEpO1xuICB2YXIgcmVzID0gdGhpcy5faW52b2tlKFwiY3JlYXRlXCIsIHsgbWV0YWRhdGE6IG1ldGFkYXRhIH0pO1xuICByZXR1cm4gbmV3IEFzeW5jUmVzdWx0TG9jYXRvcih0aGlzLCByZXMsIGlzQXJyYXkpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0YWRhdGF+U2F2ZVJlc3VsdFxuICogQHByb3Age0Jvb2xlYW59IHN1Y2Nlc3MgLSBUcnVlIGlmIG1ldGFkYXRhIGlzIHN1Y2Nlc3NmdWxseSBzYXZlZFxuICogQHByb3Age1N0cmluZ30gZnVsbE5hbWUgLSBGdWxsIG5hbWUgb2YgbWV0YWRhdGEgb2JqZWN0XG4gKi9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9TYXZlUmVzdWx0KHJlc3VsdCkge1xuICB2YXIgc2F2ZVJlc3VsdCA9IF8uY2xvbmUocmVzdWx0KTtcbiAgc2F2ZVJlc3VsdC5zdWNjZXNzID0gc2F2ZVJlc3VsdC5zdWNjZXNzID09PSAndHJ1ZSc7XG4gIHJldHVybiBzYXZlUmVzdWx0O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFkYXRhflVwc2VydFJlc3VsdFxuICogQHByb3Age0Jvb2xlYW59IHN1Y2Nlc3MgLSBUcnVlIGlmIG1ldGFkYXRhIGlzIHN1Y2Nlc3NmdWxseSBzYXZlZFxuICogQHByb3Age1N0cmluZ30gZnVsbE5hbWUgLSBGdWxsIG5hbWUgb2YgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcHJvcCB7Qm9vbGVhbn0gY3JlYXRlZCAtIFRydWUgaWYgbWV0YWRhdGEgaXMgbmV3bHkgY3JlYXRlZFxuICovXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29udmVydFRvVXBzZXJ0UmVzdWx0KHJlc3VsdCkge1xuICB2YXIgdXBzZXJ0UmVzdWx0ID0gY29udmVydFRvU2F2ZVJlc3VsdChyZXN1bHQpO1xuICB1cHNlcnRSZXN1bHQuY3JlYXRlZCA9IHVwc2VydFJlc3VsdC5jcmVhdGVkID09PSAndHJ1ZSc7XG4gIHJldHVybiB1cHNlcnRSZXN1bHQ7XG59XG5cbi8qKlxuICogU3lub255bSBvZiBNZXRhZGF0YSNjcmVhdGUoKS5cbiAqXG4gKiBAbWV0aG9kIE1ldGFkYXRhI2NyZWF0ZVN5bmNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgbWV0YWRhdGEgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge01ldGFkYXRhfk1ldGFkYXRhSW5mb3xBcnJheS48TWV0YWRhdGF+TWV0YWRhdGFJbmZvPn0gbWV0YWRhdGEgLSBNZXRhZGF0YSB0byBjcmVhdGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhflNhdmVSZXN1bHR8QXJyYXkuPE1ldGFkYXRhflNhdmVSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TWV0YWRhdGF+U2F2ZVJlc3VsdHxBcnJheS48TWV0YWRhdGF+U2F2ZVJlc3VsdD4+fVxuICovXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgYWRkcyBvbmUgb3IgbW9yZSBuZXcgbWV0YWRhdGEgY29tcG9uZW50cyB0byB0aGUgb3JnYW5pemF0aW9uLlxuICpcbiAqIEBtZXRob2QgTWV0YWRhdGEjY3JlYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIG1ldGFkYXRhIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtNZXRhZGF0YX5NZXRhZGF0YUluZm98QXJyYXkuPE1ldGFkYXRhfk1ldGFkYXRhSW5mbz59IG1ldGFkYXRhIC0gTWV0YWRhdGEgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5TYXZlUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5TYXZlUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE1ldGFkYXRhflNhdmVSZXN1bHR8QXJyYXkuPE1ldGFkYXRhflNhdmVSZXN1bHQ+Pn1cbiAqL1xuTWV0YWRhdGEucHJvdG90eXBlLmNyZWF0ZVN5bmMgPVxuTWV0YWRhdGEucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHR5cGUsIG1ldGFkYXRhLCBjYWxsYmFjaykge1xuICB2YXIgY29udmVydCA9IGZ1bmN0aW9uKG1kKSB7XG4gICAgbWRbXCJAeHNpOnR5cGVcIl0gPSB0eXBlO1xuICAgIHJldHVybiBtZDtcbiAgfTtcbiAgdmFyIGlzQXJyYXkgPSBfLmlzQXJyYXkobWV0YWRhdGEpO1xuICBtZXRhZGF0YSA9IGlzQXJyYXkgPyBfLm1hcChtZXRhZGF0YSwgY29udmVydCkgOiBjb252ZXJ0KG1ldGFkYXRhKTtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcImNyZWF0ZU1ldGFkYXRhXCIsIHsgbWV0YWRhdGE6IG1ldGFkYXRhIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgIHJldHVybiBfLmlzQXJyYXkocmVzdWx0cykgPyBfLm1hcChyZXN1bHRzLCBjb252ZXJ0VG9TYXZlUmVzdWx0KSA6IGNvbnZlcnRUb1NhdmVSZXN1bHQocmVzdWx0cyk7XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29udmVydFRvTWV0YWRhdGFJbmZvKHJlYykge1xuICB2YXIgbWV0YWRhdGFJbmZvID0gXy5jbG9uZShyZWMpO1xuICBkZWxldGUgbWV0YWRhdGFJbmZvLiQ7XG4gIHJldHVybiBtZXRhZGF0YUluZm87XG59XG5cbi8qKlxuICogU3lub255bSBvZiBNZXRhZGF0YSNyZWFkKClcbiAqXG4gKiBAbWV0aG9kIE1ldGFkYXRhI3JlYWRTeW5jXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIG1ldGFkYXRhIHRvIHJlYWRcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBmdWxsTmFtZXMgLSBmdWxsIG5hbWUocykgb2YgbWV0YWRhdGEgb2JqZWN0cyB0byByZWFkXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5NZXRhZGF0YUluZm98QXJyYXkuPE1ldGFkYXRhfk1ldGFkYXRhSW5mbz4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheS48TWV0YWRhdGF+TWV0YWRhdGFJbmZvfEFycmF5LjxNZXRhZGF0YX5NZXRhZGF0YUluZm8+Pj59XG4gKi9cbi8qKlxuICogU3luY2hyb25vdXNseSByZWFkIHNwZWNpZmllZCBtZXRhZGF0YSBjb21wb25lbnRzIGluIHRoZSBvcmdhbml6YXRpb24uXG4gKlxuICogQG1ldGhvZCBNZXRhZGF0YSNyZWFkXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIG1ldGFkYXRhIHRvIHJlYWRcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBmdWxsTmFtZXMgLSBmdWxsIG5hbWUocykgb2YgbWV0YWRhdGEgb2JqZWN0cyB0byByZWFkXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5NZXRhZGF0YUluZm98QXJyYXkuPE1ldGFkYXRhfk1ldGFkYXRhSW5mbz4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheS48TWV0YWRhdGF+TWV0YWRhdGFJbmZvfEFycmF5LjxNZXRhZGF0YX5NZXRhZGF0YUluZm8+Pj59XG4gKi9cbk1ldGFkYXRhLnByb3RvdHlwZS5yZWFkU3luYyA9XG5NZXRhZGF0YS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKHR5cGUsIGZ1bGxOYW1lcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcInJlYWRNZXRhZGF0YVwiLCB7IHR5cGU6IHR5cGUsIGZ1bGxOYW1lczogZnVsbE5hbWVzIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgcmV0dXJuIF8uaXNBcnJheShyZXMucmVjb3JkcykgPyBfLm1hcChyZXMucmVjb3JkcywgY29udmVydFRvTWV0YWRhdGFJbmZvKSA6IGNvbnZlcnRUb01ldGFkYXRhSW5mbyhyZXMucmVjb3Jkcyk7XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0YWRhdGF+VXBkYXRlTWV0YWRhdGFJbmZvXG4gKiBAcHJvcCB7U3RyaW5nfSBjdXJyZW50TmFtZSAtIFRoZSBBUEkgbmFtZSBvZiB0aGUgY29tcG9uZW50IG9yIGZpZWxkIGJlZm9yZSB0aGUgdXBkYXRlXG4gKiBAcHJvcCB7TWV0YWRhdGF+TWV0YWRhdGFJbmZvfSBtZXRhZGF0YSAtIEZ1bGwgc3BlY2lmaWNhdGlvbiBvZiB0aGUgY29tcG9uZW50IG9yIGZpZWxkIHlvdSB3aXNoIHRvIHVwZGF0ZVxuICovXG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgdXBkYXRlcyBvbmUgb3IgbW9yZSBtZXRhZGF0YSBjb21wb25lbnRzIGluIHRoZSBvcmdhbml6YXRpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBtZXRhZGF0YSB0byB1cGRhdGVcbiAqIEBwYXJhbSB7TWV0YWRhdGF+VXBkYXRlTWV0YWRhdGFJbmZvfEFycmF5LjxNZXRhZGF0YX5VcGRhdGVNZXRhZGF0YUluZm8+fSB1cGRhdGVNZXRhZGF0YSAtIFVwZGF0aW5nIG1ldGFkYXRhXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5Bc3luY1Jlc3VsdHxBcnJheS48TWV0YWRhdGF+QXN5bmNSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TWV0YWRhdGF+QXN5bmNSZXN1bHRMb2NhdG9yfVxuICovXG5NZXRhZGF0YS5wcm90b3R5cGUudXBkYXRlQXN5bmMgPSBmdW5jdGlvbih0eXBlLCB1cGRhdGVNZXRhZGF0YSwgY2FsbGJhY2spIHtcbiAgaWYgKE51bWJlcih0aGlzLl9jb25uLnZlcnNpb24pID4gMzApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyBtZXRhZGF0YSBDUlVEIGNhbGxzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIHZlciAzMS4wIG9yIGxhdGVyLlwiKTtcbiAgfVxuICB2YXIgY29udmVydCA9IGZ1bmN0aW9uKHVtZCkge1xuICAgIHVtZC5tZXRhZGF0YVtcIkB4c2k6dHlwZVwiXSA9IHR5cGU7XG4gICAgcmV0dXJuIHVtZDtcbiAgfTtcbiAgdmFyIGlzQXJyYXkgPSBfLmlzQXJyYXkodXBkYXRlTWV0YWRhdGEpO1xuICB1cGRhdGVNZXRhZGF0YSA9IGlzQXJyYXkgPyBfLm1hcCh1cGRhdGVNZXRhZGF0YSwgY29udmVydCkgOiBjb252ZXJ0KHVwZGF0ZU1ldGFkYXRhKTtcbiAgdmFyIHJlcyA9IHRoaXMuX2ludm9rZShcInVwZGF0ZVwiLCB7IHVwZGF0ZU1ldGFkYXRhOiB1cGRhdGVNZXRhZGF0YSB9KTtcbiAgcmV0dXJuIG5ldyBBc3luY1Jlc3VsdExvY2F0b3IodGhpcywgcmVzLCBpc0FycmF5KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFN5bm9ueW0gb2YgTWV0YWRhdGEjdXBkYXRlKCkuXG4gKlxuICogQG1ldGhvZCBNZXRhZGF0YSN1cGRhdGVTeW5jXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIG1ldGFkYXRhIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtNZXRhZGF0YX5NZXRhZGF0YUluZm98QXJyYXkuPE1ldGFkYXRhfk1ldGFkYXRhSW5mbz59IHVwZGF0ZU1ldGFkYXRhIC0gVXBkYXRpbmcgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhflNhdmVSZXN1bHR8QXJyYXkuPE1ldGFkYXRhflNhdmVSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TWV0YWRhdGF+U2F2ZVJlc3VsdHxBcnJheS48TWV0YWRhdGF+U2F2ZVJlc3VsdD4+fVxuICovXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgdXBkYXRlcyBvbmUgb3IgbW9yZSBtZXRhZGF0YSBjb21wb25lbnRzIGluIHRoZSBvcmdhbml6YXRpb24uXG4gKlxuICogQG1ldGhvZCBNZXRhZGF0YSN1cGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgbWV0YWRhdGEgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge01ldGFkYXRhfk1ldGFkYXRhSW5mb3xBcnJheS48TWV0YWRhdGF+TWV0YWRhdGFJbmZvPn0gdXBkYXRlTWV0YWRhdGEgLSBVcGRhdGluZyBtZXRhZGF0YVxuICogQHBhcmFtIHtDYWxsYmFjay48TWV0YWRhdGF+U2F2ZVJlc3VsdHxBcnJheS48TWV0YWRhdGF+U2F2ZVJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxNZXRhZGF0YX5TYXZlUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5TYXZlUmVzdWx0Pj59XG4gKi9cbk1ldGFkYXRhLnByb3RvdHlwZS51cGRhdGVTeW5jID1cbk1ldGFkYXRhLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbih0eXBlLCBtZXRhZGF0YSwgY2FsbGJhY2spIHtcbiAgdmFyIGNvbnZlcnQgPSBmdW5jdGlvbihtZCkge1xuICAgIG1kW1wiQHhzaTp0eXBlXCJdID0gdHlwZTtcbiAgICByZXR1cm4gbWQ7XG4gIH07XG4gIHZhciBpc0FycmF5ID0gXy5pc0FycmF5KG1ldGFkYXRhKTtcbiAgbWV0YWRhdGEgPSBpc0FycmF5ID8gXy5tYXAobWV0YWRhdGEsIGNvbnZlcnQpIDogY29udmVydChtZXRhZGF0YSk7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJ1cGRhdGVNZXRhZGF0YVwiLCB7IG1ldGFkYXRhOiBtZXRhZGF0YSB9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICByZXR1cm4gXy5pc0FycmF5KHJlc3VsdHMpID8gXy5tYXAocmVzdWx0cywgY29udmVydFRvU2F2ZVJlc3VsdCkgOiBjb252ZXJ0VG9TYXZlUmVzdWx0KHJlc3VsdHMpO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFN5bm9ueW0gb2YgTWV0YWRhdGEjdXBzZXJ0KCkuXG4gKlxuICogQG1ldGhvZCBNZXRhZGF0YSN1cHNlcnRTeW5jXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIG1ldGFkYXRhIHRvIHVwc2VydFxuICogQHBhcmFtIHtNZXRhZGF0YX5NZXRhZGF0YUluZm98QXJyYXkuPE1ldGFkYXRhfk1ldGFkYXRhSW5mbz59IG1ldGFkYXRhIC0gVXBzZXJ0aW5nIG1ldGFkYXRhXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5VcHNlcnRSZXN1bHR8QXJyYXkuPE1ldGFkYXRhflVwc2VydFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxNZXRhZGF0YX5VcHNlcnRSZXN1bHR8QXJyYXkuPE1ldGFkYXRhflVwc2VydFJlc3VsdD4+fVxuICovXG4vKipcbiAqIFVwc2VydHMgb25lIG9yIG1vcmUgY29tcG9uZW50cyBpbiB5b3VyIG9yZ2FuaXphdGlvbidzIGRhdGEuXG4gKlxuICogQG1ldGhvZCBNZXRhZGF0YSN1cHNlcnRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgbWV0YWRhdGEgdG8gdXBzZXJ0XG4gKiBAcGFyYW0ge01ldGFkYXRhfk1ldGFkYXRhSW5mb3xBcnJheS48TWV0YWRhdGF+TWV0YWRhdGFJbmZvPn0gbWV0YWRhdGEgLSBVcHNlcnRpbmcgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhflVwc2VydFJlc3VsdHxBcnJheS48TWV0YWRhdGF+VXBzZXJ0UmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE1ldGFkYXRhflVwc2VydFJlc3VsdHxBcnJheS48TWV0YWRhdGF+VXBzZXJ0UmVzdWx0Pj59XG4gKi9cbk1ldGFkYXRhLnByb3RvdHlwZS51cHNlcnRTeW5jID1cbk1ldGFkYXRhLnByb3RvdHlwZS51cHNlcnQgPSBmdW5jdGlvbih0eXBlLCBtZXRhZGF0YSwgY2FsbGJhY2spIHtcbiAgdmFyIGNvbnZlcnQgPSBmdW5jdGlvbihtZCkge1xuICAgIG1kW1wiQHhzaTp0eXBlXCJdID0gdHlwZTtcbiAgICByZXR1cm4gbWQ7XG4gIH07XG4gIHZhciBpc0FycmF5ID0gXy5pc0FycmF5KG1ldGFkYXRhKTtcbiAgbWV0YWRhdGEgPSBpc0FycmF5ID8gXy5tYXAobWV0YWRhdGEsIGNvbnZlcnQpIDogY29udmVydChtZXRhZGF0YSk7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJ1cHNlcnRNZXRhZGF0YVwiLCB7IG1ldGFkYXRhOiBtZXRhZGF0YSB9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICByZXR1cm4gXy5pc0FycmF5KHJlc3VsdHMpID8gXy5tYXAocmVzdWx0cywgY29udmVydFRvVXBzZXJ0UmVzdWx0KSA6IGNvbnZlcnRUb1Vwc2VydFJlc3VsdChyZXN1bHRzKTtcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBkZWxldGVzIHNwZWNpZmllZCBtZXRhZGF0YSBjb21wb25lbnRzIGluIHRoZSBvcmdhbml6YXRpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBtZXRhZGF0YSB0byBkZWxldGVcbiAqIEBwYXJhbSB7U3RyaW5nfE1ldGFkYXRhfk1ldGFkYXRhSW5mb3xBcnJheS48U3RyaW5nPnxBcnJheS48TWV0YWRhdGF+TWV0YWRhdGFJbmZvPn0gbWV0YWRhdGEgLSBUaGUgZnVsbE5hbWUgb2YgbWV0YWRhdGEgb3IgbWV0YWRhdGEgaW5mbyB0byBkZWxldGUuIElmIGl0IGlzIHBhc3NlZCBpbiBmdWxsTmFtZSwgdGhlIHR5cGUgcGFyYW1ldGVyIHNob3VsZCBub3QgYmUgZW1wdHkuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5Bc3luY1Jlc3VsdHxBcnJheS48TWV0YWRhdGF+QXN5bmNSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TWV0YWRhdGF+QXN5bmNSZXN1bHRMb2NhdG9yfVxuICovXG5NZXRhZGF0YS5wcm90b3R5cGUuZGVsZXRlQXN5bmMgPSBmdW5jdGlvbih0eXBlLCBtZXRhZGF0YSwgY2FsbGJhY2spIHtcbiAgaWYgKE51bWJlcih0aGlzLl9jb25uLnZlcnNpb24pID4gMzApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyBtZXRhZGF0YSBDUlVEIGNhbGxzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIHZlciAzMS4wIG9yIGxhdGVyLlwiKTtcbiAgfVxuICB2YXIgY29udmVydCA9IGZ1bmN0aW9uKG1kKSB7XG4gICAgaWYgKF8uaXNTdHJpbmcobWQpKSB7XG4gICAgICBtZCA9IHsgZnVsbE5hbWUgOiBtZCB9O1xuICAgIH1cbiAgICBtZFtcIkB4c2k6dHlwZVwiXSA9IHR5cGU7XG4gICAgcmV0dXJuIG1kO1xuICB9O1xuICB2YXIgaXNBcnJheSA9IF8uaXNBcnJheShtZXRhZGF0YSk7XG4gIG1ldGFkYXRhID0gaXNBcnJheSA/IF8ubWFwKG1ldGFkYXRhLCBjb252ZXJ0KSA6IGNvbnZlcnQobWV0YWRhdGEpO1xuICB2YXIgcmVzID0gdGhpcy5faW52b2tlKFwiZGVsZXRlXCIsIHsgbWV0YWRhdGE6IG1ldGFkYXRhIH0pO1xuICByZXR1cm4gbmV3IEFzeW5jUmVzdWx0TG9jYXRvcih0aGlzLCByZXMsIGlzQXJyYXkpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU3lub255bSBvZiBNZXRhZGF0YSNkZWxldGUoKS5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogQG1ldGhvZCBNZXRhZGF0YSNkZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gLSBUaGUgdHlwZSBvZiBtZXRhZGF0YSB0byBkZWxldGVcbiAqIEBwYXJhbSB7U3RyaW5nfE1ldGFkYXRhfk1ldGFkYXRhSW5mb3xBcnJheS48U3RyaW5nPnxBcnJheS48TWV0YWRhdGF+TWV0YWRhdGFJbmZvPn0gbWV0YWRhdGEgLSBUaGUgZnVsbE5hbWUgb2YgbWV0YWRhdGEgb3IgbWV0YWRhdGEgaW5mbyB0byBkZWxldGUuIElmIGl0IGlzIHBhc3NlZCBpbiBmdWxsTmFtZSwgdGhlIHR5cGUgcGFyYW1ldGVyIHNob3VsZCBub3QgYmUgZW1wdHkuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5Bc3luY1Jlc3VsdHxBcnJheS48TWV0YWRhdGF+QXN5bmNSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TWV0YWRhdGF+QXN5bmNSZXN1bHRMb2NhdG9yfVxuICovXG4vKipcbiAqIFN5bm9ueW0gb2YgTWV0YWRhdGEjZGVsZXRlKCkuXG4gKlxuICogQG1ldGhvZCBNZXRhZGF0YSNkZWxldGVTeW5jXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIG1ldGFkYXRhIHRvIGRlbGV0ZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGZ1bGxOYW1lcyAtIFRoZSBmdWxsTmFtZSBvZiBtZXRhZGF0YSB0byBkZWxldGUuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5TYXZlUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5TYXZlUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE1ldGFkYXRhflNhdmVSZXN1bHR8QXJyYXkuPE1ldGFkYXRhflNhdmVSZXN1bHQ+Pn1cbiAqL1xuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgZGVsZXRlcyBzcGVjaWZpZWQgbWV0YWRhdGEgY29tcG9uZW50cyBpbiB0aGUgb3JnYW5pemF0aW9uLlxuICpcbiAqIEBtZXRob2QgTWV0YWRhdGEjZGVsZXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIG1ldGFkYXRhIHRvIGRlbGV0ZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGZ1bGxOYW1lcyAtIFRoZSBmdWxsTmFtZSBvZiBtZXRhZGF0YSB0byBkZWxldGUuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5TYXZlUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5TYXZlUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE1ldGFkYXRhflNhdmVSZXN1bHR8QXJyYXkuPE1ldGFkYXRhflNhdmVSZXN1bHQ+Pn1cbiAqL1xuTWV0YWRhdGEucHJvdG90eXBlLmRlbCA9XG5NZXRhZGF0YS5wcm90b3R5cGUuZGVsZXRlU3luYyA9XG5NZXRhZGF0YS5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbih0eXBlLCBmdWxsTmFtZXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJkZWxldGVNZXRhZGF0YVwiLCB7IHR5cGU6IHR5cGUsIGZ1bGxOYW1lczogZnVsbE5hbWVzIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgIHJldHVybiBfLmlzQXJyYXkocmVzdWx0cykgPyBfLm1hcChyZXN1bHRzLCBjb252ZXJ0VG9TYXZlUmVzdWx0KSA6IGNvbnZlcnRUb1NhdmVSZXN1bHQocmVzdWx0cyk7XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmVuYW1lIGZ1bGxuYW1lIG9mIGEgbWV0YWRhdGEgY29tcG9uZW50IGluIHRoZSBvcmdhbml6YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIG1ldGFkYXRhIHRvIGRlbGV0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG9sZEZ1bGxOYW1lIC0gVGhlIG9yaWdpbmFsIGZ1bGxOYW1lIG9mIG1ldGFkYXRhXG4gKiBAcGFyYW0ge1N0cmluZ30gbmV3RnVsbE5hbWUgLSBUaGUgbmV3IGZ1bGxOYW1lIG9mIG1ldGFkYXRhXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5TYXZlUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TWV0YWRhdGF+U2F2ZVJlc3VsdD59XG4gKi9cbk1ldGFkYXRhLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbih0eXBlLCBvbGRGdWxsTmFtZSwgbmV3RnVsbE5hbWUsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJyZW5hbWVNZXRhZGF0YVwiLCB7IHR5cGU6IHR5cGUsIG9sZEZ1bGxOYW1lOiBvbGRGdWxsTmFtZSwgbmV3RnVsbE5hbWU6IG5ld0Z1bGxOYW1lIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgcmV0dXJuIGNvbnZlcnRUb1NhdmVSZXN1bHQocmVzdWx0KTtcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDaGVja3MgdGhlIHN0YXR1cyBvZiBhc3luY2hyb25vdXMgbWV0YWRhdGEgY2FsbHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaWRzIC0gVGhlIGFzeW5jaHJvbm91cyBwcm9jZXNzIElEKHMpXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5Bc3luY1Jlc3VsdHxBcnJheS48TWV0YWRhdGF+QXN5bmNSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TWV0YWRhdGF+QXN5bmNSZXN1bHRMb2NhdG9yfVxuICovXG5NZXRhZGF0YS5wcm90b3R5cGUuY2hlY2tTdGF0dXMgPSBmdW5jdGlvbihpZHMsIGNhbGxiYWNrKSB7XG4gIHZhciBpc0FycmF5ID0gXy5pc0FycmF5KGlkcyk7XG4gIHZhciByZXMgPSB0aGlzLl9pbnZva2UoXCJjaGVja1N0YXR1c1wiLCB7IGFzeW5jUHJvY2Vzc0lkOiBpZHMgfSk7XG4gIHJldHVybiBuZXcgQXN5bmNSZXN1bHRMb2NhdG9yKHRoaXMsIHJlcywgaXNBcnJheSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhZGF0YX5EZXNjcmliZU1ldGFkYXRhUmVzdWx0XG4gKiBAcHJvcCB7QXJyYXkuPE9iamVjdD59IG1ldGFkYXRhT2JqZWN0cyAtIE9uZSBvciBtb3JlIG1ldGFkYXRhIGNvbXBvbmVudHMgYW5kIHRoZWlyIGF0dHJpYnV0ZXNcbiAqIEBwcm9wIHtBcnJheS48U3RyaW5nPn0gbWV0YWRhdGFPYmplY3RzLmNoaWxkWG1sTmFtZXMgLSBMaXN0IG9mIGNoaWxkIHN1Yi1jb21wb25lbnRzIGZvciB0aGlzIGNvbXBvbmVudFxuICogQHByb3Age1N0cmluZ30gbWV0YWRhdGFPYmplY3RzLmRpcmVjdG9yeU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZGlyZWN0b3J5IGluIHRoZSAuemlwIGZpbGUgdGhhdCBjb250YWlucyB0aGlzIGNvbXBvbmVudFxuICogQHByb3Age0Jvb2xlYW59IG1ldGFkYXRhT2JqZWN0cy5pbkZvbGRlciAtIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgaW4gYSBmb2xkZXIgb3Igbm90XG4gKiBAcHJvcCB7Qm9vbGVhbn0gbWV0YWRhdGFPYmplY3RzLm1ldGFGaWxlIC0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCByZXF1aXJlcyBhbiBhY2NvbXBhbnlpbmcgbWV0YWRhdGEgZmlsZVxuICogQHByb3Age1N0cmluZ30gbWV0YWRhdGFPYmplY3RzLnN1ZmZpeCAtIFRoZSBmaWxlIHN1ZmZpeCBmb3IgdGhpcyBjb21wb25lbnRcbiAqIEBwcm9wIHtTdHJpbmd9IG1ldGFkYXRhT2JqZWN0cy54bWxOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHJvb3QgZWxlbWVudCBpbiB0aGUgbWV0YWRhdGEgZmlsZSBmb3IgdGhpcyBjb21wb25lbnRcbiAqIEBwcm9wIHtTdHJpbmd9IG9yZ2FuaXphdGlvbk5hbWVzcGFjZSAtIFRoZSBuYW1lc3BhY2Ugb2YgdGhlIG9yZ2FuaXphdGlvblxuICogQHByb3Age0Jvb2xlYW59IHBhcnRpYWxTYXZlQWxsb3dlZCAtIEluZGljYXRlcyB3aGV0aGVyIHJvbGxiYWNrT25FcnJvciBpcyBhbGxvd2VkIG9yIG5vdFxuICogQHByb3Age0Jvb2xlYW59IHRlc3RSZXF1aXJlZCAtIEluZGljYXRlcyB3aGV0aGVyIHRlc3RzIGFyZSByZXF1aXJlZCBvciBub3RcbiAqL1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgbWV0YWRhdGEgd2hpY2ggZGVzY3JpYmVzIHlvdXIgb3JnYW5pemF0aW9uLCBpbmNsdWRpbmcgQXBleCBjbGFzc2VzIGFuZCB0cmlnZ2VycyxcbiAqIGN1c3RvbSBvYmplY3RzLCBjdXN0b20gZmllbGRzIG9uIHN0YW5kYXJkIG9iamVjdHMsIHRhYiBzZXRzIHRoYXQgZGVmaW5lIGFuIGFwcCxcbiAqIGFuZCBtYW55IG90aGVyIGNvbXBvbmVudHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFt2ZXJzaW9uXSAtIFRoZSBBUEkgdmVyc2lvbiBmb3Igd2hpY2ggeW91IHdhbnQgbWV0YWRhdGE7IGZvciBleGFtcGxlLCAyOS4wXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5EZXNjcmliZU1ldGFkYXRhUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TWV0YWRhdGF+RGVzY3JpYmVNZXRhZGF0YVJlc3VsdD59XG4gKi9cbk1ldGFkYXRhLnByb3RvdHlwZS5kZXNjcmliZSA9IGZ1bmN0aW9uKHZlcnNpb24sIGNhbGxiYWNrKSB7XG4gIGlmICghXy5pc1N0cmluZyh2ZXJzaW9uKSkge1xuICAgIGNhbGxiYWNrID0gdmVyc2lvbjtcbiAgICB2ZXJzaW9uID0gdGhpcy5fY29ubi52ZXJzaW9uO1xuICB9XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJkZXNjcmliZU1ldGFkYXRhXCIsIHsgYXNPZlZlcnNpb246IHZlcnNpb24gfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICByZXMubWV0YWRhdGFPYmplY3RzID0gXy5pc0FycmF5KHJlcy5tZXRhZGF0YU9iamVjdHMpID8gcmVzLm1ldGFkYXRhT2JqZWN0cyA6IFsgcmVzLm1ldGFkYXRhT2JqZWN0cyBdO1xuICAgIHJlcy5tZXRhZGF0YU9iamVjdHMgPSBfLm1hcChyZXMubWV0YWRhdGFPYmplY3RzLCBmdW5jdGlvbihtbykge1xuICAgICAgaWYgKG1vLmNoaWxkWG1sTmFtZXMpIHtcbiAgICAgICAgbW8uY2hpbGRYbWxOYW1lcyA9IF8uaXNBcnJheShtby5jaGlsZFhtbE5hbWVzKSA/IG1vLmNoaWxkWG1sTmFtZXM6IFsgbW8uY2hpbGRYbWxOYW1lcyBdO1xuICAgICAgfVxuICAgICAgbW8uaW5Gb2xkZXIgPSBtby5pbkZvbGRlciA9PT0gJ3RydWUnO1xuICAgICAgbW8ubWV0YUZpbGUgPSBtby5tZXRhRmlsZSA9PT0gJ3RydWUnO1xuICAgICAgcmV0dXJuIG1vO1xuICAgIH0pO1xuICAgIHJlcy5wYXJ0aWFsU2F2ZUFsbG93ZWQgPSByZXMucGFydGlhbFNhdmVBbGxvd2VkID09PSAndHJ1ZSc7XG4gICAgcmVzLnRlc3RSZXF1aXJlZCA9IHJlcy50ZXN0UmVxdWlyZWQgPT09ICd0cnVlJztcbiAgICByZXR1cm4gcmVzO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFkYXRhfkxpc3RNZXRhZGF0YVF1ZXJ5XG4gKiBAcHJvcCB7U3RyaW5nfSB0eXBlIC0gVGhlIG1ldGFkYXRhIHR5cGUsIHN1Y2ggYXMgQ3VzdG9tT2JqZWN0LCBDdXN0b21GaWVsZCwgb3IgQXBleENsYXNzXG4gKiBAcHJvcCB7U3RyaW5nfSBbZm9sZGVyXSAtIFRoZSBmb2xkZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb21wb25lbnQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhZGF0YX5GaWxlUHJvcGVydGllc1xuICogQHByb3Age1N0cmluZ30gdHlwZSAtIFRoZSBtZXRhZGF0YSB0eXBlLCBzdWNoIGFzIEN1c3RvbU9iamVjdCwgQ3VzdG9tRmllbGQsIG9yIEFwZXhDbGFzc1xuICogQHByb3Age1N0cmluZ30gY3JlYXRlZEJ5SWQgLSBJRCBvZiB0aGUgdXNlciB3aG8gY3JlYXRlZCB0aGUgZmlsZVxuICogQHByb3Age1N0cmluZ30gY3JlYXRlZEJ5TmFtZSAtIE5hbWUgb2YgdGhlIHVzZXIgd2hvIGNyZWF0ZWQgdGhlIGZpbGVcbiAqIEBwcm9wIHtTdHJpbmd9IGNyZWF0ZWREYXRlIC0gRGF0ZSBhbmQgdGltZSB3aGVuIHRoZSBmaWxlIHdhcyBjcmVhdGVkXG4gKiBAcHJvcCB7U3RyaW5nfSBmaWxlTmFtZSAtIE5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwcm9wIHtTdHJpbmd9IGZ1bGxOYW1lIC0gVGhlIGZpbGUgZGV2ZWxvcGVyIG5hbWUgdXNlZCBhcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciBBUEkgYWNjZXNzXG4gKiBAcHJvcCB7U3RyaW5nfSBpZCAtIElEIG9mIHRoZSBmaWxlXG4gKiBAcHJvcCB7U3RyaW5nfSBsYXN0TW9kaWZpZWRCeUlkIC0gSUQgb2YgdGhlIHVzZXIgd2hvIGxhc3QgbW9kaWZpZWQgdGhlIGZpbGVcbiAqIEBwcm9wIHtTdHJpbmd9IGxhc3RNb2RpZmllZEJ5TmFtZSAtIE5hbWUgb2YgdGhlIHVzZXIgd2hvIGxhc3QgbW9kaWZpZWQgdGhlIGZpbGVcbiAqIEBwcm9wIHtTdHJpbmd9IGxhc3RNb2RpZmllZERhdGUgLSBEYXRlIGFuZCB0aW1lIHRoYXQgdGhlIGZpbGUgd2FzIGxhc3QgbW9kaWZpZWRcbiAqIEBwcm9wIHtTdHJpbmd9IFttYW5hZ2VhYmxlU3RhdGVdIC0gSW5kaWNhdGVzIHRoZSBtYW5hZ2VhYmxlIHN0YXRlIG9mIHRoZSBzcGVjaWZpZWQgY29tcG9uZW50IGlmIGl0IGlzIGNvbnRhaW5lZCBpbiBhIHBhY2thZ2VcbiAqIEBwcm9wIHtTdHJpbmd9IFtuYW1lc3BhY2VQcmVmaXhdIC0gVGhlIG5hbWVzcGFjZSBwcmVmaXggb2YgdGhlIGNvbXBvbmVudFxuICovXG5cbi8qKlxuICogUmV0cmlldmVzIHByb3BlcnR5IGluZm9ybWF0aW9uIGFib3V0IG1ldGFkYXRhIGNvbXBvbmVudHMgaW4geW91ciBvcmdhbml6YXRpb25cbiAqXG4gKiBAcGFyYW0ge01ldGFkYXRhfkxpc3RNZXRhZGF0YVF1ZXJ5fEFycmF5LjxNZXRhZGF0YX5MaXN0TWV0YWRhdGFRdWVyeT59IHF1ZXJpZXMgLSBUaGUgY3JpdGVyaWEgb2JqZWN0KHMpIHNwZWNpZmluZyBtZXRhZGF0YSB0byBsaXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gW3ZlcnNpb25dIC0gVGhlIEFQSSB2ZXJzaW9uIGZvciB3aGljaCB5b3Ugd2FudCBtZXRhZGF0YTsgZm9yIGV4YW1wbGUsIDI5LjBcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxNZXRhZGF0YX5GaWxlUHJvcGVydGllcz4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheS48TWV0YWRhdGF+RmlsZVByb3BlcnRpZXM+Pn1cbiAqL1xuTWV0YWRhdGEucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbihxdWVyaWVzLCB2ZXJzaW9uLCBjYWxsYmFjaykge1xuICBpZiAoIV8uaXNTdHJpbmcodmVyc2lvbikpIHtcbiAgICBjYWxsYmFjayA9IHZlcnNpb247XG4gICAgdmVyc2lvbiA9IHRoaXMuX2Nvbm4udmVyc2lvbjtcbiAgfVxuICBpZiAoIV8uaXNBcnJheShxdWVyaWVzKSkge1xuICAgIHF1ZXJpZXMgPSBbIHF1ZXJpZXMgXTtcbiAgfVxuICByZXR1cm4gdGhpcy5faW52b2tlKFwibGlzdE1ldGFkYXRhXCIsIHsgcXVlcmllczogcXVlcmllcywgYXNPZlZlcnNpb246IHZlcnNpb24gfSwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhZGF0YX5SZXRyaWV2ZVJlcXVlc3RcbiAqL1xuXG4vKipcbiAqIFJldHJpZXZlcyBYTUwgZmlsZSByZXByZXNlbnRhdGlvbnMgb2YgY29tcG9uZW50cyBpbiBhbiBvcmdhbml6YXRpb25cbiAqXG4gKiBAcGFyYW0ge01ldGFkYXRhflJldHJpZXZlUmVxdWVzdH0gcmVxdWVzdCAtIE9wdGlvbnMgZm9yIGRldGVybWluaW5nIHdoaWNoIHBhY2thZ2VzIG9yIGZpbGVzIGFyZSByZXRyaWV2ZWRcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhfkFzeW5jUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TWV0YWRhdGF+UmV0cmlldmVSZXN1bHRMb2NhdG9yfVxuICovXG5NZXRhZGF0YS5wcm90b3R5cGUucmV0cmlldmUgPSBmdW5jdGlvbihyZXF1ZXN0LCBjYWxsYmFjaykge1xuICB2YXIgcmVzID0gdGhpcy5faW52b2tlKFwicmV0cmlldmVcIiwgeyByZXF1ZXN0OiByZXF1ZXN0IH0pO1xuICByZXR1cm4gbmV3IFJldHJpZXZlUmVzdWx0TG9jYXRvcih0aGlzLCByZXMpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHRoZSBzdGF0dXMgb2YgZGVjbGFyYXRpdmUgbWV0YWRhdGEgY2FsbCByZXRyaWV2ZSgpIGFuZCByZXR1cm5zIHRoZSB6aXAgZmlsZSBjb250ZW50c1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIEFzeW5jIHByb2Nlc3MgaWQgcmV0dXJuZWQgZnJvbSBwcmV2aW91cyByZXRyaWV2ZSByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5SZXRyaWV2ZVJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE1ldGFkYXRhflJldHJpZXZlUmVzdWx0Pn1cbiAqL1xuTWV0YWRhdGEucHJvdG90eXBlLmNoZWNrUmV0cmlldmVTdGF0dXMgPSBmdW5jdGlvbihpZCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcImNoZWNrUmV0cmlldmVTdGF0dXNcIiwgeyBhc3luY1Byb2Nlc3NJZDogaWQgfSwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBEZXBsb3kgY29tcG9uZW50cyBpbnRvIGFuIG9yZ2FuaXphdGlvbiB1c2luZyB6aXBwZWQgZmlsZSByZXByZXNlbnRhdGlvbnNcbiAqXG4gKiBAcGFyYW0ge3N0cmVhbS5TdHJlYW18QnVmZmVyfFN0cmluZ30gemlwSW5wdXQgLSBaaXBwZWQgZmlsZSBpbnB1dCBzb3VyY2UgaW4gcmVhZGFibGUgc3RyZWFtLCBiaW5hcnkgYnVmZmVyIG9yIEJhc2U2NC1lbmNvZGVkIHN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgdXNlZCBpbiBkZXBsb3ltZW50XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93TWlzc2luZ0ZpbGVzXSAtIFNwZWNpZmllcyB3aGV0aGVyIGEgZGVwbG95IHN1Y2NlZWRzIGV2ZW4gaWYgZmlsZXMgdGhhdCBhcmUgc3BlY2lmaWVkIGluIHBhY2thZ2UueG1sIGJ1dCBhcmUgbm90IGluIHRoZSAuemlwIGZpbGUgb3Igbm90LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvVXBkYXRlUGFja2FnZV0gLSBJZiBhIGZpbGUgaXMgaW4gdGhlIC56aXAgZmlsZSBidXQgbm90IHNwZWNpZmllZCBpbiBwYWNrYWdlLnhtbCwgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZpbGUgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIHBhY2thZ2Ugb3Igbm90LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jaGVja09ubHldIC0gSW5kaWNhdGVzIHdoZXRoZXIgQXBleCBjbGFzc2VzIGFuZCB0cmlnZ2VycyBhcmUgc2F2ZWQgdG8gdGhlIG9yZ2FuaXphdGlvbiBhcyBwYXJ0IG9mIHRoZSBkZXBsb3ltZW50IChmYWxzZSkgb3Igbm90ICh0cnVlKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaWdub3JlV2FybmluZ3NdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSB3YXJuaW5nIHNob3VsZCBhbGxvdyBhIGRlcGxveW1lbnQgdG8gY29tcGxldGUgc3VjY2Vzc2Z1bGx5ICh0cnVlKSBvciBub3QgKGZhbHNlKS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnBlcmZvcm1SZXRyaWV2ZV0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHJldHJpZXZlKCkgY2FsbCBpcyBwZXJmb3JtZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGRlcGxveW1lbnQgKHRydWUpIG9yIG5vdCAoZmFsc2UpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5wdXJnZU9uRGVsZXRlXSAtIElmIHRydWUsIHRoZSBkZWxldGVkIGNvbXBvbmVudHMgaW4gdGhlIGRlc3RydWN0aXZlQ2hhbmdlcy54bWwgbWFuaWZlc3QgZmlsZSBhcmVuJ3Qgc3RvcmVkIGluIHRoZSBSZWN5Y2xlIEJpbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucm9sbGJhY2tPbkVycm9yXSAtIEluZGljYXRlcyB3aGV0aGVyIGFueSBmYWlsdXJlIGNhdXNlcyBhIGNvbXBsZXRlIHJvbGxiYWNrICh0cnVlKSBvciBub3QgKGZhbHNlKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnVuQWxsVGVzdHNdIC0gSWYgdHJ1ZSwgYWxsIEFwZXggdGVzdHMgZGVmaW5lZCBpbiB0aGUgb3JnYW5pemF0aW9uIGFyZSBydW4uXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBbb3B0aW9ucy5ydW5UZXN0c10gLSBBIGxpc3Qgb2YgQXBleCB0ZXN0cyB0byBiZSBydW4gZHVyaW5nIGRlcGxveW1lbnQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNpbmdsZVBhY2thZ2VdIC0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCAuemlwIGZpbGUgcG9pbnRzIHRvIGEgZGlyZWN0b3J5IHN0cnVjdHVyZSB3aXRoIGEgc2luZ2xlIHBhY2thZ2UgKHRydWUpIG9yIGEgc2V0IG9mIHBhY2thZ2VzIChmYWxzZSkuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5Bc3luY1Jlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge01ldGFkYXRhfkRlcGxveVJlc3VsdExvY2F0b3J9XG4gKi9cbk1ldGFkYXRhLnByb3RvdHlwZS5kZXBsb3kgPSBmdW5jdGlvbih6aXBJbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKCFvcHRpb25zIHx8IF8uaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgdmFyIGRlZmVycmVkID0gUHJvbWlzZS5kZWZlcigpO1xuICBpZiAoXy5pc09iamVjdCh6aXBJbnB1dCkgJiYgXy5pc0Z1bmN0aW9uKHppcElucHV0LnBpcGUpKSB7XG4gICAgdmFyIGJ1ZnMgPSBbXTtcbiAgICB6aXBJbnB1dC5vbignZGF0YScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIGJ1ZnMucHVzaChkKTtcbiAgICB9KTtcbiAgICB6aXBJbnB1dC5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKEJ1ZmZlci5jb25jYXQoYnVmcykudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICB9KTtcbiAgICAvLyB6aXBJbnB1dC5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmICh6aXBJbnB1dCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgIGRlZmVycmVkLnJlc29sdmUoemlwSW5wdXQudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgfSBlbHNlIGlmICh6aXBJbnB1dCBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2YgemlwSW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSh6aXBJbnB1dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgXCJVbmV4cGVjdGVkIHppcElucHV0IHR5cGVcIjtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJlcyA9IGRlZmVycmVkLnByb21pc2UudGhlbihmdW5jdGlvbih6aXBDb250ZW50QjY0KSB7XG4gICAgcmV0dXJuIHNlbGYuX2ludm9rZShcImRlcGxveVwiLCB7XG4gICAgICBaaXBGaWxlOiB6aXBDb250ZW50QjY0LFxuICAgICAgRGVwbG95T3B0aW9uczogb3B0aW9uc1xuICAgIH0sIGNhbGxiYWNrKTtcbiAgfSk7XG4gIHJldHVybiBuZXcgRGVwbG95UmVzdWx0TG9jYXRvcih0aGlzLCByZXMpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHRoZSBzdGF0dXMgb2YgZGVjbGFyYXRpdmUgbWV0YWRhdGEgY2FsbCBkZXBsb3koKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIEFzeW5jIHByb2Nlc3MgaWQgcmV0dXJuZWQgZnJvbSBwcmV2aW91cyBkZXBsb3kgcmVxdWVzdFxuICogQHBhcmFtIHtCb29sZWFufSBbaW5jbHVkZURldGFpbHNdIC0gU2V0cyB0aGUgRGVwbG95UmVzdWx0IG9iamVjdCB0byBpbmNsdWRlIGRldGFpbHMgaW5mb3JtYXRpb24gKGRlZmF1bHQ6IGZhbHNlKVxuICogQHBhcmFtIHtDYWxsYmFjay48TWV0YWRhdGF+RGVwbG95UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TWV0YWRhdGF+RGVwbG95UmVzdWx0Pn1cbiAqL1xuTWV0YWRhdGEucHJvdG90eXBlLmNoZWNrRGVwbG95U3RhdHVzID0gZnVuY3Rpb24oaWQsIGluY2x1ZGVEZXRhaWxzLCBjYWxsYmFjaykge1xuICBpZiAoXy5pc09iamVjdChpbmNsdWRlRGV0YWlscykgfHwgXy5pc0Jvb2xlYW4oaW5jbHVkZURldGFpbHMpKSB7XG4gICAgaW5jbHVkZURldGFpbHMgPSAhIWluY2x1ZGVEZXRhaWxzO1xuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrID0gaW5jbHVkZURldGFpbHM7XG4gICAgaW5jbHVkZURldGFpbHMgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdGhpcy5faW52b2tlKFwiY2hlY2tEZXBsb3lTdGF0dXNcIiwge1xuICAgIGFzeW5jUHJvY2Vzc0lkOiBpZCxcbiAgICBpbmNsdWRlRGV0YWlscyA6IGluY2x1ZGVEZXRhaWxzXG4gIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgcmVzLmRvbmUgPSByZXMuZG9uZSA9PT0gJ3RydWUnO1xuICAgIHJlcy5zdWNjZXNzID0gcmVzLnN1Y2Nlc3MgPT09ICd0cnVlJztcbiAgICByZXMuY2hlY2tPbmx5ID0gcmVzLmNoZWNrT25seSA9PT0gJ3RydWUnO1xuICAgIHJlcy5ydW5UZXN0c0VuYWJsZWQgPSByZXMucnVuVGVzdHNFbmFibGVkID09PSAndHJ1ZSc7XG4gICAgaWYgKHJlcy5pZ25vcmVXYXJuaW5ncykge1xuICAgICAgcmVzLmlnbm9yZVdhcm5pbmdzID0gcmVzLmlnbm9yZVdhcm5pbmdzID09PSAndHJ1ZSc7XG4gICAgfVxuICAgIGlmIChyZXMucm9sbGJhY2tPbkVycm9yKSB7XG4gICAgICByZXMucm9sbGJhY2tPbkVycm9yID0gcmVzLnJvbGxiYWNrT25FcnJvciA9PT0gJ3RydWUnO1xuICAgIH1cbiAgICByZXMubnVtYmVyQ29tcG9uZW50RXJyb3JzID0gTnVtYmVyKHJlcy5udW1iZXJDb21wb25lbnRFcnJvcnMpO1xuICAgIHJlcy5udW1iZXJDb21wb25lbnRzRGVwbG95ZWQgPSBOdW1iZXIocmVzLm51bWJlckNvbXBvbmVudHNEZXBsb3llZCk7XG4gICAgcmVzLm51bWJlckNvbXBvbmVudHNUb3RhbCA9IE51bWJlcihyZXMubnVtYmVyQ29tcG9uZW50c1RvdGFsKTtcbiAgICByZXMubnVtYmVyVGVzdEVycm9ycyA9IE51bWJlcihyZXMubnVtYmVyVGVzdEVycm9ycyk7XG4gICAgcmVzLm51bWJlclRlc3RzQ29tcGxldGVkID0gTnVtYmVyKHJlcy5udW1iZXJUZXN0c0NvbXBsZXRlZCk7XG4gICAgcmVzLm51bWJlclRlc3RzVG90YWwgPSBOdW1iZXIocmVzLm51bWJlclRlc3RzVG90YWwpO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhZGF0YX5Bc3luY1Jlc3VsdFxuICogQHByb3Age0Jvb2xlYW59IGRvbmUgLSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY2FsbCBoYXMgY29tcGxldGVkIG9yIG5vdFxuICogQHByb3Age1N0cmluZ30gaWQgLSBJRCBvZiB0aGUgY29tcG9uZW50IGJlaW5nIGNyZWF0ZWQsIHVwZGF0ZWQsIGRlbGV0ZWQsIGRlcGxveWVkLCBvciByZXRyaWV2ZWRcbiAqIEBwcm9wIHtTdHJpbmd9IHN0YXRlIC0gVGhlIHN0YXRlIGZvdXIgcG9zc2libGUgdmFsdWVzOiBRdWV1ZWQsIEluUHJvZ3Jlc3MsIENvbXBsZXRlZCwgYW5kIEVycm9yLlxuICogQHByb3Age1N0cmluZ30gW3N0YXR1c0NvZGVdIC0gSWYgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBjcmVhdGUoKSwgdXBkYXRlKCksIG9yIGRlbGV0ZSgpIGNhbGwsIGEgc3RhdHVzIGNvZGUgaXMgcmV0dXJuZWRcbiAqIEBwcm9wIHtTdHJpbmd9IFttZXNzYWdlXSAtIE1lc3NhZ2UgY29ycmVzcG9uZGluZyB0byB0aGUgc3RhdHVzQ29kZSBmaWVsZCByZXR1cm5lZFxuICovXG5cbi8qKlxuICogVGhlIGxvY2F0b3IgY2xhc3MgZm9yIE1ldGFkYXRhIEFQSSBhc3luY2hyb25vdXMgY2FsbCByZXN1bHRcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAY2xhc3MgTWV0YWRhdGF+QXN5bmNSZXN1bHRMb2NhdG9yXG4gKiBAZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyXG4gKiBAaW1wbGVtZW50cyBQcm9taXNlLjxNZXRhZGF0YX5Bc3luY1Jlc3VsdHxBcnJheS48TWV0YWRhdGF+QXN5bmNSZXN1bHQ+PlxuICogQHBhcmFtIHtNZXRhZGF0YX0gbWV0YSAtIE1ldGFkYXRhIEFQSSBvYmplY3RcbiAqIEBwYXJhbSB7UHJvbWlzZS48TWV0YWRhdGF+QXN5bmNSZXN1bHR8QXJyYXkuPE1ldGFkYXRhfkFzeW5jUmVzdWx0Pj59IHJlc3VsdHMgLSBQcm9taXNlIG9iamVjdCBmb3IgYXN5bmMgcmVzdWx0IGluZm9cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzQXJyYXldIC0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFzeW5jIHJlcXVlc3QgaXMgZ2l2ZW4gaW4gYXJyYXkgb3Igc2luZ2xlIG9iamVjdFxuICovXG52YXIgQXN5bmNSZXN1bHRMb2NhdG9yID0gZnVuY3Rpb24obWV0YSwgcmVzdWx0cywgaXNBcnJheSkge1xuICB0aGlzLl9tZXRhID0gbWV0YTtcbiAgdGhpcy5fcmVzdWx0cyA9IHJlc3VsdHM7XG4gIHRoaXMuX2lzQXJyYXkgPSBpc0FycmF5O1xufTtcblxuaW5oZXJpdHMoQXN5bmNSZXN1bHRMb2NhdG9yLCBldmVudHMuRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBQcm9taXNlL0ErIGludGVyZmFjZVxuICogaHR0cDovL3Byb21pc2VzLWFwbHVzLmdpdGh1Yi5pby9wcm9taXNlcy1zcGVjL1xuICpcbiAqIERlbGVnYXRlIHRvIGRlZmVycmVkIHByb21pc2UsIHJldHVybiBwcm9taXNlIGluc3RhbmNlIGZvciBiYXRjaCByZXN1bHRcbiAqXG4gKiBAbWV0aG9kIE1ldGFkYXRhfkFzeW5jUmVzdWx0TG9jYXRvciN0aGVuXG4gKi9cbkFzeW5jUmVzdWx0TG9jYXRvci5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uUmVzb2x2ZSwgb25SZWplY3QpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gdGhpcy5fcmVzdWx0cy50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICB2YXIgY29udmVydFR5cGUgPSBmdW5jdGlvbihyZXMpIHtcbiAgICAgIGlmIChyZXMuJCAmJiByZXMuJFtcInhzaTpuaWxcIl0gPT09ICd0cnVlJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJlcy5kb25lID0gcmVzLmRvbmUgPT09ICd0cnVlJztcbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXN1bHRzID0gXy5pc0FycmF5KHJlc3VsdHMpID8gXy5tYXAocmVzdWx0cywgY29udmVydFR5cGUpIDogY29udmVydFR5cGUocmVzdWx0cyk7XG4gICAgaWYgKHNlbGYuX2lzQXJyYXkgJiYgIV8uaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgcmVzdWx0cyA9IFsgcmVzdWx0cyBdO1xuICAgIH1cbiAgICByZXR1cm4gb25SZXNvbHZlKHJlc3VsdHMpO1xuICB9LCBvblJlamVjdCk7XG59O1xuXG4vKipcbiAqIFByb21pc2UvQSsgZXh0ZW5zaW9uXG4gKiBDYWxsIFwidGhlblwiIHVzaW5nIGdpdmVuIG5vZGUtc3R5bGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqXG4gKiBAbWV0aG9kIE1ldGFkYXRhfkFzeW5jUmVzdWx0TG9jYXRvciN0aGVuQ2FsbFxuICovXG5Bc3luY1Jlc3VsdExvY2F0b3IucHJvdG90eXBlLnRoZW5DYWxsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuIF8uaXNGdW5jdGlvbihjYWxsYmFjaykgPyB0aGlzLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgfSk7XG4gIH0sIGZ1bmN0aW9uKGVycikge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICB9KSA6IHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrIHRoZSBzdGF0dXMgb2YgYXN5bmMgcmVxdWVzdFxuICpcbiAqIEBtZXRob2QgTWV0YWRhdGF+QXN5bmNSZXN1bHRMb2NhdG9yI2NoZWNrXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNZXRhZGF0YX5Bc3luY1Jlc3VsdHxBcnJheS48TWV0YWRhdGF+QXN5bmNSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TWV0YWRhdGF+QXN5bmNSZXN1bHR8QXJyYXkuPE1ldGFkYXRhfkFzeW5jUmVzdWx0Pj59XG4gKi9cbkFzeW5jUmVzdWx0TG9jYXRvci5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBtZXRhID0gdGhpcy5fbWV0YTtcbiAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgdmFyIGlkcyA9IF8uaXNBcnJheShyZXN1bHRzKSA/IF8ubWFwKHJlc3VsdHMsIGZ1bmN0aW9uKHJlcyl7IHJldHVybiByZXMuaWQ7IH0pIDogcmVzdWx0cy5pZDtcbiAgICBzZWxmLl9pZHMgPSBpZHM7XG4gICAgcmV0dXJuIG1ldGEuY2hlY2tTdGF0dXMoaWRzKTtcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBQb2xsaW5nIHVudGlsIGFzeW5jIGNhbGwgc3RhdHVzIGJlY29tZXMgY29tcGxldGUgb3IgZXJyb3JcbiAqXG4gKiBAbWV0aG9kIE1ldGFkYXRhfkFzeW5jUmVzdWx0TG9jYXRvciNwb2xsXG4gKiBAcGFyYW0ge051bWJlcn0gaW50ZXJ2YWwgLSBQb2xsaW5nIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgLSBQb2xsaW5nIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbkFzeW5jUmVzdWx0TG9jYXRvci5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uKGludGVydmFsLCB0aW1lb3V0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB2YXIgcG9sbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBpZiAoc3RhcnRUaW1lICsgdGltZW91dCA8IG5vdykge1xuICAgICAgdmFyIGVyck1zZyA9IFwiUG9sbGluZyB0aW1lIG91dC5cIjtcbiAgICAgIGlmIChzZWxmLl9pZHMpIHtcbiAgICAgICAgZXJyTXNnICs9IFwiIFByb2Nlc3MgSWQgPSBcIiArIHNlbGYuX2lkcztcbiAgICAgIH1cbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoZXJyTXNnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuY2hlY2soKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIHZhciBkb25lID0gdHJ1ZTtcbiAgICAgIHZhciByZXN1bHRBcnIgPSBfLmlzQXJyYXkocmVzdWx0cykgPyByZXN1bHRzIDogWyByZXN1bHRzIF07XG4gICAgICBmb3IgKHZhciBpPTAsIGxlbj1yZXN1bHRBcnIubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRBcnJbaV07XG4gICAgICAgIGlmIChyZXN1bHQgJiYgIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIHJlc3VsdCk7XG4gICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBzZWxmLmVtaXQoJ2NvbXBsZXRlJywgcmVzdWx0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KHBvbGwsIGludGVydmFsKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH0pO1xuICB9O1xuICBzZXRUaW1lb3V0KHBvbGwsIGludGVydmFsKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgYW5kIHdhaXQgdW50aWwgdGhlIGFzeW5jIHJlcXVlc3RzIGJlY29tZSBpbiBjb21wbGV0ZWQgc3RhdHVzXG4gKlxuICogQG1ldGhvZCBNZXRhZGF0YX5Bc3luY1Jlc3VsdExvY2F0b3IjY29tcGxldGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhfkFzeW5jUmVzdWx0fEFycmF5LjxNZXRhZGF0YX5Bc3luY1Jlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxNZXRhZGF0YX5Bc3luY1Jlc3VsdHxBcnJheS48TWV0YWRhdGF+QXN5bmNSZXN1bHQ+Pn1cbiAqL1xuQXN5bmNSZXN1bHRMb2NhdG9yLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBkZWZlcnJlZCA9IFByb21pc2UuZGVmZXIoKTtcbiAgdGhpcy5vbignY29tcGxldGUnLCBmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHRzKTtcbiAgfSk7XG4gIHRoaXMub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gIH0pO1xuICB2YXIgbWV0YSA9IHRoaXMuX21ldGE7XG4gIHRoaXMucG9sbChtZXRhLnBvbGxJbnRlcnZhbCwgbWV0YS5wb2xsVGltZW91dCk7XG4gIHJldHVybiBkZWZlcnJlZC5wcm9taXNlLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBUaGUgbG9jYXRvciBjbGFzcyB0byB0cmFjayByZXRyZWl2ZSgpIE1ldGFkYXRhIEFQSSBjYWxsIHJlc3VsdFxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBjbGFzcyBNZXRhZGF0YX5SZXRyaWV2ZVJlc3VsdExvY2F0b3JcbiAqIEBleHRlbmRzIE1ldGFkYXRhfkFzeW5jUmVzdWx0TG9jYXRvclxuICogQHBhcmFtIHtNZXRhZGF0YX0gbWV0YSAtIE1ldGFkYXRhIEFQSSBvYmplY3RcbiAqIEBwYXJhbSB7UHJvbWlzZS48TWV0YWRhdGF+QXN5bmNSZXN1bHQ+fSByZXN1bHQgLSBQcm9taXNlIG9iamVjdCBmb3IgYXN5bmMgcmVzdWx0IG9mIHJldHJpZXZlIGNhbGwoKVxuICovXG52YXIgUmV0cmlldmVSZXN1bHRMb2NhdG9yID0gZnVuY3Rpb24obWV0YSwgcmVzdWx0KSB7XG4gIFJldHJpZXZlUmVzdWx0TG9jYXRvci5zdXBlcl8uY2FsbCh0aGlzLCBtZXRhLCByZXN1bHQpO1xufTtcblxuaW5oZXJpdHMoUmV0cmlldmVSZXN1bHRMb2NhdG9yLCBBc3luY1Jlc3VsdExvY2F0b3IpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFkYXRhflJldHJpZXZlUmVzdWx0XG4gKiBAcHJvcCB7QXJyYXkuPE1ldGFkYXRhfkZpbGVQcm9wZXJ0aWVzPn0gZmlsZVByb3BlcnRpZXMgLSBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcHJvcGVydGllcyBvZiBlYWNoIGNvbXBvbmVudCBpbiB0aGUgLnppcCBmaWxlLCBhbmQgdGhlIG1hbmlmZXN0IGZpbGUgcGFja2FnZS54bWxcbiAqIEBwcm9wIHtTdHJpbmd9IGlkIC0gSUQgb2YgdGhlIGNvbXBvbmVudCBiZWluZyByZXRyaWV2ZWRcbiAqIEBwcm9wIHtBcnJheS48T2JqZWN0Pn0gbWVzc2FnZXMgLSBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3VjY2VzcyBvciBmYWlsdXJlIG9mIHRoZSByZXRyaWV2ZSgpIGNhbGxcbiAqIEBwcm9wIHtTdHJpbmd9IHppcEZpbGUgLSBUaGUgemlwIGZpbGUgcmV0dXJuZWQgYnkgdGhlIHJldHJpZXZlIHJlcXVlc3QuIEJhc2UgNjQtZW5jb2RlZCBiaW5hcnkgZGF0YVxuICovXG5cbi8qKlxuICogQ2hlY2sgYW5kIHdhaXQgdW50aWwgdGhlIGFzeW5jIHJlcXVlc3QgYmVjb21lcyBpbiBjb21wbGV0ZWQgc3RhdHVzLFxuICogYW5kIHJldHJpZXZlIHRoZSByZXN1bHQgZGF0YS5cbiAqXG4gKiBAbWVtdGhvZCBNZXRhZGF0YX5SZXRyaWV2ZVJlc3VsdExvY2F0b3IjY29tcGxldGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhflJldHJpZXZlUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TWV0YWRhdGF+UmV0cmlldmVSZXN1bHQ+fVxuICovXG5SZXRyaWV2ZVJlc3VsdExvY2F0b3IucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIG1ldGEgPSB0aGlzLl9tZXRhO1xuICByZXR1cm4gUmV0cmlldmVSZXN1bHRMb2NhdG9yLnN1cGVyXy5wcm90b3R5cGUuY29tcGxldGUuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHJldHVybiBtZXRhLmNoZWNrUmV0cmlldmVTdGF0dXMocmVzdWx0LmlkKTtcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHJldHJpZXZlZCByZXN1bHQgdG8gTm9kZS5qcyByZWFkYWJsZSBzdHJlYW1cbiAqXG4gKiBAbWV0aG9kIE1ldGFkYXRhflJldHJpZXZlUmVzdWx0TG9jYXRvciNzdHJlYW1cbiAqIEByZXR1cm5zIHtzdHJlYW0uUmVhZGFibGV9XG4gKi9cblJldHJpZXZlUmVzdWx0TG9jYXRvci5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJlc3VsdFN0cmVhbSA9IG5ldyBzdHJlYW0uUmVhZGFibGUoKTtcbiAgdmFyIHJlYWRpbmcgPSBmYWxzZTtcbiAgcmVzdWx0U3RyZWFtLl9yZWFkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHJlYWRpbmcpIHsgcmV0dXJuOyB9XG4gICAgcmVhZGluZyA9IHRydWU7XG4gICAgc2VsZi5jb21wbGV0ZShmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXN1bHRTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0U3RyZWFtLnB1c2goQnVmZmVyLmZyb20ocmVzdWx0LnppcEZpbGUsICdiYXNlNjQnKSk7XG4gICAgICAgIHJlc3VsdFN0cmVhbS5wdXNoKG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gcmVzdWx0U3RyZWFtO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIFRoZSBsb2NhdG9yIGNsYXNzIHRvIHRyYWNrIGRlcGxveSgpIE1ldGFkYXRhIEFQSSBjYWxsIHJlc3VsdFxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBjbGFzcyBNZXRhZGF0YX5EZXBsb3lSZXN1bHRMb2NhdG9yXG4gKiBAZXh0ZW5kcyBNZXRhZGF0YX5Bc3luY1Jlc3VsdExvY2F0b3JcbiAqIEBwYXJhbSB7TWV0YWRhdGF9IG1ldGEgLSBNZXRhZGF0YSBBUEkgb2JqZWN0XG4gKiBAcGFyYW0ge1Byb21pc2UuPE1ldGFkYXRhfkFzeW5jUmVzdWx0Pn0gcmVzdWx0IC0gUHJvbWlzZSBvYmplY3QgZm9yIGFzeW5jIHJlc3VsdCBvZiBkZXBsb3koKSBjYWxsXG4gKi9cbnZhciBEZXBsb3lSZXN1bHRMb2NhdG9yID0gZnVuY3Rpb24obWV0YSwgcmVzdWx0KSB7XG4gIERlcGxveVJlc3VsdExvY2F0b3Iuc3VwZXJfLmNhbGwodGhpcywgbWV0YSwgcmVzdWx0KTtcbn07XG5cbmluaGVyaXRzKERlcGxveVJlc3VsdExvY2F0b3IsIEFzeW5jUmVzdWx0TG9jYXRvcik7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0YWRhdGF+RGVwbG95UmVzdWx0XG4gKiBAcHJvcCB7U3RyaW5nfSBpZCAtIElEIG9mIHRoZSBjb21wb25lbnQgYmVpbmcgZGVwbG95ZWRcbiAqIEBwcm9wIHtCb29sZWFufSBjaGVja09ubHkgLSBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGRlcGxveW1lbnQgaXMgYmVpbmcgdXNlZCB0byBjaGVjayB0aGUgdmFsaWRpdHkgb2YgdGhlIGRlcGxveWVkIGZpbGVzIHdpdGhvdXQgbWFraW5nIGFueSBjaGFuZ2VzIGluIHRoZSBvcmdhbml6YXRpb24gb3Igbm90XG4gKiBAcHJvcCB7U3RyaW5nfSBjb21wbGV0ZWREYXRlIC0gVGltZXN0YW1wIGZvciB3aGVuIHRoZSBkZXBsb3ltZW50IHByb2Nlc3MgZW5kZWRcbiAqIEBwcm9wIHtTdHJpbmd9IGNyZWF0ZWREYXRlIC0gVGltZXN0YW1wIGZvciB3aGVuIHRoZSBkZXBsb3koKSBjYWxsIHdhcyByZWNlaXZlZFxuICogQHByb3Age0FycmF5LjxPYmplY3Q+fSBbZGV0YWlsc10gLSBQcm92aWRlcyB0aGUgZGV0YWlscyBvZiBhIGRlcGxveW1lbnQgdGhhdCBpcyBpbi1wcm9ncmVzcyBvciBlbmRlZCwgaWYgaW5jbHVkZURldGFpbHMgaXMgc2V0IHRvIHRydWUgaW4gY2hlY2tEZXBsb3lTdGF0dXMoKSBjYWxsXG4gKiBAcHJvcCB7Qm9vbGVhbn0gZG9uZSAtIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzZXJ2ZXIgZmluaXNoZWQgcHJvY2Vzc2luZyB0aGUgZGVwbG95KCkgY2FsbCBmb3IgdGhlIHNwZWNpZmllZCBpZFxuICogQHByb3Age1N0cmluZ30gW2Vycm9yTWVzc2FnZV0gLSBNZXNzYWdlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHZhbHVlcyBpbiB0aGUgZXJyb3JTdGF0dXNDb2RlIGZpZWxkXG4gKiBAcHJvcCB7U3RyaW5nfSBbZXJyb3JTdGF0dXNDb2RlXSAtIElmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgZGVwbG95KCkgY2FsbCwgYSBzdGF0dXMgY29kZSBpcyByZXR1cm5lZCwgYW5kIHRoZSBtZXNzYWdlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHN0YXR1cyBjb2RlIGlzIHJldHVybmVkIGluIHRoZSBlcnJvck1lc3NhZ2VmaWVsZFxuICogQHByb3Age0Jvb2xlYW59IFtpZ25vcmVXYXJuaW5nc10gLSBTcGVjaWZpZXMgd2hldGhlciBhIGRlcGxveW1lbnQgc2hvdWxkIGNvbnRpbnVlIGV2ZW4gaWYgdGhlIGRlcGxveW1lbnQgZ2VuZXJhdGVzIHdhcm5pbmdzXG4gKiBAcHJvcCB7U3RyaW5nfSBsYXN0TW9kaWZpZWREYXRlIC0gVGltZXN0YW1wIG9mIHRoZSBsYXN0IHVwZGF0ZSBmb3IgdGhlIGRlcGxveW1lbnQgcHJvY2Vzc1xuICogQHByb3Age051bWJlcn0gbnVtYmVyQ29tcG9uZW50RXJyb3JzIC0gVGhlIG51bWJlciBvZiBjb21wb25lbnRzIHRoYXQgZ2VuZXJhdGVkIGVycm9ycyBkdXJpbmcgdGhpcyBkZXBsb3ltZW50XG4gKiBAcHJvcCB7TnVtYmVyfSBudW1iZXJDb21wb25lbnRzRGVwbG95ZWQgLSBUaGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgZGVwbG95ZWQgaW4gdGhlIGRlcGxveW1lbnQgcHJvY2Vzc1xuICogQHByb3Age051bWJlcn0gbnVtYmVyQ29tcG9uZW50c1RvdGFsIC0gVGhlIHRvdGFsIG51bWJlciBvZiBjb21wb25lbnRzIGluIHRoZSBkZXBsb3ltZW50XG4gKiBAcHJvcCB7TnVtYmVyfSBudW1iZXJUZXN0RXJyb3JzIC0gVGhlIG51bWJlciBvZiBBcGV4IHRlc3RzIHRoYXQgaGF2ZSBnZW5lcmF0ZWQgZXJyb3JzIGR1cmluZyB0aGlzIGRlcGxveW1lbnRcbiAqIEBwcm9wIHtOdW1iZXJ9IG51bWJlclRlc3RzQ29tcGxldGVkIC0gVGhlIG51bWJlciBvZiBjb21wbGV0ZWRBcGV4IHRlc3RzIGZvciB0aGlzIGRlcGxveW1lbnRcbiAqIEBwcm9wIHtOdW1iZXJ9IG51bWJlclRlc3RzVG90YWwgLSBUaGUgdG90YWwgbnVtYmVyIG9mIEFwZXggdGVzdHMgZm9yIHRoaXMgZGVwbG95bWVudFxuICogQHByb3Age0Jvb2xlYW59IFtyb2xsYmFja09uRXJyb3JdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYW55IGZhaWx1cmUgY2F1c2VzIGEgY29tcGxldGUgcm9sbGJhY2sgb3Igbm90LiBEZWZhdWx0IGlzIHRydWUuXG4gKiBAcHJvcCB7U3RyaW5nfSBzdGFydERhdGUgLSBUaW1lc3RhbXAgZm9yIHdoZW4gdGhlIGRlcGxveW1lbnQgcHJvY2VzcyBiZWdhblxuICogQHByb3Age1N0cmluZ30gc3RhdHVzIC0gSW5kaWNhdGVzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBkZXBsb3ltZW50XG4gKiBAcHJvcCB7Qm9vbGVhbn0gc3VjY2VzcyAtIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkZXBsb3ltZW50IHdhcyBzdWNjZXNzZnVsIG9yIG5vdFxuICovXG5cbi8qKlxuICogQ2hlY2sgYW5kIHdhaXQgdW50aWwgdGhlIGFzeW5jIHJlcXVlc3QgYmVjb21lcyBpbiBjb21wbGV0ZWQgc3RhdHVzLFxuICogYW5kIHJldHJpZXZlIHRoZSByZXN1bHQgZGF0YS5cbiAqXG4gKiBAbWV0aG9kIE1ldGFkYXRhfkRlcGxveVJlc3VsdExvY2F0b3IjY29tcGxldGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1ldGFkYXRhfkRlcGxveVJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE1ldGFkYXRhfkRlcGxveVJlc3VsdD59XG4gKi9cbkRlcGxveVJlc3VsdExvY2F0b3IucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oaW5jbHVkZURldGFpbHMsIGNhbGxiYWNrKSB7XG4gIGlmIChfLmlzRnVuY3Rpb24oaW5jbHVkZURldGFpbHMpKSB7XG4gICAgY2FsbGJhY2sgPSBpbmNsdWRlRGV0YWlscztcbiAgICBpbmNsdWRlRGV0YWlscyA9IGZhbHNlO1xuICB9XG4gIHZhciBtZXRhID0gdGhpcy5fbWV0YTtcbiAgcmV0dXJuIERlcGxveVJlc3VsdExvY2F0b3Iuc3VwZXJfLnByb3RvdHlwZS5jb21wbGV0ZS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgcmV0dXJuIG1ldGEuY2hlY2tEZXBsb3lTdGF0dXMocmVzdWx0LmlkLCBpbmNsdWRlRGV0YWlscyk7XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKlxuICogUmVnaXN0ZXIgaG9vayBpbiBjb25uZWN0aW9uIGluc3RhbnRpYXRpb24gZm9yIGR5bmFtaWNhbGx5IGFkZGluZyB0aGlzIEFQSSBtb2R1bGUgZmVhdHVyZXNcbiAqL1xuanNmb3JjZS5vbignY29ubmVjdGlvbjpuZXcnLCBmdW5jdGlvbihjb25uKSB7XG4gIGNvbm4ubWV0YWRhdGEgPSBuZXcgTWV0YWRhdGEoY29ubik7XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/api/metadata.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/api/soap.js":
/*!**********************************************!*\
  !*** ./node_modules/jsforce/lib/api/soap.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Salesforce SOAP API\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar _ = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\");\nvar jsforce = __webpack_require__(/*! ../core */ \"(action-browser)/./node_modules/jsforce/lib/core.js\");\nvar SOAP = __webpack_require__(/*! ../soap */ \"(action-browser)/./node_modules/jsforce/lib/soap.js\");\n\n/**\n * API class for Partner SOAP call\n *\n * @class\n * @param {Connection} conn - Connection\n */\nvar SoapApi = module.exports = function(conn) {\n  this._conn = conn;\n};\n\n/**\n * Call SOAP Api (Partner) endpoint\n * @private\n */\nSoapApi.prototype._invoke = function(method, message, schema, callback) {\n  var soapEndpoint = new SOAP(this._conn, {\n    xmlns: \"urn:partner.soap.sforce.com\",\n    endpointUrl: this._conn.instanceUrl + \"/services/Soap/u/\" + this._conn.version\n  });\n  return soapEndpoint.invoke(method, message, { result: schema }).then(function(res) {\n    return res.result;\n  }).thenCall(callback);\n};\n\n\n/* */\nvar Schemas = {};\n\n/**\n * @typedef SoapApi~LeadConvert\n * @prop {String} convertedStatus - Status of converted lead\n * @prop {String} leadId - Lead record Id to convert\n * @prop {String} [accountId] - Account record Id to assign the converted record\n * @prop {String} [contactId] - Contact record Id to assign the converted record\n * @prop {Boolean} [doNotCreateOpportunity] - True if you don't want to create a new opportunity\n * @prop {String} [opportunityName] - Name of opportunity to create\n * @prop {Boolean} [overwriteLeadSource] - True if overwriting lead source\n * @prop {String} [ownerId] - Owner Id\n * @prop {Boolean} [sendNotificationEmail] - True if send notification email\n */\n/**\n * @typedef SoapApi~LeadConvertResult\n * @prop {String} leadId - Lead record Id to convert\n * @prop {String} [accountId] - Account record Id of converted lead\n * @prop {String} [contactId] - Contact record Id of converted lead\n * @prop {String} [opportunityId] - Opportunity record Id created in conversion\n * @prop {Boolean} success - True if successfully converted\n * @prop {Array.<Object>} errors - Error\n */\n/**\n * Converts a Lead into an Account, Contact, or (optionally) an Opportunity.\n *\n * @param {SoapApi~LeadConvert|Array.<SoapApi~LeadConvert>} leadConverts\n * @param {Callback.<SoapApi~LeadConvertResult|Array.<SoapApi~LeadConvertResult>>} [callback] - Callback function\n * @returns {Promise.<SoapApi~LeadConvertResult|Array.<SoapApi~LeadConvertResult>>}\n */\nSoapApi.prototype.convertLead = function(leadConverts, callback) {\n  var schema = _.isArray(leadConverts) ? [ Schemas.LeadConvertResult ] : Schemas.LeadConvertResult;\n  return this._invoke(\"convertLead\", { leadConverts: leadConverts }, schema, callback);\n};\nSchemas.LeadConvertResult = {\n  success: 'boolean',\n  errors: [],\n  leadId: 'string',\n  accountId: 'string',\n  contactId: 'string',\n  opportunityId: 'string'\n};\n\n/**\n * @typedef SoapApi~MergeRequest\n * @prop {Object} masterRecord - The merge destination record\n * @prop {Array.<String>} recordToMergeIds - Ids of records to merge\n */\n/**\n * @typedef SoapApi~MergeResult\n * @prop {Boolean} success - True if successfully merged\n * @prop {Array.<Object>} errors - Error\n * @prop {String} id - ID of the master record\n * @prop {Array.<String>} mergedRecordIds - ID of the records that were merged into the master record\n * @prop {Array.<String>} updatedRelatedIds - ID of all related records that were moved (re-parented) as a result of the merge\n */\n\n/**\n * Merge up to three records into one\n *\n * @param {SoapApi~MergeRequest|Array.<SoapApi~MergeRequest>} mergeRequests\n * @param {Callback.<SoapApi~MergeResult|Array.<SoapApi~MergeResult>>} [callback] - Callback function\n * @returns {Promise.<SoapApi~MergeResult|Array.<SoapApi~MergeResult>>}\n */\nSoapApi.prototype.merge = function(mergeRequests, callback) {\n  var schema = _.isArray(mergeRequests) ? [ Schemas.MergeResult ] : Schemas.MergeResult;\n  return this._invoke(\"merge\", { mergeRequests: mergeRequests }, schema, callback);\n};\nSchemas.MergeResult = {\n  success: 'boolean',\n  errors: [],\n  id: 'string',\n  mergedRecordIds: ['string'],\n  updatedRelatedIds: ['string']\n};\n\n\n/**\n * @typedef SoapApi~EmptyRecycleBinResult\n * @prop {String} id - ID of an sObject that you attempted to delete from the Recycle Bin\n * @prop {Boolean} success - Whether the call succeeded (true) or not (false) for this record\n * @prop {Array.<Object>} errors - Errors\n */\n/**\n * Delete records from the recycle bin immediately\n *\n * @param {Array.<String>} ids - Record ids to empty from recycle bin\n * @param {Callback.<Array.<SoapApi~EmptyRecycleBinResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<SoapApi~EmptyRecycleBinResult>>}\n */\nSoapApi.prototype.emptyRecycleBin = function(ids, callback) {\n  return this._invoke(\"emptyRecycleBin\", { ids: ids }, [ Schemas.EmptyRecycleBinResult ], callback);\n};\nSchemas.EmptyRecycleBinResult = {\n  id: 'string',\n  success: 'boolean',\n  errors: []\n};\n\n\n/**\n * @typedef SoapApi~DescribeTabSetResult\n * @prop {String} label - The display label for this standard or custom app\n * @prop {String} logoUrl - A fully qualified URL to the logo image associated with the standard or custom app\n * @prop {String} namespace - Namespace of application package\n * @prop {Boolean} selected - If true, then this standard or custom app is the users currently selected app\n * @prop {Array.<SoapApi~DescribeTab>} tabs - An array of tabs that are displayed for the specified standard app or custom app\n */\n/**\n * @typedef SoapApi~DescribeTab\n * @prop {Array.<Object>} colors - Array of color information used for a tab\n * @prop {Boolean} custom - true if this is a custom tab\n * @prop {String} iconUrl - The URL for the main 32 x 32 pixel icon for a tab\n * @prop {Array.<Object>} icons - Array of icon information used for a tab\n * @prop {String} label - The display label for this tab\n * @prop {String} miniIconUrl - The URL for the 16 x 16 pixel icon that represents a tab\n * @prop {String} name - The API name of the tab\n * @prop {String} sobjectName - The name of the sObject that is primarily displayed on this tab\n * @prop {String} url - A fully qualified URL for viewing this tab\n */\n/**\n * Returns information about the standard and custom apps available to the logged-in user\n *\n * @param {Callback.<Array.<SoapApi~DescribeTabSetResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<SoapApi~DescribeTabSetResult>>}\n */\nSoapApi.prototype.describeTabs = function(callback) {\n  return this._invoke(\"describeTabs\", {}, [ Schemas.DescribeTabSetResult ], callback);\n};\nSchemas.DescribeTabSetResult = {\n  label: 'string',\n  logoUrl: 'string',\n  namespace: 'string',\n  selected: 'boolean',\n  tabs: [{\n    colors: [{\n      theme: 'string',\n      color: 'string',\n      context: 'string'\n    }],\n    iconUrl: 'string',\n    icons: [{\n      theme: 'string',\n      height: 'number',\n      width: 'number',\n      url: 'string',\n      contentType: 'string'\n    }],\n    label: 'string',\n    custom: 'boolean',\n    miniIconUrl: 'string',\n    name: 'string',\n    sobjectName: 'string',\n    url: 'string'\n  }]\n};\n\n/**\n * Retrieves the current system timestamp (Coordinated Universal Time (UTC) time zone) from the API\n *\n * @typedef SoapApi~ServerTimestampResult\n * @prop {String} timestamp - Timestamp\n */\n/**\n * @param {Callback.<SoapApi~ServerTimestampResult>} [callback] - Callback function\n * @returns {Promise.<SoapApi~ServerTimestampResult>}\n */\nSoapApi.prototype.getServerTimestamp = function(callback) {\n  return this._invoke(\"getServerTimestamp\", {}, Schemas.GetServerTimestampResult, callback);\n};\nSchemas.GetServerTimestampResult = {\n  timestamp: 'string'\n};\n\n/**\n * @typedef SoapApi~UserInfoResult\n * @prop {Boolean} accessibilityMode\n * @prop {String} currencySymbol\n * @prop {Number} orgAttachmentFileSizeLimit\n * @prop {String} orgDefaultCurrencyIsoCode\n * @prop {String} orgDisallowHtmlAttachments\n * @prop {Boolean} orgHasPersonAccounts\n * @prop {String} organizationId\n * @prop {Boolean} organizationMultiCurrency\n * @prop {String} organizationName\n * @prop {String} profileId\n * @prop {String} roleId\n * @prop {Number} sessionSecondsValid\n * @prop {String} userDefaultCurrencyIsoCode\n * @prop {String} userEmail\n * @prop {String} userFullName\n * @prop {String} userId\n * @prop {String} userLanguage\n * @prop {String} userLocale\n * @prop {String} userName\n * @prop {String} userTimeZone\n * @prop {String} userType\n * @prop {String} userUiSkin\n */\n/**\n * Retrieves personal information for the user associated with the current session\n *\n * @param {Callback.<SoapApi~UserInfoResult>} [callback] - Callback function\n * @returns {Promise.<SoapApi~UserInfoResult>}\n */\nSoapApi.prototype.getUserInfo = function(callback) {\n  return this._invoke(\"getUserInfo\", {}, Schemas.GetUserInfoResult, callback);\n};\nSchemas.GetUserInfoResult = {\n  accessibilityMode: 'boolean',\n  currencySymbol: 'string',\n  orgAttachmentFileSizeLimit: 'number',\n  orgDefaultCurrencyIsoCode: 'string',\n  orgDisallowHtmlAttachments: 'boolean',\n  orgHasPersonAccounts: 'boolean',\n  organizationId: 'string',\n  organizationMultiCurrency: 'boolean',\n  organizationName: 'string',\n  profileId: 'string',\n  roleId: 'string',\n  sessionSecondsValid: 'number',\n  userDefaultCurrencyIsoCode: 'string',\n  userEmail: 'string',\n  userFullName: 'string',\n  userId: 'string',\n  userLanguage: 'string',\n  userLocale: 'string',\n  userName: 'string',\n  userTimeZone: 'string',\n  userType: 'string',\n  userUiSkin: 'string'\n};\n\n/**\n * Sets the specified users password to the specified value\n *\n * @param {String} userId - User Id to set password\n * @param {String} password - New password\n * @param {Callback.<String>} [callback] - Callback function\n * @returns {Promise.<String>}\n */\nSoapApi.prototype.setPassword = function(userId, password, callback) {\n  return this._invoke(\"setPassword\", { userId: userId, password: password }, callback);\n};\n\n/**\n * @typedef SoapApi~ResetPasswordResult\n * @prop {String} password\n */\n/**\n * Resets the specified users password\n *\n * @param {String} userId - User Id to set password\n * @param {String} password - New password\n * @param {Callback.<SoapApi~ResetPasswordResult>} [callback] - Callback function\n * @returns {Promise.<SoapApi~ResetPasswordResult>}\n */\nSoapApi.prototype.resetPassword = function(userId, callback) {\n  return this._invoke(\"resetPassword\", { userId: userId }, callback);\n};\n\n/**\n * Adds one or more new records to your organizations data\n *\n * @param {Array.<Object>} sObjects - Records to insert\n * @param {Callback.<SoapApi~SaveResult>} [callback] - Callback function\n * @returns {Promise.<SoapApi~SaveResult>}\n */\nSoapApi.prototype.create = function(sObjects, callback) {\n  var schema = _.isArray(sObjects) ? [ Schemas.SaveResult ] : Schemas.SaveResult;\n  var args = {\n    '@xmlns' : 'urn:partner.soap.sforce.com',\n    '@xmlns:ns1' : 'sobject.partner.soap.sforce.com',\n    'ns1:sObjects' : sObjects\n  };\n  return this._invoke(\"create\", args, schema, callback);\n};\n\n/**\n * Updates one or more existing records in your organizations data.\n *\n * @param {Array.<Object>} sObjects - Records to update\n * @param {Callback.<SoapApi~SaveResult>} [callback] - Callback function\n * @returns {Promise.<SoapApi~SaveResult>}\n */\nSoapApi.prototype.update = function(sObjects, callback) {\n  var schema = _.isArray(sObjects) ? [ Schemas.SaveResult ] : Schemas.SaveResult;\n  var args = {\n    '@xmlns' : 'urn:partner.soap.sforce.com',\n    '@xmlns:ns1' : 'sobject.partner.soap.sforce.com',\n    'ns1:sObjects' : sObjects\n  };\n  return this._invoke(\"update\", args, schema, callback);\n};\n\nSchemas.SaveResult = {\n  success: 'boolean',\n  errors: [],\n  id: 'string'\n};\n\n/**\n * Creates new records and updates existing records in your organizations data.\n *\n * @param {Array.<Object>} sObjects - Records to upsert\n * @param {Callback.<SoapApi~UpsertResult>} [callback] - Callback function\n * @returns {Promise.<SoapApi~UpsertResult>}\n */\nSoapApi.prototype.upsert = function(externalIdFieldName, sObjects, callback) {\n  var schema = _.isArray(sObjects) ? [ Schemas.UpsertResult ] : Schemas.UpsertResult;\n  var args = {\n    '@xmlns' : 'urn:partner.soap.sforce.com',\n    '@xmlns:ns1' : 'sobject.partner.soap.sforce.com',\n    'ns1:externalIDFieldName' : externalIdFieldName,\n    'ns1:sObjects' : sObjects\n  };\n  return this._invoke(\"upsert\", args, schema, callback);\n};\n\nSchemas.UpsertResult = {\n  created: 'boolean',\n  success: 'boolean',\n  errors: [],\n  id: 'string'\n};\n\n/**\n * Deletes one or more records from your organizations data\n *\n * @param {Array.<Object>} ids - Id of records to delete\n * @param {Callback.<SoapApi~DeleteResult>} [callback] - Callback function\n * @returns {Promise.<SoapApi~DeleteResult>}\n */\nSoapApi.prototype.delete = function(ids, callback) {\n  var schema = _.isArray(ids) ? [ Schemas.DeleteResult ] : Schemas.DeleteResult;\n  var args = {\n    '@xmlns' : 'urn:partner.soap.sforce.com',\n    '@xmlns:ns1' : 'sobject.partner.soap.sforce.com',\n    'ns1:ids' : ids\n  };\n  return this._invoke(\"delete\", args, schema, callback);\n};\n\nSchemas.DeleteResult = {\n  success: 'boolean',\n  errors: [],\n  id: 'string'\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.soap = new SoapApi(conn);\n});\n\n\nmodule.exports = SoapApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvc29hcC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixRQUFRLG1CQUFPLENBQUMsbUVBQWE7QUFDN0IsY0FBYyxtQkFBTyxDQUFDLG9FQUFTO0FBQy9CLFdBQVcsbUJBQU8sQ0FBQyxvRUFBUzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsUUFBUTtBQUNsQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpREFBaUQ7QUFDNUQsV0FBVyx3RUFBd0U7QUFDbkYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0QkFBNEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsUUFBUTtBQUNsQixVQUFVLGdCQUFnQjtBQUMxQixVQUFVLGdCQUFnQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1EQUFtRDtBQUM5RCxXQUFXLDREQUE0RDtBQUN2RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDhCQUE4QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQixVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsa0RBQWtEO0FBQzdELGFBQWE7QUFDYjtBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsU0FBUztBQUNuQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxnQkFBZ0I7QUFDMUIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaURBQWlEO0FBQzVELGFBQWE7QUFDYjtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLDBDQUEwQztBQUNyRCxhQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUMsYUFBYTtBQUNiO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBLHVDQUF1QyxvQ0FBb0M7QUFDM0U7O0FBRUE7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyx3Q0FBd0M7QUFDbkQsYUFBYTtBQUNiO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsK0JBQStCO0FBQzFDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLCtCQUErQjtBQUMxQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvc29hcC5qcz82OTg1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgU2FsZXNmb3JjZSBTT0FQIEFQSVxuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyk7XG52YXIganNmb3JjZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBTT0FQID0gcmVxdWlyZSgnLi4vc29hcCcpO1xuXG4vKipcbiAqIEFQSSBjbGFzcyBmb3IgUGFydG5lciBTT0FQIGNhbGxcbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiAtIENvbm5lY3Rpb25cbiAqL1xudmFyIFNvYXBBcGkgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbm4pIHtcbiAgdGhpcy5fY29ubiA9IGNvbm47XG59O1xuXG4vKipcbiAqIENhbGwgU09BUCBBcGkgKFBhcnRuZXIpIGVuZHBvaW50XG4gKiBAcHJpdmF0ZVxuICovXG5Tb2FwQXBpLnByb3RvdHlwZS5faW52b2tlID0gZnVuY3Rpb24obWV0aG9kLCBtZXNzYWdlLCBzY2hlbWEsIGNhbGxiYWNrKSB7XG4gIHZhciBzb2FwRW5kcG9pbnQgPSBuZXcgU09BUCh0aGlzLl9jb25uLCB7XG4gICAgeG1sbnM6IFwidXJuOnBhcnRuZXIuc29hcC5zZm9yY2UuY29tXCIsXG4gICAgZW5kcG9pbnRVcmw6IHRoaXMuX2Nvbm4uaW5zdGFuY2VVcmwgKyBcIi9zZXJ2aWNlcy9Tb2FwL3UvXCIgKyB0aGlzLl9jb25uLnZlcnNpb25cbiAgfSk7XG4gIHJldHVybiBzb2FwRW5kcG9pbnQuaW52b2tlKG1ldGhvZCwgbWVzc2FnZSwgeyByZXN1bHQ6IHNjaGVtYSB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG5cbi8qICovXG52YXIgU2NoZW1hcyA9IHt9O1xuXG4vKipcbiAqIEB0eXBlZGVmIFNvYXBBcGl+TGVhZENvbnZlcnRcbiAqIEBwcm9wIHtTdHJpbmd9IGNvbnZlcnRlZFN0YXR1cyAtIFN0YXR1cyBvZiBjb252ZXJ0ZWQgbGVhZFxuICogQHByb3Age1N0cmluZ30gbGVhZElkIC0gTGVhZCByZWNvcmQgSWQgdG8gY29udmVydFxuICogQHByb3Age1N0cmluZ30gW2FjY291bnRJZF0gLSBBY2NvdW50IHJlY29yZCBJZCB0byBhc3NpZ24gdGhlIGNvbnZlcnRlZCByZWNvcmRcbiAqIEBwcm9wIHtTdHJpbmd9IFtjb250YWN0SWRdIC0gQ29udGFjdCByZWNvcmQgSWQgdG8gYXNzaWduIHRoZSBjb252ZXJ0ZWQgcmVjb3JkXG4gKiBAcHJvcCB7Qm9vbGVhbn0gW2RvTm90Q3JlYXRlT3Bwb3J0dW5pdHldIC0gVHJ1ZSBpZiB5b3UgZG9uJ3Qgd2FudCB0byBjcmVhdGUgYSBuZXcgb3Bwb3J0dW5pdHlcbiAqIEBwcm9wIHtTdHJpbmd9IFtvcHBvcnR1bml0eU5hbWVdIC0gTmFtZSBvZiBvcHBvcnR1bml0eSB0byBjcmVhdGVcbiAqIEBwcm9wIHtCb29sZWFufSBbb3ZlcndyaXRlTGVhZFNvdXJjZV0gLSBUcnVlIGlmIG92ZXJ3cml0aW5nIGxlYWQgc291cmNlXG4gKiBAcHJvcCB7U3RyaW5nfSBbb3duZXJJZF0gLSBPd25lciBJZFxuICogQHByb3Age0Jvb2xlYW59IFtzZW5kTm90aWZpY2F0aW9uRW1haWxdIC0gVHJ1ZSBpZiBzZW5kIG5vdGlmaWNhdGlvbiBlbWFpbFxuICovXG4vKipcbiAqIEB0eXBlZGVmIFNvYXBBcGl+TGVhZENvbnZlcnRSZXN1bHRcbiAqIEBwcm9wIHtTdHJpbmd9IGxlYWRJZCAtIExlYWQgcmVjb3JkIElkIHRvIGNvbnZlcnRcbiAqIEBwcm9wIHtTdHJpbmd9IFthY2NvdW50SWRdIC0gQWNjb3VudCByZWNvcmQgSWQgb2YgY29udmVydGVkIGxlYWRcbiAqIEBwcm9wIHtTdHJpbmd9IFtjb250YWN0SWRdIC0gQ29udGFjdCByZWNvcmQgSWQgb2YgY29udmVydGVkIGxlYWRcbiAqIEBwcm9wIHtTdHJpbmd9IFtvcHBvcnR1bml0eUlkXSAtIE9wcG9ydHVuaXR5IHJlY29yZCBJZCBjcmVhdGVkIGluIGNvbnZlcnNpb25cbiAqIEBwcm9wIHtCb29sZWFufSBzdWNjZXNzIC0gVHJ1ZSBpZiBzdWNjZXNzZnVsbHkgY29udmVydGVkXG4gKiBAcHJvcCB7QXJyYXkuPE9iamVjdD59IGVycm9ycyAtIEVycm9yXG4gKi9cbi8qKlxuICogQ29udmVydHMgYSBMZWFkIGludG8gYW4gQWNjb3VudCwgQ29udGFjdCwgb3IgKG9wdGlvbmFsbHkpIGFuIE9wcG9ydHVuaXR5LlxuICpcbiAqIEBwYXJhbSB7U29hcEFwaX5MZWFkQ29udmVydHxBcnJheS48U29hcEFwaX5MZWFkQ29udmVydD59IGxlYWRDb252ZXJ0c1xuICogQHBhcmFtIHtDYWxsYmFjay48U29hcEFwaX5MZWFkQ29udmVydFJlc3VsdHxBcnJheS48U29hcEFwaX5MZWFkQ29udmVydFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxTb2FwQXBpfkxlYWRDb252ZXJ0UmVzdWx0fEFycmF5LjxTb2FwQXBpfkxlYWRDb252ZXJ0UmVzdWx0Pj59XG4gKi9cblNvYXBBcGkucHJvdG90eXBlLmNvbnZlcnRMZWFkID0gZnVuY3Rpb24obGVhZENvbnZlcnRzLCBjYWxsYmFjaykge1xuICB2YXIgc2NoZW1hID0gXy5pc0FycmF5KGxlYWRDb252ZXJ0cykgPyBbIFNjaGVtYXMuTGVhZENvbnZlcnRSZXN1bHQgXSA6IFNjaGVtYXMuTGVhZENvbnZlcnRSZXN1bHQ7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJjb252ZXJ0TGVhZFwiLCB7IGxlYWRDb252ZXJ0czogbGVhZENvbnZlcnRzIH0sIHNjaGVtYSwgY2FsbGJhY2spO1xufTtcblNjaGVtYXMuTGVhZENvbnZlcnRSZXN1bHQgPSB7XG4gIHN1Y2Nlc3M6ICdib29sZWFuJyxcbiAgZXJyb3JzOiBbXSxcbiAgbGVhZElkOiAnc3RyaW5nJyxcbiAgYWNjb3VudElkOiAnc3RyaW5nJyxcbiAgY29udGFjdElkOiAnc3RyaW5nJyxcbiAgb3Bwb3J0dW5pdHlJZDogJ3N0cmluZydcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgU29hcEFwaX5NZXJnZVJlcXVlc3RcbiAqIEBwcm9wIHtPYmplY3R9IG1hc3RlclJlY29yZCAtIFRoZSBtZXJnZSBkZXN0aW5hdGlvbiByZWNvcmRcbiAqIEBwcm9wIHtBcnJheS48U3RyaW5nPn0gcmVjb3JkVG9NZXJnZUlkcyAtIElkcyBvZiByZWNvcmRzIHRvIG1lcmdlXG4gKi9cbi8qKlxuICogQHR5cGVkZWYgU29hcEFwaX5NZXJnZVJlc3VsdFxuICogQHByb3Age0Jvb2xlYW59IHN1Y2Nlc3MgLSBUcnVlIGlmIHN1Y2Nlc3NmdWxseSBtZXJnZWRcbiAqIEBwcm9wIHtBcnJheS48T2JqZWN0Pn0gZXJyb3JzIC0gRXJyb3JcbiAqIEBwcm9wIHtTdHJpbmd9IGlkIC0gSUQgb2YgdGhlIG1hc3RlciByZWNvcmRcbiAqIEBwcm9wIHtBcnJheS48U3RyaW5nPn0gbWVyZ2VkUmVjb3JkSWRzIC0gSUQgb2YgdGhlIHJlY29yZHMgdGhhdCB3ZXJlIG1lcmdlZCBpbnRvIHRoZSBtYXN0ZXIgcmVjb3JkXG4gKiBAcHJvcCB7QXJyYXkuPFN0cmluZz59IHVwZGF0ZWRSZWxhdGVkSWRzIC0gSUQgb2YgYWxsIHJlbGF0ZWQgcmVjb3JkcyB0aGF0IHdlcmUgbW92ZWQgKHJlLXBhcmVudGVkKSBhcyBhIHJlc3VsdCBvZiB0aGUgbWVyZ2VcbiAqL1xuXG4vKipcbiAqIE1lcmdlIHVwIHRvIHRocmVlIHJlY29yZHMgaW50byBvbmVcbiAqXG4gKiBAcGFyYW0ge1NvYXBBcGl+TWVyZ2VSZXF1ZXN0fEFycmF5LjxTb2FwQXBpfk1lcmdlUmVxdWVzdD59IG1lcmdlUmVxdWVzdHNcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFNvYXBBcGl+TWVyZ2VSZXN1bHR8QXJyYXkuPFNvYXBBcGl+TWVyZ2VSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48U29hcEFwaX5NZXJnZVJlc3VsdHxBcnJheS48U29hcEFwaX5NZXJnZVJlc3VsdD4+fVxuICovXG5Tb2FwQXBpLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG1lcmdlUmVxdWVzdHMsIGNhbGxiYWNrKSB7XG4gIHZhciBzY2hlbWEgPSBfLmlzQXJyYXkobWVyZ2VSZXF1ZXN0cykgPyBbIFNjaGVtYXMuTWVyZ2VSZXN1bHQgXSA6IFNjaGVtYXMuTWVyZ2VSZXN1bHQ7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJtZXJnZVwiLCB7IG1lcmdlUmVxdWVzdHM6IG1lcmdlUmVxdWVzdHMgfSwgc2NoZW1hLCBjYWxsYmFjayk7XG59O1xuU2NoZW1hcy5NZXJnZVJlc3VsdCA9IHtcbiAgc3VjY2VzczogJ2Jvb2xlYW4nLFxuICBlcnJvcnM6IFtdLFxuICBpZDogJ3N0cmluZycsXG4gIG1lcmdlZFJlY29yZElkczogWydzdHJpbmcnXSxcbiAgdXBkYXRlZFJlbGF0ZWRJZHM6IFsnc3RyaW5nJ11cbn07XG5cblxuLyoqXG4gKiBAdHlwZWRlZiBTb2FwQXBpfkVtcHR5UmVjeWNsZUJpblJlc3VsdFxuICogQHByb3Age1N0cmluZ30gaWQgLSBJRCBvZiBhbiBzT2JqZWN0IHRoYXQgeW91IGF0dGVtcHRlZCB0byBkZWxldGUgZnJvbSB0aGUgUmVjeWNsZSBCaW5cbiAqIEBwcm9wIHtCb29sZWFufSBzdWNjZXNzIC0gV2hldGhlciB0aGUgY2FsbCBzdWNjZWVkZWQgKHRydWUpIG9yIG5vdCAoZmFsc2UpIGZvciB0aGlzIHJlY29yZFxuICogQHByb3Age0FycmF5LjxPYmplY3Q+fSBlcnJvcnMgLSBFcnJvcnNcbiAqL1xuLyoqXG4gKiBEZWxldGUgcmVjb3JkcyBmcm9tIHRoZSByZWN5Y2xlIGJpbiBpbW1lZGlhdGVseVxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IGlkcyAtIFJlY29yZCBpZHMgdG8gZW1wdHkgZnJvbSByZWN5Y2xlIGJpblxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFNvYXBBcGl+RW1wdHlSZWN5Y2xlQmluUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxTb2FwQXBpfkVtcHR5UmVjeWNsZUJpblJlc3VsdD4+fVxuICovXG5Tb2FwQXBpLnByb3RvdHlwZS5lbXB0eVJlY3ljbGVCaW4gPSBmdW5jdGlvbihpZHMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJlbXB0eVJlY3ljbGVCaW5cIiwgeyBpZHM6IGlkcyB9LCBbIFNjaGVtYXMuRW1wdHlSZWN5Y2xlQmluUmVzdWx0IF0sIGNhbGxiYWNrKTtcbn07XG5TY2hlbWFzLkVtcHR5UmVjeWNsZUJpblJlc3VsdCA9IHtcbiAgaWQ6ICdzdHJpbmcnLFxuICBzdWNjZXNzOiAnYm9vbGVhbicsXG4gIGVycm9yczogW11cbn07XG5cblxuLyoqXG4gKiBAdHlwZWRlZiBTb2FwQXBpfkRlc2NyaWJlVGFiU2V0UmVzdWx0XG4gKiBAcHJvcCB7U3RyaW5nfSBsYWJlbCAtIFRoZSBkaXNwbGF5IGxhYmVsIGZvciB0aGlzIHN0YW5kYXJkIG9yIGN1c3RvbSBhcHBcbiAqIEBwcm9wIHtTdHJpbmd9IGxvZ29VcmwgLSBBIGZ1bGx5IHF1YWxpZmllZCBVUkwgdG8gdGhlIGxvZ28gaW1hZ2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBzdGFuZGFyZCBvciBjdXN0b20gYXBwXG4gKiBAcHJvcCB7U3RyaW5nfSBuYW1lc3BhY2UgLSBOYW1lc3BhY2Ugb2YgYXBwbGljYXRpb24gcGFja2FnZVxuICogQHByb3Age0Jvb2xlYW59IHNlbGVjdGVkIC0gSWYgdHJ1ZSwgdGhlbiB0aGlzIHN0YW5kYXJkIG9yIGN1c3RvbSBhcHAgaXMgdGhlIHVzZXLigJlzIGN1cnJlbnRseSBzZWxlY3RlZCBhcHBcbiAqIEBwcm9wIHtBcnJheS48U29hcEFwaX5EZXNjcmliZVRhYj59IHRhYnMgLSBBbiBhcnJheSBvZiB0YWJzIHRoYXQgYXJlIGRpc3BsYXllZCBmb3IgdGhlIHNwZWNpZmllZCBzdGFuZGFyZCBhcHAgb3IgY3VzdG9tIGFwcFxuICovXG4vKipcbiAqIEB0eXBlZGVmIFNvYXBBcGl+RGVzY3JpYmVUYWJcbiAqIEBwcm9wIHtBcnJheS48T2JqZWN0Pn0gY29sb3JzIC0gQXJyYXkgb2YgY29sb3IgaW5mb3JtYXRpb24gdXNlZCBmb3IgYSB0YWJcbiAqIEBwcm9wIHtCb29sZWFufSBjdXN0b20gLSB0cnVlIGlmIHRoaXMgaXMgYSBjdXN0b20gdGFiXG4gKiBAcHJvcCB7U3RyaW5nfSBpY29uVXJsIC0gVGhlIFVSTCBmb3IgdGhlIG1haW4gMzIgeCAzMiBwaXhlbCBpY29uIGZvciBhIHRhYlxuICogQHByb3Age0FycmF5LjxPYmplY3Q+fSBpY29ucyAtIEFycmF5IG9mIGljb24gaW5mb3JtYXRpb24gdXNlZCBmb3IgYSB0YWJcbiAqIEBwcm9wIHtTdHJpbmd9IGxhYmVsIC0gVGhlIGRpc3BsYXkgbGFiZWwgZm9yIHRoaXMgdGFiXG4gKiBAcHJvcCB7U3RyaW5nfSBtaW5pSWNvblVybCAtIFRoZSBVUkwgZm9yIHRoZSAxNiB4IDE2IHBpeGVsIGljb24gdGhhdCByZXByZXNlbnRzIGEgdGFiXG4gKiBAcHJvcCB7U3RyaW5nfSBuYW1lIC0gVGhlIEFQSSBuYW1lIG9mIHRoZSB0YWJcbiAqIEBwcm9wIHtTdHJpbmd9IHNvYmplY3ROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNPYmplY3QgdGhhdCBpcyBwcmltYXJpbHkgZGlzcGxheWVkIG9uIHRoaXMgdGFiXG4gKiBAcHJvcCB7U3RyaW5nfSB1cmwgLSBBIGZ1bGx5IHF1YWxpZmllZCBVUkwgZm9yIHZpZXdpbmcgdGhpcyB0YWJcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzdGFuZGFyZCBhbmQgY3VzdG9tIGFwcHMgYXZhaWxhYmxlIHRvIHRoZSBsb2dnZWQtaW4gdXNlclxuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxTb2FwQXBpfkRlc2NyaWJlVGFiU2V0UmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxTb2FwQXBpfkRlc2NyaWJlVGFiU2V0UmVzdWx0Pj59XG4gKi9cblNvYXBBcGkucHJvdG90eXBlLmRlc2NyaWJlVGFicyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJkZXNjcmliZVRhYnNcIiwge30sIFsgU2NoZW1hcy5EZXNjcmliZVRhYlNldFJlc3VsdCBdLCBjYWxsYmFjayk7XG59O1xuU2NoZW1hcy5EZXNjcmliZVRhYlNldFJlc3VsdCA9IHtcbiAgbGFiZWw6ICdzdHJpbmcnLFxuICBsb2dvVXJsOiAnc3RyaW5nJyxcbiAgbmFtZXNwYWNlOiAnc3RyaW5nJyxcbiAgc2VsZWN0ZWQ6ICdib29sZWFuJyxcbiAgdGFiczogW3tcbiAgICBjb2xvcnM6IFt7XG4gICAgICB0aGVtZTogJ3N0cmluZycsXG4gICAgICBjb2xvcjogJ3N0cmluZycsXG4gICAgICBjb250ZXh0OiAnc3RyaW5nJ1xuICAgIH1dLFxuICAgIGljb25Vcmw6ICdzdHJpbmcnLFxuICAgIGljb25zOiBbe1xuICAgICAgdGhlbWU6ICdzdHJpbmcnLFxuICAgICAgaGVpZ2h0OiAnbnVtYmVyJyxcbiAgICAgIHdpZHRoOiAnbnVtYmVyJyxcbiAgICAgIHVybDogJ3N0cmluZycsXG4gICAgICBjb250ZW50VHlwZTogJ3N0cmluZydcbiAgICB9XSxcbiAgICBsYWJlbDogJ3N0cmluZycsXG4gICAgY3VzdG9tOiAnYm9vbGVhbicsXG4gICAgbWluaUljb25Vcmw6ICdzdHJpbmcnLFxuICAgIG5hbWU6ICdzdHJpbmcnLFxuICAgIHNvYmplY3ROYW1lOiAnc3RyaW5nJyxcbiAgICB1cmw6ICdzdHJpbmcnXG4gIH1dXG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBzeXN0ZW0gdGltZXN0YW1wIChDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZSAoVVRDKSB0aW1lIHpvbmUpIGZyb20gdGhlIEFQSVxuICpcbiAqIEB0eXBlZGVmIFNvYXBBcGl+U2VydmVyVGltZXN0YW1wUmVzdWx0XG4gKiBAcHJvcCB7U3RyaW5nfSB0aW1lc3RhbXAgLSBUaW1lc3RhbXBcbiAqL1xuLyoqXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxTb2FwQXBpflNlcnZlclRpbWVzdGFtcFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFNvYXBBcGl+U2VydmVyVGltZXN0YW1wUmVzdWx0Pn1cbiAqL1xuU29hcEFwaS5wcm90b3R5cGUuZ2V0U2VydmVyVGltZXN0YW1wID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcImdldFNlcnZlclRpbWVzdGFtcFwiLCB7fSwgU2NoZW1hcy5HZXRTZXJ2ZXJUaW1lc3RhbXBSZXN1bHQsIGNhbGxiYWNrKTtcbn07XG5TY2hlbWFzLkdldFNlcnZlclRpbWVzdGFtcFJlc3VsdCA9IHtcbiAgdGltZXN0YW1wOiAnc3RyaW5nJ1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBTb2FwQXBpflVzZXJJbmZvUmVzdWx0XG4gKiBAcHJvcCB7Qm9vbGVhbn0gYWNjZXNzaWJpbGl0eU1vZGVcbiAqIEBwcm9wIHtTdHJpbmd9IGN1cnJlbmN5U3ltYm9sXG4gKiBAcHJvcCB7TnVtYmVyfSBvcmdBdHRhY2htZW50RmlsZVNpemVMaW1pdFxuICogQHByb3Age1N0cmluZ30gb3JnRGVmYXVsdEN1cnJlbmN5SXNvQ29kZVxuICogQHByb3Age1N0cmluZ30gb3JnRGlzYWxsb3dIdG1sQXR0YWNobWVudHNcbiAqIEBwcm9wIHtCb29sZWFufSBvcmdIYXNQZXJzb25BY2NvdW50c1xuICogQHByb3Age1N0cmluZ30gb3JnYW5pemF0aW9uSWRcbiAqIEBwcm9wIHtCb29sZWFufSBvcmdhbml6YXRpb25NdWx0aUN1cnJlbmN5XG4gKiBAcHJvcCB7U3RyaW5nfSBvcmdhbml6YXRpb25OYW1lXG4gKiBAcHJvcCB7U3RyaW5nfSBwcm9maWxlSWRcbiAqIEBwcm9wIHtTdHJpbmd9IHJvbGVJZFxuICogQHByb3Age051bWJlcn0gc2Vzc2lvblNlY29uZHNWYWxpZFxuICogQHByb3Age1N0cmluZ30gdXNlckRlZmF1bHRDdXJyZW5jeUlzb0NvZGVcbiAqIEBwcm9wIHtTdHJpbmd9IHVzZXJFbWFpbFxuICogQHByb3Age1N0cmluZ30gdXNlckZ1bGxOYW1lXG4gKiBAcHJvcCB7U3RyaW5nfSB1c2VySWRcbiAqIEBwcm9wIHtTdHJpbmd9IHVzZXJMYW5ndWFnZVxuICogQHByb3Age1N0cmluZ30gdXNlckxvY2FsZVxuICogQHByb3Age1N0cmluZ30gdXNlck5hbWVcbiAqIEBwcm9wIHtTdHJpbmd9IHVzZXJUaW1lWm9uZVxuICogQHByb3Age1N0cmluZ30gdXNlclR5cGVcbiAqIEBwcm9wIHtTdHJpbmd9IHVzZXJVaVNraW5cbiAqL1xuLyoqXG4gKiBSZXRyaWV2ZXMgcGVyc29uYWwgaW5mb3JtYXRpb24gZm9yIHRoZSB1c2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBzZXNzaW9uXG4gKlxuICogQHBhcmFtIHtDYWxsYmFjay48U29hcEFwaX5Vc2VySW5mb1Jlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFNvYXBBcGl+VXNlckluZm9SZXN1bHQ+fVxuICovXG5Tb2FwQXBpLnByb3RvdHlwZS5nZXRVc2VySW5mbyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJnZXRVc2VySW5mb1wiLCB7fSwgU2NoZW1hcy5HZXRVc2VySW5mb1Jlc3VsdCwgY2FsbGJhY2spO1xufTtcblNjaGVtYXMuR2V0VXNlckluZm9SZXN1bHQgPSB7XG4gIGFjY2Vzc2liaWxpdHlNb2RlOiAnYm9vbGVhbicsXG4gIGN1cnJlbmN5U3ltYm9sOiAnc3RyaW5nJyxcbiAgb3JnQXR0YWNobWVudEZpbGVTaXplTGltaXQ6ICdudW1iZXInLFxuICBvcmdEZWZhdWx0Q3VycmVuY3lJc29Db2RlOiAnc3RyaW5nJyxcbiAgb3JnRGlzYWxsb3dIdG1sQXR0YWNobWVudHM6ICdib29sZWFuJyxcbiAgb3JnSGFzUGVyc29uQWNjb3VudHM6ICdib29sZWFuJyxcbiAgb3JnYW5pemF0aW9uSWQ6ICdzdHJpbmcnLFxuICBvcmdhbml6YXRpb25NdWx0aUN1cnJlbmN5OiAnYm9vbGVhbicsXG4gIG9yZ2FuaXphdGlvbk5hbWU6ICdzdHJpbmcnLFxuICBwcm9maWxlSWQ6ICdzdHJpbmcnLFxuICByb2xlSWQ6ICdzdHJpbmcnLFxuICBzZXNzaW9uU2Vjb25kc1ZhbGlkOiAnbnVtYmVyJyxcbiAgdXNlckRlZmF1bHRDdXJyZW5jeUlzb0NvZGU6ICdzdHJpbmcnLFxuICB1c2VyRW1haWw6ICdzdHJpbmcnLFxuICB1c2VyRnVsbE5hbWU6ICdzdHJpbmcnLFxuICB1c2VySWQ6ICdzdHJpbmcnLFxuICB1c2VyTGFuZ3VhZ2U6ICdzdHJpbmcnLFxuICB1c2VyTG9jYWxlOiAnc3RyaW5nJyxcbiAgdXNlck5hbWU6ICdzdHJpbmcnLFxuICB1c2VyVGltZVpvbmU6ICdzdHJpbmcnLFxuICB1c2VyVHlwZTogJ3N0cmluZycsXG4gIHVzZXJVaVNraW46ICdzdHJpbmcnXG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHNwZWNpZmllZCB1c2Vy4oCZcyBwYXNzd29yZCB0byB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJJZCAtIFVzZXIgSWQgdG8gc2V0IHBhc3N3b3JkXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQgLSBOZXcgcGFzc3dvcmRcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFN0cmluZz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFN0cmluZz59XG4gKi9cblNvYXBBcGkucHJvdG90eXBlLnNldFBhc3N3b3JkID0gZnVuY3Rpb24odXNlcklkLCBwYXNzd29yZCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcInNldFBhc3N3b3JkXCIsIHsgdXNlcklkOiB1c2VySWQsIHBhc3N3b3JkOiBwYXNzd29yZCB9LCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIFNvYXBBcGl+UmVzZXRQYXNzd29yZFJlc3VsdFxuICogQHByb3Age1N0cmluZ30gcGFzc3dvcmRcbiAqL1xuLyoqXG4gKiBSZXNldHMgdGhlIHNwZWNpZmllZCB1c2Vy4oCZcyBwYXNzd29yZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VySWQgLSBVc2VyIElkIHRvIHNldCBwYXNzd29yZFxuICogQHBhcmFtIHtTdHJpbmd9IHBhc3N3b3JkIC0gTmV3IHBhc3N3b3JkXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxTb2FwQXBpflJlc2V0UGFzc3dvcmRSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxTb2FwQXBpflJlc2V0UGFzc3dvcmRSZXN1bHQ+fVxuICovXG5Tb2FwQXBpLnByb3RvdHlwZS5yZXNldFBhc3N3b3JkID0gZnVuY3Rpb24odXNlcklkLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwicmVzZXRQYXNzd29yZFwiLCB7IHVzZXJJZDogdXNlcklkIH0sIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQWRkcyBvbmUgb3IgbW9yZSBuZXcgcmVjb3JkcyB0byB5b3VyIG9yZ2FuaXphdGlvbuKAmXMgZGF0YVxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IHNPYmplY3RzIC0gUmVjb3JkcyB0byBpbnNlcnRcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFNvYXBBcGl+U2F2ZVJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFNvYXBBcGl+U2F2ZVJlc3VsdD59XG4gKi9cblNvYXBBcGkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHNPYmplY3RzLCBjYWxsYmFjaykge1xuICB2YXIgc2NoZW1hID0gXy5pc0FycmF5KHNPYmplY3RzKSA/IFsgU2NoZW1hcy5TYXZlUmVzdWx0IF0gOiBTY2hlbWFzLlNhdmVSZXN1bHQ7XG4gIHZhciBhcmdzID0ge1xuICAgICdAeG1sbnMnIDogJ3VybjpwYXJ0bmVyLnNvYXAuc2ZvcmNlLmNvbScsXG4gICAgJ0B4bWxuczpuczEnIDogJ3NvYmplY3QucGFydG5lci5zb2FwLnNmb3JjZS5jb20nLFxuICAgICduczE6c09iamVjdHMnIDogc09iamVjdHNcbiAgfTtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcImNyZWF0ZVwiLCBhcmdzLCBzY2hlbWEsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyBvbmUgb3IgbW9yZSBleGlzdGluZyByZWNvcmRzIGluIHlvdXIgb3JnYW5pemF0aW9u4oCZcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IHNPYmplY3RzIC0gUmVjb3JkcyB0byB1cGRhdGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFNvYXBBcGl+U2F2ZVJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFNvYXBBcGl+U2F2ZVJlc3VsdD59XG4gKi9cblNvYXBBcGkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHNPYmplY3RzLCBjYWxsYmFjaykge1xuICB2YXIgc2NoZW1hID0gXy5pc0FycmF5KHNPYmplY3RzKSA/IFsgU2NoZW1hcy5TYXZlUmVzdWx0IF0gOiBTY2hlbWFzLlNhdmVSZXN1bHQ7XG4gIHZhciBhcmdzID0ge1xuICAgICdAeG1sbnMnIDogJ3VybjpwYXJ0bmVyLnNvYXAuc2ZvcmNlLmNvbScsXG4gICAgJ0B4bWxuczpuczEnIDogJ3NvYmplY3QucGFydG5lci5zb2FwLnNmb3JjZS5jb20nLFxuICAgICduczE6c09iamVjdHMnIDogc09iamVjdHNcbiAgfTtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcInVwZGF0ZVwiLCBhcmdzLCBzY2hlbWEsIGNhbGxiYWNrKTtcbn07XG5cblNjaGVtYXMuU2F2ZVJlc3VsdCA9IHtcbiAgc3VjY2VzczogJ2Jvb2xlYW4nLFxuICBlcnJvcnM6IFtdLFxuICBpZDogJ3N0cmluZydcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgcmVjb3JkcyBhbmQgdXBkYXRlcyBleGlzdGluZyByZWNvcmRzIGluIHlvdXIgb3JnYW5pemF0aW9u4oCZcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IHNPYmplY3RzIC0gUmVjb3JkcyB0byB1cHNlcnRcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFNvYXBBcGl+VXBzZXJ0UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48U29hcEFwaX5VcHNlcnRSZXN1bHQ+fVxuICovXG5Tb2FwQXBpLnByb3RvdHlwZS51cHNlcnQgPSBmdW5jdGlvbihleHRlcm5hbElkRmllbGROYW1lLCBzT2JqZWN0cywgY2FsbGJhY2spIHtcbiAgdmFyIHNjaGVtYSA9IF8uaXNBcnJheShzT2JqZWN0cykgPyBbIFNjaGVtYXMuVXBzZXJ0UmVzdWx0IF0gOiBTY2hlbWFzLlVwc2VydFJlc3VsdDtcbiAgdmFyIGFyZ3MgPSB7XG4gICAgJ0B4bWxucycgOiAndXJuOnBhcnRuZXIuc29hcC5zZm9yY2UuY29tJyxcbiAgICAnQHhtbG5zOm5zMScgOiAnc29iamVjdC5wYXJ0bmVyLnNvYXAuc2ZvcmNlLmNvbScsXG4gICAgJ25zMTpleHRlcm5hbElERmllbGROYW1lJyA6IGV4dGVybmFsSWRGaWVsZE5hbWUsXG4gICAgJ25zMTpzT2JqZWN0cycgOiBzT2JqZWN0c1xuICB9O1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwidXBzZXJ0XCIsIGFyZ3MsIHNjaGVtYSwgY2FsbGJhY2spO1xufTtcblxuU2NoZW1hcy5VcHNlcnRSZXN1bHQgPSB7XG4gIGNyZWF0ZWQ6ICdib29sZWFuJyxcbiAgc3VjY2VzczogJ2Jvb2xlYW4nLFxuICBlcnJvcnM6IFtdLFxuICBpZDogJ3N0cmluZydcbn07XG5cbi8qKlxuICogRGVsZXRlcyBvbmUgb3IgbW9yZSByZWNvcmRzIGZyb20geW91ciBvcmdhbml6YXRpb27igJlzIGRhdGFcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBpZHMgLSBJZCBvZiByZWNvcmRzIHRvIGRlbGV0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48U29hcEFwaX5EZWxldGVSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxTb2FwQXBpfkRlbGV0ZVJlc3VsdD59XG4gKi9cblNvYXBBcGkucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uKGlkcywgY2FsbGJhY2spIHtcbiAgdmFyIHNjaGVtYSA9IF8uaXNBcnJheShpZHMpID8gWyBTY2hlbWFzLkRlbGV0ZVJlc3VsdCBdIDogU2NoZW1hcy5EZWxldGVSZXN1bHQ7XG4gIHZhciBhcmdzID0ge1xuICAgICdAeG1sbnMnIDogJ3VybjpwYXJ0bmVyLnNvYXAuc2ZvcmNlLmNvbScsXG4gICAgJ0B4bWxuczpuczEnIDogJ3NvYmplY3QucGFydG5lci5zb2FwLnNmb3JjZS5jb20nLFxuICAgICduczE6aWRzJyA6IGlkc1xuICB9O1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwiZGVsZXRlXCIsIGFyZ3MsIHNjaGVtYSwgY2FsbGJhY2spO1xufTtcblxuU2NoZW1hcy5EZWxldGVSZXN1bHQgPSB7XG4gIHN1Y2Nlc3M6ICdib29sZWFuJyxcbiAgZXJyb3JzOiBbXSxcbiAgaWQ6ICdzdHJpbmcnXG59O1xuXG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLypcbiAqIFJlZ2lzdGVyIGhvb2sgaW4gY29ubmVjdGlvbiBpbnN0YW50aWF0aW9uIGZvciBkeW5hbWljYWxseSBhZGRpbmcgdGhpcyBBUEkgbW9kdWxlIGZlYXR1cmVzXG4gKi9cbmpzZm9yY2Uub24oJ2Nvbm5lY3Rpb246bmV3JywgZnVuY3Rpb24oY29ubikge1xuICBjb25uLnNvYXAgPSBuZXcgU29hcEFwaShjb25uKTtcbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU29hcEFwaTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/api/soap.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/api/soap.js":
/*!**********************************************!*\
  !*** ./node_modules/jsforce/lib/api/soap.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Salesforce SOAP API\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar _ = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\");\nvar jsforce = __webpack_require__(/*! ../core */ \"(rsc)/./node_modules/jsforce/lib/core.js\");\nvar SOAP = __webpack_require__(/*! ../soap */ \"(rsc)/./node_modules/jsforce/lib/soap.js\");\n\n/**\n * API class for Partner SOAP call\n *\n * @class\n * @param {Connection} conn - Connection\n */\nvar SoapApi = module.exports = function(conn) {\n  this._conn = conn;\n};\n\n/**\n * Call SOAP Api (Partner) endpoint\n * @private\n */\nSoapApi.prototype._invoke = function(method, message, schema, callback) {\n  var soapEndpoint = new SOAP(this._conn, {\n    xmlns: \"urn:partner.soap.sforce.com\",\n    endpointUrl: this._conn.instanceUrl + \"/services/Soap/u/\" + this._conn.version\n  });\n  return soapEndpoint.invoke(method, message, { result: schema }).then(function(res) {\n    return res.result;\n  }).thenCall(callback);\n};\n\n\n/* */\nvar Schemas = {};\n\n/**\n * @typedef SoapApi~LeadConvert\n * @prop {String} convertedStatus - Status of converted lead\n * @prop {String} leadId - Lead record Id to convert\n * @prop {String} [accountId] - Account record Id to assign the converted record\n * @prop {String} [contactId] - Contact record Id to assign the converted record\n * @prop {Boolean} [doNotCreateOpportunity] - True if you don't want to create a new opportunity\n * @prop {String} [opportunityName] - Name of opportunity to create\n * @prop {Boolean} [overwriteLeadSource] - True if overwriting lead source\n * @prop {String} [ownerId] - Owner Id\n * @prop {Boolean} [sendNotificationEmail] - True if send notification email\n */\n/**\n * @typedef SoapApi~LeadConvertResult\n * @prop {String} leadId - Lead record Id to convert\n * @prop {String} [accountId] - Account record Id of converted lead\n * @prop {String} [contactId] - Contact record Id of converted lead\n * @prop {String} [opportunityId] - Opportunity record Id created in conversion\n * @prop {Boolean} success - True if successfully converted\n * @prop {Array.<Object>} errors - Error\n */\n/**\n * Converts a Lead into an Account, Contact, or (optionally) an Opportunity.\n *\n * @param {SoapApi~LeadConvert|Array.<SoapApi~LeadConvert>} leadConverts\n * @param {Callback.<SoapApi~LeadConvertResult|Array.<SoapApi~LeadConvertResult>>} [callback] - Callback function\n * @returns {Promise.<SoapApi~LeadConvertResult|Array.<SoapApi~LeadConvertResult>>}\n */\nSoapApi.prototype.convertLead = function(leadConverts, callback) {\n  var schema = _.isArray(leadConverts) ? [ Schemas.LeadConvertResult ] : Schemas.LeadConvertResult;\n  return this._invoke(\"convertLead\", { leadConverts: leadConverts }, schema, callback);\n};\nSchemas.LeadConvertResult = {\n  success: 'boolean',\n  errors: [],\n  leadId: 'string',\n  accountId: 'string',\n  contactId: 'string',\n  opportunityId: 'string'\n};\n\n/**\n * @typedef SoapApi~MergeRequest\n * @prop {Object} masterRecord - The merge destination record\n * @prop {Array.<String>} recordToMergeIds - Ids of records to merge\n */\n/**\n * @typedef SoapApi~MergeResult\n * @prop {Boolean} success - True if successfully merged\n * @prop {Array.<Object>} errors - Error\n * @prop {String} id - ID of the master record\n * @prop {Array.<String>} mergedRecordIds - ID of the records that were merged into the master record\n * @prop {Array.<String>} updatedRelatedIds - ID of all related records that were moved (re-parented) as a result of the merge\n */\n\n/**\n * Merge up to three records into one\n *\n * @param {SoapApi~MergeRequest|Array.<SoapApi~MergeRequest>} mergeRequests\n * @param {Callback.<SoapApi~MergeResult|Array.<SoapApi~MergeResult>>} [callback] - Callback function\n * @returns {Promise.<SoapApi~MergeResult|Array.<SoapApi~MergeResult>>}\n */\nSoapApi.prototype.merge = function(mergeRequests, callback) {\n  var schema = _.isArray(mergeRequests) ? [ Schemas.MergeResult ] : Schemas.MergeResult;\n  return this._invoke(\"merge\", { mergeRequests: mergeRequests }, schema, callback);\n};\nSchemas.MergeResult = {\n  success: 'boolean',\n  errors: [],\n  id: 'string',\n  mergedRecordIds: ['string'],\n  updatedRelatedIds: ['string']\n};\n\n\n/**\n * @typedef SoapApi~EmptyRecycleBinResult\n * @prop {String} id - ID of an sObject that you attempted to delete from the Recycle Bin\n * @prop {Boolean} success - Whether the call succeeded (true) or not (false) for this record\n * @prop {Array.<Object>} errors - Errors\n */\n/**\n * Delete records from the recycle bin immediately\n *\n * @param {Array.<String>} ids - Record ids to empty from recycle bin\n * @param {Callback.<Array.<SoapApi~EmptyRecycleBinResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<SoapApi~EmptyRecycleBinResult>>}\n */\nSoapApi.prototype.emptyRecycleBin = function(ids, callback) {\n  return this._invoke(\"emptyRecycleBin\", { ids: ids }, [ Schemas.EmptyRecycleBinResult ], callback);\n};\nSchemas.EmptyRecycleBinResult = {\n  id: 'string',\n  success: 'boolean',\n  errors: []\n};\n\n\n/**\n * @typedef SoapApi~DescribeTabSetResult\n * @prop {String} label - The display label for this standard or custom app\n * @prop {String} logoUrl - A fully qualified URL to the logo image associated with the standard or custom app\n * @prop {String} namespace - Namespace of application package\n * @prop {Boolean} selected - If true, then this standard or custom app is the users currently selected app\n * @prop {Array.<SoapApi~DescribeTab>} tabs - An array of tabs that are displayed for the specified standard app or custom app\n */\n/**\n * @typedef SoapApi~DescribeTab\n * @prop {Array.<Object>} colors - Array of color information used for a tab\n * @prop {Boolean} custom - true if this is a custom tab\n * @prop {String} iconUrl - The URL for the main 32 x 32 pixel icon for a tab\n * @prop {Array.<Object>} icons - Array of icon information used for a tab\n * @prop {String} label - The display label for this tab\n * @prop {String} miniIconUrl - The URL for the 16 x 16 pixel icon that represents a tab\n * @prop {String} name - The API name of the tab\n * @prop {String} sobjectName - The name of the sObject that is primarily displayed on this tab\n * @prop {String} url - A fully qualified URL for viewing this tab\n */\n/**\n * Returns information about the standard and custom apps available to the logged-in user\n *\n * @param {Callback.<Array.<SoapApi~DescribeTabSetResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<SoapApi~DescribeTabSetResult>>}\n */\nSoapApi.prototype.describeTabs = function(callback) {\n  return this._invoke(\"describeTabs\", {}, [ Schemas.DescribeTabSetResult ], callback);\n};\nSchemas.DescribeTabSetResult = {\n  label: 'string',\n  logoUrl: 'string',\n  namespace: 'string',\n  selected: 'boolean',\n  tabs: [{\n    colors: [{\n      theme: 'string',\n      color: 'string',\n      context: 'string'\n    }],\n    iconUrl: 'string',\n    icons: [{\n      theme: 'string',\n      height: 'number',\n      width: 'number',\n      url: 'string',\n      contentType: 'string'\n    }],\n    label: 'string',\n    custom: 'boolean',\n    miniIconUrl: 'string',\n    name: 'string',\n    sobjectName: 'string',\n    url: 'string'\n  }]\n};\n\n/**\n * Retrieves the current system timestamp (Coordinated Universal Time (UTC) time zone) from the API\n *\n * @typedef SoapApi~ServerTimestampResult\n * @prop {String} timestamp - Timestamp\n */\n/**\n * @param {Callback.<SoapApi~ServerTimestampResult>} [callback] - Callback function\n * @returns {Promise.<SoapApi~ServerTimestampResult>}\n */\nSoapApi.prototype.getServerTimestamp = function(callback) {\n  return this._invoke(\"getServerTimestamp\", {}, Schemas.GetServerTimestampResult, callback);\n};\nSchemas.GetServerTimestampResult = {\n  timestamp: 'string'\n};\n\n/**\n * @typedef SoapApi~UserInfoResult\n * @prop {Boolean} accessibilityMode\n * @prop {String} currencySymbol\n * @prop {Number} orgAttachmentFileSizeLimit\n * @prop {String} orgDefaultCurrencyIsoCode\n * @prop {String} orgDisallowHtmlAttachments\n * @prop {Boolean} orgHasPersonAccounts\n * @prop {String} organizationId\n * @prop {Boolean} organizationMultiCurrency\n * @prop {String} organizationName\n * @prop {String} profileId\n * @prop {String} roleId\n * @prop {Number} sessionSecondsValid\n * @prop {String} userDefaultCurrencyIsoCode\n * @prop {String} userEmail\n * @prop {String} userFullName\n * @prop {String} userId\n * @prop {String} userLanguage\n * @prop {String} userLocale\n * @prop {String} userName\n * @prop {String} userTimeZone\n * @prop {String} userType\n * @prop {String} userUiSkin\n */\n/**\n * Retrieves personal information for the user associated with the current session\n *\n * @param {Callback.<SoapApi~UserInfoResult>} [callback] - Callback function\n * @returns {Promise.<SoapApi~UserInfoResult>}\n */\nSoapApi.prototype.getUserInfo = function(callback) {\n  return this._invoke(\"getUserInfo\", {}, Schemas.GetUserInfoResult, callback);\n};\nSchemas.GetUserInfoResult = {\n  accessibilityMode: 'boolean',\n  currencySymbol: 'string',\n  orgAttachmentFileSizeLimit: 'number',\n  orgDefaultCurrencyIsoCode: 'string',\n  orgDisallowHtmlAttachments: 'boolean',\n  orgHasPersonAccounts: 'boolean',\n  organizationId: 'string',\n  organizationMultiCurrency: 'boolean',\n  organizationName: 'string',\n  profileId: 'string',\n  roleId: 'string',\n  sessionSecondsValid: 'number',\n  userDefaultCurrencyIsoCode: 'string',\n  userEmail: 'string',\n  userFullName: 'string',\n  userId: 'string',\n  userLanguage: 'string',\n  userLocale: 'string',\n  userName: 'string',\n  userTimeZone: 'string',\n  userType: 'string',\n  userUiSkin: 'string'\n};\n\n/**\n * Sets the specified users password to the specified value\n *\n * @param {String} userId - User Id to set password\n * @param {String} password - New password\n * @param {Callback.<String>} [callback] - Callback function\n * @returns {Promise.<String>}\n */\nSoapApi.prototype.setPassword = function(userId, password, callback) {\n  return this._invoke(\"setPassword\", { userId: userId, password: password }, callback);\n};\n\n/**\n * @typedef SoapApi~ResetPasswordResult\n * @prop {String} password\n */\n/**\n * Resets the specified users password\n *\n * @param {String} userId - User Id to set password\n * @param {String} password - New password\n * @param {Callback.<SoapApi~ResetPasswordResult>} [callback] - Callback function\n * @returns {Promise.<SoapApi~ResetPasswordResult>}\n */\nSoapApi.prototype.resetPassword = function(userId, callback) {\n  return this._invoke(\"resetPassword\", { userId: userId }, callback);\n};\n\n/**\n * Adds one or more new records to your organizations data\n *\n * @param {Array.<Object>} sObjects - Records to insert\n * @param {Callback.<SoapApi~SaveResult>} [callback] - Callback function\n * @returns {Promise.<SoapApi~SaveResult>}\n */\nSoapApi.prototype.create = function(sObjects, callback) {\n  var schema = _.isArray(sObjects) ? [ Schemas.SaveResult ] : Schemas.SaveResult;\n  var args = {\n    '@xmlns' : 'urn:partner.soap.sforce.com',\n    '@xmlns:ns1' : 'sobject.partner.soap.sforce.com',\n    'ns1:sObjects' : sObjects\n  };\n  return this._invoke(\"create\", args, schema, callback);\n};\n\n/**\n * Updates one or more existing records in your organizations data.\n *\n * @param {Array.<Object>} sObjects - Records to update\n * @param {Callback.<SoapApi~SaveResult>} [callback] - Callback function\n * @returns {Promise.<SoapApi~SaveResult>}\n */\nSoapApi.prototype.update = function(sObjects, callback) {\n  var schema = _.isArray(sObjects) ? [ Schemas.SaveResult ] : Schemas.SaveResult;\n  var args = {\n    '@xmlns' : 'urn:partner.soap.sforce.com',\n    '@xmlns:ns1' : 'sobject.partner.soap.sforce.com',\n    'ns1:sObjects' : sObjects\n  };\n  return this._invoke(\"update\", args, schema, callback);\n};\n\nSchemas.SaveResult = {\n  success: 'boolean',\n  errors: [],\n  id: 'string'\n};\n\n/**\n * Creates new records and updates existing records in your organizations data.\n *\n * @param {Array.<Object>} sObjects - Records to upsert\n * @param {Callback.<SoapApi~UpsertResult>} [callback] - Callback function\n * @returns {Promise.<SoapApi~UpsertResult>}\n */\nSoapApi.prototype.upsert = function(externalIdFieldName, sObjects, callback) {\n  var schema = _.isArray(sObjects) ? [ Schemas.UpsertResult ] : Schemas.UpsertResult;\n  var args = {\n    '@xmlns' : 'urn:partner.soap.sforce.com',\n    '@xmlns:ns1' : 'sobject.partner.soap.sforce.com',\n    'ns1:externalIDFieldName' : externalIdFieldName,\n    'ns1:sObjects' : sObjects\n  };\n  return this._invoke(\"upsert\", args, schema, callback);\n};\n\nSchemas.UpsertResult = {\n  created: 'boolean',\n  success: 'boolean',\n  errors: [],\n  id: 'string'\n};\n\n/**\n * Deletes one or more records from your organizations data\n *\n * @param {Array.<Object>} ids - Id of records to delete\n * @param {Callback.<SoapApi~DeleteResult>} [callback] - Callback function\n * @returns {Promise.<SoapApi~DeleteResult>}\n */\nSoapApi.prototype.delete = function(ids, callback) {\n  var schema = _.isArray(ids) ? [ Schemas.DeleteResult ] : Schemas.DeleteResult;\n  var args = {\n    '@xmlns' : 'urn:partner.soap.sforce.com',\n    '@xmlns:ns1' : 'sobject.partner.soap.sforce.com',\n    'ns1:ids' : ids\n  };\n  return this._invoke(\"delete\", args, schema, callback);\n};\n\nSchemas.DeleteResult = {\n  success: 'boolean',\n  errors: [],\n  id: 'string'\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.soap = new SoapApi(conn);\n});\n\n\nmodule.exports = SoapApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL3NvYXAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLHdEQUFhO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyx5REFBUztBQUMvQixXQUFXLG1CQUFPLENBQUMseURBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsUUFBUTtBQUNsQixVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQixVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaURBQWlEO0FBQzVELFdBQVcsd0VBQXdFO0FBQ25GLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNEJBQTRCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQixVQUFVLGdCQUFnQjtBQUMxQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxnQkFBZ0I7QUFDMUIsVUFBVSxnQkFBZ0I7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBbUQ7QUFDOUQsV0FBVyw0REFBNEQ7QUFDdkUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw4QkFBOEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLGtEQUFrRDtBQUM3RCxhQUFhO0FBQ2I7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQixVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlEQUFpRDtBQUM1RCxhQUFhO0FBQ2I7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0EsV0FBVywwQ0FBMEM7QUFDckQsYUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsUUFBUTtBQUNsQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQSx1Q0FBdUMsb0NBQW9DO0FBQzNFOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsd0NBQXdDO0FBQ25ELGFBQWE7QUFDYjtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLCtCQUErQjtBQUMxQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVywrQkFBK0I7QUFDMUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsaUNBQWlDO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL3NvYXAuanM/NDRmZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIFNhbGVzZm9yY2UgU09BUCBBUElcbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpO1xudmFyIGpzZm9yY2UgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgU09BUCA9IHJlcXVpcmUoJy4uL3NvYXAnKTtcblxuLyoqXG4gKiBBUEkgY2xhc3MgZm9yIFBhcnRuZXIgU09BUCBjYWxsXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gLSBDb25uZWN0aW9uXG4gKi9cbnZhciBTb2FwQXBpID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb25uKSB7XG4gIHRoaXMuX2Nvbm4gPSBjb25uO1xufTtcblxuLyoqXG4gKiBDYWxsIFNPQVAgQXBpIChQYXJ0bmVyKSBlbmRwb2ludFxuICogQHByaXZhdGVcbiAqL1xuU29hcEFwaS5wcm90b3R5cGUuX2ludm9rZSA9IGZ1bmN0aW9uKG1ldGhvZCwgbWVzc2FnZSwgc2NoZW1hLCBjYWxsYmFjaykge1xuICB2YXIgc29hcEVuZHBvaW50ID0gbmV3IFNPQVAodGhpcy5fY29ubiwge1xuICAgIHhtbG5zOiBcInVybjpwYXJ0bmVyLnNvYXAuc2ZvcmNlLmNvbVwiLFxuICAgIGVuZHBvaW50VXJsOiB0aGlzLl9jb25uLmluc3RhbmNlVXJsICsgXCIvc2VydmljZXMvU29hcC91L1wiICsgdGhpcy5fY29ubi52ZXJzaW9uXG4gIH0pO1xuICByZXR1cm4gc29hcEVuZHBvaW50Lmludm9rZShtZXRob2QsIG1lc3NhZ2UsIHsgcmVzdWx0OiBzY2hlbWEgfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuXG4vKiAqL1xudmFyIFNjaGVtYXMgPSB7fTtcblxuLyoqXG4gKiBAdHlwZWRlZiBTb2FwQXBpfkxlYWRDb252ZXJ0XG4gKiBAcHJvcCB7U3RyaW5nfSBjb252ZXJ0ZWRTdGF0dXMgLSBTdGF0dXMgb2YgY29udmVydGVkIGxlYWRcbiAqIEBwcm9wIHtTdHJpbmd9IGxlYWRJZCAtIExlYWQgcmVjb3JkIElkIHRvIGNvbnZlcnRcbiAqIEBwcm9wIHtTdHJpbmd9IFthY2NvdW50SWRdIC0gQWNjb3VudCByZWNvcmQgSWQgdG8gYXNzaWduIHRoZSBjb252ZXJ0ZWQgcmVjb3JkXG4gKiBAcHJvcCB7U3RyaW5nfSBbY29udGFjdElkXSAtIENvbnRhY3QgcmVjb3JkIElkIHRvIGFzc2lnbiB0aGUgY29udmVydGVkIHJlY29yZFxuICogQHByb3Age0Jvb2xlYW59IFtkb05vdENyZWF0ZU9wcG9ydHVuaXR5XSAtIFRydWUgaWYgeW91IGRvbid0IHdhbnQgdG8gY3JlYXRlIGEgbmV3IG9wcG9ydHVuaXR5XG4gKiBAcHJvcCB7U3RyaW5nfSBbb3Bwb3J0dW5pdHlOYW1lXSAtIE5hbWUgb2Ygb3Bwb3J0dW5pdHkgdG8gY3JlYXRlXG4gKiBAcHJvcCB7Qm9vbGVhbn0gW292ZXJ3cml0ZUxlYWRTb3VyY2VdIC0gVHJ1ZSBpZiBvdmVyd3JpdGluZyBsZWFkIHNvdXJjZVxuICogQHByb3Age1N0cmluZ30gW293bmVySWRdIC0gT3duZXIgSWRcbiAqIEBwcm9wIHtCb29sZWFufSBbc2VuZE5vdGlmaWNhdGlvbkVtYWlsXSAtIFRydWUgaWYgc2VuZCBub3RpZmljYXRpb24gZW1haWxcbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiBTb2FwQXBpfkxlYWRDb252ZXJ0UmVzdWx0XG4gKiBAcHJvcCB7U3RyaW5nfSBsZWFkSWQgLSBMZWFkIHJlY29yZCBJZCB0byBjb252ZXJ0XG4gKiBAcHJvcCB7U3RyaW5nfSBbYWNjb3VudElkXSAtIEFjY291bnQgcmVjb3JkIElkIG9mIGNvbnZlcnRlZCBsZWFkXG4gKiBAcHJvcCB7U3RyaW5nfSBbY29udGFjdElkXSAtIENvbnRhY3QgcmVjb3JkIElkIG9mIGNvbnZlcnRlZCBsZWFkXG4gKiBAcHJvcCB7U3RyaW5nfSBbb3Bwb3J0dW5pdHlJZF0gLSBPcHBvcnR1bml0eSByZWNvcmQgSWQgY3JlYXRlZCBpbiBjb252ZXJzaW9uXG4gKiBAcHJvcCB7Qm9vbGVhbn0gc3VjY2VzcyAtIFRydWUgaWYgc3VjY2Vzc2Z1bGx5IGNvbnZlcnRlZFxuICogQHByb3Age0FycmF5LjxPYmplY3Q+fSBlcnJvcnMgLSBFcnJvclxuICovXG4vKipcbiAqIENvbnZlcnRzIGEgTGVhZCBpbnRvIGFuIEFjY291bnQsIENvbnRhY3QsIG9yIChvcHRpb25hbGx5KSBhbiBPcHBvcnR1bml0eS5cbiAqXG4gKiBAcGFyYW0ge1NvYXBBcGl+TGVhZENvbnZlcnR8QXJyYXkuPFNvYXBBcGl+TGVhZENvbnZlcnQ+fSBsZWFkQ29udmVydHNcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFNvYXBBcGl+TGVhZENvbnZlcnRSZXN1bHR8QXJyYXkuPFNvYXBBcGl+TGVhZENvbnZlcnRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48U29hcEFwaX5MZWFkQ29udmVydFJlc3VsdHxBcnJheS48U29hcEFwaX5MZWFkQ29udmVydFJlc3VsdD4+fVxuICovXG5Tb2FwQXBpLnByb3RvdHlwZS5jb252ZXJ0TGVhZCA9IGZ1bmN0aW9uKGxlYWRDb252ZXJ0cywgY2FsbGJhY2spIHtcbiAgdmFyIHNjaGVtYSA9IF8uaXNBcnJheShsZWFkQ29udmVydHMpID8gWyBTY2hlbWFzLkxlYWRDb252ZXJ0UmVzdWx0IF0gOiBTY2hlbWFzLkxlYWRDb252ZXJ0UmVzdWx0O1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwiY29udmVydExlYWRcIiwgeyBsZWFkQ29udmVydHM6IGxlYWRDb252ZXJ0cyB9LCBzY2hlbWEsIGNhbGxiYWNrKTtcbn07XG5TY2hlbWFzLkxlYWRDb252ZXJ0UmVzdWx0ID0ge1xuICBzdWNjZXNzOiAnYm9vbGVhbicsXG4gIGVycm9yczogW10sXG4gIGxlYWRJZDogJ3N0cmluZycsXG4gIGFjY291bnRJZDogJ3N0cmluZycsXG4gIGNvbnRhY3RJZDogJ3N0cmluZycsXG4gIG9wcG9ydHVuaXR5SWQ6ICdzdHJpbmcnXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIFNvYXBBcGl+TWVyZ2VSZXF1ZXN0XG4gKiBAcHJvcCB7T2JqZWN0fSBtYXN0ZXJSZWNvcmQgLSBUaGUgbWVyZ2UgZGVzdGluYXRpb24gcmVjb3JkXG4gKiBAcHJvcCB7QXJyYXkuPFN0cmluZz59IHJlY29yZFRvTWVyZ2VJZHMgLSBJZHMgb2YgcmVjb3JkcyB0byBtZXJnZVxuICovXG4vKipcbiAqIEB0eXBlZGVmIFNvYXBBcGl+TWVyZ2VSZXN1bHRcbiAqIEBwcm9wIHtCb29sZWFufSBzdWNjZXNzIC0gVHJ1ZSBpZiBzdWNjZXNzZnVsbHkgbWVyZ2VkXG4gKiBAcHJvcCB7QXJyYXkuPE9iamVjdD59IGVycm9ycyAtIEVycm9yXG4gKiBAcHJvcCB7U3RyaW5nfSBpZCAtIElEIG9mIHRoZSBtYXN0ZXIgcmVjb3JkXG4gKiBAcHJvcCB7QXJyYXkuPFN0cmluZz59IG1lcmdlZFJlY29yZElkcyAtIElEIG9mIHRoZSByZWNvcmRzIHRoYXQgd2VyZSBtZXJnZWQgaW50byB0aGUgbWFzdGVyIHJlY29yZFxuICogQHByb3Age0FycmF5LjxTdHJpbmc+fSB1cGRhdGVkUmVsYXRlZElkcyAtIElEIG9mIGFsbCByZWxhdGVkIHJlY29yZHMgdGhhdCB3ZXJlIG1vdmVkIChyZS1wYXJlbnRlZCkgYXMgYSByZXN1bHQgb2YgdGhlIG1lcmdlXG4gKi9cblxuLyoqXG4gKiBNZXJnZSB1cCB0byB0aHJlZSByZWNvcmRzIGludG8gb25lXG4gKlxuICogQHBhcmFtIHtTb2FwQXBpfk1lcmdlUmVxdWVzdHxBcnJheS48U29hcEFwaX5NZXJnZVJlcXVlc3Q+fSBtZXJnZVJlcXVlc3RzXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxTb2FwQXBpfk1lcmdlUmVzdWx0fEFycmF5LjxTb2FwQXBpfk1lcmdlUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFNvYXBBcGl+TWVyZ2VSZXN1bHR8QXJyYXkuPFNvYXBBcGl+TWVyZ2VSZXN1bHQ+Pn1cbiAqL1xuU29hcEFwaS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihtZXJnZVJlcXVlc3RzLCBjYWxsYmFjaykge1xuICB2YXIgc2NoZW1hID0gXy5pc0FycmF5KG1lcmdlUmVxdWVzdHMpID8gWyBTY2hlbWFzLk1lcmdlUmVzdWx0IF0gOiBTY2hlbWFzLk1lcmdlUmVzdWx0O1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwibWVyZ2VcIiwgeyBtZXJnZVJlcXVlc3RzOiBtZXJnZVJlcXVlc3RzIH0sIHNjaGVtYSwgY2FsbGJhY2spO1xufTtcblNjaGVtYXMuTWVyZ2VSZXN1bHQgPSB7XG4gIHN1Y2Nlc3M6ICdib29sZWFuJyxcbiAgZXJyb3JzOiBbXSxcbiAgaWQ6ICdzdHJpbmcnLFxuICBtZXJnZWRSZWNvcmRJZHM6IFsnc3RyaW5nJ10sXG4gIHVwZGF0ZWRSZWxhdGVkSWRzOiBbJ3N0cmluZyddXG59O1xuXG5cbi8qKlxuICogQHR5cGVkZWYgU29hcEFwaX5FbXB0eVJlY3ljbGVCaW5SZXN1bHRcbiAqIEBwcm9wIHtTdHJpbmd9IGlkIC0gSUQgb2YgYW4gc09iamVjdCB0aGF0IHlvdSBhdHRlbXB0ZWQgdG8gZGVsZXRlIGZyb20gdGhlIFJlY3ljbGUgQmluXG4gKiBAcHJvcCB7Qm9vbGVhbn0gc3VjY2VzcyAtIFdoZXRoZXIgdGhlIGNhbGwgc3VjY2VlZGVkICh0cnVlKSBvciBub3QgKGZhbHNlKSBmb3IgdGhpcyByZWNvcmRcbiAqIEBwcm9wIHtBcnJheS48T2JqZWN0Pn0gZXJyb3JzIC0gRXJyb3JzXG4gKi9cbi8qKlxuICogRGVsZXRlIHJlY29yZHMgZnJvbSB0aGUgcmVjeWNsZSBiaW4gaW1tZWRpYXRlbHlcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBpZHMgLSBSZWNvcmQgaWRzIHRvIGVtcHR5IGZyb20gcmVjeWNsZSBiaW5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxTb2FwQXBpfkVtcHR5UmVjeWNsZUJpblJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheS48U29hcEFwaX5FbXB0eVJlY3ljbGVCaW5SZXN1bHQ+Pn1cbiAqL1xuU29hcEFwaS5wcm90b3R5cGUuZW1wdHlSZWN5Y2xlQmluID0gZnVuY3Rpb24oaWRzLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwiZW1wdHlSZWN5Y2xlQmluXCIsIHsgaWRzOiBpZHMgfSwgWyBTY2hlbWFzLkVtcHR5UmVjeWNsZUJpblJlc3VsdCBdLCBjYWxsYmFjayk7XG59O1xuU2NoZW1hcy5FbXB0eVJlY3ljbGVCaW5SZXN1bHQgPSB7XG4gIGlkOiAnc3RyaW5nJyxcbiAgc3VjY2VzczogJ2Jvb2xlYW4nLFxuICBlcnJvcnM6IFtdXG59O1xuXG5cbi8qKlxuICogQHR5cGVkZWYgU29hcEFwaX5EZXNjcmliZVRhYlNldFJlc3VsdFxuICogQHByb3Age1N0cmluZ30gbGFiZWwgLSBUaGUgZGlzcGxheSBsYWJlbCBmb3IgdGhpcyBzdGFuZGFyZCBvciBjdXN0b20gYXBwXG4gKiBAcHJvcCB7U3RyaW5nfSBsb2dvVXJsIC0gQSBmdWxseSBxdWFsaWZpZWQgVVJMIHRvIHRoZSBsb2dvIGltYWdlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3RhbmRhcmQgb3IgY3VzdG9tIGFwcFxuICogQHByb3Age1N0cmluZ30gbmFtZXNwYWNlIC0gTmFtZXNwYWNlIG9mIGFwcGxpY2F0aW9uIHBhY2thZ2VcbiAqIEBwcm9wIHtCb29sZWFufSBzZWxlY3RlZCAtIElmIHRydWUsIHRoZW4gdGhpcyBzdGFuZGFyZCBvciBjdXN0b20gYXBwIGlzIHRoZSB1c2Vy4oCZcyBjdXJyZW50bHkgc2VsZWN0ZWQgYXBwXG4gKiBAcHJvcCB7QXJyYXkuPFNvYXBBcGl+RGVzY3JpYmVUYWI+fSB0YWJzIC0gQW4gYXJyYXkgb2YgdGFicyB0aGF0IGFyZSBkaXNwbGF5ZWQgZm9yIHRoZSBzcGVjaWZpZWQgc3RhbmRhcmQgYXBwIG9yIGN1c3RvbSBhcHBcbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiBTb2FwQXBpfkRlc2NyaWJlVGFiXG4gKiBAcHJvcCB7QXJyYXkuPE9iamVjdD59IGNvbG9ycyAtIEFycmF5IG9mIGNvbG9yIGluZm9ybWF0aW9uIHVzZWQgZm9yIGEgdGFiXG4gKiBAcHJvcCB7Qm9vbGVhbn0gY3VzdG9tIC0gdHJ1ZSBpZiB0aGlzIGlzIGEgY3VzdG9tIHRhYlxuICogQHByb3Age1N0cmluZ30gaWNvblVybCAtIFRoZSBVUkwgZm9yIHRoZSBtYWluIDMyIHggMzIgcGl4ZWwgaWNvbiBmb3IgYSB0YWJcbiAqIEBwcm9wIHtBcnJheS48T2JqZWN0Pn0gaWNvbnMgLSBBcnJheSBvZiBpY29uIGluZm9ybWF0aW9uIHVzZWQgZm9yIGEgdGFiXG4gKiBAcHJvcCB7U3RyaW5nfSBsYWJlbCAtIFRoZSBkaXNwbGF5IGxhYmVsIGZvciB0aGlzIHRhYlxuICogQHByb3Age1N0cmluZ30gbWluaUljb25VcmwgLSBUaGUgVVJMIGZvciB0aGUgMTYgeCAxNiBwaXhlbCBpY29uIHRoYXQgcmVwcmVzZW50cyBhIHRhYlxuICogQHByb3Age1N0cmluZ30gbmFtZSAtIFRoZSBBUEkgbmFtZSBvZiB0aGUgdGFiXG4gKiBAcHJvcCB7U3RyaW5nfSBzb2JqZWN0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzT2JqZWN0IHRoYXQgaXMgcHJpbWFyaWx5IGRpc3BsYXllZCBvbiB0aGlzIHRhYlxuICogQHByb3Age1N0cmluZ30gdXJsIC0gQSBmdWxseSBxdWFsaWZpZWQgVVJMIGZvciB2aWV3aW5nIHRoaXMgdGFiXG4gKi9cbi8qKlxuICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3RhbmRhcmQgYW5kIGN1c3RvbSBhcHBzIGF2YWlsYWJsZSB0byB0aGUgbG9nZ2VkLWluIHVzZXJcbiAqXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48U29hcEFwaX5EZXNjcmliZVRhYlNldFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheS48U29hcEFwaX5EZXNjcmliZVRhYlNldFJlc3VsdD4+fVxuICovXG5Tb2FwQXBpLnByb3RvdHlwZS5kZXNjcmliZVRhYnMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwiZGVzY3JpYmVUYWJzXCIsIHt9LCBbIFNjaGVtYXMuRGVzY3JpYmVUYWJTZXRSZXN1bHQgXSwgY2FsbGJhY2spO1xufTtcblNjaGVtYXMuRGVzY3JpYmVUYWJTZXRSZXN1bHQgPSB7XG4gIGxhYmVsOiAnc3RyaW5nJyxcbiAgbG9nb1VybDogJ3N0cmluZycsXG4gIG5hbWVzcGFjZTogJ3N0cmluZycsXG4gIHNlbGVjdGVkOiAnYm9vbGVhbicsXG4gIHRhYnM6IFt7XG4gICAgY29sb3JzOiBbe1xuICAgICAgdGhlbWU6ICdzdHJpbmcnLFxuICAgICAgY29sb3I6ICdzdHJpbmcnLFxuICAgICAgY29udGV4dDogJ3N0cmluZydcbiAgICB9XSxcbiAgICBpY29uVXJsOiAnc3RyaW5nJyxcbiAgICBpY29uczogW3tcbiAgICAgIHRoZW1lOiAnc3RyaW5nJyxcbiAgICAgIGhlaWdodDogJ251bWJlcicsXG4gICAgICB3aWR0aDogJ251bWJlcicsXG4gICAgICB1cmw6ICdzdHJpbmcnLFxuICAgICAgY29udGVudFR5cGU6ICdzdHJpbmcnXG4gICAgfV0sXG4gICAgbGFiZWw6ICdzdHJpbmcnLFxuICAgIGN1c3RvbTogJ2Jvb2xlYW4nLFxuICAgIG1pbmlJY29uVXJsOiAnc3RyaW5nJyxcbiAgICBuYW1lOiAnc3RyaW5nJyxcbiAgICBzb2JqZWN0TmFtZTogJ3N0cmluZycsXG4gICAgdXJsOiAnc3RyaW5nJ1xuICB9XVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgc3lzdGVtIHRpbWVzdGFtcCAoQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUgKFVUQykgdGltZSB6b25lKSBmcm9tIHRoZSBBUElcbiAqXG4gKiBAdHlwZWRlZiBTb2FwQXBpflNlcnZlclRpbWVzdGFtcFJlc3VsdFxuICogQHByb3Age1N0cmluZ30gdGltZXN0YW1wIC0gVGltZXN0YW1wXG4gKi9cbi8qKlxuICogQHBhcmFtIHtDYWxsYmFjay48U29hcEFwaX5TZXJ2ZXJUaW1lc3RhbXBSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxTb2FwQXBpflNlcnZlclRpbWVzdGFtcFJlc3VsdD59XG4gKi9cblNvYXBBcGkucHJvdG90eXBlLmdldFNlcnZlclRpbWVzdGFtcCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJnZXRTZXJ2ZXJUaW1lc3RhbXBcIiwge30sIFNjaGVtYXMuR2V0U2VydmVyVGltZXN0YW1wUmVzdWx0LCBjYWxsYmFjayk7XG59O1xuU2NoZW1hcy5HZXRTZXJ2ZXJUaW1lc3RhbXBSZXN1bHQgPSB7XG4gIHRpbWVzdGFtcDogJ3N0cmluZydcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgU29hcEFwaX5Vc2VySW5mb1Jlc3VsdFxuICogQHByb3Age0Jvb2xlYW59IGFjY2Vzc2liaWxpdHlNb2RlXG4gKiBAcHJvcCB7U3RyaW5nfSBjdXJyZW5jeVN5bWJvbFxuICogQHByb3Age051bWJlcn0gb3JnQXR0YWNobWVudEZpbGVTaXplTGltaXRcbiAqIEBwcm9wIHtTdHJpbmd9IG9yZ0RlZmF1bHRDdXJyZW5jeUlzb0NvZGVcbiAqIEBwcm9wIHtTdHJpbmd9IG9yZ0Rpc2FsbG93SHRtbEF0dGFjaG1lbnRzXG4gKiBAcHJvcCB7Qm9vbGVhbn0gb3JnSGFzUGVyc29uQWNjb3VudHNcbiAqIEBwcm9wIHtTdHJpbmd9IG9yZ2FuaXphdGlvbklkXG4gKiBAcHJvcCB7Qm9vbGVhbn0gb3JnYW5pemF0aW9uTXVsdGlDdXJyZW5jeVxuICogQHByb3Age1N0cmluZ30gb3JnYW5pemF0aW9uTmFtZVxuICogQHByb3Age1N0cmluZ30gcHJvZmlsZUlkXG4gKiBAcHJvcCB7U3RyaW5nfSByb2xlSWRcbiAqIEBwcm9wIHtOdW1iZXJ9IHNlc3Npb25TZWNvbmRzVmFsaWRcbiAqIEBwcm9wIHtTdHJpbmd9IHVzZXJEZWZhdWx0Q3VycmVuY3lJc29Db2RlXG4gKiBAcHJvcCB7U3RyaW5nfSB1c2VyRW1haWxcbiAqIEBwcm9wIHtTdHJpbmd9IHVzZXJGdWxsTmFtZVxuICogQHByb3Age1N0cmluZ30gdXNlcklkXG4gKiBAcHJvcCB7U3RyaW5nfSB1c2VyTGFuZ3VhZ2VcbiAqIEBwcm9wIHtTdHJpbmd9IHVzZXJMb2NhbGVcbiAqIEBwcm9wIHtTdHJpbmd9IHVzZXJOYW1lXG4gKiBAcHJvcCB7U3RyaW5nfSB1c2VyVGltZVpvbmVcbiAqIEBwcm9wIHtTdHJpbmd9IHVzZXJUeXBlXG4gKiBAcHJvcCB7U3RyaW5nfSB1c2VyVWlTa2luXG4gKi9cbi8qKlxuICogUmV0cmlldmVzIHBlcnNvbmFsIGluZm9ybWF0aW9uIGZvciB0aGUgdXNlciBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgc2Vzc2lvblxuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFNvYXBBcGl+VXNlckluZm9SZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxTb2FwQXBpflVzZXJJbmZvUmVzdWx0Pn1cbiAqL1xuU29hcEFwaS5wcm90b3R5cGUuZ2V0VXNlckluZm8gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwiZ2V0VXNlckluZm9cIiwge30sIFNjaGVtYXMuR2V0VXNlckluZm9SZXN1bHQsIGNhbGxiYWNrKTtcbn07XG5TY2hlbWFzLkdldFVzZXJJbmZvUmVzdWx0ID0ge1xuICBhY2Nlc3NpYmlsaXR5TW9kZTogJ2Jvb2xlYW4nLFxuICBjdXJyZW5jeVN5bWJvbDogJ3N0cmluZycsXG4gIG9yZ0F0dGFjaG1lbnRGaWxlU2l6ZUxpbWl0OiAnbnVtYmVyJyxcbiAgb3JnRGVmYXVsdEN1cnJlbmN5SXNvQ29kZTogJ3N0cmluZycsXG4gIG9yZ0Rpc2FsbG93SHRtbEF0dGFjaG1lbnRzOiAnYm9vbGVhbicsXG4gIG9yZ0hhc1BlcnNvbkFjY291bnRzOiAnYm9vbGVhbicsXG4gIG9yZ2FuaXphdGlvbklkOiAnc3RyaW5nJyxcbiAgb3JnYW5pemF0aW9uTXVsdGlDdXJyZW5jeTogJ2Jvb2xlYW4nLFxuICBvcmdhbml6YXRpb25OYW1lOiAnc3RyaW5nJyxcbiAgcHJvZmlsZUlkOiAnc3RyaW5nJyxcbiAgcm9sZUlkOiAnc3RyaW5nJyxcbiAgc2Vzc2lvblNlY29uZHNWYWxpZDogJ251bWJlcicsXG4gIHVzZXJEZWZhdWx0Q3VycmVuY3lJc29Db2RlOiAnc3RyaW5nJyxcbiAgdXNlckVtYWlsOiAnc3RyaW5nJyxcbiAgdXNlckZ1bGxOYW1lOiAnc3RyaW5nJyxcbiAgdXNlcklkOiAnc3RyaW5nJyxcbiAgdXNlckxhbmd1YWdlOiAnc3RyaW5nJyxcbiAgdXNlckxvY2FsZTogJ3N0cmluZycsXG4gIHVzZXJOYW1lOiAnc3RyaW5nJyxcbiAgdXNlclRpbWVab25lOiAnc3RyaW5nJyxcbiAgdXNlclR5cGU6ICdzdHJpbmcnLFxuICB1c2VyVWlTa2luOiAnc3RyaW5nJ1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgdXNlcuKAmXMgcGFzc3dvcmQgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VySWQgLSBVc2VyIElkIHRvIHNldCBwYXNzd29yZFxuICogQHBhcmFtIHtTdHJpbmd9IHBhc3N3b3JkIC0gTmV3IHBhc3N3b3JkXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxTdHJpbmc+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxTdHJpbmc+fVxuICovXG5Tb2FwQXBpLnByb3RvdHlwZS5zZXRQYXNzd29yZCA9IGZ1bmN0aW9uKHVzZXJJZCwgcGFzc3dvcmQsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJzZXRQYXNzd29yZFwiLCB7IHVzZXJJZDogdXNlcklkLCBwYXNzd29yZDogcGFzc3dvcmQgfSwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBTb2FwQXBpflJlc2V0UGFzc3dvcmRSZXN1bHRcbiAqIEBwcm9wIHtTdHJpbmd9IHBhc3N3b3JkXG4gKi9cbi8qKlxuICogUmVzZXRzIHRoZSBzcGVjaWZpZWQgdXNlcuKAmXMgcGFzc3dvcmRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXNlcklkIC0gVXNlciBJZCB0byBzZXQgcGFzc3dvcmRcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCAtIE5ldyBwYXNzd29yZFxuICogQHBhcmFtIHtDYWxsYmFjay48U29hcEFwaX5SZXNldFBhc3N3b3JkUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48U29hcEFwaX5SZXNldFBhc3N3b3JkUmVzdWx0Pn1cbiAqL1xuU29hcEFwaS5wcm90b3R5cGUucmVzZXRQYXNzd29yZCA9IGZ1bmN0aW9uKHVzZXJJZCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcInJlc2V0UGFzc3dvcmRcIiwgeyB1c2VySWQ6IHVzZXJJZCB9LCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEFkZHMgb25lIG9yIG1vcmUgbmV3IHJlY29yZHMgdG8geW91ciBvcmdhbml6YXRpb27igJlzIGRhdGFcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBzT2JqZWN0cyAtIFJlY29yZHMgdG8gaW5zZXJ0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxTb2FwQXBpflNhdmVSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxTb2FwQXBpflNhdmVSZXN1bHQ+fVxuICovXG5Tb2FwQXBpLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihzT2JqZWN0cywgY2FsbGJhY2spIHtcbiAgdmFyIHNjaGVtYSA9IF8uaXNBcnJheShzT2JqZWN0cykgPyBbIFNjaGVtYXMuU2F2ZVJlc3VsdCBdIDogU2NoZW1hcy5TYXZlUmVzdWx0O1xuICB2YXIgYXJncyA9IHtcbiAgICAnQHhtbG5zJyA6ICd1cm46cGFydG5lci5zb2FwLnNmb3JjZS5jb20nLFxuICAgICdAeG1sbnM6bnMxJyA6ICdzb2JqZWN0LnBhcnRuZXIuc29hcC5zZm9yY2UuY29tJyxcbiAgICAnbnMxOnNPYmplY3RzJyA6IHNPYmplY3RzXG4gIH07XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJjcmVhdGVcIiwgYXJncywgc2NoZW1hLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgb25lIG9yIG1vcmUgZXhpc3RpbmcgcmVjb3JkcyBpbiB5b3VyIG9yZ2FuaXphdGlvbuKAmXMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBzT2JqZWN0cyAtIFJlY29yZHMgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxTb2FwQXBpflNhdmVSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxTb2FwQXBpflNhdmVSZXN1bHQ+fVxuICovXG5Tb2FwQXBpLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihzT2JqZWN0cywgY2FsbGJhY2spIHtcbiAgdmFyIHNjaGVtYSA9IF8uaXNBcnJheShzT2JqZWN0cykgPyBbIFNjaGVtYXMuU2F2ZVJlc3VsdCBdIDogU2NoZW1hcy5TYXZlUmVzdWx0O1xuICB2YXIgYXJncyA9IHtcbiAgICAnQHhtbG5zJyA6ICd1cm46cGFydG5lci5zb2FwLnNmb3JjZS5jb20nLFxuICAgICdAeG1sbnM6bnMxJyA6ICdzb2JqZWN0LnBhcnRuZXIuc29hcC5zZm9yY2UuY29tJyxcbiAgICAnbnMxOnNPYmplY3RzJyA6IHNPYmplY3RzXG4gIH07XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJ1cGRhdGVcIiwgYXJncywgc2NoZW1hLCBjYWxsYmFjayk7XG59O1xuXG5TY2hlbWFzLlNhdmVSZXN1bHQgPSB7XG4gIHN1Y2Nlc3M6ICdib29sZWFuJyxcbiAgZXJyb3JzOiBbXSxcbiAgaWQ6ICdzdHJpbmcnXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IHJlY29yZHMgYW5kIHVwZGF0ZXMgZXhpc3RpbmcgcmVjb3JkcyBpbiB5b3VyIG9yZ2FuaXphdGlvbuKAmXMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBzT2JqZWN0cyAtIFJlY29yZHMgdG8gdXBzZXJ0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxTb2FwQXBpflVwc2VydFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFNvYXBBcGl+VXBzZXJ0UmVzdWx0Pn1cbiAqL1xuU29hcEFwaS5wcm90b3R5cGUudXBzZXJ0ID0gZnVuY3Rpb24oZXh0ZXJuYWxJZEZpZWxkTmFtZSwgc09iamVjdHMsIGNhbGxiYWNrKSB7XG4gIHZhciBzY2hlbWEgPSBfLmlzQXJyYXkoc09iamVjdHMpID8gWyBTY2hlbWFzLlVwc2VydFJlc3VsdCBdIDogU2NoZW1hcy5VcHNlcnRSZXN1bHQ7XG4gIHZhciBhcmdzID0ge1xuICAgICdAeG1sbnMnIDogJ3VybjpwYXJ0bmVyLnNvYXAuc2ZvcmNlLmNvbScsXG4gICAgJ0B4bWxuczpuczEnIDogJ3NvYmplY3QucGFydG5lci5zb2FwLnNmb3JjZS5jb20nLFxuICAgICduczE6ZXh0ZXJuYWxJREZpZWxkTmFtZScgOiBleHRlcm5hbElkRmllbGROYW1lLFxuICAgICduczE6c09iamVjdHMnIDogc09iamVjdHNcbiAgfTtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcInVwc2VydFwiLCBhcmdzLCBzY2hlbWEsIGNhbGxiYWNrKTtcbn07XG5cblNjaGVtYXMuVXBzZXJ0UmVzdWx0ID0ge1xuICBjcmVhdGVkOiAnYm9vbGVhbicsXG4gIHN1Y2Nlc3M6ICdib29sZWFuJyxcbiAgZXJyb3JzOiBbXSxcbiAgaWQ6ICdzdHJpbmcnXG59O1xuXG4vKipcbiAqIERlbGV0ZXMgb25lIG9yIG1vcmUgcmVjb3JkcyBmcm9tIHlvdXIgb3JnYW5pemF0aW9u4oCZcyBkYXRhXG4gKlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gaWRzIC0gSWQgb2YgcmVjb3JkcyB0byBkZWxldGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFNvYXBBcGl+RGVsZXRlUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48U29hcEFwaX5EZWxldGVSZXN1bHQ+fVxuICovXG5Tb2FwQXBpLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbihpZHMsIGNhbGxiYWNrKSB7XG4gIHZhciBzY2hlbWEgPSBfLmlzQXJyYXkoaWRzKSA/IFsgU2NoZW1hcy5EZWxldGVSZXN1bHQgXSA6IFNjaGVtYXMuRGVsZXRlUmVzdWx0O1xuICB2YXIgYXJncyA9IHtcbiAgICAnQHhtbG5zJyA6ICd1cm46cGFydG5lci5zb2FwLnNmb3JjZS5jb20nLFxuICAgICdAeG1sbnM6bnMxJyA6ICdzb2JqZWN0LnBhcnRuZXIuc29hcC5zZm9yY2UuY29tJyxcbiAgICAnbnMxOmlkcycgOiBpZHNcbiAgfTtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcImRlbGV0ZVwiLCBhcmdzLCBzY2hlbWEsIGNhbGxiYWNrKTtcbn07XG5cblNjaGVtYXMuRGVsZXRlUmVzdWx0ID0ge1xuICBzdWNjZXNzOiAnYm9vbGVhbicsXG4gIGVycm9yczogW10sXG4gIGlkOiAnc3RyaW5nJ1xufTtcblxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qXG4gKiBSZWdpc3RlciBob29rIGluIGNvbm5lY3Rpb24gaW5zdGFudGlhdGlvbiBmb3IgZHluYW1pY2FsbHkgYWRkaW5nIHRoaXMgQVBJIG1vZHVsZSBmZWF0dXJlc1xuICovXG5qc2ZvcmNlLm9uKCdjb25uZWN0aW9uOm5ldycsIGZ1bmN0aW9uKGNvbm4pIHtcbiAgY29ubi5zb2FwID0gbmV3IFNvYXBBcGkoY29ubik7XG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNvYXBBcGk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/api/soap.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/api/streaming-extension.js":
/*!*************************************************************!*\
  !*** ./node_modules/jsforce/lib/api/streaming-extension.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("/**\n * Faye Client extensions: https://faye.jcoglan.com/browser/extensions.html\n *\n * For use with Streaming.prototype.createClient()\n**/\nvar StreamingExtension = {};\n\n/**\n * Constructor for an auth failure detector extension\n *\n * Based on new feature released with Salesforce Spring '18:\n * https://releasenotes.docs.salesforce.com/en-us/spring18/release-notes/rn_messaging_cometd_auth_validation.htm?edition=&impact=\n *\n * Example triggering error message:\n *\n * ```\n * {\n *   \"ext\":{\n *     \"sfdc\":{\"failureReason\":\"401::Authentication invalid\"},\n *     \"replay\":true},\n *   \"advice\":{\"reconnect\":\"none\"},\n *   \"channel\":\"/meta/handshake\",\n *   \"error\":\"403::Handshake denied\",\n *   \"successful\":false\n * }\n * ```\n *\n * Example usage:\n *\n * ```javascript\n * const conn = new jsforce.Connection({  });\n * \n * const channel = \"/event/My_Event__e\";\n * \n * // Exit the Node process when auth fails\n * const exitCallback = () => process.exit(1);\n * const authFailureExt = new jsforce.StreamingExtension.AuthFailure(exitCallback);\n * \n * const fayeClient = conn.streaming.createClient([ authFailureExt ]);\n * \n * const subscription = fayeClient.subscribe(channel, data => {\n *   console.log('topic received data', data);\n * });\n * \n * subscription.cancel();\n * ```\n *\n * @param {Function} failureCallback - Invoked when authentication becomes invalid\n */\nStreamingExtension.AuthFailure = function(failureCallback) {\n  this.incoming = function(message, callback) {\n    if (\n      (message.channel === '/meta/connect' ||\n        message.channel === '/meta/handshake')\n      && message.advice\n      && message.advice.reconnect == 'none'\n    ) {\n      failureCallback(message);\n    } else {\n      callback(message);\n    }\n  }\n};\n\n/**\n * Constructor for a durable streaming replay extension\n *\n * Modified from original Salesforce demo source code:\n * https://github.com/developerforce/SalesforceDurableStreamingDemo/blob/3d4a56eac956f744ad6c22e6a8141b6feb57abb9/staticresources/cometdReplayExtension.resource\n * \n * Example usage:\n *\n * ```javascript\n * const conn = new jsforce.Connection({  });\n * \n * const channel = \"/event/My_Event__e\";\n * const replayId = -2; // -2 is all retained events\n * \n * const replayExt = new jsforce.StreamingExtension.Replay(channel, replayId);\n * \n * const fayeClient = conn.streaming.createClient([ replayExt ]);\n * \n * const subscription = fayeClient.subscribe(channel, data => {\n *   console.log('topic received data', data);\n * });\n * \n * subscription.cancel();\n * ```\n */\nStreamingExtension.Replay = function(channel, replayId) {\n  var REPLAY_FROM_KEY = \"replay\";\n  \n  var _extensionEnabled = replayId != null ? true : false;\n  var _replay = replayId;\n  var _channel = channel;\n\n  this.setExtensionEnabled = function(extensionEnabled) {\n    _extensionEnabled = extensionEnabled;\n  }\n\n  this.setReplay = function (replay) {\n    _replay = parseInt(replay, 10);\n  }\n\n  this.setChannel = function(channel) {\n    _channel = channel;\n  }\n\n  this.incoming = function(message, callback) {\n    if (message.channel === '/meta/handshake') {\n      if (message.ext && message.ext[REPLAY_FROM_KEY] == true) {\n        _extensionEnabled = true;\n      }\n    } else if (message.channel === _channel && message.data && message.data.event && message.data.event.replayId) {\n      _replay = message.data.event.replayId;\n    }\n    callback(message);\n  }\n  \n  this.outgoing = function(message, callback) {\n    if (message.channel === '/meta/subscribe' && message.subscription === _channel) {\n      if (_extensionEnabled) {\n        if (!message.ext) { message.ext = {}; }\n\n        var replayFromMap = {};\n        replayFromMap[_channel] = _replay;\n\n        // add \"ext : { \"replay\" : { CHANNEL : REPLAY_VALUE }}\" to subscribe message\n        message.ext[REPLAY_FROM_KEY] = replayFromMap;\n      }\n    }\n    callback(message);\n  };\n};\n\nmodule.exports = StreamingExtension;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvc3RyZWFtaW5nLWV4dGVuc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQThDO0FBQzdELHFCQUFxQjtBQUNyQixlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsR0FBRztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxHQUFHO0FBQzVDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBLHdCQUF3QixhQUFhLHlCQUF5QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2FwaS9zdHJlYW1pbmctZXh0ZW5zaW9uLmpzP2QxZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGYXllIENsaWVudCBleHRlbnNpb25zOiBodHRwczovL2ZheWUuamNvZ2xhbi5jb20vYnJvd3Nlci9leHRlbnNpb25zLmh0bWxcbiAqXG4gKiBGb3IgdXNlIHdpdGggU3RyZWFtaW5nLnByb3RvdHlwZS5jcmVhdGVDbGllbnQoKVxuKiovXG52YXIgU3RyZWFtaW5nRXh0ZW5zaW9uID0ge307XG5cbi8qKlxuICogQ29uc3RydWN0b3IgZm9yIGFuIGF1dGggZmFpbHVyZSBkZXRlY3RvciBleHRlbnNpb25cbiAqXG4gKiBCYXNlZCBvbiBuZXcgZmVhdHVyZSByZWxlYXNlZCB3aXRoIFNhbGVzZm9yY2UgU3ByaW5nICcxODpcbiAqIGh0dHBzOi8vcmVsZWFzZW5vdGVzLmRvY3Muc2FsZXNmb3JjZS5jb20vZW4tdXMvc3ByaW5nMTgvcmVsZWFzZS1ub3Rlcy9ybl9tZXNzYWdpbmdfY29tZXRkX2F1dGhfdmFsaWRhdGlvbi5odG0/ZWRpdGlvbj0maW1wYWN0PVxuICpcbiAqIEV4YW1wbGUgdHJpZ2dlcmluZyBlcnJvciBtZXNzYWdlOlxuICpcbiAqIGBgYFxuICoge1xuICogICBcImV4dFwiOntcbiAqICAgICBcInNmZGNcIjp7XCJmYWlsdXJlUmVhc29uXCI6XCI0MDE6OkF1dGhlbnRpY2F0aW9uIGludmFsaWRcIn0sXG4gKiAgICAgXCJyZXBsYXlcIjp0cnVlfSxcbiAqICAgXCJhZHZpY2VcIjp7XCJyZWNvbm5lY3RcIjpcIm5vbmVcIn0sXG4gKiAgIFwiY2hhbm5lbFwiOlwiL21ldGEvaGFuZHNoYWtlXCIsXG4gKiAgIFwiZXJyb3JcIjpcIjQwMzo6SGFuZHNoYWtlIGRlbmllZFwiLFxuICogICBcInN1Y2Nlc3NmdWxcIjpmYWxzZVxuICogfVxuICogYGBgXG4gKlxuICogRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBjb25uID0gbmV3IGpzZm9yY2UuQ29ubmVjdGlvbih7IOKApiB9KTtcbiAqIFxuICogY29uc3QgY2hhbm5lbCA9IFwiL2V2ZW50L015X0V2ZW50X19lXCI7XG4gKiBcbiAqIC8vIEV4aXQgdGhlIE5vZGUgcHJvY2VzcyB3aGVuIGF1dGggZmFpbHNcbiAqIGNvbnN0IGV4aXRDYWxsYmFjayA9ICgpID0+IHByb2Nlc3MuZXhpdCgxKTtcbiAqIGNvbnN0IGF1dGhGYWlsdXJlRXh0ID0gbmV3IGpzZm9yY2UuU3RyZWFtaW5nRXh0ZW5zaW9uLkF1dGhGYWlsdXJlKGV4aXRDYWxsYmFjayk7XG4gKiBcbiAqIGNvbnN0IGZheWVDbGllbnQgPSBjb25uLnN0cmVhbWluZy5jcmVhdGVDbGllbnQoWyBhdXRoRmFpbHVyZUV4dCBdKTtcbiAqIFxuICogY29uc3Qgc3Vic2NyaXB0aW9uID0gZmF5ZUNsaWVudC5zdWJzY3JpYmUoY2hhbm5lbCwgZGF0YSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCd0b3BpYyByZWNlaXZlZCBkYXRhJywgZGF0YSk7XG4gKiB9KTtcbiAqIFxuICogc3Vic2NyaXB0aW9uLmNhbmNlbCgpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZmFpbHVyZUNhbGxiYWNrIC0gSW52b2tlZCB3aGVuIGF1dGhlbnRpY2F0aW9uIGJlY29tZXMgaW52YWxpZFxuICovXG5TdHJlYW1pbmdFeHRlbnNpb24uQXV0aEZhaWx1cmUgPSBmdW5jdGlvbihmYWlsdXJlQ2FsbGJhY2spIHtcbiAgdGhpcy5pbmNvbWluZyA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKFxuICAgICAgKG1lc3NhZ2UuY2hhbm5lbCA9PT0gJy9tZXRhL2Nvbm5lY3QnIHx8XG4gICAgICAgIG1lc3NhZ2UuY2hhbm5lbCA9PT0gJy9tZXRhL2hhbmRzaGFrZScpXG4gICAgICAmJiBtZXNzYWdlLmFkdmljZVxuICAgICAgJiYgbWVzc2FnZS5hZHZpY2UucmVjb25uZWN0ID09ICdub25lJ1xuICAgICkge1xuICAgICAgZmFpbHVyZUNhbGxiYWNrKG1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ29uc3RydWN0b3IgZm9yIGEgZHVyYWJsZSBzdHJlYW1pbmcgcmVwbGF5IGV4dGVuc2lvblxuICpcbiAqIE1vZGlmaWVkIGZyb20gb3JpZ2luYWwgU2FsZXNmb3JjZSBkZW1vIHNvdXJjZSBjb2RlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BlcmZvcmNlL1NhbGVzZm9yY2VEdXJhYmxlU3RyZWFtaW5nRGVtby9ibG9iLzNkNGE1NmVhYzk1NmY3NDRhZDZjMjJlNmE4MTQxYjZmZWI1N2FiYjkvc3RhdGljcmVzb3VyY2VzL2NvbWV0ZFJlcGxheUV4dGVuc2lvbi5yZXNvdXJjZVxuICogXG4gKiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGNvbm4gPSBuZXcganNmb3JjZS5Db25uZWN0aW9uKHsg4oCmIH0pO1xuICogXG4gKiBjb25zdCBjaGFubmVsID0gXCIvZXZlbnQvTXlfRXZlbnRfX2VcIjtcbiAqIGNvbnN0IHJlcGxheUlkID0gLTI7IC8vIC0yIGlzIGFsbCByZXRhaW5lZCBldmVudHNcbiAqIFxuICogY29uc3QgcmVwbGF5RXh0ID0gbmV3IGpzZm9yY2UuU3RyZWFtaW5nRXh0ZW5zaW9uLlJlcGxheShjaGFubmVsLCByZXBsYXlJZCk7XG4gKiBcbiAqIGNvbnN0IGZheWVDbGllbnQgPSBjb25uLnN0cmVhbWluZy5jcmVhdGVDbGllbnQoWyByZXBsYXlFeHQgXSk7XG4gKiBcbiAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGZheWVDbGllbnQuc3Vic2NyaWJlKGNoYW5uZWwsIGRhdGEgPT4ge1xuICogICBjb25zb2xlLmxvZygndG9waWMgcmVjZWl2ZWQgZGF0YScsIGRhdGEpO1xuICogfSk7XG4gKiBcbiAqIHN1YnNjcmlwdGlvbi5jYW5jZWwoKTtcbiAqIGBgYFxuICovXG5TdHJlYW1pbmdFeHRlbnNpb24uUmVwbGF5ID0gZnVuY3Rpb24oY2hhbm5lbCwgcmVwbGF5SWQpIHtcbiAgdmFyIFJFUExBWV9GUk9NX0tFWSA9IFwicmVwbGF5XCI7XG4gIFxuICB2YXIgX2V4dGVuc2lvbkVuYWJsZWQgPSByZXBsYXlJZCAhPSBudWxsID8gdHJ1ZSA6IGZhbHNlO1xuICB2YXIgX3JlcGxheSA9IHJlcGxheUlkO1xuICB2YXIgX2NoYW5uZWwgPSBjaGFubmVsO1xuXG4gIHRoaXMuc2V0RXh0ZW5zaW9uRW5hYmxlZCA9IGZ1bmN0aW9uKGV4dGVuc2lvbkVuYWJsZWQpIHtcbiAgICBfZXh0ZW5zaW9uRW5hYmxlZCA9IGV4dGVuc2lvbkVuYWJsZWQ7XG4gIH1cblxuICB0aGlzLnNldFJlcGxheSA9IGZ1bmN0aW9uIChyZXBsYXkpIHtcbiAgICBfcmVwbGF5ID0gcGFyc2VJbnQocmVwbGF5LCAxMCk7XG4gIH1cblxuICB0aGlzLnNldENoYW5uZWwgPSBmdW5jdGlvbihjaGFubmVsKSB7XG4gICAgX2NoYW5uZWwgPSBjaGFubmVsO1xuICB9XG5cbiAgdGhpcy5pbmNvbWluZyA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKG1lc3NhZ2UuY2hhbm5lbCA9PT0gJy9tZXRhL2hhbmRzaGFrZScpIHtcbiAgICAgIGlmIChtZXNzYWdlLmV4dCAmJiBtZXNzYWdlLmV4dFtSRVBMQVlfRlJPTV9LRVldID09IHRydWUpIHtcbiAgICAgICAgX2V4dGVuc2lvbkVuYWJsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5jaGFubmVsID09PSBfY2hhbm5lbCAmJiBtZXNzYWdlLmRhdGEgJiYgbWVzc2FnZS5kYXRhLmV2ZW50ICYmIG1lc3NhZ2UuZGF0YS5ldmVudC5yZXBsYXlJZCkge1xuICAgICAgX3JlcGxheSA9IG1lc3NhZ2UuZGF0YS5ldmVudC5yZXBsYXlJZDtcbiAgICB9XG4gICAgY2FsbGJhY2sobWVzc2FnZSk7XG4gIH1cbiAgXG4gIHRoaXMub3V0Z29pbmcgPSBmdW5jdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIGlmIChtZXNzYWdlLmNoYW5uZWwgPT09ICcvbWV0YS9zdWJzY3JpYmUnICYmIG1lc3NhZ2Uuc3Vic2NyaXB0aW9uID09PSBfY2hhbm5lbCkge1xuICAgICAgaWYgKF9leHRlbnNpb25FbmFibGVkKSB7XG4gICAgICAgIGlmICghbWVzc2FnZS5leHQpIHsgbWVzc2FnZS5leHQgPSB7fTsgfVxuXG4gICAgICAgIHZhciByZXBsYXlGcm9tTWFwID0ge307XG4gICAgICAgIHJlcGxheUZyb21NYXBbX2NoYW5uZWxdID0gX3JlcGxheTtcblxuICAgICAgICAvLyBhZGQgXCJleHQgOiB7IFwicmVwbGF5XCIgOiB7IENIQU5ORUwgOiBSRVBMQVlfVkFMVUUgfX1cIiB0byBzdWJzY3JpYmUgbWVzc2FnZVxuICAgICAgICBtZXNzYWdlLmV4dFtSRVBMQVlfRlJPTV9LRVldID0gcmVwbGF5RnJvbU1hcDtcbiAgICAgIH1cbiAgICB9XG4gICAgY2FsbGJhY2sobWVzc2FnZSk7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbWluZ0V4dGVuc2lvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/api/streaming-extension.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/api/streaming-extension.js":
/*!*************************************************************!*\
  !*** ./node_modules/jsforce/lib/api/streaming-extension.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("/**\n * Faye Client extensions: https://faye.jcoglan.com/browser/extensions.html\n *\n * For use with Streaming.prototype.createClient()\n**/\nvar StreamingExtension = {};\n\n/**\n * Constructor for an auth failure detector extension\n *\n * Based on new feature released with Salesforce Spring '18:\n * https://releasenotes.docs.salesforce.com/en-us/spring18/release-notes/rn_messaging_cometd_auth_validation.htm?edition=&impact=\n *\n * Example triggering error message:\n *\n * ```\n * {\n *   \"ext\":{\n *     \"sfdc\":{\"failureReason\":\"401::Authentication invalid\"},\n *     \"replay\":true},\n *   \"advice\":{\"reconnect\":\"none\"},\n *   \"channel\":\"/meta/handshake\",\n *   \"error\":\"403::Handshake denied\",\n *   \"successful\":false\n * }\n * ```\n *\n * Example usage:\n *\n * ```javascript\n * const conn = new jsforce.Connection({  });\n * \n * const channel = \"/event/My_Event__e\";\n * \n * // Exit the Node process when auth fails\n * const exitCallback = () => process.exit(1);\n * const authFailureExt = new jsforce.StreamingExtension.AuthFailure(exitCallback);\n * \n * const fayeClient = conn.streaming.createClient([ authFailureExt ]);\n * \n * const subscription = fayeClient.subscribe(channel, data => {\n *   console.log('topic received data', data);\n * });\n * \n * subscription.cancel();\n * ```\n *\n * @param {Function} failureCallback - Invoked when authentication becomes invalid\n */\nStreamingExtension.AuthFailure = function(failureCallback) {\n  this.incoming = function(message, callback) {\n    if (\n      (message.channel === '/meta/connect' ||\n        message.channel === '/meta/handshake')\n      && message.advice\n      && message.advice.reconnect == 'none'\n    ) {\n      failureCallback(message);\n    } else {\n      callback(message);\n    }\n  }\n};\n\n/**\n * Constructor for a durable streaming replay extension\n *\n * Modified from original Salesforce demo source code:\n * https://github.com/developerforce/SalesforceDurableStreamingDemo/blob/3d4a56eac956f744ad6c22e6a8141b6feb57abb9/staticresources/cometdReplayExtension.resource\n * \n * Example usage:\n *\n * ```javascript\n * const conn = new jsforce.Connection({  });\n * \n * const channel = \"/event/My_Event__e\";\n * const replayId = -2; // -2 is all retained events\n * \n * const replayExt = new jsforce.StreamingExtension.Replay(channel, replayId);\n * \n * const fayeClient = conn.streaming.createClient([ replayExt ]);\n * \n * const subscription = fayeClient.subscribe(channel, data => {\n *   console.log('topic received data', data);\n * });\n * \n * subscription.cancel();\n * ```\n */\nStreamingExtension.Replay = function(channel, replayId) {\n  var REPLAY_FROM_KEY = \"replay\";\n  \n  var _extensionEnabled = replayId != null ? true : false;\n  var _replay = replayId;\n  var _channel = channel;\n\n  this.setExtensionEnabled = function(extensionEnabled) {\n    _extensionEnabled = extensionEnabled;\n  }\n\n  this.setReplay = function (replay) {\n    _replay = parseInt(replay, 10);\n  }\n\n  this.setChannel = function(channel) {\n    _channel = channel;\n  }\n\n  this.incoming = function(message, callback) {\n    if (message.channel === '/meta/handshake') {\n      if (message.ext && message.ext[REPLAY_FROM_KEY] == true) {\n        _extensionEnabled = true;\n      }\n    } else if (message.channel === _channel && message.data && message.data.event && message.data.event.replayId) {\n      _replay = message.data.event.replayId;\n    }\n    callback(message);\n  }\n  \n  this.outgoing = function(message, callback) {\n    if (message.channel === '/meta/subscribe' && message.subscription === _channel) {\n      if (_extensionEnabled) {\n        if (!message.ext) { message.ext = {}; }\n\n        var replayFromMap = {};\n        replayFromMap[_channel] = _replay;\n\n        // add \"ext : { \"replay\" : { CHANNEL : REPLAY_VALUE }}\" to subscribe message\n        message.ext[REPLAY_FROM_KEY] = replayFromMap;\n      }\n    }\n    callback(message);\n  };\n};\n\nmodule.exports = StreamingExtension;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL3N0cmVhbWluZy1leHRlbnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhDQUE4QztBQUM3RCxxQkFBcUI7QUFDckIsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEdBQUc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsR0FBRztBQUM1QztBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQSx3QkFBd0IsYUFBYSx5QkFBeUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvc3RyZWFtaW5nLWV4dGVuc2lvbi5qcz8yNmE0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRmF5ZSBDbGllbnQgZXh0ZW5zaW9uczogaHR0cHM6Ly9mYXllLmpjb2dsYW4uY29tL2Jyb3dzZXIvZXh0ZW5zaW9ucy5odG1sXG4gKlxuICogRm9yIHVzZSB3aXRoIFN0cmVhbWluZy5wcm90b3R5cGUuY3JlYXRlQ2xpZW50KClcbioqL1xudmFyIFN0cmVhbWluZ0V4dGVuc2lvbiA9IHt9O1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIGZvciBhbiBhdXRoIGZhaWx1cmUgZGV0ZWN0b3IgZXh0ZW5zaW9uXG4gKlxuICogQmFzZWQgb24gbmV3IGZlYXR1cmUgcmVsZWFzZWQgd2l0aCBTYWxlc2ZvcmNlIFNwcmluZyAnMTg6XG4gKiBodHRwczovL3JlbGVhc2Vub3Rlcy5kb2NzLnNhbGVzZm9yY2UuY29tL2VuLXVzL3NwcmluZzE4L3JlbGVhc2Utbm90ZXMvcm5fbWVzc2FnaW5nX2NvbWV0ZF9hdXRoX3ZhbGlkYXRpb24uaHRtP2VkaXRpb249JmltcGFjdD1cbiAqXG4gKiBFeGFtcGxlIHRyaWdnZXJpbmcgZXJyb3IgbWVzc2FnZTpcbiAqXG4gKiBgYGBcbiAqIHtcbiAqICAgXCJleHRcIjp7XG4gKiAgICAgXCJzZmRjXCI6e1wiZmFpbHVyZVJlYXNvblwiOlwiNDAxOjpBdXRoZW50aWNhdGlvbiBpbnZhbGlkXCJ9LFxuICogICAgIFwicmVwbGF5XCI6dHJ1ZX0sXG4gKiAgIFwiYWR2aWNlXCI6e1wicmVjb25uZWN0XCI6XCJub25lXCJ9LFxuICogICBcImNoYW5uZWxcIjpcIi9tZXRhL2hhbmRzaGFrZVwiLFxuICogICBcImVycm9yXCI6XCI0MDM6OkhhbmRzaGFrZSBkZW5pZWRcIixcbiAqICAgXCJzdWNjZXNzZnVsXCI6ZmFsc2VcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEV4YW1wbGUgdXNhZ2U6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgY29ubiA9IG5ldyBqc2ZvcmNlLkNvbm5lY3Rpb24oeyDigKYgfSk7XG4gKiBcbiAqIGNvbnN0IGNoYW5uZWwgPSBcIi9ldmVudC9NeV9FdmVudF9fZVwiO1xuICogXG4gKiAvLyBFeGl0IHRoZSBOb2RlIHByb2Nlc3Mgd2hlbiBhdXRoIGZhaWxzXG4gKiBjb25zdCBleGl0Q2FsbGJhY2sgPSAoKSA9PiBwcm9jZXNzLmV4aXQoMSk7XG4gKiBjb25zdCBhdXRoRmFpbHVyZUV4dCA9IG5ldyBqc2ZvcmNlLlN0cmVhbWluZ0V4dGVuc2lvbi5BdXRoRmFpbHVyZShleGl0Q2FsbGJhY2spO1xuICogXG4gKiBjb25zdCBmYXllQ2xpZW50ID0gY29ubi5zdHJlYW1pbmcuY3JlYXRlQ2xpZW50KFsgYXV0aEZhaWx1cmVFeHQgXSk7XG4gKiBcbiAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGZheWVDbGllbnQuc3Vic2NyaWJlKGNoYW5uZWwsIGRhdGEgPT4ge1xuICogICBjb25zb2xlLmxvZygndG9waWMgcmVjZWl2ZWQgZGF0YScsIGRhdGEpO1xuICogfSk7XG4gKiBcbiAqIHN1YnNjcmlwdGlvbi5jYW5jZWwoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZhaWx1cmVDYWxsYmFjayAtIEludm9rZWQgd2hlbiBhdXRoZW50aWNhdGlvbiBiZWNvbWVzIGludmFsaWRcbiAqL1xuU3RyZWFtaW5nRXh0ZW5zaW9uLkF1dGhGYWlsdXJlID0gZnVuY3Rpb24oZmFpbHVyZUNhbGxiYWNrKSB7XG4gIHRoaXMuaW5jb21pbmcgPSBmdW5jdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIGlmIChcbiAgICAgIChtZXNzYWdlLmNoYW5uZWwgPT09ICcvbWV0YS9jb25uZWN0JyB8fFxuICAgICAgICBtZXNzYWdlLmNoYW5uZWwgPT09ICcvbWV0YS9oYW5kc2hha2UnKVxuICAgICAgJiYgbWVzc2FnZS5hZHZpY2VcbiAgICAgICYmIG1lc3NhZ2UuYWR2aWNlLnJlY29ubmVjdCA9PSAnbm9uZSdcbiAgICApIHtcbiAgICAgIGZhaWx1cmVDYWxsYmFjayhtZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sobWVzc2FnZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIGZvciBhIGR1cmFibGUgc3RyZWFtaW5nIHJlcGxheSBleHRlbnNpb25cbiAqXG4gKiBNb2RpZmllZCBmcm9tIG9yaWdpbmFsIFNhbGVzZm9yY2UgZGVtbyBzb3VyY2UgY29kZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9wZXJmb3JjZS9TYWxlc2ZvcmNlRHVyYWJsZVN0cmVhbWluZ0RlbW8vYmxvYi8zZDRhNTZlYWM5NTZmNzQ0YWQ2YzIyZTZhODE0MWI2ZmViNTdhYmI5L3N0YXRpY3Jlc291cmNlcy9jb21ldGRSZXBsYXlFeHRlbnNpb24ucmVzb3VyY2VcbiAqIFxuICogRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBjb25uID0gbmV3IGpzZm9yY2UuQ29ubmVjdGlvbih7IOKApiB9KTtcbiAqIFxuICogY29uc3QgY2hhbm5lbCA9IFwiL2V2ZW50L015X0V2ZW50X19lXCI7XG4gKiBjb25zdCByZXBsYXlJZCA9IC0yOyAvLyAtMiBpcyBhbGwgcmV0YWluZWQgZXZlbnRzXG4gKiBcbiAqIGNvbnN0IHJlcGxheUV4dCA9IG5ldyBqc2ZvcmNlLlN0cmVhbWluZ0V4dGVuc2lvbi5SZXBsYXkoY2hhbm5lbCwgcmVwbGF5SWQpO1xuICogXG4gKiBjb25zdCBmYXllQ2xpZW50ID0gY29ubi5zdHJlYW1pbmcuY3JlYXRlQ2xpZW50KFsgcmVwbGF5RXh0IF0pO1xuICogXG4gKiBjb25zdCBzdWJzY3JpcHRpb24gPSBmYXllQ2xpZW50LnN1YnNjcmliZShjaGFubmVsLCBkYXRhID0+IHtcbiAqICAgY29uc29sZS5sb2coJ3RvcGljIHJlY2VpdmVkIGRhdGEnLCBkYXRhKTtcbiAqIH0pO1xuICogXG4gKiBzdWJzY3JpcHRpb24uY2FuY2VsKCk7XG4gKiBgYGBcbiAqL1xuU3RyZWFtaW5nRXh0ZW5zaW9uLlJlcGxheSA9IGZ1bmN0aW9uKGNoYW5uZWwsIHJlcGxheUlkKSB7XG4gIHZhciBSRVBMQVlfRlJPTV9LRVkgPSBcInJlcGxheVwiO1xuICBcbiAgdmFyIF9leHRlbnNpb25FbmFibGVkID0gcmVwbGF5SWQgIT0gbnVsbCA/IHRydWUgOiBmYWxzZTtcbiAgdmFyIF9yZXBsYXkgPSByZXBsYXlJZDtcbiAgdmFyIF9jaGFubmVsID0gY2hhbm5lbDtcblxuICB0aGlzLnNldEV4dGVuc2lvbkVuYWJsZWQgPSBmdW5jdGlvbihleHRlbnNpb25FbmFibGVkKSB7XG4gICAgX2V4dGVuc2lvbkVuYWJsZWQgPSBleHRlbnNpb25FbmFibGVkO1xuICB9XG5cbiAgdGhpcy5zZXRSZXBsYXkgPSBmdW5jdGlvbiAocmVwbGF5KSB7XG4gICAgX3JlcGxheSA9IHBhcnNlSW50KHJlcGxheSwgMTApO1xuICB9XG5cbiAgdGhpcy5zZXRDaGFubmVsID0gZnVuY3Rpb24oY2hhbm5lbCkge1xuICAgIF9jaGFubmVsID0gY2hhbm5lbDtcbiAgfVxuXG4gIHRoaXMuaW5jb21pbmcgPSBmdW5jdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIGlmIChtZXNzYWdlLmNoYW5uZWwgPT09ICcvbWV0YS9oYW5kc2hha2UnKSB7XG4gICAgICBpZiAobWVzc2FnZS5leHQgJiYgbWVzc2FnZS5leHRbUkVQTEFZX0ZST01fS0VZXSA9PSB0cnVlKSB7XG4gICAgICAgIF9leHRlbnNpb25FbmFibGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UuY2hhbm5lbCA9PT0gX2NoYW5uZWwgJiYgbWVzc2FnZS5kYXRhICYmIG1lc3NhZ2UuZGF0YS5ldmVudCAmJiBtZXNzYWdlLmRhdGEuZXZlbnQucmVwbGF5SWQpIHtcbiAgICAgIF9yZXBsYXkgPSBtZXNzYWdlLmRhdGEuZXZlbnQucmVwbGF5SWQ7XG4gICAgfVxuICAgIGNhbGxiYWNrKG1lc3NhZ2UpO1xuICB9XG4gIFxuICB0aGlzLm91dGdvaW5nID0gZnVuY3Rpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBpZiAobWVzc2FnZS5jaGFubmVsID09PSAnL21ldGEvc3Vic2NyaWJlJyAmJiBtZXNzYWdlLnN1YnNjcmlwdGlvbiA9PT0gX2NoYW5uZWwpIHtcbiAgICAgIGlmIChfZXh0ZW5zaW9uRW5hYmxlZCkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UuZXh0KSB7IG1lc3NhZ2UuZXh0ID0ge307IH1cblxuICAgICAgICB2YXIgcmVwbGF5RnJvbU1hcCA9IHt9O1xuICAgICAgICByZXBsYXlGcm9tTWFwW19jaGFubmVsXSA9IF9yZXBsYXk7XG5cbiAgICAgICAgLy8gYWRkIFwiZXh0IDogeyBcInJlcGxheVwiIDogeyBDSEFOTkVMIDogUkVQTEFZX1ZBTFVFIH19XCIgdG8gc3Vic2NyaWJlIG1lc3NhZ2VcbiAgICAgICAgbWVzc2FnZS5leHRbUkVQTEFZX0ZST01fS0VZXSA9IHJlcGxheUZyb21NYXA7XG4gICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKG1lc3NhZ2UpO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1pbmdFeHRlbnNpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/api/streaming-extension.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/api/streaming.js":
/*!***************************************************!*\
  !*** ./node_modules/jsforce/lib/api/streaming.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages Streaming APIs\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar events = __webpack_require__(/*! events */ \"events\"),\n    inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\"),\n    _ = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    Faye   = __webpack_require__(/*! faye */ \"(action-browser)/./node_modules/faye/src/faye_node.js\"),\n    StreamingExtension = __webpack_require__(/*! ./streaming-extension */ \"(action-browser)/./node_modules/jsforce/lib/api/streaming-extension.js\"),\n    jsforce = __webpack_require__(/*! ../core */ \"(action-browser)/./node_modules/jsforce/lib/core.js\");\n\n/**\n * Streaming API topic class\n *\n * @class Streaming~Topic\n * @param {Streaming} steaming - Streaming API object\n * @param {String} name - Topic name\n */\nvar Topic = function(streaming, name) {\n  this._streaming = streaming;\n  this.name = name;\n};\n\n/**\n * @typedef {Object} Streaming~StreamingMessage\n * @prop {Object} event\n * @prop {Object} event.type - Event type\n * @prop {Record} sobject - Record information\n */\n/**\n * Subscribe listener to topic\n *\n * @method Streaming~Topic#subscribe\n * @param {Callback.<Streaming~StreamingMesasge>} listener - Streaming message listener\n * @returns {Subscription} - Faye subscription object\n */\nTopic.prototype.subscribe = function(listener) {\n  return this._streaming.subscribe(this.name, listener);\n};\n\n/**\n * Unsubscribe listener from topic\n *\n * @method Streaming~Topic#unsubscribe\n * @param {Callback.<Streaming~StreamingMesasge>} listener - Streaming message listener\n * @returns {Streaming~Topic}\n */\nTopic.prototype.unsubscribe = function(listener) {\n  this._streaming.unsubscribe(this.name, listener);\n  return this;\n};\n\n/*--------------------------------------------*/\n\n/**\n * Streaming API Generic Streaming Channel\n *\n * @class Streaming~Channel\n * @param {Streaming} steaming - Streaming API object\n * @param {String} name - Channel name (starts with \"/u/\")\n */\nvar Channel = function(streaming, name) {\n  this._streaming = streaming;\n  this._name = name;\n};\n\n/**\n * Subscribe to channel\n *\n * @param {Callback.<Streaming~StreamingMessage>} listener - Streaming message listener\n * @returns {Subscription} - Faye subscription object\n */\nChannel.prototype.subscribe = function(listener) {\n  return this._streaming.subscribe(this._name, listener);\n};\n\nChannel.prototype.unsubscribe = function(listener) {\n  this._streaming.unsubscribe(this._name, listener);\n  return this;\n};\n\nChannel.prototype.push = function(events, callback) {\n  var isArray = _.isArray(events);\n  events = isArray ? events : [ events ];\n  var conn = this._streaming._conn;\n  if (!this._id) {\n    this._id = conn.sobject('StreamingChannel').findOne({ Name: this._name }, 'Id')\n      .then(function(rec) { return rec.Id });\n  }\n  return this._id.then(function(id) {\n    var channelUrl = '/sobjects/StreamingChannel/' + id + '/push';\n    return conn.requestPost(channelUrl, { pushEvents: events });\n  }).then(function(rets) {\n    return isArray ? rets : rets[0];\n  }).thenCall(callback);\n};\n\n/*--------------------------------------------*/\n\n/**\n * Streaming API class\n *\n * @class\n * @extends events.EventEmitter\n * @param {Connection} conn - Connection object\n */\nvar Streaming = function(conn) {\n  this._conn = conn;\n};\n\ninherits(Streaming, events.EventEmitter);\n\n/** @private **/\nStreaming.prototype._createClient = function(forChannelName, extensions) {\n  // forChannelName is advisory, for an API workaround. It does not restrict or select the channel.\n  var needsReplayFix = typeof forChannelName === 'string' && forChannelName.indexOf('/u/') === 0;\n  var endpointUrl = [\n    this._conn.instanceUrl,\n    // special endpoint \"/cometd/replay/xx.x\" is only available in 36.0.\n    // See https://releasenotes.docs.salesforce.com/en-us/summer16/release-notes/rn_api_streaming_classic_replay.htm\n    \"cometd\" + (needsReplayFix === true && this._conn.version === \"36.0\" ? \"/replay\" : \"\"),\n    this._conn.version\n  ].join('/');\n  var fayeClient = new Faye.Client(endpointUrl, {});\n  fayeClient.setHeader('Authorization', 'OAuth '+this._conn.accessToken);\n  if (extensions instanceof Array) {\n    extensions.forEach(function(extension) {\n      fayeClient.addExtension(extension);\n    });\n  }\n  if (fayeClient._dispatcher.getConnectionTypes().indexOf('callback-polling') === -1) {\n    // prevent streaming API server error\n    fayeClient._dispatcher.selectTransport('long-polling');\n    fayeClient._dispatcher._transport.batching = false;\n  }\n  return fayeClient;\n};\n\n/** @private **/\nStreaming.prototype._getFayeClient = function(channelName) {\n  var isGeneric = channelName.indexOf('/u/') === 0;\n  var clientType = isGeneric ? 'generic' : 'pushTopic';\n  if (!this._fayeClients || !this._fayeClients[clientType]) {\n    this._fayeClients = this._fayeClients || {};\n    this._fayeClients[clientType] = this._createClient(channelName);\n  }\n  return this._fayeClients[clientType];\n};\n\n\n/**\n * Get named topic\n *\n * @param {String} name - Topic name\n * @returns {Streaming~Topic}\n */\nStreaming.prototype.topic = function(name) {\n  this._topics = this._topics || {};\n  var topic = this._topics[name] =\n    this._topics[name] || new Topic(this, name);\n  return topic;\n};\n\n/**\n * Get Channel for Id\n * @param {String} channelId - Id of StreamingChannel object\n * @returns {Streaming~Channel}\n */\nStreaming.prototype.channel = function(channelId) {\n  return new Channel(this, channelId);\n};\n\n/**\n * Subscribe topic/channel\n *\n * @param {String} name - Topic name\n * @param {Callback.<Streaming~StreamingMessage>} listener - Streaming message listener\n * @returns {Subscription} - Faye subscription object\n */\nStreaming.prototype.subscribe = function(name, listener) {\n  var channelName = name.indexOf('/') === 0 ? name : '/topic/' + name;\n  var fayeClient = this._getFayeClient(channelName);\n  return fayeClient.subscribe(channelName, listener);\n};\n\n/**\n * Unsubscribe topic\n *\n * @param {String} name - Topic name\n * @param {Callback.<Streaming~StreamingMessage>} listener - Streaming message listener\n * @returns {Streaming}\n */\nStreaming.prototype.unsubscribe = function(name, listener) {\n  var channelName = name.indexOf('/') === 0 ? name : '/topic/' + name;\n  var fayeClient = this._getFayeClient(channelName);\n  fayeClient.unsubscribe(channelName, listener);\n  return this;\n};\n\n\n/**\n * Create a Streaming client, optionally with extensions\n *\n * See Faye docs for implementation details: https://faye.jcoglan.com/browser/extensions.html\n *\n * Example usage:\n * \n * ```javascript\n * // Establish a Salesforce connection. (Details elided)\n * const conn = new jsforce.Connection({  });\n * \n * const fayeClient = conn.streaming.createClient();\n * \n * const subscription = fayeClient.subscribe(channel, data => {\n *   console.log('topic received data', data);\n * });\n * \n * subscription.cancel();\n * ```\n * \n * Example with extensions, using Replay & Auth Failure extensions in a server-side Node.js app:\n * \n * ```javascript\n * // Establish a Salesforce connection. (Details elided)\n * const conn = new jsforce.Connection({  });\n * \n * const channel = \"/event/My_Event__e\";\n * const replayId = -2; // -2 is all retained events\n * \n * const exitCallback = () => process.exit(1);\n * const authFailureExt = new jsforce.StreamingExtension.AuthFailure(exitCallback);\n * \n * const replayExt = new jsforce.StreamingExtension.Replay(channel, replayId);\n * \n * const fayeClient = conn.streaming.createClient([\n *   authFailureExt,\n *   replayExt\n * ]);\n * \n * const subscription = fayeClient.subscribe(channel, data => {\n *   console.log('topic received data', data);\n * });\n * \n * subscription.cancel();\n * ```\n * \n * @param {Array} Extensions - Optional, extensions to apply to the Faye client\n * @returns {FayeClient} - Faye client object\n */\nStreaming.prototype.createClient = function(extensions) {\n  return this._createClient(null, extensions);\n};\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.streaming = new Streaming(conn);\n});\n\n/*\n * \n */\njsforce.StreamingExtension = StreamingExtension;\n\nmodule.exports = Streaming;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvc3RyZWFtaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixlQUFlLG1CQUFPLENBQUMsc0VBQVU7QUFDakMsUUFBUSxtQkFBTyxDQUFDLG1FQUFhO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxtRUFBTTtBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQyxxR0FBdUI7QUFDeEQsY0FBYyxtQkFBTyxDQUFDLG9FQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQkFBb0I7QUFDOUQsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVDQUF1QztBQUNsRCxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVDQUF1QztBQUNsRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxHQUFHO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxHQUFHO0FBQzVDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2FwaS9zdHJlYW1pbmcuanM/OTc5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIE1hbmFnZXMgU3RyZWFtaW5nIEFQSXNcbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpLFxuICAgIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKSxcbiAgICBfID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKSxcbiAgICBGYXllICAgPSByZXF1aXJlKCdmYXllJyksXG4gICAgU3RyZWFtaW5nRXh0ZW5zaW9uID0gcmVxdWlyZSgnLi9zdHJlYW1pbmctZXh0ZW5zaW9uJyksXG4gICAganNmb3JjZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuLyoqXG4gKiBTdHJlYW1pbmcgQVBJIHRvcGljIGNsYXNzXG4gKlxuICogQGNsYXNzIFN0cmVhbWluZ35Ub3BpY1xuICogQHBhcmFtIHtTdHJlYW1pbmd9IHN0ZWFtaW5nIC0gU3RyZWFtaW5nIEFQSSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVG9waWMgbmFtZVxuICovXG52YXIgVG9waWMgPSBmdW5jdGlvbihzdHJlYW1pbmcsIG5hbWUpIHtcbiAgdGhpcy5fc3RyZWFtaW5nID0gc3RyZWFtaW5nO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdHJlYW1pbmd+U3RyZWFtaW5nTWVzc2FnZVxuICogQHByb3Age09iamVjdH0gZXZlbnRcbiAqIEBwcm9wIHtPYmplY3R9IGV2ZW50LnR5cGUgLSBFdmVudCB0eXBlXG4gKiBAcHJvcCB7UmVjb3JkfSBzb2JqZWN0IC0gUmVjb3JkIGluZm9ybWF0aW9uXG4gKi9cbi8qKlxuICogU3Vic2NyaWJlIGxpc3RlbmVyIHRvIHRvcGljXG4gKlxuICogQG1ldGhvZCBTdHJlYW1pbmd+VG9waWMjc3Vic2NyaWJlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxTdHJlYW1pbmd+U3RyZWFtaW5nTWVzYXNnZT59IGxpc3RlbmVyIC0gU3RyZWFtaW5nIG1lc3NhZ2UgbGlzdGVuZXJcbiAqIEByZXR1cm5zIHtTdWJzY3JpcHRpb259IC0gRmF5ZSBzdWJzY3JpcHRpb24gb2JqZWN0XG4gKi9cblRvcGljLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICByZXR1cm4gdGhpcy5fc3RyZWFtaW5nLnN1YnNjcmliZSh0aGlzLm5hbWUsIGxpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgbGlzdGVuZXIgZnJvbSB0b3BpY1xuICpcbiAqIEBtZXRob2QgU3RyZWFtaW5nflRvcGljI3Vuc3Vic2NyaWJlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxTdHJlYW1pbmd+U3RyZWFtaW5nTWVzYXNnZT59IGxpc3RlbmVyIC0gU3RyZWFtaW5nIG1lc3NhZ2UgbGlzdGVuZXJcbiAqIEByZXR1cm5zIHtTdHJlYW1pbmd+VG9waWN9XG4gKi9cblRvcGljLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gIHRoaXMuX3N0cmVhbWluZy51bnN1YnNjcmliZSh0aGlzLm5hbWUsIGxpc3RlbmVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBTdHJlYW1pbmcgQVBJIEdlbmVyaWMgU3RyZWFtaW5nIENoYW5uZWxcbiAqXG4gKiBAY2xhc3MgU3RyZWFtaW5nfkNoYW5uZWxcbiAqIEBwYXJhbSB7U3RyZWFtaW5nfSBzdGVhbWluZyAtIFN0cmVhbWluZyBBUEkgb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIENoYW5uZWwgbmFtZSAoc3RhcnRzIHdpdGggXCIvdS9cIilcbiAqL1xudmFyIENoYW5uZWwgPSBmdW5jdGlvbihzdHJlYW1pbmcsIG5hbWUpIHtcbiAgdGhpcy5fc3RyZWFtaW5nID0gc3RyZWFtaW5nO1xuICB0aGlzLl9uYW1lID0gbmFtZTtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIGNoYW5uZWxcbiAqXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxTdHJlYW1pbmd+U3RyZWFtaW5nTWVzc2FnZT59IGxpc3RlbmVyIC0gU3RyZWFtaW5nIG1lc3NhZ2UgbGlzdGVuZXJcbiAqIEByZXR1cm5zIHtTdWJzY3JpcHRpb259IC0gRmF5ZSBzdWJzY3JpcHRpb24gb2JqZWN0XG4gKi9cbkNoYW5uZWwucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gIHJldHVybiB0aGlzLl9zdHJlYW1pbmcuc3Vic2NyaWJlKHRoaXMuX25hbWUsIGxpc3RlbmVyKTtcbn07XG5cbkNoYW5uZWwucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgdGhpcy5fc3RyZWFtaW5nLnVuc3Vic2NyaWJlKHRoaXMuX25hbWUsIGxpc3RlbmVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5DaGFubmVsLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZXZlbnRzLCBjYWxsYmFjaykge1xuICB2YXIgaXNBcnJheSA9IF8uaXNBcnJheShldmVudHMpO1xuICBldmVudHMgPSBpc0FycmF5ID8gZXZlbnRzIDogWyBldmVudHMgXTtcbiAgdmFyIGNvbm4gPSB0aGlzLl9zdHJlYW1pbmcuX2Nvbm47XG4gIGlmICghdGhpcy5faWQpIHtcbiAgICB0aGlzLl9pZCA9IGNvbm4uc29iamVjdCgnU3RyZWFtaW5nQ2hhbm5lbCcpLmZpbmRPbmUoeyBOYW1lOiB0aGlzLl9uYW1lIH0sICdJZCcpXG4gICAgICAudGhlbihmdW5jdGlvbihyZWMpIHsgcmV0dXJuIHJlYy5JZCB9KTtcbiAgfVxuICByZXR1cm4gdGhpcy5faWQudGhlbihmdW5jdGlvbihpZCkge1xuICAgIHZhciBjaGFubmVsVXJsID0gJy9zb2JqZWN0cy9TdHJlYW1pbmdDaGFubmVsLycgKyBpZCArICcvcHVzaCc7XG4gICAgcmV0dXJuIGNvbm4ucmVxdWVzdFBvc3QoY2hhbm5lbFVybCwgeyBwdXNoRXZlbnRzOiBldmVudHMgfSk7XG4gIH0pLnRoZW4oZnVuY3Rpb24ocmV0cykge1xuICAgIHJldHVybiBpc0FycmF5ID8gcmV0cyA6IHJldHNbMF07XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKipcbiAqIFN0cmVhbWluZyBBUEkgY2xhc3NcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXJcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiAtIENvbm5lY3Rpb24gb2JqZWN0XG4gKi9cbnZhciBTdHJlYW1pbmcgPSBmdW5jdGlvbihjb25uKSB7XG4gIHRoaXMuX2Nvbm4gPSBjb25uO1xufTtcblxuaW5oZXJpdHMoU3RyZWFtaW5nLCBldmVudHMuRXZlbnRFbWl0dGVyKTtcblxuLyoqIEBwcml2YXRlICoqL1xuU3RyZWFtaW5nLnByb3RvdHlwZS5fY3JlYXRlQ2xpZW50ID0gZnVuY3Rpb24oZm9yQ2hhbm5lbE5hbWUsIGV4dGVuc2lvbnMpIHtcbiAgLy8gZm9yQ2hhbm5lbE5hbWUgaXMgYWR2aXNvcnksIGZvciBhbiBBUEkgd29ya2Fyb3VuZC4gSXQgZG9lcyBub3QgcmVzdHJpY3Qgb3Igc2VsZWN0IHRoZSBjaGFubmVsLlxuICB2YXIgbmVlZHNSZXBsYXlGaXggPSB0eXBlb2YgZm9yQ2hhbm5lbE5hbWUgPT09ICdzdHJpbmcnICYmIGZvckNoYW5uZWxOYW1lLmluZGV4T2YoJy91LycpID09PSAwO1xuICB2YXIgZW5kcG9pbnRVcmwgPSBbXG4gICAgdGhpcy5fY29ubi5pbnN0YW5jZVVybCxcbiAgICAvLyBzcGVjaWFsIGVuZHBvaW50IFwiL2NvbWV0ZC9yZXBsYXkveHgueFwiIGlzIG9ubHkgYXZhaWxhYmxlIGluIDM2LjAuXG4gICAgLy8gU2VlIGh0dHBzOi8vcmVsZWFzZW5vdGVzLmRvY3Muc2FsZXNmb3JjZS5jb20vZW4tdXMvc3VtbWVyMTYvcmVsZWFzZS1ub3Rlcy9ybl9hcGlfc3RyZWFtaW5nX2NsYXNzaWNfcmVwbGF5Lmh0bVxuICAgIFwiY29tZXRkXCIgKyAobmVlZHNSZXBsYXlGaXggPT09IHRydWUgJiYgdGhpcy5fY29ubi52ZXJzaW9uID09PSBcIjM2LjBcIiA/IFwiL3JlcGxheVwiIDogXCJcIiksXG4gICAgdGhpcy5fY29ubi52ZXJzaW9uXG4gIF0uam9pbignLycpO1xuICB2YXIgZmF5ZUNsaWVudCA9IG5ldyBGYXllLkNsaWVudChlbmRwb2ludFVybCwge30pO1xuICBmYXllQ2xpZW50LnNldEhlYWRlcignQXV0aG9yaXphdGlvbicsICdPQXV0aCAnK3RoaXMuX2Nvbm4uYWNjZXNzVG9rZW4pO1xuICBpZiAoZXh0ZW5zaW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGV4dGVuc2lvbikge1xuICAgICAgZmF5ZUNsaWVudC5hZGRFeHRlbnNpb24oZXh0ZW5zaW9uKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoZmF5ZUNsaWVudC5fZGlzcGF0Y2hlci5nZXRDb25uZWN0aW9uVHlwZXMoKS5pbmRleE9mKCdjYWxsYmFjay1wb2xsaW5nJykgPT09IC0xKSB7XG4gICAgLy8gcHJldmVudCBzdHJlYW1pbmcgQVBJIHNlcnZlciBlcnJvclxuICAgIGZheWVDbGllbnQuX2Rpc3BhdGNoZXIuc2VsZWN0VHJhbnNwb3J0KCdsb25nLXBvbGxpbmcnKTtcbiAgICBmYXllQ2xpZW50Ll9kaXNwYXRjaGVyLl90cmFuc3BvcnQuYmF0Y2hpbmcgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gZmF5ZUNsaWVudDtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqKi9cblN0cmVhbWluZy5wcm90b3R5cGUuX2dldEZheWVDbGllbnQgPSBmdW5jdGlvbihjaGFubmVsTmFtZSkge1xuICB2YXIgaXNHZW5lcmljID0gY2hhbm5lbE5hbWUuaW5kZXhPZignL3UvJykgPT09IDA7XG4gIHZhciBjbGllbnRUeXBlID0gaXNHZW5lcmljID8gJ2dlbmVyaWMnIDogJ3B1c2hUb3BpYyc7XG4gIGlmICghdGhpcy5fZmF5ZUNsaWVudHMgfHwgIXRoaXMuX2ZheWVDbGllbnRzW2NsaWVudFR5cGVdKSB7XG4gICAgdGhpcy5fZmF5ZUNsaWVudHMgPSB0aGlzLl9mYXllQ2xpZW50cyB8fCB7fTtcbiAgICB0aGlzLl9mYXllQ2xpZW50c1tjbGllbnRUeXBlXSA9IHRoaXMuX2NyZWF0ZUNsaWVudChjaGFubmVsTmFtZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2ZheWVDbGllbnRzW2NsaWVudFR5cGVdO1xufTtcblxuXG4vKipcbiAqIEdldCBuYW1lZCB0b3BpY1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVG9waWMgbmFtZVxuICogQHJldHVybnMge1N0cmVhbWluZ35Ub3BpY31cbiAqL1xuU3RyZWFtaW5nLnByb3RvdHlwZS50b3BpYyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdGhpcy5fdG9waWNzID0gdGhpcy5fdG9waWNzIHx8IHt9O1xuICB2YXIgdG9waWMgPSB0aGlzLl90b3BpY3NbbmFtZV0gPVxuICAgIHRoaXMuX3RvcGljc1tuYW1lXSB8fCBuZXcgVG9waWModGhpcywgbmFtZSk7XG4gIHJldHVybiB0b3BpYztcbn07XG5cbi8qKlxuICogR2V0IENoYW5uZWwgZm9yIElkXG4gKiBAcGFyYW0ge1N0cmluZ30gY2hhbm5lbElkIC0gSWQgb2YgU3RyZWFtaW5nQ2hhbm5lbCBvYmplY3RcbiAqIEByZXR1cm5zIHtTdHJlYW1pbmd+Q2hhbm5lbH1cbiAqL1xuU3RyZWFtaW5nLnByb3RvdHlwZS5jaGFubmVsID0gZnVuY3Rpb24oY2hhbm5lbElkKSB7XG4gIHJldHVybiBuZXcgQ2hhbm5lbCh0aGlzLCBjaGFubmVsSWQpO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG9waWMvY2hhbm5lbFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVG9waWMgbmFtZVxuICogQHBhcmFtIHtDYWxsYmFjay48U3RyZWFtaW5nflN0cmVhbWluZ01lc3NhZ2U+fSBsaXN0ZW5lciAtIFN0cmVhbWluZyBtZXNzYWdlIGxpc3RlbmVyXG4gKiBAcmV0dXJucyB7U3Vic2NyaXB0aW9ufSAtIEZheWUgc3Vic2NyaXB0aW9uIG9iamVjdFxuICovXG5TdHJlYW1pbmcucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBjaGFubmVsTmFtZSA9IG5hbWUuaW5kZXhPZignLycpID09PSAwID8gbmFtZSA6ICcvdG9waWMvJyArIG5hbWU7XG4gIHZhciBmYXllQ2xpZW50ID0gdGhpcy5fZ2V0RmF5ZUNsaWVudChjaGFubmVsTmFtZSk7XG4gIHJldHVybiBmYXllQ2xpZW50LnN1YnNjcmliZShjaGFubmVsTmFtZSwgbGlzdGVuZXIpO1xufTtcblxuLyoqXG4gKiBVbnN1YnNjcmliZSB0b3BpY1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVG9waWMgbmFtZVxuICogQHBhcmFtIHtDYWxsYmFjay48U3RyZWFtaW5nflN0cmVhbWluZ01lc3NhZ2U+fSBsaXN0ZW5lciAtIFN0cmVhbWluZyBtZXNzYWdlIGxpc3RlbmVyXG4gKiBAcmV0dXJucyB7U3RyZWFtaW5nfVxuICovXG5TdHJlYW1pbmcucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGNoYW5uZWxOYW1lID0gbmFtZS5pbmRleE9mKCcvJykgPT09IDAgPyBuYW1lIDogJy90b3BpYy8nICsgbmFtZTtcbiAgdmFyIGZheWVDbGllbnQgPSB0aGlzLl9nZXRGYXllQ2xpZW50KGNoYW5uZWxOYW1lKTtcbiAgZmF5ZUNsaWVudC51bnN1YnNjcmliZShjaGFubmVsTmFtZSwgbGlzdGVuZXIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBTdHJlYW1pbmcgY2xpZW50LCBvcHRpb25hbGx5IHdpdGggZXh0ZW5zaW9uc1xuICpcbiAqIFNlZSBGYXllIGRvY3MgZm9yIGltcGxlbWVudGF0aW9uIGRldGFpbHM6IGh0dHBzOi8vZmF5ZS5qY29nbGFuLmNvbS9icm93c2VyL2V4dGVuc2lvbnMuaHRtbFxuICpcbiAqIEV4YW1wbGUgdXNhZ2U6XG4gKiBcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIEVzdGFibGlzaCBhIFNhbGVzZm9yY2UgY29ubmVjdGlvbi4gKERldGFpbHMgZWxpZGVkKVxuICogY29uc3QgY29ubiA9IG5ldyBqc2ZvcmNlLkNvbm5lY3Rpb24oeyDigKYgfSk7XG4gKiBcbiAqIGNvbnN0IGZheWVDbGllbnQgPSBjb25uLnN0cmVhbWluZy5jcmVhdGVDbGllbnQoKTtcbiAqIFxuICogY29uc3Qgc3Vic2NyaXB0aW9uID0gZmF5ZUNsaWVudC5zdWJzY3JpYmUoY2hhbm5lbCwgZGF0YSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCd0b3BpYyByZWNlaXZlZCBkYXRhJywgZGF0YSk7XG4gKiB9KTtcbiAqIFxuICogc3Vic2NyaXB0aW9uLmNhbmNlbCgpO1xuICogYGBgXG4gKiBcbiAqIEV4YW1wbGUgd2l0aCBleHRlbnNpb25zLCB1c2luZyBSZXBsYXkgJiBBdXRoIEZhaWx1cmUgZXh0ZW5zaW9ucyBpbiBhIHNlcnZlci1zaWRlIE5vZGUuanMgYXBwOlxuICogXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBFc3RhYmxpc2ggYSBTYWxlc2ZvcmNlIGNvbm5lY3Rpb24uIChEZXRhaWxzIGVsaWRlZClcbiAqIGNvbnN0IGNvbm4gPSBuZXcganNmb3JjZS5Db25uZWN0aW9uKHsg4oCmIH0pO1xuICogXG4gKiBjb25zdCBjaGFubmVsID0gXCIvZXZlbnQvTXlfRXZlbnRfX2VcIjtcbiAqIGNvbnN0IHJlcGxheUlkID0gLTI7IC8vIC0yIGlzIGFsbCByZXRhaW5lZCBldmVudHNcbiAqIFxuICogY29uc3QgZXhpdENhbGxiYWNrID0gKCkgPT4gcHJvY2Vzcy5leGl0KDEpO1xuICogY29uc3QgYXV0aEZhaWx1cmVFeHQgPSBuZXcganNmb3JjZS5TdHJlYW1pbmdFeHRlbnNpb24uQXV0aEZhaWx1cmUoZXhpdENhbGxiYWNrKTtcbiAqIFxuICogY29uc3QgcmVwbGF5RXh0ID0gbmV3IGpzZm9yY2UuU3RyZWFtaW5nRXh0ZW5zaW9uLlJlcGxheShjaGFubmVsLCByZXBsYXlJZCk7XG4gKiBcbiAqIGNvbnN0IGZheWVDbGllbnQgPSBjb25uLnN0cmVhbWluZy5jcmVhdGVDbGllbnQoW1xuICogICBhdXRoRmFpbHVyZUV4dCxcbiAqICAgcmVwbGF5RXh0XG4gKiBdKTtcbiAqIFxuICogY29uc3Qgc3Vic2NyaXB0aW9uID0gZmF5ZUNsaWVudC5zdWJzY3JpYmUoY2hhbm5lbCwgZGF0YSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCd0b3BpYyByZWNlaXZlZCBkYXRhJywgZGF0YSk7XG4gKiB9KTtcbiAqIFxuICogc3Vic2NyaXB0aW9uLmNhbmNlbCgpO1xuICogYGBgXG4gKiBcbiAqIEBwYXJhbSB7QXJyYXl9IEV4dGVuc2lvbnMgLSBPcHRpb25hbCwgZXh0ZW5zaW9ucyB0byBhcHBseSB0byB0aGUgRmF5ZSBjbGllbnRcbiAqIEByZXR1cm5zIHtGYXllQ2xpZW50fSAtIEZheWUgY2xpZW50IG9iamVjdFxuICovXG5TdHJlYW1pbmcucHJvdG90eXBlLmNyZWF0ZUNsaWVudCA9IGZ1bmN0aW9uKGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUNsaWVudChudWxsLCBleHRlbnNpb25zKTtcbn07XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLypcbiAqIFJlZ2lzdGVyIGhvb2sgaW4gY29ubmVjdGlvbiBpbnN0YW50aWF0aW9uIGZvciBkeW5hbWljYWxseSBhZGRpbmcgdGhpcyBBUEkgbW9kdWxlIGZlYXR1cmVzXG4gKi9cbmpzZm9yY2Uub24oJ2Nvbm5lY3Rpb246bmV3JywgZnVuY3Rpb24oY29ubikge1xuICBjb25uLnN0cmVhbWluZyA9IG5ldyBTdHJlYW1pbmcoY29ubik7XG59KTtcblxuLypcbiAqIFxuICovXG5qc2ZvcmNlLlN0cmVhbWluZ0V4dGVuc2lvbiA9IFN0cmVhbWluZ0V4dGVuc2lvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1pbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/api/streaming.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/api/streaming.js":
/*!***************************************************!*\
  !*** ./node_modules/jsforce/lib/api/streaming.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages Streaming APIs\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar events = __webpack_require__(/*! events */ \"events\"),\n    inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\"),\n    _ = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    Faye   = __webpack_require__(/*! faye */ \"(rsc)/./node_modules/faye/src/faye_node.js\"),\n    StreamingExtension = __webpack_require__(/*! ./streaming-extension */ \"(rsc)/./node_modules/jsforce/lib/api/streaming-extension.js\"),\n    jsforce = __webpack_require__(/*! ../core */ \"(rsc)/./node_modules/jsforce/lib/core.js\");\n\n/**\n * Streaming API topic class\n *\n * @class Streaming~Topic\n * @param {Streaming} steaming - Streaming API object\n * @param {String} name - Topic name\n */\nvar Topic = function(streaming, name) {\n  this._streaming = streaming;\n  this.name = name;\n};\n\n/**\n * @typedef {Object} Streaming~StreamingMessage\n * @prop {Object} event\n * @prop {Object} event.type - Event type\n * @prop {Record} sobject - Record information\n */\n/**\n * Subscribe listener to topic\n *\n * @method Streaming~Topic#subscribe\n * @param {Callback.<Streaming~StreamingMesasge>} listener - Streaming message listener\n * @returns {Subscription} - Faye subscription object\n */\nTopic.prototype.subscribe = function(listener) {\n  return this._streaming.subscribe(this.name, listener);\n};\n\n/**\n * Unsubscribe listener from topic\n *\n * @method Streaming~Topic#unsubscribe\n * @param {Callback.<Streaming~StreamingMesasge>} listener - Streaming message listener\n * @returns {Streaming~Topic}\n */\nTopic.prototype.unsubscribe = function(listener) {\n  this._streaming.unsubscribe(this.name, listener);\n  return this;\n};\n\n/*--------------------------------------------*/\n\n/**\n * Streaming API Generic Streaming Channel\n *\n * @class Streaming~Channel\n * @param {Streaming} steaming - Streaming API object\n * @param {String} name - Channel name (starts with \"/u/\")\n */\nvar Channel = function(streaming, name) {\n  this._streaming = streaming;\n  this._name = name;\n};\n\n/**\n * Subscribe to channel\n *\n * @param {Callback.<Streaming~StreamingMessage>} listener - Streaming message listener\n * @returns {Subscription} - Faye subscription object\n */\nChannel.prototype.subscribe = function(listener) {\n  return this._streaming.subscribe(this._name, listener);\n};\n\nChannel.prototype.unsubscribe = function(listener) {\n  this._streaming.unsubscribe(this._name, listener);\n  return this;\n};\n\nChannel.prototype.push = function(events, callback) {\n  var isArray = _.isArray(events);\n  events = isArray ? events : [ events ];\n  var conn = this._streaming._conn;\n  if (!this._id) {\n    this._id = conn.sobject('StreamingChannel').findOne({ Name: this._name }, 'Id')\n      .then(function(rec) { return rec.Id });\n  }\n  return this._id.then(function(id) {\n    var channelUrl = '/sobjects/StreamingChannel/' + id + '/push';\n    return conn.requestPost(channelUrl, { pushEvents: events });\n  }).then(function(rets) {\n    return isArray ? rets : rets[0];\n  }).thenCall(callback);\n};\n\n/*--------------------------------------------*/\n\n/**\n * Streaming API class\n *\n * @class\n * @extends events.EventEmitter\n * @param {Connection} conn - Connection object\n */\nvar Streaming = function(conn) {\n  this._conn = conn;\n};\n\ninherits(Streaming, events.EventEmitter);\n\n/** @private **/\nStreaming.prototype._createClient = function(forChannelName, extensions) {\n  // forChannelName is advisory, for an API workaround. It does not restrict or select the channel.\n  var needsReplayFix = typeof forChannelName === 'string' && forChannelName.indexOf('/u/') === 0;\n  var endpointUrl = [\n    this._conn.instanceUrl,\n    // special endpoint \"/cometd/replay/xx.x\" is only available in 36.0.\n    // See https://releasenotes.docs.salesforce.com/en-us/summer16/release-notes/rn_api_streaming_classic_replay.htm\n    \"cometd\" + (needsReplayFix === true && this._conn.version === \"36.0\" ? \"/replay\" : \"\"),\n    this._conn.version\n  ].join('/');\n  var fayeClient = new Faye.Client(endpointUrl, {});\n  fayeClient.setHeader('Authorization', 'OAuth '+this._conn.accessToken);\n  if (extensions instanceof Array) {\n    extensions.forEach(function(extension) {\n      fayeClient.addExtension(extension);\n    });\n  }\n  if (fayeClient._dispatcher.getConnectionTypes().indexOf('callback-polling') === -1) {\n    // prevent streaming API server error\n    fayeClient._dispatcher.selectTransport('long-polling');\n    fayeClient._dispatcher._transport.batching = false;\n  }\n  return fayeClient;\n};\n\n/** @private **/\nStreaming.prototype._getFayeClient = function(channelName) {\n  var isGeneric = channelName.indexOf('/u/') === 0;\n  var clientType = isGeneric ? 'generic' : 'pushTopic';\n  if (!this._fayeClients || !this._fayeClients[clientType]) {\n    this._fayeClients = this._fayeClients || {};\n    this._fayeClients[clientType] = this._createClient(channelName);\n  }\n  return this._fayeClients[clientType];\n};\n\n\n/**\n * Get named topic\n *\n * @param {String} name - Topic name\n * @returns {Streaming~Topic}\n */\nStreaming.prototype.topic = function(name) {\n  this._topics = this._topics || {};\n  var topic = this._topics[name] =\n    this._topics[name] || new Topic(this, name);\n  return topic;\n};\n\n/**\n * Get Channel for Id\n * @param {String} channelId - Id of StreamingChannel object\n * @returns {Streaming~Channel}\n */\nStreaming.prototype.channel = function(channelId) {\n  return new Channel(this, channelId);\n};\n\n/**\n * Subscribe topic/channel\n *\n * @param {String} name - Topic name\n * @param {Callback.<Streaming~StreamingMessage>} listener - Streaming message listener\n * @returns {Subscription} - Faye subscription object\n */\nStreaming.prototype.subscribe = function(name, listener) {\n  var channelName = name.indexOf('/') === 0 ? name : '/topic/' + name;\n  var fayeClient = this._getFayeClient(channelName);\n  return fayeClient.subscribe(channelName, listener);\n};\n\n/**\n * Unsubscribe topic\n *\n * @param {String} name - Topic name\n * @param {Callback.<Streaming~StreamingMessage>} listener - Streaming message listener\n * @returns {Streaming}\n */\nStreaming.prototype.unsubscribe = function(name, listener) {\n  var channelName = name.indexOf('/') === 0 ? name : '/topic/' + name;\n  var fayeClient = this._getFayeClient(channelName);\n  fayeClient.unsubscribe(channelName, listener);\n  return this;\n};\n\n\n/**\n * Create a Streaming client, optionally with extensions\n *\n * See Faye docs for implementation details: https://faye.jcoglan.com/browser/extensions.html\n *\n * Example usage:\n * \n * ```javascript\n * // Establish a Salesforce connection. (Details elided)\n * const conn = new jsforce.Connection({  });\n * \n * const fayeClient = conn.streaming.createClient();\n * \n * const subscription = fayeClient.subscribe(channel, data => {\n *   console.log('topic received data', data);\n * });\n * \n * subscription.cancel();\n * ```\n * \n * Example with extensions, using Replay & Auth Failure extensions in a server-side Node.js app:\n * \n * ```javascript\n * // Establish a Salesforce connection. (Details elided)\n * const conn = new jsforce.Connection({  });\n * \n * const channel = \"/event/My_Event__e\";\n * const replayId = -2; // -2 is all retained events\n * \n * const exitCallback = () => process.exit(1);\n * const authFailureExt = new jsforce.StreamingExtension.AuthFailure(exitCallback);\n * \n * const replayExt = new jsforce.StreamingExtension.Replay(channel, replayId);\n * \n * const fayeClient = conn.streaming.createClient([\n *   authFailureExt,\n *   replayExt\n * ]);\n * \n * const subscription = fayeClient.subscribe(channel, data => {\n *   console.log('topic received data', data);\n * });\n * \n * subscription.cancel();\n * ```\n * \n * @param {Array} Extensions - Optional, extensions to apply to the Faye client\n * @returns {FayeClient} - Faye client object\n */\nStreaming.prototype.createClient = function(extensions) {\n  return this._createClient(null, extensions);\n};\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.streaming = new Streaming(conn);\n});\n\n/*\n * \n */\njsforce.StreamingExtension = StreamingExtension;\n\nmodule.exports = Streaming;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL3N0cmVhbWluZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsZUFBZSxtQkFBTyxDQUFDLDJEQUFVO0FBQ2pDLFFBQVEsbUJBQU8sQ0FBQyx3REFBYTtBQUM3QixhQUFhLG1CQUFPLENBQUMsd0RBQU07QUFDM0IseUJBQXlCLG1CQUFPLENBQUMsMEZBQXVCO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQyx5REFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUNBQXVDO0FBQ2xELGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUNBQXVDO0FBQ2xELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUNBQXVDO0FBQ2xELGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGtCQUFrQjtBQUM1RSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlELEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1Q0FBdUM7QUFDbEQsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1Q0FBdUM7QUFDbEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsR0FBRztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsR0FBRztBQUM1QztBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvc3RyZWFtaW5nLmpzPzAzNmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBNYW5hZ2VzIFN0cmVhbWluZyBBUElzXG4gKiBAYXV0aG9yIFNoaW5pY2hpIFRvbWl0YSA8c2hpbmljaGkudG9taXRhQGdtYWlsLmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKSxcbiAgICBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgXyA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyksXG4gICAgRmF5ZSAgID0gcmVxdWlyZSgnZmF5ZScpLFxuICAgIFN0cmVhbWluZ0V4dGVuc2lvbiA9IHJlcXVpcmUoJy4vc3RyZWFtaW5nLWV4dGVuc2lvbicpLFxuICAgIGpzZm9yY2UgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbi8qKlxuICogU3RyZWFtaW5nIEFQSSB0b3BpYyBjbGFzc1xuICpcbiAqIEBjbGFzcyBTdHJlYW1pbmd+VG9waWNcbiAqIEBwYXJhbSB7U3RyZWFtaW5nfSBzdGVhbWluZyAtIFN0cmVhbWluZyBBUEkgb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRvcGljIG5hbWVcbiAqL1xudmFyIFRvcGljID0gZnVuY3Rpb24oc3RyZWFtaW5nLCBuYW1lKSB7XG4gIHRoaXMuX3N0cmVhbWluZyA9IHN0cmVhbWluZztcbiAgdGhpcy5uYW1lID0gbmFtZTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU3RyZWFtaW5nflN0cmVhbWluZ01lc3NhZ2VcbiAqIEBwcm9wIHtPYmplY3R9IGV2ZW50XG4gKiBAcHJvcCB7T2JqZWN0fSBldmVudC50eXBlIC0gRXZlbnQgdHlwZVxuICogQHByb3Age1JlY29yZH0gc29iamVjdCAtIFJlY29yZCBpbmZvcm1hdGlvblxuICovXG4vKipcbiAqIFN1YnNjcmliZSBsaXN0ZW5lciB0byB0b3BpY1xuICpcbiAqIEBtZXRob2QgU3RyZWFtaW5nflRvcGljI3N1YnNjcmliZVxuICogQHBhcmFtIHtDYWxsYmFjay48U3RyZWFtaW5nflN0cmVhbWluZ01lc2FzZ2U+fSBsaXN0ZW5lciAtIFN0cmVhbWluZyBtZXNzYWdlIGxpc3RlbmVyXG4gKiBAcmV0dXJucyB7U3Vic2NyaXB0aW9ufSAtIEZheWUgc3Vic2NyaXB0aW9uIG9iamVjdFxuICovXG5Ub3BpYy5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgcmV0dXJuIHRoaXMuX3N0cmVhbWluZy5zdWJzY3JpYmUodGhpcy5uYW1lLCBsaXN0ZW5lcik7XG59O1xuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGxpc3RlbmVyIGZyb20gdG9waWNcbiAqXG4gKiBAbWV0aG9kIFN0cmVhbWluZ35Ub3BpYyN1bnN1YnNjcmliZVxuICogQHBhcmFtIHtDYWxsYmFjay48U3RyZWFtaW5nflN0cmVhbWluZ01lc2FzZ2U+fSBsaXN0ZW5lciAtIFN0cmVhbWluZyBtZXNzYWdlIGxpc3RlbmVyXG4gKiBAcmV0dXJucyB7U3RyZWFtaW5nflRvcGljfVxuICovXG5Ub3BpYy5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICB0aGlzLl9zdHJlYW1pbmcudW5zdWJzY3JpYmUodGhpcy5uYW1lLCBsaXN0ZW5lcik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKlxuICogU3RyZWFtaW5nIEFQSSBHZW5lcmljIFN0cmVhbWluZyBDaGFubmVsXG4gKlxuICogQGNsYXNzIFN0cmVhbWluZ35DaGFubmVsXG4gKiBAcGFyYW0ge1N0cmVhbWluZ30gc3RlYW1pbmcgLSBTdHJlYW1pbmcgQVBJIG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBDaGFubmVsIG5hbWUgKHN0YXJ0cyB3aXRoIFwiL3UvXCIpXG4gKi9cbnZhciBDaGFubmVsID0gZnVuY3Rpb24oc3RyZWFtaW5nLCBuYW1lKSB7XG4gIHRoaXMuX3N0cmVhbWluZyA9IHN0cmVhbWluZztcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBjaGFubmVsXG4gKlxuICogQHBhcmFtIHtDYWxsYmFjay48U3RyZWFtaW5nflN0cmVhbWluZ01lc3NhZ2U+fSBsaXN0ZW5lciAtIFN0cmVhbWluZyBtZXNzYWdlIGxpc3RlbmVyXG4gKiBAcmV0dXJucyB7U3Vic2NyaXB0aW9ufSAtIEZheWUgc3Vic2NyaXB0aW9uIG9iamVjdFxuICovXG5DaGFubmVsLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICByZXR1cm4gdGhpcy5fc3RyZWFtaW5nLnN1YnNjcmliZSh0aGlzLl9uYW1lLCBsaXN0ZW5lcik7XG59O1xuXG5DaGFubmVsLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gIHRoaXMuX3N0cmVhbWluZy51bnN1YnNjcmliZSh0aGlzLl9uYW1lLCBsaXN0ZW5lcik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuQ2hhbm5lbC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGV2ZW50cywgY2FsbGJhY2spIHtcbiAgdmFyIGlzQXJyYXkgPSBfLmlzQXJyYXkoZXZlbnRzKTtcbiAgZXZlbnRzID0gaXNBcnJheSA/IGV2ZW50cyA6IFsgZXZlbnRzIF07XG4gIHZhciBjb25uID0gdGhpcy5fc3RyZWFtaW5nLl9jb25uO1xuICBpZiAoIXRoaXMuX2lkKSB7XG4gICAgdGhpcy5faWQgPSBjb25uLnNvYmplY3QoJ1N0cmVhbWluZ0NoYW5uZWwnKS5maW5kT25lKHsgTmFtZTogdGhpcy5fbmFtZSB9LCAnSWQnKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmVjKSB7IHJldHVybiByZWMuSWQgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2lkLnRoZW4oZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgY2hhbm5lbFVybCA9ICcvc29iamVjdHMvU3RyZWFtaW5nQ2hhbm5lbC8nICsgaWQgKyAnL3B1c2gnO1xuICAgIHJldHVybiBjb25uLnJlcXVlc3RQb3N0KGNoYW5uZWxVcmwsIHsgcHVzaEV2ZW50czogZXZlbnRzIH0pO1xuICB9KS50aGVuKGZ1bmN0aW9uKHJldHMpIHtcbiAgICByZXR1cm4gaXNBcnJheSA/IHJldHMgOiByZXRzWzBdO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBTdHJlYW1pbmcgQVBJIGNsYXNzXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gLSBDb25uZWN0aW9uIG9iamVjdFxuICovXG52YXIgU3RyZWFtaW5nID0gZnVuY3Rpb24oY29ubikge1xuICB0aGlzLl9jb25uID0gY29ubjtcbn07XG5cbmluaGVyaXRzKFN0cmVhbWluZywgZXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cbi8qKiBAcHJpdmF0ZSAqKi9cblN0cmVhbWluZy5wcm90b3R5cGUuX2NyZWF0ZUNsaWVudCA9IGZ1bmN0aW9uKGZvckNoYW5uZWxOYW1lLCBleHRlbnNpb25zKSB7XG4gIC8vIGZvckNoYW5uZWxOYW1lIGlzIGFkdmlzb3J5LCBmb3IgYW4gQVBJIHdvcmthcm91bmQuIEl0IGRvZXMgbm90IHJlc3RyaWN0IG9yIHNlbGVjdCB0aGUgY2hhbm5lbC5cbiAgdmFyIG5lZWRzUmVwbGF5Rml4ID0gdHlwZW9mIGZvckNoYW5uZWxOYW1lID09PSAnc3RyaW5nJyAmJiBmb3JDaGFubmVsTmFtZS5pbmRleE9mKCcvdS8nKSA9PT0gMDtcbiAgdmFyIGVuZHBvaW50VXJsID0gW1xuICAgIHRoaXMuX2Nvbm4uaW5zdGFuY2VVcmwsXG4gICAgLy8gc3BlY2lhbCBlbmRwb2ludCBcIi9jb21ldGQvcmVwbGF5L3h4LnhcIiBpcyBvbmx5IGF2YWlsYWJsZSBpbiAzNi4wLlxuICAgIC8vIFNlZSBodHRwczovL3JlbGVhc2Vub3Rlcy5kb2NzLnNhbGVzZm9yY2UuY29tL2VuLXVzL3N1bW1lcjE2L3JlbGVhc2Utbm90ZXMvcm5fYXBpX3N0cmVhbWluZ19jbGFzc2ljX3JlcGxheS5odG1cbiAgICBcImNvbWV0ZFwiICsgKG5lZWRzUmVwbGF5Rml4ID09PSB0cnVlICYmIHRoaXMuX2Nvbm4udmVyc2lvbiA9PT0gXCIzNi4wXCIgPyBcIi9yZXBsYXlcIiA6IFwiXCIpLFxuICAgIHRoaXMuX2Nvbm4udmVyc2lvblxuICBdLmpvaW4oJy8nKTtcbiAgdmFyIGZheWVDbGllbnQgPSBuZXcgRmF5ZS5DbGllbnQoZW5kcG9pbnRVcmwsIHt9KTtcbiAgZmF5ZUNsaWVudC5zZXRIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnT0F1dGggJyt0aGlzLl9jb25uLmFjY2Vzc1Rva2VuKTtcbiAgaWYgKGV4dGVuc2lvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGV4dGVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbihleHRlbnNpb24pIHtcbiAgICAgIGZheWVDbGllbnQuYWRkRXh0ZW5zaW9uKGV4dGVuc2lvbik7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGZheWVDbGllbnQuX2Rpc3BhdGNoZXIuZ2V0Q29ubmVjdGlvblR5cGVzKCkuaW5kZXhPZignY2FsbGJhY2stcG9sbGluZycpID09PSAtMSkge1xuICAgIC8vIHByZXZlbnQgc3RyZWFtaW5nIEFQSSBzZXJ2ZXIgZXJyb3JcbiAgICBmYXllQ2xpZW50Ll9kaXNwYXRjaGVyLnNlbGVjdFRyYW5zcG9ydCgnbG9uZy1wb2xsaW5nJyk7XG4gICAgZmF5ZUNsaWVudC5fZGlzcGF0Y2hlci5fdHJhbnNwb3J0LmJhdGNoaW5nID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZheWVDbGllbnQ7XG59O1xuXG4vKiogQHByaXZhdGUgKiovXG5TdHJlYW1pbmcucHJvdG90eXBlLl9nZXRGYXllQ2xpZW50ID0gZnVuY3Rpb24oY2hhbm5lbE5hbWUpIHtcbiAgdmFyIGlzR2VuZXJpYyA9IGNoYW5uZWxOYW1lLmluZGV4T2YoJy91LycpID09PSAwO1xuICB2YXIgY2xpZW50VHlwZSA9IGlzR2VuZXJpYyA/ICdnZW5lcmljJyA6ICdwdXNoVG9waWMnO1xuICBpZiAoIXRoaXMuX2ZheWVDbGllbnRzIHx8ICF0aGlzLl9mYXllQ2xpZW50c1tjbGllbnRUeXBlXSkge1xuICAgIHRoaXMuX2ZheWVDbGllbnRzID0gdGhpcy5fZmF5ZUNsaWVudHMgfHwge307XG4gICAgdGhpcy5fZmF5ZUNsaWVudHNbY2xpZW50VHlwZV0gPSB0aGlzLl9jcmVhdGVDbGllbnQoY2hhbm5lbE5hbWUpO1xuICB9XG4gIHJldHVybiB0aGlzLl9mYXllQ2xpZW50c1tjbGllbnRUeXBlXTtcbn07XG5cblxuLyoqXG4gKiBHZXQgbmFtZWQgdG9waWNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRvcGljIG5hbWVcbiAqIEByZXR1cm5zIHtTdHJlYW1pbmd+VG9waWN9XG4gKi9cblN0cmVhbWluZy5wcm90b3R5cGUudG9waWMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRoaXMuX3RvcGljcyA9IHRoaXMuX3RvcGljcyB8fCB7fTtcbiAgdmFyIHRvcGljID0gdGhpcy5fdG9waWNzW25hbWVdID1cbiAgICB0aGlzLl90b3BpY3NbbmFtZV0gfHwgbmV3IFRvcGljKHRoaXMsIG5hbWUpO1xuICByZXR1cm4gdG9waWM7XG59O1xuXG4vKipcbiAqIEdldCBDaGFubmVsIGZvciBJZFxuICogQHBhcmFtIHtTdHJpbmd9IGNoYW5uZWxJZCAtIElkIG9mIFN0cmVhbWluZ0NoYW5uZWwgb2JqZWN0XG4gKiBAcmV0dXJucyB7U3RyZWFtaW5nfkNoYW5uZWx9XG4gKi9cblN0cmVhbWluZy5wcm90b3R5cGUuY2hhbm5lbCA9IGZ1bmN0aW9uKGNoYW5uZWxJZCkge1xuICByZXR1cm4gbmV3IENoYW5uZWwodGhpcywgY2hhbm5lbElkKTtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvcGljL2NoYW5uZWxcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRvcGljIG5hbWVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFN0cmVhbWluZ35TdHJlYW1pbmdNZXNzYWdlPn0gbGlzdGVuZXIgLSBTdHJlYW1pbmcgbWVzc2FnZSBsaXN0ZW5lclxuICogQHJldHVybnMge1N1YnNjcmlwdGlvbn0gLSBGYXllIHN1YnNjcmlwdGlvbiBvYmplY3RcbiAqL1xuU3RyZWFtaW5nLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbihuYW1lLCBsaXN0ZW5lcikge1xuICB2YXIgY2hhbm5lbE5hbWUgPSBuYW1lLmluZGV4T2YoJy8nKSA9PT0gMCA/IG5hbWUgOiAnL3RvcGljLycgKyBuYW1lO1xuICB2YXIgZmF5ZUNsaWVudCA9IHRoaXMuX2dldEZheWVDbGllbnQoY2hhbm5lbE5hbWUpO1xuICByZXR1cm4gZmF5ZUNsaWVudC5zdWJzY3JpYmUoY2hhbm5lbE5hbWUsIGxpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgdG9waWNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRvcGljIG5hbWVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFN0cmVhbWluZ35TdHJlYW1pbmdNZXNzYWdlPn0gbGlzdGVuZXIgLSBTdHJlYW1pbmcgbWVzc2FnZSBsaXN0ZW5lclxuICogQHJldHVybnMge1N0cmVhbWluZ31cbiAqL1xuU3RyZWFtaW5nLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBjaGFubmVsTmFtZSA9IG5hbWUuaW5kZXhPZignLycpID09PSAwID8gbmFtZSA6ICcvdG9waWMvJyArIG5hbWU7XG4gIHZhciBmYXllQ2xpZW50ID0gdGhpcy5fZ2V0RmF5ZUNsaWVudChjaGFubmVsTmFtZSk7XG4gIGZheWVDbGllbnQudW5zdWJzY3JpYmUoY2hhbm5lbE5hbWUsIGxpc3RlbmVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgU3RyZWFtaW5nIGNsaWVudCwgb3B0aW9uYWxseSB3aXRoIGV4dGVuc2lvbnNcbiAqXG4gKiBTZWUgRmF5ZSBkb2NzIGZvciBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzOiBodHRwczovL2ZheWUuamNvZ2xhbi5jb20vYnJvd3Nlci9leHRlbnNpb25zLmh0bWxcbiAqXG4gKiBFeGFtcGxlIHVzYWdlOlxuICogXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBFc3RhYmxpc2ggYSBTYWxlc2ZvcmNlIGNvbm5lY3Rpb24uIChEZXRhaWxzIGVsaWRlZClcbiAqIGNvbnN0IGNvbm4gPSBuZXcganNmb3JjZS5Db25uZWN0aW9uKHsg4oCmIH0pO1xuICogXG4gKiBjb25zdCBmYXllQ2xpZW50ID0gY29ubi5zdHJlYW1pbmcuY3JlYXRlQ2xpZW50KCk7XG4gKiBcbiAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGZheWVDbGllbnQuc3Vic2NyaWJlKGNoYW5uZWwsIGRhdGEgPT4ge1xuICogICBjb25zb2xlLmxvZygndG9waWMgcmVjZWl2ZWQgZGF0YScsIGRhdGEpO1xuICogfSk7XG4gKiBcbiAqIHN1YnNjcmlwdGlvbi5jYW5jZWwoKTtcbiAqIGBgYFxuICogXG4gKiBFeGFtcGxlIHdpdGggZXh0ZW5zaW9ucywgdXNpbmcgUmVwbGF5ICYgQXV0aCBGYWlsdXJlIGV4dGVuc2lvbnMgaW4gYSBzZXJ2ZXItc2lkZSBOb2RlLmpzIGFwcDpcbiAqIFxuICogYGBgamF2YXNjcmlwdFxuICogLy8gRXN0YWJsaXNoIGEgU2FsZXNmb3JjZSBjb25uZWN0aW9uLiAoRGV0YWlscyBlbGlkZWQpXG4gKiBjb25zdCBjb25uID0gbmV3IGpzZm9yY2UuQ29ubmVjdGlvbih7IOKApiB9KTtcbiAqIFxuICogY29uc3QgY2hhbm5lbCA9IFwiL2V2ZW50L015X0V2ZW50X19lXCI7XG4gKiBjb25zdCByZXBsYXlJZCA9IC0yOyAvLyAtMiBpcyBhbGwgcmV0YWluZWQgZXZlbnRzXG4gKiBcbiAqIGNvbnN0IGV4aXRDYWxsYmFjayA9ICgpID0+IHByb2Nlc3MuZXhpdCgxKTtcbiAqIGNvbnN0IGF1dGhGYWlsdXJlRXh0ID0gbmV3IGpzZm9yY2UuU3RyZWFtaW5nRXh0ZW5zaW9uLkF1dGhGYWlsdXJlKGV4aXRDYWxsYmFjayk7XG4gKiBcbiAqIGNvbnN0IHJlcGxheUV4dCA9IG5ldyBqc2ZvcmNlLlN0cmVhbWluZ0V4dGVuc2lvbi5SZXBsYXkoY2hhbm5lbCwgcmVwbGF5SWQpO1xuICogXG4gKiBjb25zdCBmYXllQ2xpZW50ID0gY29ubi5zdHJlYW1pbmcuY3JlYXRlQ2xpZW50KFtcbiAqICAgYXV0aEZhaWx1cmVFeHQsXG4gKiAgIHJlcGxheUV4dFxuICogXSk7XG4gKiBcbiAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGZheWVDbGllbnQuc3Vic2NyaWJlKGNoYW5uZWwsIGRhdGEgPT4ge1xuICogICBjb25zb2xlLmxvZygndG9waWMgcmVjZWl2ZWQgZGF0YScsIGRhdGEpO1xuICogfSk7XG4gKiBcbiAqIHN1YnNjcmlwdGlvbi5jYW5jZWwoKTtcbiAqIGBgYFxuICogXG4gKiBAcGFyYW0ge0FycmF5fSBFeHRlbnNpb25zIC0gT3B0aW9uYWwsIGV4dGVuc2lvbnMgdG8gYXBwbHkgdG8gdGhlIEZheWUgY2xpZW50XG4gKiBAcmV0dXJucyB7RmF5ZUNsaWVudH0gLSBGYXllIGNsaWVudCBvYmplY3RcbiAqL1xuU3RyZWFtaW5nLnByb3RvdHlwZS5jcmVhdGVDbGllbnQgPSBmdW5jdGlvbihleHRlbnNpb25zKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVDbGllbnQobnVsbCwgZXh0ZW5zaW9ucyk7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qXG4gKiBSZWdpc3RlciBob29rIGluIGNvbm5lY3Rpb24gaW5zdGFudGlhdGlvbiBmb3IgZHluYW1pY2FsbHkgYWRkaW5nIHRoaXMgQVBJIG1vZHVsZSBmZWF0dXJlc1xuICovXG5qc2ZvcmNlLm9uKCdjb25uZWN0aW9uOm5ldycsIGZ1bmN0aW9uKGNvbm4pIHtcbiAgY29ubi5zdHJlYW1pbmcgPSBuZXcgU3RyZWFtaW5nKGNvbm4pO1xufSk7XG5cbi8qXG4gKiBcbiAqL1xuanNmb3JjZS5TdHJlYW1pbmdFeHRlbnNpb24gPSBTdHJlYW1pbmdFeHRlbnNpb247XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtaW5nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/api/streaming.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/api/tooling.js":
/*!*************************************************!*\
  !*** ./node_modules/jsforce/lib/api/tooling.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages Tooling APIs\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar jsforce = __webpack_require__(/*! ../core */ \"(action-browser)/./node_modules/jsforce/lib/core.js\"),\n    _     = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    Cache = __webpack_require__(/*! ../cache */ \"(action-browser)/./node_modules/jsforce/lib/cache.js\");\n\n/**\n * API class for Tooling API call\n *\n * @class\n * @param {Connection} conn - Connection\n */\nvar Tooling = function(conn) {\n  this._conn = conn;\n  this._logger = conn._logger;\n  var delegates = [\n    \"query\",\n    \"queryMore\",\n    \"_toRecordResult\",\n    \"create\",\n    \"_createSingle\",\n    \"_createParallel\",\n    \"_createMany\",\n    \"insert\",\n    \"retrieve\",\n    \"_retrieveSingle\",\n    \"_retrieveParallel\",\n    \"_retrieveMany\",\n    \"update\",\n    \"_updateSingle\",\n    \"_updateParallel\",\n    \"_updateMany\",\n    \"upsert\",\n    \"del\",\n    \"delete\",\n    \"destroy\",\n    \"_destroySingle\",\n    \"_destroyParallel\",\n    \"_destroyMany\",\n    \"describe\",\n    \"describeGlobal\",\n    \"sobject\"\n  ];\n  delegates.forEach(function(method) {\n    this[method] = conn.constructor.prototype[method];\n  }, this);\n\n  this.cache = new Cache();\n\n  var cacheOptions = {\n    key: function(type) { return type ? \"describe.\" + type : \"describe\"; }\n  };\n  this.describe$ = this.cache.makeCacheable(this.describe, this, cacheOptions);\n  this.describe = this.cache.makeResponseCacheable(this.describe, this, cacheOptions);\n  this.describeSObject$ = this.describe$;\n  this.describeSObject = this.describe;\n\n  cacheOptions = { key: 'describeGlobal' };\n  this.describeGlobal$ = this.cache.makeCacheable(this.describeGlobal, this, cacheOptions);\n  this.describeGlobal = this.cache.makeResponseCacheable(this.describeGlobal, this, cacheOptions);\n\n  this.initialize();\n};\n\n/**\n * Initialize tooling API\n * @protected\n */\nTooling.prototype.initialize = function() {\n  this.sobjects = {};\n  this.cache.clear();\n  this.cache.get('describeGlobal').removeAllListeners('value');\n  this.cache.get('describeGlobal').on('value', _.bind(function(res) {\n    if (res.result) {\n      var types = _.map(res.result.sobjects, function(so) { return so.name; });\n      types.forEach(this.sobject, this);\n    }\n  }, this));\n};\n\n/**\n * @private\n */\nTooling.prototype._baseUrl = function() {\n  return this._conn._baseUrl() + \"/tooling\";\n};\n\n/**\n * @private\n */\nTooling.prototype._supports = function(feature) {\n  // should return false in order not to use compsite collection\n  if (feature === 'sobject-collection') {\n    return false;\n  }\n  return this._conn._supports.apply(this._conn, arguments);\n};\n\n/**\n * @private\n */\nTooling.prototype.request = function() {\n  return this._conn.request.apply(this._conn, arguments);\n};\n\n/**\n * Execute query by using SOQL\n *\n * @param {String} soql - SOQL string\n * @param {Callback.<QueryResult>} [callback] - Callback function\n * @returns {Query.<QueryResult>}\n */\n/**\n * Query next record set by using query locator\n *\n * @method Tooling#query\n * @param {String} locator - Next record set locator\n * @param {Callback.<QueryResult>} [callback] - Callback function\n * @returns {Query.<QueryResult>}\n */\n/**\n * Retrieve specified records\n *\n * @method Tooling#queryMore\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A record ID or array of record IDs\n * @param {Callback.<Record|Array.<Record>>} [callback] - Callback function\n * @returns {Promise.<Record|Array.<Record>>}\n */\n\n/**\n * Synonym of Tooling#create()\n *\n * @method Tooling#insert\n * @param {String} type - SObject Type\n * @param {Object|Array.<Object>} records - A record or array of records to create\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Create records\n *\n * @method Tooling#create\n * @param {String} type - SObject Type\n * @param {Record|Array.<Record>} records - A record or array of records to create\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n\n/**\n * Update records\n *\n * @method Tooling#update\n * @param {String} type - SObject Type\n * @param {Record|Array.<Record>} records - A record or array of records to update\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n\n/**\n * Upsert records\n *\n * @method Tooling#upsert\n * @param {String} type - SObject Type\n * @param {Record|Array.<Record>} records - Record or array of records to upsert\n * @param {String} extIdField - External ID field name\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n\n/**\n * Synonym of Tooling#destroy()\n *\n * @method Tooling#delete\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Synonym of Tooling#destroy()\n *\n * @method Tooling#del\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Delete records\n *\n * @method Tooling#destroy\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n\n/**\n * Synonym of Tooling#describe()\n *\n * @method Tooling#describeSObject\n * @param {String} type - SObject Type\n * @param {Callback.<DescribeSObjectResult>} [callback] - Callback function\n * @returns {Promise.<DescribeSObjectResult>}\n */\n/**\n * Describe SObject metadata\n *\n * @method Tooling#describe\n * @param {String} type - SObject Type\n * @param {Callback.<DescribeSObjectResult>} [callback] - Callback function\n * @returns {Promise.<DescribeSObjectResult>}\n */\n\n/**\n * Describe global SObjects\n *\n * @method Tooling#describeGlobal\n * @param {Callback.<DescribeGlobalResult>} [callback] - Callback function\n * @returns {Promise.<DescribeGlobalResult>}\n */\n\n/**\n * Get SObject instance\n *\n * @method Tooling#sobject\n * @param {String} type - SObject Type\n * @returns {SObject}\n */\n\n/**\n * @typedef {Object} Tooling~ExecuteAnonymousResult\n * @prop {Boolean} compiled - Flag if the query is compiled successfully\n * @prop {String} compileProblem - Error reason in compilation\n * @prop {Boolean} success - Flag if the code is executed successfully\n * @prop {Number} line - Line number for the error\n * @prop {Number} column - Column number for the error\n * @prop {String} exceptionMessage - Exception message\n * @prop {String} exceptionStackTrace - Exception stack trace\n */\n/**\n * Executes Apex code anonymously\n *\n * @param {String} body - Anonymous Apex code\n * @param {Callback.<Tooling~ExecuteAnonymousResult>} [callback] - Callback function\n * @returns {Promise.<Tooling~ExecuteAnonymousResult>}\n */\nTooling.prototype.executeAnonymous = function(body, callback) {\n  var url = this._baseUrl() + \"/executeAnonymous?anonymousBody=\" + encodeURIComponent(body);\n  return this.request(url).thenCall(callback);\n};\n\n/**\n * Executes Apex tests asynchronously\n *\n * @param {Array.<String>} classids - Comma separated list of class IDs\n * @param {Callback.<Tooling~ExecuteAnonymousResult>} [callback] - Callback function\n * @returns {Promise.<Tooling~ExecuteAnonymousResult>}\n */\nTooling.prototype.runTestsAsynchronous = function(classids, callback) {\n  var url = this._baseUrl() + \"/runTestsAsynchronous/\";\n  return this._conn.requestPost(url, {classids : classids.join(',')}, undefined, callback);\n};\n\n/**\n * Executes Apex tests synchronously\n *\n * @param {Array.<String>} classnames - Comma separated list of class Names\n * @param {Callback.<Tooling~ExecuteAnonymousResult>} [callback] - Callback function\n * @returns {Promise.<Tooling~ExecuteAnonymousResult>}\n */\nTooling.prototype.runTestsSynchronous = function(classnames, callback) {\n  var url = this._baseUrl() + \"/runTestsSynchronous/\";\n  return this._conn.requestPost(url, {classnames : classnames.join(',')}, undefined, callback);\n};\n\n/**\n * @typedef {Object} Tooling~CompletionsResult\n * @prop {Object} publicDeclarations\n */\n/**\n * Retrieves available code completions of the referenced type\n *\n * @param {String} [type] - completion type (default 'apex')\n * @param {Callback.<Tooling~CompletionsResult>} [callback] - Callback function\n * @returns {Promise.<Tooling~CompletionsResult>}\n */\nTooling.prototype.completions = function(type, callback) {\n  if (!_.isString(type)) {\n    callback = type;\n    type = 'apex';\n  }\n  var url = this._baseUrl() + \"/completions?type=\" + encodeURIComponent(type);\n  return this.request(url).thenCall(callback);\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.tooling = new Tooling(conn);\n});\n\n\nmodule.exports = Tooling;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvdG9vbGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsb0VBQVM7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLG1FQUFhO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyxzRUFBVTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHdCQUF3QjtBQUNuQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHdCQUF3QjtBQUNuQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLGtDQUFrQztBQUM3QyxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyw4Q0FBOEM7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyw4Q0FBOEM7QUFDekQsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyw4Q0FBOEM7QUFDekQsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtDQUFrQztBQUM3QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtDQUFrQztBQUM3QyxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsU0FBUztBQUNuQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLDJDQUEyQztBQUN0RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLDJDQUEyQztBQUN0RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhCQUE4QjtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLDJDQUEyQztBQUN0RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtDQUFrQztBQUN4RTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxzQ0FBc0M7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2FwaS90b29saW5nLmpzP2NkOTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBNYW5hZ2VzIFRvb2xpbmcgQVBJc1xuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIganNmb3JjZSA9IHJlcXVpcmUoJy4uL2NvcmUnKSxcbiAgICBfICAgICA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyksXG4gICAgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZScpO1xuXG4vKipcbiAqIEFQSSBjbGFzcyBmb3IgVG9vbGluZyBBUEkgY2FsbFxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIC0gQ29ubmVjdGlvblxuICovXG52YXIgVG9vbGluZyA9IGZ1bmN0aW9uKGNvbm4pIHtcbiAgdGhpcy5fY29ubiA9IGNvbm47XG4gIHRoaXMuX2xvZ2dlciA9IGNvbm4uX2xvZ2dlcjtcbiAgdmFyIGRlbGVnYXRlcyA9IFtcbiAgICBcInF1ZXJ5XCIsXG4gICAgXCJxdWVyeU1vcmVcIixcbiAgICBcIl90b1JlY29yZFJlc3VsdFwiLFxuICAgIFwiY3JlYXRlXCIsXG4gICAgXCJfY3JlYXRlU2luZ2xlXCIsXG4gICAgXCJfY3JlYXRlUGFyYWxsZWxcIixcbiAgICBcIl9jcmVhdGVNYW55XCIsXG4gICAgXCJpbnNlcnRcIixcbiAgICBcInJldHJpZXZlXCIsXG4gICAgXCJfcmV0cmlldmVTaW5nbGVcIixcbiAgICBcIl9yZXRyaWV2ZVBhcmFsbGVsXCIsXG4gICAgXCJfcmV0cmlldmVNYW55XCIsXG4gICAgXCJ1cGRhdGVcIixcbiAgICBcIl91cGRhdGVTaW5nbGVcIixcbiAgICBcIl91cGRhdGVQYXJhbGxlbFwiLFxuICAgIFwiX3VwZGF0ZU1hbnlcIixcbiAgICBcInVwc2VydFwiLFxuICAgIFwiZGVsXCIsXG4gICAgXCJkZWxldGVcIixcbiAgICBcImRlc3Ryb3lcIixcbiAgICBcIl9kZXN0cm95U2luZ2xlXCIsXG4gICAgXCJfZGVzdHJveVBhcmFsbGVsXCIsXG4gICAgXCJfZGVzdHJveU1hbnlcIixcbiAgICBcImRlc2NyaWJlXCIsXG4gICAgXCJkZXNjcmliZUdsb2JhbFwiLFxuICAgIFwic29iamVjdFwiXG4gIF07XG4gIGRlbGVnYXRlcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIHRoaXNbbWV0aG9kXSA9IGNvbm4uY29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZF07XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuY2FjaGUgPSBuZXcgQ2FjaGUoKTtcblxuICB2YXIgY2FjaGVPcHRpb25zID0ge1xuICAgIGtleTogZnVuY3Rpb24odHlwZSkgeyByZXR1cm4gdHlwZSA/IFwiZGVzY3JpYmUuXCIgKyB0eXBlIDogXCJkZXNjcmliZVwiOyB9XG4gIH07XG4gIHRoaXMuZGVzY3JpYmUkID0gdGhpcy5jYWNoZS5tYWtlQ2FjaGVhYmxlKHRoaXMuZGVzY3JpYmUsIHRoaXMsIGNhY2hlT3B0aW9ucyk7XG4gIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmNhY2hlLm1ha2VSZXNwb25zZUNhY2hlYWJsZSh0aGlzLmRlc2NyaWJlLCB0aGlzLCBjYWNoZU9wdGlvbnMpO1xuICB0aGlzLmRlc2NyaWJlU09iamVjdCQgPSB0aGlzLmRlc2NyaWJlJDtcbiAgdGhpcy5kZXNjcmliZVNPYmplY3QgPSB0aGlzLmRlc2NyaWJlO1xuXG4gIGNhY2hlT3B0aW9ucyA9IHsga2V5OiAnZGVzY3JpYmVHbG9iYWwnIH07XG4gIHRoaXMuZGVzY3JpYmVHbG9iYWwkID0gdGhpcy5jYWNoZS5tYWtlQ2FjaGVhYmxlKHRoaXMuZGVzY3JpYmVHbG9iYWwsIHRoaXMsIGNhY2hlT3B0aW9ucyk7XG4gIHRoaXMuZGVzY3JpYmVHbG9iYWwgPSB0aGlzLmNhY2hlLm1ha2VSZXNwb25zZUNhY2hlYWJsZSh0aGlzLmRlc2NyaWJlR2xvYmFsLCB0aGlzLCBjYWNoZU9wdGlvbnMpO1xuXG4gIHRoaXMuaW5pdGlhbGl6ZSgpO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRvb2xpbmcgQVBJXG4gKiBAcHJvdGVjdGVkXG4gKi9cblRvb2xpbmcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zb2JqZWN0cyA9IHt9O1xuICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gIHRoaXMuY2FjaGUuZ2V0KCdkZXNjcmliZUdsb2JhbCcpLnJlbW92ZUFsbExpc3RlbmVycygndmFsdWUnKTtcbiAgdGhpcy5jYWNoZS5nZXQoJ2Rlc2NyaWJlR2xvYmFsJykub24oJ3ZhbHVlJywgXy5iaW5kKGZ1bmN0aW9uKHJlcykge1xuICAgIGlmIChyZXMucmVzdWx0KSB7XG4gICAgICB2YXIgdHlwZXMgPSBfLm1hcChyZXMucmVzdWx0LnNvYmplY3RzLCBmdW5jdGlvbihzbykgeyByZXR1cm4gc28ubmFtZTsgfSk7XG4gICAgICB0eXBlcy5mb3JFYWNoKHRoaXMuc29iamVjdCwgdGhpcyk7XG4gICAgfVxuICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblRvb2xpbmcucHJvdG90eXBlLl9iYXNlVXJsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jb25uLl9iYXNlVXJsKCkgKyBcIi90b29saW5nXCI7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblRvb2xpbmcucHJvdG90eXBlLl9zdXBwb3J0cyA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgLy8gc2hvdWxkIHJldHVybiBmYWxzZSBpbiBvcmRlciBub3QgdG8gdXNlIGNvbXBzaXRlIGNvbGxlY3Rpb25cbiAgaWYgKGZlYXR1cmUgPT09ICdzb2JqZWN0LWNvbGxlY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0aGlzLl9jb25uLl9zdXBwb3J0cy5hcHBseSh0aGlzLl9jb25uLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5Ub29saW5nLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QuYXBwbHkodGhpcy5fY29ubiwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBxdWVyeSBieSB1c2luZyBTT1FMXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNvcWwgLSBTT1FMIHN0cmluZ1xuICogQHBhcmFtIHtDYWxsYmFjay48UXVlcnlSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtRdWVyeS48UXVlcnlSZXN1bHQ+fVxuICovXG4vKipcbiAqIFF1ZXJ5IG5leHQgcmVjb3JkIHNldCBieSB1c2luZyBxdWVyeSBsb2NhdG9yXG4gKlxuICogQG1ldGhvZCBUb29saW5nI3F1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gbG9jYXRvciAtIE5leHQgcmVjb3JkIHNldCBsb2NhdG9yXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxRdWVyeVJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1F1ZXJ5LjxRdWVyeVJlc3VsdD59XG4gKi9cbi8qKlxuICogUmV0cmlldmUgc3BlY2lmaWVkIHJlY29yZHNcbiAqXG4gKiBAbWV0aG9kIFRvb2xpbmcjcXVlcnlNb3JlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGlkcyAtIEEgcmVjb3JkIElEIG9yIGFycmF5IG9mIHJlY29yZCBJRHNcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZHxBcnJheS48UmVjb3JkPj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZHxBcnJheS48UmVjb3JkPj59XG4gKi9cblxuLyoqXG4gKiBTeW5vbnltIG9mIFRvb2xpbmcjY3JlYXRlKClcbiAqXG4gKiBAbWV0aG9kIFRvb2xpbmcjaW5zZXJ0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtPYmplY3R8QXJyYXkuPE9iamVjdD59IHJlY29yZHMgLSBBIHJlY29yZCBvciBhcnJheSBvZiByZWNvcmRzIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuLyoqXG4gKiBDcmVhdGUgcmVjb3Jkc1xuICpcbiAqIEBtZXRob2QgVG9vbGluZyNjcmVhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gU09iamVjdCBUeXBlXG4gKiBAcGFyYW0ge1JlY29yZHxBcnJheS48UmVjb3JkPn0gcmVjb3JkcyAtIEEgcmVjb3JkIG9yIGFycmF5IG9mIHJlY29yZHMgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG5cbi8qKlxuICogVXBkYXRlIHJlY29yZHNcbiAqXG4gKiBAbWV0aG9kIFRvb2xpbmcjdXBkYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtSZWNvcmR8QXJyYXkuPFJlY29yZD59IHJlY29yZHMgLSBBIHJlY29yZCBvciBhcnJheSBvZiByZWNvcmRzIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuXG4vKipcbiAqIFVwc2VydCByZWNvcmRzXG4gKlxuICogQG1ldGhvZCBUb29saW5nI3Vwc2VydFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IFR5cGVcbiAqIEBwYXJhbSB7UmVjb3JkfEFycmF5LjxSZWNvcmQ+fSByZWNvcmRzIC0gUmVjb3JkIG9yIGFycmF5IG9mIHJlY29yZHMgdG8gdXBzZXJ0XG4gKiBAcGFyYW0ge1N0cmluZ30gZXh0SWRGaWVsZCAtIEV4dGVybmFsIElEIGZpZWxkIG5hbWVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFja1xuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cblxuLyoqXG4gKiBTeW5vbnltIG9mIFRvb2xpbmcjZGVzdHJveSgpXG4gKlxuICogQG1ldGhvZCBUb29saW5nI2RlbGV0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IFR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBpZHMgLSBBIElEIG9yIGFycmF5IG9mIElEcyB0byBkZWxldGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFja1xuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cbi8qKlxuICogU3lub255bSBvZiBUb29saW5nI2Rlc3Ryb3koKVxuICpcbiAqIEBtZXRob2QgVG9vbGluZyNkZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gU09iamVjdCBUeXBlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaWRzIC0gQSBJRCBvciBhcnJheSBvZiBJRHMgdG8gZGVsZXRlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2tcbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG4vKipcbiAqIERlbGV0ZSByZWNvcmRzXG4gKlxuICogQG1ldGhvZCBUb29saW5nI2Rlc3Ryb3lcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gU09iamVjdCBUeXBlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaWRzIC0gQSBJRCBvciBhcnJheSBvZiBJRHMgdG8gZGVsZXRlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2tcbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG5cbi8qKlxuICogU3lub255bSBvZiBUb29saW5nI2Rlc2NyaWJlKClcbiAqXG4gKiBAbWV0aG9kIFRvb2xpbmcjZGVzY3JpYmVTT2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtDYWxsYmFjay48RGVzY3JpYmVTT2JqZWN0UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48RGVzY3JpYmVTT2JqZWN0UmVzdWx0Pn1cbiAqL1xuLyoqXG4gKiBEZXNjcmliZSBTT2JqZWN0IG1ldGFkYXRhXG4gKlxuICogQG1ldGhvZCBUb29saW5nI2Rlc2NyaWJlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtDYWxsYmFjay48RGVzY3JpYmVTT2JqZWN0UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48RGVzY3JpYmVTT2JqZWN0UmVzdWx0Pn1cbiAqL1xuXG4vKipcbiAqIERlc2NyaWJlIGdsb2JhbCBTT2JqZWN0c1xuICpcbiAqIEBtZXRob2QgVG9vbGluZyNkZXNjcmliZUdsb2JhbFxuICogQHBhcmFtIHtDYWxsYmFjay48RGVzY3JpYmVHbG9iYWxSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxEZXNjcmliZUdsb2JhbFJlc3VsdD59XG4gKi9cblxuLyoqXG4gKiBHZXQgU09iamVjdCBpbnN0YW5jZVxuICpcbiAqIEBtZXRob2QgVG9vbGluZyNzb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHJldHVybnMge1NPYmplY3R9XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUb29saW5nfkV4ZWN1dGVBbm9ueW1vdXNSZXN1bHRcbiAqIEBwcm9wIHtCb29sZWFufSBjb21waWxlZCAtIEZsYWcgaWYgdGhlIHF1ZXJ5IGlzIGNvbXBpbGVkIHN1Y2Nlc3NmdWxseVxuICogQHByb3Age1N0cmluZ30gY29tcGlsZVByb2JsZW0gLSBFcnJvciByZWFzb24gaW4gY29tcGlsYXRpb25cbiAqIEBwcm9wIHtCb29sZWFufSBzdWNjZXNzIC0gRmxhZyBpZiB0aGUgY29kZSBpcyBleGVjdXRlZCBzdWNjZXNzZnVsbHlcbiAqIEBwcm9wIHtOdW1iZXJ9IGxpbmUgLSBMaW5lIG51bWJlciBmb3IgdGhlIGVycm9yXG4gKiBAcHJvcCB7TnVtYmVyfSBjb2x1bW4gLSBDb2x1bW4gbnVtYmVyIGZvciB0aGUgZXJyb3JcbiAqIEBwcm9wIHtTdHJpbmd9IGV4Y2VwdGlvbk1lc3NhZ2UgLSBFeGNlcHRpb24gbWVzc2FnZVxuICogQHByb3Age1N0cmluZ30gZXhjZXB0aW9uU3RhY2tUcmFjZSAtIEV4Y2VwdGlvbiBzdGFjayB0cmFjZVxuICovXG4vKipcbiAqIEV4ZWN1dGVzIEFwZXggY29kZSBhbm9ueW1vdXNseVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBib2R5IC0gQW5vbnltb3VzIEFwZXggY29kZVxuICogQHBhcmFtIHtDYWxsYmFjay48VG9vbGluZ35FeGVjdXRlQW5vbnltb3VzUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48VG9vbGluZ35FeGVjdXRlQW5vbnltb3VzUmVzdWx0Pn1cbiAqL1xuVG9vbGluZy5wcm90b3R5cGUuZXhlY3V0ZUFub255bW91cyA9IGZ1bmN0aW9uKGJvZHksIGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSB0aGlzLl9iYXNlVXJsKCkgKyBcIi9leGVjdXRlQW5vbnltb3VzP2Fub255bW91c0JvZHk9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoYm9keSk7XG4gIHJldHVybiB0aGlzLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIEFwZXggdGVzdHMgYXN5bmNocm9ub3VzbHlcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBjbGFzc2lkcyAtIENvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzIElEc1xuICogQHBhcmFtIHtDYWxsYmFjay48VG9vbGluZ35FeGVjdXRlQW5vbnltb3VzUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48VG9vbGluZ35FeGVjdXRlQW5vbnltb3VzUmVzdWx0Pn1cbiAqL1xuVG9vbGluZy5wcm90b3R5cGUucnVuVGVzdHNBc3luY2hyb25vdXMgPSBmdW5jdGlvbihjbGFzc2lkcywgY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IHRoaXMuX2Jhc2VVcmwoKSArIFwiL3J1blRlc3RzQXN5bmNocm9ub3VzL1wiO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0UG9zdCh1cmwsIHtjbGFzc2lkcyA6IGNsYXNzaWRzLmpvaW4oJywnKX0sIHVuZGVmaW5lZCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBBcGV4IHRlc3RzIHN5bmNocm9ub3VzbHlcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBjbGFzc25hbWVzIC0gQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgY2xhc3MgTmFtZXNcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFRvb2xpbmd+RXhlY3V0ZUFub255bW91c1Jlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFRvb2xpbmd+RXhlY3V0ZUFub255bW91c1Jlc3VsdD59XG4gKi9cblRvb2xpbmcucHJvdG90eXBlLnJ1blRlc3RzU3luY2hyb25vdXMgPSBmdW5jdGlvbihjbGFzc25hbWVzLCBjYWxsYmFjaykge1xuICB2YXIgdXJsID0gdGhpcy5fYmFzZVVybCgpICsgXCIvcnVuVGVzdHNTeW5jaHJvbm91cy9cIjtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdFBvc3QodXJsLCB7Y2xhc3NuYW1lcyA6IGNsYXNzbmFtZXMuam9pbignLCcpfSwgdW5kZWZpbmVkLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRvb2xpbmd+Q29tcGxldGlvbnNSZXN1bHRcbiAqIEBwcm9wIHtPYmplY3R9IHB1YmxpY0RlY2xhcmF0aW9uc1xuICovXG4vKipcbiAqIFJldHJpZXZlcyBhdmFpbGFibGUgY29kZSBjb21wbGV0aW9ucyBvZiB0aGUgcmVmZXJlbmNlZCB0eXBlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAtIGNvbXBsZXRpb24gdHlwZSAoZGVmYXVsdCAnYXBleCcpXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxUb29saW5nfkNvbXBsZXRpb25zUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48VG9vbGluZ35Db21wbGV0aW9uc1Jlc3VsdD59XG4gKi9cblRvb2xpbmcucHJvdG90eXBlLmNvbXBsZXRpb25zID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKCFfLmlzU3RyaW5nKHR5cGUpKSB7XG4gICAgY2FsbGJhY2sgPSB0eXBlO1xuICAgIHR5cGUgPSAnYXBleCc7XG4gIH1cbiAgdmFyIHVybCA9IHRoaXMuX2Jhc2VVcmwoKSArIFwiL2NvbXBsZXRpb25zP3R5cGU9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodHlwZSk7XG4gIHJldHVybiB0aGlzLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLypcbiAqIFJlZ2lzdGVyIGhvb2sgaW4gY29ubmVjdGlvbiBpbnN0YW50aWF0aW9uIGZvciBkeW5hbWljYWxseSBhZGRpbmcgdGhpcyBBUEkgbW9kdWxlIGZlYXR1cmVzXG4gKi9cbmpzZm9yY2Uub24oJ2Nvbm5lY3Rpb246bmV3JywgZnVuY3Rpb24oY29ubikge1xuICBjb25uLnRvb2xpbmcgPSBuZXcgVG9vbGluZyhjb25uKTtcbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVG9vbGluZztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/api/tooling.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/api/tooling.js":
/*!*************************************************!*\
  !*** ./node_modules/jsforce/lib/api/tooling.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages Tooling APIs\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar jsforce = __webpack_require__(/*! ../core */ \"(rsc)/./node_modules/jsforce/lib/core.js\"),\n    _     = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    Cache = __webpack_require__(/*! ../cache */ \"(rsc)/./node_modules/jsforce/lib/cache.js\");\n\n/**\n * API class for Tooling API call\n *\n * @class\n * @param {Connection} conn - Connection\n */\nvar Tooling = function(conn) {\n  this._conn = conn;\n  this._logger = conn._logger;\n  var delegates = [\n    \"query\",\n    \"queryMore\",\n    \"_toRecordResult\",\n    \"create\",\n    \"_createSingle\",\n    \"_createParallel\",\n    \"_createMany\",\n    \"insert\",\n    \"retrieve\",\n    \"_retrieveSingle\",\n    \"_retrieveParallel\",\n    \"_retrieveMany\",\n    \"update\",\n    \"_updateSingle\",\n    \"_updateParallel\",\n    \"_updateMany\",\n    \"upsert\",\n    \"del\",\n    \"delete\",\n    \"destroy\",\n    \"_destroySingle\",\n    \"_destroyParallel\",\n    \"_destroyMany\",\n    \"describe\",\n    \"describeGlobal\",\n    \"sobject\"\n  ];\n  delegates.forEach(function(method) {\n    this[method] = conn.constructor.prototype[method];\n  }, this);\n\n  this.cache = new Cache();\n\n  var cacheOptions = {\n    key: function(type) { return type ? \"describe.\" + type : \"describe\"; }\n  };\n  this.describe$ = this.cache.makeCacheable(this.describe, this, cacheOptions);\n  this.describe = this.cache.makeResponseCacheable(this.describe, this, cacheOptions);\n  this.describeSObject$ = this.describe$;\n  this.describeSObject = this.describe;\n\n  cacheOptions = { key: 'describeGlobal' };\n  this.describeGlobal$ = this.cache.makeCacheable(this.describeGlobal, this, cacheOptions);\n  this.describeGlobal = this.cache.makeResponseCacheable(this.describeGlobal, this, cacheOptions);\n\n  this.initialize();\n};\n\n/**\n * Initialize tooling API\n * @protected\n */\nTooling.prototype.initialize = function() {\n  this.sobjects = {};\n  this.cache.clear();\n  this.cache.get('describeGlobal').removeAllListeners('value');\n  this.cache.get('describeGlobal').on('value', _.bind(function(res) {\n    if (res.result) {\n      var types = _.map(res.result.sobjects, function(so) { return so.name; });\n      types.forEach(this.sobject, this);\n    }\n  }, this));\n};\n\n/**\n * @private\n */\nTooling.prototype._baseUrl = function() {\n  return this._conn._baseUrl() + \"/tooling\";\n};\n\n/**\n * @private\n */\nTooling.prototype._supports = function(feature) {\n  // should return false in order not to use compsite collection\n  if (feature === 'sobject-collection') {\n    return false;\n  }\n  return this._conn._supports.apply(this._conn, arguments);\n};\n\n/**\n * @private\n */\nTooling.prototype.request = function() {\n  return this._conn.request.apply(this._conn, arguments);\n};\n\n/**\n * Execute query by using SOQL\n *\n * @param {String} soql - SOQL string\n * @param {Callback.<QueryResult>} [callback] - Callback function\n * @returns {Query.<QueryResult>}\n */\n/**\n * Query next record set by using query locator\n *\n * @method Tooling#query\n * @param {String} locator - Next record set locator\n * @param {Callback.<QueryResult>} [callback] - Callback function\n * @returns {Query.<QueryResult>}\n */\n/**\n * Retrieve specified records\n *\n * @method Tooling#queryMore\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A record ID or array of record IDs\n * @param {Callback.<Record|Array.<Record>>} [callback] - Callback function\n * @returns {Promise.<Record|Array.<Record>>}\n */\n\n/**\n * Synonym of Tooling#create()\n *\n * @method Tooling#insert\n * @param {String} type - SObject Type\n * @param {Object|Array.<Object>} records - A record or array of records to create\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Create records\n *\n * @method Tooling#create\n * @param {String} type - SObject Type\n * @param {Record|Array.<Record>} records - A record or array of records to create\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n\n/**\n * Update records\n *\n * @method Tooling#update\n * @param {String} type - SObject Type\n * @param {Record|Array.<Record>} records - A record or array of records to update\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n\n/**\n * Upsert records\n *\n * @method Tooling#upsert\n * @param {String} type - SObject Type\n * @param {Record|Array.<Record>} records - Record or array of records to upsert\n * @param {String} extIdField - External ID field name\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n\n/**\n * Synonym of Tooling#destroy()\n *\n * @method Tooling#delete\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Synonym of Tooling#destroy()\n *\n * @method Tooling#del\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Delete records\n *\n * @method Tooling#destroy\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n\n/**\n * Synonym of Tooling#describe()\n *\n * @method Tooling#describeSObject\n * @param {String} type - SObject Type\n * @param {Callback.<DescribeSObjectResult>} [callback] - Callback function\n * @returns {Promise.<DescribeSObjectResult>}\n */\n/**\n * Describe SObject metadata\n *\n * @method Tooling#describe\n * @param {String} type - SObject Type\n * @param {Callback.<DescribeSObjectResult>} [callback] - Callback function\n * @returns {Promise.<DescribeSObjectResult>}\n */\n\n/**\n * Describe global SObjects\n *\n * @method Tooling#describeGlobal\n * @param {Callback.<DescribeGlobalResult>} [callback] - Callback function\n * @returns {Promise.<DescribeGlobalResult>}\n */\n\n/**\n * Get SObject instance\n *\n * @method Tooling#sobject\n * @param {String} type - SObject Type\n * @returns {SObject}\n */\n\n/**\n * @typedef {Object} Tooling~ExecuteAnonymousResult\n * @prop {Boolean} compiled - Flag if the query is compiled successfully\n * @prop {String} compileProblem - Error reason in compilation\n * @prop {Boolean} success - Flag if the code is executed successfully\n * @prop {Number} line - Line number for the error\n * @prop {Number} column - Column number for the error\n * @prop {String} exceptionMessage - Exception message\n * @prop {String} exceptionStackTrace - Exception stack trace\n */\n/**\n * Executes Apex code anonymously\n *\n * @param {String} body - Anonymous Apex code\n * @param {Callback.<Tooling~ExecuteAnonymousResult>} [callback] - Callback function\n * @returns {Promise.<Tooling~ExecuteAnonymousResult>}\n */\nTooling.prototype.executeAnonymous = function(body, callback) {\n  var url = this._baseUrl() + \"/executeAnonymous?anonymousBody=\" + encodeURIComponent(body);\n  return this.request(url).thenCall(callback);\n};\n\n/**\n * Executes Apex tests asynchronously\n *\n * @param {Array.<String>} classids - Comma separated list of class IDs\n * @param {Callback.<Tooling~ExecuteAnonymousResult>} [callback] - Callback function\n * @returns {Promise.<Tooling~ExecuteAnonymousResult>}\n */\nTooling.prototype.runTestsAsynchronous = function(classids, callback) {\n  var url = this._baseUrl() + \"/runTestsAsynchronous/\";\n  return this._conn.requestPost(url, {classids : classids.join(',')}, undefined, callback);\n};\n\n/**\n * Executes Apex tests synchronously\n *\n * @param {Array.<String>} classnames - Comma separated list of class Names\n * @param {Callback.<Tooling~ExecuteAnonymousResult>} [callback] - Callback function\n * @returns {Promise.<Tooling~ExecuteAnonymousResult>}\n */\nTooling.prototype.runTestsSynchronous = function(classnames, callback) {\n  var url = this._baseUrl() + \"/runTestsSynchronous/\";\n  return this._conn.requestPost(url, {classnames : classnames.join(',')}, undefined, callback);\n};\n\n/**\n * @typedef {Object} Tooling~CompletionsResult\n * @prop {Object} publicDeclarations\n */\n/**\n * Retrieves available code completions of the referenced type\n *\n * @param {String} [type] - completion type (default 'apex')\n * @param {Callback.<Tooling~CompletionsResult>} [callback] - Callback function\n * @returns {Promise.<Tooling~CompletionsResult>}\n */\nTooling.prototype.completions = function(type, callback) {\n  if (!_.isString(type)) {\n    callback = type;\n    type = 'apex';\n  }\n  var url = this._baseUrl() + \"/completions?type=\" + encodeURIComponent(type);\n  return this.request(url).thenCall(callback);\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.tooling = new Tooling(conn);\n});\n\n\nmodule.exports = Tooling;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYXBpL3Rvb2xpbmcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHlEQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyx3REFBYTtBQUNqQyxZQUFZLG1CQUFPLENBQUMsMkRBQVU7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx3QkFBd0I7QUFDbkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx3QkFBd0I7QUFDbkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxrQ0FBa0M7QUFDN0MsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLDhDQUE4QztBQUN6RCxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLDhDQUE4QztBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLDhDQUE4QztBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLDhDQUE4QztBQUN6RCxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxrQ0FBa0M7QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxrQ0FBa0M7QUFDN0MsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVywyQ0FBMkM7QUFDdEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVywyQ0FBMkM7QUFDdEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw4QkFBOEI7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVywyQ0FBMkM7QUFDdEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQ0FBa0M7QUFDeEU7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsc0NBQXNDO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9hcGkvdG9vbGluZy5qcz81ZWEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgTWFuYWdlcyBUb29saW5nIEFQSXNcbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGpzZm9yY2UgPSByZXF1aXJlKCcuLi9jb3JlJyksXG4gICAgXyAgICAgPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpLFxuICAgIENhY2hlID0gcmVxdWlyZSgnLi4vY2FjaGUnKTtcblxuLyoqXG4gKiBBUEkgY2xhc3MgZm9yIFRvb2xpbmcgQVBJIGNhbGxcbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiAtIENvbm5lY3Rpb25cbiAqL1xudmFyIFRvb2xpbmcgPSBmdW5jdGlvbihjb25uKSB7XG4gIHRoaXMuX2Nvbm4gPSBjb25uO1xuICB0aGlzLl9sb2dnZXIgPSBjb25uLl9sb2dnZXI7XG4gIHZhciBkZWxlZ2F0ZXMgPSBbXG4gICAgXCJxdWVyeVwiLFxuICAgIFwicXVlcnlNb3JlXCIsXG4gICAgXCJfdG9SZWNvcmRSZXN1bHRcIixcbiAgICBcImNyZWF0ZVwiLFxuICAgIFwiX2NyZWF0ZVNpbmdsZVwiLFxuICAgIFwiX2NyZWF0ZVBhcmFsbGVsXCIsXG4gICAgXCJfY3JlYXRlTWFueVwiLFxuICAgIFwiaW5zZXJ0XCIsXG4gICAgXCJyZXRyaWV2ZVwiLFxuICAgIFwiX3JldHJpZXZlU2luZ2xlXCIsXG4gICAgXCJfcmV0cmlldmVQYXJhbGxlbFwiLFxuICAgIFwiX3JldHJpZXZlTWFueVwiLFxuICAgIFwidXBkYXRlXCIsXG4gICAgXCJfdXBkYXRlU2luZ2xlXCIsXG4gICAgXCJfdXBkYXRlUGFyYWxsZWxcIixcbiAgICBcIl91cGRhdGVNYW55XCIsXG4gICAgXCJ1cHNlcnRcIixcbiAgICBcImRlbFwiLFxuICAgIFwiZGVsZXRlXCIsXG4gICAgXCJkZXN0cm95XCIsXG4gICAgXCJfZGVzdHJveVNpbmdsZVwiLFxuICAgIFwiX2Rlc3Ryb3lQYXJhbGxlbFwiLFxuICAgIFwiX2Rlc3Ryb3lNYW55XCIsXG4gICAgXCJkZXNjcmliZVwiLFxuICAgIFwiZGVzY3JpYmVHbG9iYWxcIixcbiAgICBcInNvYmplY3RcIlxuICBdO1xuICBkZWxlZ2F0ZXMuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICB0aGlzW21ldGhvZF0gPSBjb25uLmNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2RdO1xuICB9LCB0aGlzKTtcblxuICB0aGlzLmNhY2hlID0gbmV3IENhY2hlKCk7XG5cbiAgdmFyIGNhY2hlT3B0aW9ucyA9IHtcbiAgICBrZXk6IGZ1bmN0aW9uKHR5cGUpIHsgcmV0dXJuIHR5cGUgPyBcImRlc2NyaWJlLlwiICsgdHlwZSA6IFwiZGVzY3JpYmVcIjsgfVxuICB9O1xuICB0aGlzLmRlc2NyaWJlJCA9IHRoaXMuY2FjaGUubWFrZUNhY2hlYWJsZSh0aGlzLmRlc2NyaWJlLCB0aGlzLCBjYWNoZU9wdGlvbnMpO1xuICB0aGlzLmRlc2NyaWJlID0gdGhpcy5jYWNoZS5tYWtlUmVzcG9uc2VDYWNoZWFibGUodGhpcy5kZXNjcmliZSwgdGhpcywgY2FjaGVPcHRpb25zKTtcbiAgdGhpcy5kZXNjcmliZVNPYmplY3QkID0gdGhpcy5kZXNjcmliZSQ7XG4gIHRoaXMuZGVzY3JpYmVTT2JqZWN0ID0gdGhpcy5kZXNjcmliZTtcblxuICBjYWNoZU9wdGlvbnMgPSB7IGtleTogJ2Rlc2NyaWJlR2xvYmFsJyB9O1xuICB0aGlzLmRlc2NyaWJlR2xvYmFsJCA9IHRoaXMuY2FjaGUubWFrZUNhY2hlYWJsZSh0aGlzLmRlc2NyaWJlR2xvYmFsLCB0aGlzLCBjYWNoZU9wdGlvbnMpO1xuICB0aGlzLmRlc2NyaWJlR2xvYmFsID0gdGhpcy5jYWNoZS5tYWtlUmVzcG9uc2VDYWNoZWFibGUodGhpcy5kZXNjcmliZUdsb2JhbCwgdGhpcywgY2FjaGVPcHRpb25zKTtcblxuICB0aGlzLmluaXRpYWxpemUoKTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0b29saW5nIEFQSVxuICogQHByb3RlY3RlZFxuICovXG5Ub29saW5nLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc29iamVjdHMgPSB7fTtcbiAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICB0aGlzLmNhY2hlLmdldCgnZGVzY3JpYmVHbG9iYWwnKS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3ZhbHVlJyk7XG4gIHRoaXMuY2FjaGUuZ2V0KCdkZXNjcmliZUdsb2JhbCcpLm9uKCd2YWx1ZScsIF8uYmluZChmdW5jdGlvbihyZXMpIHtcbiAgICBpZiAocmVzLnJlc3VsdCkge1xuICAgICAgdmFyIHR5cGVzID0gXy5tYXAocmVzLnJlc3VsdC5zb2JqZWN0cywgZnVuY3Rpb24oc28pIHsgcmV0dXJuIHNvLm5hbWU7IH0pO1xuICAgICAgdHlwZXMuZm9yRWFjaCh0aGlzLnNvYmplY3QsIHRoaXMpO1xuICAgIH1cbiAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5Ub29saW5nLnByb3RvdHlwZS5fYmFzZVVybCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY29ubi5fYmFzZVVybCgpICsgXCIvdG9vbGluZ1wiO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5Ub29saW5nLnByb3RvdHlwZS5fc3VwcG9ydHMgPSBmdW5jdGlvbihmZWF0dXJlKSB7XG4gIC8vIHNob3VsZCByZXR1cm4gZmFsc2UgaW4gb3JkZXIgbm90IHRvIHVzZSBjb21wc2l0ZSBjb2xsZWN0aW9uXG4gIGlmIChmZWF0dXJlID09PSAnc29iamVjdC1jb2xsZWN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fY29ubi5fc3VwcG9ydHMuYXBwbHkodGhpcy5fY29ubiwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuVG9vbGluZy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0LmFwcGx5KHRoaXMuX2Nvbm4sIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgcXVlcnkgYnkgdXNpbmcgU09RTFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzb3FsIC0gU09RTCBzdHJpbmdcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFF1ZXJ5UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UXVlcnkuPFF1ZXJ5UmVzdWx0Pn1cbiAqL1xuLyoqXG4gKiBRdWVyeSBuZXh0IHJlY29yZCBzZXQgYnkgdXNpbmcgcXVlcnkgbG9jYXRvclxuICpcbiAqIEBtZXRob2QgVG9vbGluZyNxdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IGxvY2F0b3IgLSBOZXh0IHJlY29yZCBzZXQgbG9jYXRvclxuICogQHBhcmFtIHtDYWxsYmFjay48UXVlcnlSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtRdWVyeS48UXVlcnlSZXN1bHQ+fVxuICovXG4vKipcbiAqIFJldHJpZXZlIHNwZWNpZmllZCByZWNvcmRzXG4gKlxuICogQG1ldGhvZCBUb29saW5nI3F1ZXJ5TW9yZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IFR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBpZHMgLSBBIHJlY29yZCBJRCBvciBhcnJheSBvZiByZWNvcmQgSURzXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmR8QXJyYXkuPFJlY29yZD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmR8QXJyYXkuPFJlY29yZD4+fVxuICovXG5cbi8qKlxuICogU3lub255bSBvZiBUb29saW5nI2NyZWF0ZSgpXG4gKlxuICogQG1ldGhvZCBUb29saW5nI2luc2VydFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IFR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5LjxPYmplY3Q+fSByZWNvcmRzIC0gQSByZWNvcmQgb3IgYXJyYXkgb2YgcmVjb3JkcyB0byBjcmVhdGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cbi8qKlxuICogQ3JlYXRlIHJlY29yZHNcbiAqXG4gKiBAbWV0aG9kIFRvb2xpbmcjY3JlYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtSZWNvcmR8QXJyYXkuPFJlY29yZD59IHJlY29yZHMgLSBBIHJlY29yZCBvciBhcnJheSBvZiByZWNvcmRzIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuXG4vKipcbiAqIFVwZGF0ZSByZWNvcmRzXG4gKlxuICogQG1ldGhvZCBUb29saW5nI3VwZGF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IFR5cGVcbiAqIEBwYXJhbSB7UmVjb3JkfEFycmF5LjxSZWNvcmQ+fSByZWNvcmRzIC0gQSByZWNvcmQgb3IgYXJyYXkgb2YgcmVjb3JkcyB0byB1cGRhdGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cblxuLyoqXG4gKiBVcHNlcnQgcmVjb3Jkc1xuICpcbiAqIEBtZXRob2QgVG9vbGluZyN1cHNlcnRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gU09iamVjdCBUeXBlXG4gKiBAcGFyYW0ge1JlY29yZHxBcnJheS48UmVjb3JkPn0gcmVjb3JkcyAtIFJlY29yZCBvciBhcnJheSBvZiByZWNvcmRzIHRvIHVwc2VydFxuICogQHBhcmFtIHtTdHJpbmd9IGV4dElkRmllbGQgLSBFeHRlcm5hbCBJRCBmaWVsZCBuYW1lXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2tcbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG5cbi8qKlxuICogU3lub255bSBvZiBUb29saW5nI2Rlc3Ryb3koKVxuICpcbiAqIEBtZXRob2QgVG9vbGluZyNkZWxldGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gU09iamVjdCBUeXBlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaWRzIC0gQSBJRCBvciBhcnJheSBvZiBJRHMgdG8gZGVsZXRlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2tcbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG4vKipcbiAqIFN5bm9ueW0gb2YgVG9vbGluZyNkZXN0cm95KClcbiAqXG4gKiBAbWV0aG9kIFRvb2xpbmcjZGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGlkcyAtIEEgSUQgb3IgYXJyYXkgb2YgSURzIHRvIGRlbGV0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuLyoqXG4gKiBEZWxldGUgcmVjb3Jkc1xuICpcbiAqIEBtZXRob2QgVG9vbGluZyNkZXN0cm95XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGlkcyAtIEEgSUQgb3IgYXJyYXkgb2YgSURzIHRvIGRlbGV0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuXG4vKipcbiAqIFN5bm9ueW0gb2YgVG9vbGluZyNkZXNjcmliZSgpXG4gKlxuICogQG1ldGhvZCBUb29saW5nI2Rlc2NyaWJlU09iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IFR5cGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPERlc2NyaWJlU09iamVjdFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPERlc2NyaWJlU09iamVjdFJlc3VsdD59XG4gKi9cbi8qKlxuICogRGVzY3JpYmUgU09iamVjdCBtZXRhZGF0YVxuICpcbiAqIEBtZXRob2QgVG9vbGluZyNkZXNjcmliZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IFR5cGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPERlc2NyaWJlU09iamVjdFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPERlc2NyaWJlU09iamVjdFJlc3VsdD59XG4gKi9cblxuLyoqXG4gKiBEZXNjcmliZSBnbG9iYWwgU09iamVjdHNcbiAqXG4gKiBAbWV0aG9kIFRvb2xpbmcjZGVzY3JpYmVHbG9iYWxcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPERlc2NyaWJlR2xvYmFsUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48RGVzY3JpYmVHbG9iYWxSZXN1bHQ+fVxuICovXG5cbi8qKlxuICogR2V0IFNPYmplY3QgaW5zdGFuY2VcbiAqXG4gKiBAbWV0aG9kIFRvb2xpbmcjc29iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IFR5cGVcbiAqIEByZXR1cm5zIHtTT2JqZWN0fVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVG9vbGluZ35FeGVjdXRlQW5vbnltb3VzUmVzdWx0XG4gKiBAcHJvcCB7Qm9vbGVhbn0gY29tcGlsZWQgLSBGbGFnIGlmIHRoZSBxdWVyeSBpcyBjb21waWxlZCBzdWNjZXNzZnVsbHlcbiAqIEBwcm9wIHtTdHJpbmd9IGNvbXBpbGVQcm9ibGVtIC0gRXJyb3IgcmVhc29uIGluIGNvbXBpbGF0aW9uXG4gKiBAcHJvcCB7Qm9vbGVhbn0gc3VjY2VzcyAtIEZsYWcgaWYgdGhlIGNvZGUgaXMgZXhlY3V0ZWQgc3VjY2Vzc2Z1bGx5XG4gKiBAcHJvcCB7TnVtYmVyfSBsaW5lIC0gTGluZSBudW1iZXIgZm9yIHRoZSBlcnJvclxuICogQHByb3Age051bWJlcn0gY29sdW1uIC0gQ29sdW1uIG51bWJlciBmb3IgdGhlIGVycm9yXG4gKiBAcHJvcCB7U3RyaW5nfSBleGNlcHRpb25NZXNzYWdlIC0gRXhjZXB0aW9uIG1lc3NhZ2VcbiAqIEBwcm9wIHtTdHJpbmd9IGV4Y2VwdGlvblN0YWNrVHJhY2UgLSBFeGNlcHRpb24gc3RhY2sgdHJhY2VcbiAqL1xuLyoqXG4gKiBFeGVjdXRlcyBBcGV4IGNvZGUgYW5vbnltb3VzbHlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYm9keSAtIEFub255bW91cyBBcGV4IGNvZGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFRvb2xpbmd+RXhlY3V0ZUFub255bW91c1Jlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFRvb2xpbmd+RXhlY3V0ZUFub255bW91c1Jlc3VsdD59XG4gKi9cblRvb2xpbmcucHJvdG90eXBlLmV4ZWN1dGVBbm9ueW1vdXMgPSBmdW5jdGlvbihib2R5LCBjYWxsYmFjaykge1xuICB2YXIgdXJsID0gdGhpcy5fYmFzZVVybCgpICsgXCIvZXhlY3V0ZUFub255bW91cz9hbm9ueW1vdXNCb2R5PVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGJvZHkpO1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBBcGV4IHRlc3RzIGFzeW5jaHJvbm91c2x5XG4gKlxuICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gY2xhc3NpZHMgLSBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBjbGFzcyBJRHNcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFRvb2xpbmd+RXhlY3V0ZUFub255bW91c1Jlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFRvb2xpbmd+RXhlY3V0ZUFub255bW91c1Jlc3VsdD59XG4gKi9cblRvb2xpbmcucHJvdG90eXBlLnJ1blRlc3RzQXN5bmNocm9ub3VzID0gZnVuY3Rpb24oY2xhc3NpZHMsIGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSB0aGlzLl9iYXNlVXJsKCkgKyBcIi9ydW5UZXN0c0FzeW5jaHJvbm91cy9cIjtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdFBvc3QodXJsLCB7Y2xhc3NpZHMgOiBjbGFzc2lkcy5qb2luKCcsJyl9LCB1bmRlZmluZWQsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgQXBleCB0ZXN0cyBzeW5jaHJvbm91c2x5XG4gKlxuICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gY2xhc3NuYW1lcyAtIENvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzIE5hbWVzXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxUb29saW5nfkV4ZWN1dGVBbm9ueW1vdXNSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxUb29saW5nfkV4ZWN1dGVBbm9ueW1vdXNSZXN1bHQ+fVxuICovXG5Ub29saW5nLnByb3RvdHlwZS5ydW5UZXN0c1N5bmNocm9ub3VzID0gZnVuY3Rpb24oY2xhc3NuYW1lcywgY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IHRoaXMuX2Jhc2VVcmwoKSArIFwiL3J1blRlc3RzU3luY2hyb25vdXMvXCI7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3RQb3N0KHVybCwge2NsYXNzbmFtZXMgOiBjbGFzc25hbWVzLmpvaW4oJywnKX0sIHVuZGVmaW5lZCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUb29saW5nfkNvbXBsZXRpb25zUmVzdWx0XG4gKiBAcHJvcCB7T2JqZWN0fSBwdWJsaWNEZWNsYXJhdGlvbnNcbiAqL1xuLyoqXG4gKiBSZXRyaWV2ZXMgYXZhaWxhYmxlIGNvZGUgY29tcGxldGlvbnMgb2YgdGhlIHJlZmVyZW5jZWQgdHlwZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gLSBjb21wbGV0aW9uIHR5cGUgKGRlZmF1bHQgJ2FwZXgnKVxuICogQHBhcmFtIHtDYWxsYmFjay48VG9vbGluZ35Db21wbGV0aW9uc1Jlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFRvb2xpbmd+Q29tcGxldGlvbnNSZXN1bHQ+fVxuICovXG5Ub29saW5nLnByb3RvdHlwZS5jb21wbGV0aW9ucyA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICghXy5pc1N0cmluZyh0eXBlKSkge1xuICAgIGNhbGxiYWNrID0gdHlwZTtcbiAgICB0eXBlID0gJ2FwZXgnO1xuICB9XG4gIHZhciB1cmwgPSB0aGlzLl9iYXNlVXJsKCkgKyBcIi9jb21wbGV0aW9ucz90eXBlPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHR5cGUpO1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qXG4gKiBSZWdpc3RlciBob29rIGluIGNvbm5lY3Rpb24gaW5zdGFudGlhdGlvbiBmb3IgZHluYW1pY2FsbHkgYWRkaW5nIHRoaXMgQVBJIG1vZHVsZSBmZWF0dXJlc1xuICovXG5qc2ZvcmNlLm9uKCdjb25uZWN0aW9uOm5ldycsIGZ1bmN0aW9uKGNvbm4pIHtcbiAgY29ubi50b29saW5nID0gbmV3IFRvb2xpbmcoY29ubik7XG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRvb2xpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/api/tooling.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/browser/canvas.js":
/*!****************************************************!*\
  !*** ./node_modules/jsforce/lib/browser/canvas.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global Sfdc */\n\n\nvar Duplex = (__webpack_require__(/*! readable-stream */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/readable.js\").Duplex),\n    _ = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\");\n\nfunction parseHeaders(hs) {\n  var headers = {};\n  hs.split(/\\n/).forEach(function(line) {\n    var pair = line.split(/\\s*:\\s*/);\n    var name = pair[0].toLowerCase();\n    var value = pair[1];\n    headers[name] = value;\n  });\n  return headers;\n}\n\nmodule.exports = {\n\n  supported: typeof Sfdc === 'object' && typeof Sfdc.canvas !== 'undefined',\n\n  createRequest: function(signedRequest) {\n    return function(params, callback) {\n      var response;\n      var str = new Duplex();\n      str._read = function(size) {\n        if (response) {\n          str.push(response.body);\n        }\n      };\n      var bufs = [];\n      var sent = false;\n      str._write = function(chunk, encoding, callback) {\n        bufs.push(chunk.toString(encoding));\n        callback();\n      };\n      str.on('finish', function() {\n        if (!sent) {\n          send(bufs.join(''));\n          sent = true;\n        }\n      });\n      if (params.body || params.body === \"\" || !/^(put|post|patch)$/i.test(params.method)) {\n        send(params.body);\n        sent = true;\n      }\n\n      function send(body) {\n        var settings = {\n          client: signedRequest.client,\n          method: params.method,\n          data: body\n        };\n        if (params.headers) {\n          settings.headers = {};\n          for (var name in params.headers) {\n            if (name.toLowerCase() === 'content-type') {\n              settings.contentType = params.headers[name];\n            } else {\n              settings.headers[name] = params.headers[name];\n            }\n          }\n        }\n        settings.success = function(data) {\n          var headers = parseHeaders(data.responseHeaders);\n          var body = data.payload;\n          if (!_.isString(body)) {\n            body = JSON.stringify(body);\n          }\n          response = {\n            statusCode : data.status,\n            headers: headers,\n            body: body\n          };\n          if (callback) {\n            callback(null, response, response.body);\n          }\n          str.end();\n        };\n        settings.failure = function(err) {\n          if (callback) {\n            callback(err);\n          }\n        };\n        Sfdc.canvas.client.ajax(params.url, settings);\n      }\n      return str;\n    };\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9icm93c2VyL2NhbnZhcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLGFBQWEsdUlBQWlDO0FBQzlDLFFBQVEsbUJBQU8sQ0FBQyxtRUFBYTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2Jyb3dzZXIvY2FudmFzLmpzP2MxMDMiXSwic291cmNlc0NvbnRlbnQiOlsiLypnbG9iYWwgU2ZkYyAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuRHVwbGV4LFxuICAgIF8gPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpO1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMoaHMpIHtcbiAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgaHMuc3BsaXQoL1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgIHZhciBwYWlyID0gbGluZS5zcGxpdCgvXFxzKjpcXHMqLyk7XG4gICAgdmFyIG5hbWUgPSBwYWlyWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHZhbHVlID0gcGFpclsxXTtcbiAgICBoZWFkZXJzW25hbWVdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gaGVhZGVycztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgc3VwcG9ydGVkOiB0eXBlb2YgU2ZkYyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIFNmZGMuY2FudmFzICE9PSAndW5kZWZpbmVkJyxcblxuICBjcmVhdGVSZXF1ZXN0OiBmdW5jdGlvbihzaWduZWRSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgIHZhciByZXNwb25zZTtcbiAgICAgIHZhciBzdHIgPSBuZXcgRHVwbGV4KCk7XG4gICAgICBzdHIuX3JlYWQgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgIHN0ci5wdXNoKHJlc3BvbnNlLmJvZHkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGJ1ZnMgPSBbXTtcbiAgICAgIHZhciBzZW50ID0gZmFsc2U7XG4gICAgICBzdHIuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBidWZzLnB1c2goY2h1bmsudG9TdHJpbmcoZW5jb2RpbmcpKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH07XG4gICAgICBzdHIub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbnQpIHtcbiAgICAgICAgICBzZW5kKGJ1ZnMuam9pbignJykpO1xuICAgICAgICAgIHNlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChwYXJhbXMuYm9keSB8fCBwYXJhbXMuYm9keSA9PT0gXCJcIiB8fCAhL14ocHV0fHBvc3R8cGF0Y2gpJC9pLnRlc3QocGFyYW1zLm1ldGhvZCkpIHtcbiAgICAgICAgc2VuZChwYXJhbXMuYm9keSk7XG4gICAgICAgIHNlbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZW5kKGJvZHkpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0ge1xuICAgICAgICAgIGNsaWVudDogc2lnbmVkUmVxdWVzdC5jbGllbnQsXG4gICAgICAgICAgbWV0aG9kOiBwYXJhbXMubWV0aG9kLFxuICAgICAgICAgIGRhdGE6IGJvZHlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBhcmFtcy5oZWFkZXJzKSB7XG4gICAgICAgICAgc2V0dGluZ3MuaGVhZGVycyA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gcGFyYW1zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgICAgIHNldHRpbmdzLmNvbnRlbnRUeXBlID0gcGFyYW1zLmhlYWRlcnNbbmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXR0aW5ncy5oZWFkZXJzW25hbWVdID0gcGFyYW1zLmhlYWRlcnNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldHRpbmdzLnN1Y2Nlc3MgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgdmFyIGhlYWRlcnMgPSBwYXJzZUhlYWRlcnMoZGF0YS5yZXNwb25zZUhlYWRlcnMpO1xuICAgICAgICAgIHZhciBib2R5ID0gZGF0YS5wYXlsb2FkO1xuICAgICAgICAgIGlmICghXy5pc1N0cmluZyhib2R5KSkge1xuICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGUgOiBkYXRhLnN0YXR1cyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlLCByZXNwb25zZS5ib2R5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyLmVuZCgpO1xuICAgICAgICB9O1xuICAgICAgICBzZXR0aW5ncy5mYWlsdXJlID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU2ZkYy5jYW52YXMuY2xpZW50LmFqYXgocGFyYW1zLnVybCwgc2V0dGluZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/browser/canvas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/browser/canvas.js":
/*!****************************************************!*\
  !*** ./node_modules/jsforce/lib/browser/canvas.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global Sfdc */\n\n\nvar Duplex = (__webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/readable.js\").Duplex),\n    _ = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\");\n\nfunction parseHeaders(hs) {\n  var headers = {};\n  hs.split(/\\n/).forEach(function(line) {\n    var pair = line.split(/\\s*:\\s*/);\n    var name = pair[0].toLowerCase();\n    var value = pair[1];\n    headers[name] = value;\n  });\n  return headers;\n}\n\nmodule.exports = {\n\n  supported: typeof Sfdc === 'object' && typeof Sfdc.canvas !== 'undefined',\n\n  createRequest: function(signedRequest) {\n    return function(params, callback) {\n      var response;\n      var str = new Duplex();\n      str._read = function(size) {\n        if (response) {\n          str.push(response.body);\n        }\n      };\n      var bufs = [];\n      var sent = false;\n      str._write = function(chunk, encoding, callback) {\n        bufs.push(chunk.toString(encoding));\n        callback();\n      };\n      str.on('finish', function() {\n        if (!sent) {\n          send(bufs.join(''));\n          sent = true;\n        }\n      });\n      if (params.body || params.body === \"\" || !/^(put|post|patch)$/i.test(params.method)) {\n        send(params.body);\n        sent = true;\n      }\n\n      function send(body) {\n        var settings = {\n          client: signedRequest.client,\n          method: params.method,\n          data: body\n        };\n        if (params.headers) {\n          settings.headers = {};\n          for (var name in params.headers) {\n            if (name.toLowerCase() === 'content-type') {\n              settings.contentType = params.headers[name];\n            } else {\n              settings.headers[name] = params.headers[name];\n            }\n          }\n        }\n        settings.success = function(data) {\n          var headers = parseHeaders(data.responseHeaders);\n          var body = data.payload;\n          if (!_.isString(body)) {\n            body = JSON.stringify(body);\n          }\n          response = {\n            statusCode : data.status,\n            headers: headers,\n            body: body\n          };\n          if (callback) {\n            callback(null, response, response.body);\n          }\n          str.end();\n        };\n        settings.failure = function(err) {\n          if (callback) {\n            callback(err);\n          }\n        };\n        Sfdc.canvas.client.ajax(params.url, settings);\n      }\n      return str;\n    };\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYnJvd3Nlci9jYW52YXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYixhQUFhLDRIQUFpQztBQUM5QyxRQUFRLG1CQUFPLENBQUMsd0RBQWE7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9icm93c2VyL2NhbnZhcy5qcz9iZjIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIFNmZGMgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLkR1cGxleCxcbiAgICBfID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKTtcblxuZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhzKSB7XG4gIHZhciBoZWFkZXJzID0ge307XG4gIGhzLnNwbGl0KC9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB2YXIgcGFpciA9IGxpbmUuc3BsaXQoL1xccyo6XFxzKi8pO1xuICAgIHZhciBuYW1lID0gcGFpclswXS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciB2YWx1ZSA9IHBhaXJbMV07XG4gICAgaGVhZGVyc1tuYW1lXSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIHN1cHBvcnRlZDogdHlwZW9mIFNmZGMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBTZmRjLmNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY3JlYXRlUmVxdWVzdDogZnVuY3Rpb24oc2lnbmVkUmVxdWVzdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcmVzcG9uc2U7XG4gICAgICB2YXIgc3RyID0gbmV3IER1cGxleCgpO1xuICAgICAgc3RyLl9yZWFkID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICBzdHIucHVzaChyZXNwb25zZS5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBidWZzID0gW107XG4gICAgICB2YXIgc2VudCA9IGZhbHNlO1xuICAgICAgc3RyLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgYnVmcy5wdXNoKGNodW5rLnRvU3RyaW5nKGVuY29kaW5nKSk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9O1xuICAgICAgc3RyLm9uKCdmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFzZW50KSB7XG4gICAgICAgICAgc2VuZChidWZzLmpvaW4oJycpKTtcbiAgICAgICAgICBzZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocGFyYW1zLmJvZHkgfHwgcGFyYW1zLmJvZHkgPT09IFwiXCIgfHwgIS9eKHB1dHxwb3N0fHBhdGNoKSQvaS50ZXN0KHBhcmFtcy5tZXRob2QpKSB7XG4gICAgICAgIHNlbmQocGFyYW1zLmJvZHkpO1xuICAgICAgICBzZW50ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2VuZChib2R5KSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHtcbiAgICAgICAgICBjbGllbnQ6IHNpZ25lZFJlcXVlc3QuY2xpZW50LFxuICAgICAgICAgIG1ldGhvZDogcGFyYW1zLm1ldGhvZCxcbiAgICAgICAgICBkYXRhOiBib2R5XG4gICAgICAgIH07XG4gICAgICAgIGlmIChwYXJhbXMuaGVhZGVycykge1xuICAgICAgICAgIHNldHRpbmdzLmhlYWRlcnMgPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHBhcmFtcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgICAgICBzZXR0aW5ncy5jb250ZW50VHlwZSA9IHBhcmFtcy5oZWFkZXJzW25hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3MuaGVhZGVyc1tuYW1lXSA9IHBhcmFtcy5oZWFkZXJzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXR0aW5ncy5zdWNjZXNzID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIHZhciBoZWFkZXJzID0gcGFyc2VIZWFkZXJzKGRhdGEucmVzcG9uc2VIZWFkZXJzKTtcbiAgICAgICAgICB2YXIgYm9keSA9IGRhdGEucGF5bG9hZDtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcoYm9keSkpIHtcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICBzdGF0dXNDb2RlIDogZGF0YS5zdGF0dXMsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXNwb25zZSwgcmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ci5lbmQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2V0dGluZ3MuZmFpbHVyZSA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFNmZGMuY2FudmFzLmNsaWVudC5hamF4KHBhcmFtcy51cmwsIHNldHRpbmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/browser/canvas.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/browser/jsonp.js":
/*!***************************************************!*\
  !*** ./node_modules/jsforce/lib/browser/jsonp.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("/*global window, document */\n\n\nvar _index = 0;\n\nmodule.exports = {\n\n  supported: typeof window !== 'undefined' && typeof document !== 'undefined',\n\n  createRequest: function(jsonpParam, timeout) {\n    jsonpParam = jsonpParam || 'callback';\n    timeout = timeout || 10000;\n\n    return function(params, callback) {\n      if (params.method.toUpperCase() !== 'GET') {\n        return callback(new Error('JSONP only supports GET request.'));\n      }\n      var cbFuncName = '_jsforce_jsonpCallback_' + (++_index);\n      var callbacks = window;\n      var url = params.url;\n      url += url.indexOf('?')>0 ? '&' : '?';\n      url += jsonpParam + '=' + cbFuncName;\n\n      var script = document.createElement('script');\n      script.type = 'text/javascript';\n      script.src = url;\n      document.documentElement.appendChild(script);\n\n      var pid = setTimeout(function() {\n        cleanup();\n        callback(new Error(\"JSONP call time out.\"));\n      }, timeout);\n\n      callbacks[cbFuncName] = function(res) {\n        cleanup();\n        callback(null, {\n          statusCode: 200,\n          headers: { \"content-type\": \"application/json\" },\n          body: JSON.stringify(res)\n        });\n      };\n\n      var cleanup = function() {\n        clearTimeout(pid);\n        document.documentElement.removeChild(script);\n        delete callbacks[cbFuncName];\n      };\n    };\n\n  }\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9icm93c2VyL2pzb25wLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9DQUFvQztBQUN6RDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2Jyb3dzZXIvanNvbnAuanM/Y2NhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCB3aW5kb3csIGRvY3VtZW50ICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfaW5kZXggPSAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBzdXBwb3J0ZWQ6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY3JlYXRlUmVxdWVzdDogZnVuY3Rpb24oanNvbnBQYXJhbSwgdGltZW91dCkge1xuICAgIGpzb25wUGFyYW0gPSBqc29ucFBhcmFtIHx8ICdjYWxsYmFjayc7XG4gICAgdGltZW91dCA9IHRpbWVvdXQgfHwgMTAwMDA7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHBhcmFtcy5tZXRob2QudG9VcHBlckNhc2UoKSAhPT0gJ0dFVCcpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignSlNPTlAgb25seSBzdXBwb3J0cyBHRVQgcmVxdWVzdC4nKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2JGdW5jTmFtZSA9ICdfanNmb3JjZV9qc29ucENhbGxiYWNrXycgKyAoKytfaW5kZXgpO1xuICAgICAgdmFyIGNhbGxiYWNrcyA9IHdpbmRvdztcbiAgICAgIHZhciB1cmwgPSBwYXJhbXMudXJsO1xuICAgICAgdXJsICs9IHVybC5pbmRleE9mKCc/Jyk+MCA/ICcmJyA6ICc/JztcbiAgICAgIHVybCArPSBqc29ucFBhcmFtICsgJz0nICsgY2JGdW5jTmFtZTtcblxuICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblxuICAgICAgdmFyIHBpZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKFwiSlNPTlAgY2FsbCB0aW1lIG91dC5cIikpO1xuICAgICAgfSwgdGltZW91dCk7XG5cbiAgICAgIGNhbGxiYWNrc1tjYkZ1bmNOYW1lXSA9IGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgICAgaGVhZGVyczogeyBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcylcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQocGlkKTtcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgIGRlbGV0ZSBjYWxsYmFja3NbY2JGdW5jTmFtZV07XG4gICAgICB9O1xuICAgIH07XG5cbiAgfVxuXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/browser/jsonp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/browser/jsonp.js":
/*!***************************************************!*\
  !*** ./node_modules/jsforce/lib/browser/jsonp.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("/*global window, document */\n\n\nvar _index = 0;\n\nmodule.exports = {\n\n  supported: typeof window !== 'undefined' && typeof document !== 'undefined',\n\n  createRequest: function(jsonpParam, timeout) {\n    jsonpParam = jsonpParam || 'callback';\n    timeout = timeout || 10000;\n\n    return function(params, callback) {\n      if (params.method.toUpperCase() !== 'GET') {\n        return callback(new Error('JSONP only supports GET request.'));\n      }\n      var cbFuncName = '_jsforce_jsonpCallback_' + (++_index);\n      var callbacks = window;\n      var url = params.url;\n      url += url.indexOf('?')>0 ? '&' : '?';\n      url += jsonpParam + '=' + cbFuncName;\n\n      var script = document.createElement('script');\n      script.type = 'text/javascript';\n      script.src = url;\n      document.documentElement.appendChild(script);\n\n      var pid = setTimeout(function() {\n        cleanup();\n        callback(new Error(\"JSONP call time out.\"));\n      }, timeout);\n\n      callbacks[cbFuncName] = function(res) {\n        cleanup();\n        callback(null, {\n          statusCode: 200,\n          headers: { \"content-type\": \"application/json\" },\n          body: JSON.stringify(res)\n        });\n      };\n\n      var cleanup = function() {\n        clearTimeout(pid);\n        document.documentElement.removeChild(script);\n        delete callbacks[cbFuncName];\n      };\n    };\n\n  }\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvYnJvd3Nlci9qc29ucC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQ0FBb0M7QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9icm93c2VyL2pzb25wLmpzPzMyMGYiXSwic291cmNlc0NvbnRlbnQiOlsiLypnbG9iYWwgd2luZG93LCBkb2N1bWVudCAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2luZGV4ID0gMDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgc3VwcG9ydGVkOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNyZWF0ZVJlcXVlc3Q6IGZ1bmN0aW9uKGpzb25wUGFyYW0sIHRpbWVvdXQpIHtcbiAgICBqc29ucFBhcmFtID0ganNvbnBQYXJhbSB8fCAnY2FsbGJhY2snO1xuICAgIHRpbWVvdXQgPSB0aW1lb3V0IHx8IDEwMDAwO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChwYXJhbXMubWV0aG9kLnRvVXBwZXJDYXNlKCkgIT09ICdHRVQnKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0pTT05QIG9ubHkgc3VwcG9ydHMgR0VUIHJlcXVlc3QuJykpO1xuICAgICAgfVxuICAgICAgdmFyIGNiRnVuY05hbWUgPSAnX2pzZm9yY2VfanNvbnBDYWxsYmFja18nICsgKCsrX2luZGV4KTtcbiAgICAgIHZhciBjYWxsYmFja3MgPSB3aW5kb3c7XG4gICAgICB2YXIgdXJsID0gcGFyYW1zLnVybDtcbiAgICAgIHVybCArPSB1cmwuaW5kZXhPZignPycpPjAgPyAnJicgOiAnPyc7XG4gICAgICB1cmwgKz0ganNvbnBQYXJhbSArICc9JyArIGNiRnVuY05hbWU7XG5cbiAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cbiAgICAgIHZhciBwaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcIkpTT05QIGNhbGwgdGltZSBvdXQuXCIpKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgICBjYWxsYmFja3NbY2JGdW5jTmFtZV0gPSBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICAgIGhlYWRlcnM6IHsgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXMpXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHBpZCk7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICBkZWxldGUgY2FsbGJhY2tzW2NiRnVuY05hbWVdO1xuICAgICAgfTtcbiAgICB9O1xuXG4gIH1cblxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/browser/jsonp.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/cache.js":
/*!*******************************************!*\
  !*** ./node_modules/jsforce/lib/cache.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages asynchronous method response cache\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar events = __webpack_require__(/*! events */ \"events\"),\n    inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\"),\n    _      = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\");\n\n/**\n * Class for managing cache entry\n *\n * @private\n * @class\n * @constructor\n * @template T\n */\nvar CacheEntry = function() {\n  this.fetching = false;\n};\n\ninherits(CacheEntry, events.EventEmitter);\n\n/**\n * Get value in the cache entry\n *\n * @param {Callback.<T>} [callback] - Callback function callbacked the cache entry updated\n * @returns {T|undefined}\n */\nCacheEntry.prototype.get = function(callback) {\n  if (!callback) {\n    return this._value;\n  } else {\n    this.once('value', callback);\n    if (!_.isUndefined(this._value)) {\n      this.emit('value', this._value);\n    }\n  }\n};\n\n/**\n * Set value in the cache entry\n *\n * @param {T} [value] - A value for caching\n */\nCacheEntry.prototype.set = function(value) {\n  this._value = value;\n  this.emit('value', this._value);\n};\n\n/**\n * Clear cached value\n */\nCacheEntry.prototype.clear = function() {\n  this.fetching = false;\n  delete this._value;\n};\n\n\n/**\n * Caching manager for async methods\n *\n * @class\n * @constructor\n */\nvar Cache = function() {\n  this._entries = {};\n};\n\n/**\n * retrive cache entry, or create if not exists.\n *\n * @param {String} [key] - Key of cache entry\n * @returns {CacheEntry}\n */\nCache.prototype.get = function(key) {\n  if (key && this._entries[key]) {\n    return this._entries[key];\n  } else {\n    var entry = new CacheEntry();\n    this._entries[key] = entry;\n    return entry;\n  }\n};\n\n/**\n * clear cache entries prefix matching given key\n * @param {String} [key] - Key prefix of cache entry to clear\n */\nCache.prototype.clear = function(key) {\n  for (var k in this._entries) {\n    if (!key || k.indexOf(key) === 0) {\n      this._entries[k].clear();\n    }\n  }\n};\n\n/**\n * create and return cache key from namespace and serialized arguments.\n * @private\n */\nfunction createCacheKey(namespace, args) {\n  args = Array.prototype.slice.apply(args);\n  return namespace + '(' + _.map(args, function(a){ return JSON.stringify(a); }).join(',') + ')';\n}\n\n/**\n * Enable caching for async call fn to intercept the response and store it to cache.\n * The original async calll fn is always invoked.\n *\n * @protected\n * @param {Function} fn - Function to covert cacheable\n * @param {Object} [scope] - Scope of function call\n * @param {Object} [options] - Options\n * @return {Function} - Cached version of function\n */\nCache.prototype.makeResponseCacheable = function(fn, scope, options) {\n  var cache = this;\n  options = options || {};\n  return function() {\n    var args = Array.prototype.slice.apply(arguments);\n    var callback = args.pop();\n    if (!_.isFunction(callback)) {\n      args.push(callback);\n      callback = null;\n    }\n    var keys = _.isString(options.key) ? options.key :\n               _.isFunction(options.key) ? options.key.apply(scope, args) :\n               createCacheKey(options.namespace, args);\n    if (!Array.isArray(keys)) { keys = [ keys ]; }\n    var entries = [];\n    keys.forEach(function (key) {\n      var entry = cache.get(key);\n      entry.fetching = true;\n      entries.push(entry);\n    })\n    if (callback) {\n      args.push(function(err, result) {\n        if (Array.isArray(result) && result.length == entries.length) {\n          entries.forEach(function (entry, index) {\n            entry.set({ error: err, result: result[index] });\n          })\n        } else {\n          entries.forEach(function (entry) {\n            entry.set({ error: err, result: result });\n          });\n        }\n        callback(err, result);\n      });\n    }\n    var ret, error;\n    try {\n      ret = fn.apply(scope || this, args);\n    } catch(e) {\n      error = e;\n    }\n    if (ret && _.isFunction(ret.then)) { // if the returned value is promise\n      if (!callback) {\n        return ret.then(function(result) {\n          if (Array.isArray(result) && result.length == entries.length) {\n            entries.forEach(function (entry, index) {\n              entry.set({ error: undefined, result: result[index] });\n            })\n          } else {\n            entries.forEach(function (entry) {\n              entry.set({ error: undefined, result: result });\n            });\n          }\n          return result;\n        }, function(err) {\n          if (Array.isArray(err) && err.length == entries.length) {\n            entries.forEach(function (entry, index) {\n              entry.set({ error: err[index], result: undefined });\n            })\n          } else {\n            entries.forEach(function (entry) {\n              entry.set({ error: err, result: undefined });\n            });\n          }\n          throw err;\n        });\n      } else {\n        return ret;\n      }\n    } else {\n      if (Array.isArray(ret) && ret.length == entries.length) {\n        entries.forEach(function (entry, index) {\n          entry.set({ error: error, result: ret[index] });\n        })\n      } else {\n        entries.forEach(function (entry) {\n          entry.set({ error: error, result: ret });\n        });\n      }\n      if (error) { throw error; }\n      return ret;\n    }\n  };\n};\n\n/**\n * Enable caching for async call fn to lookup the response cache first, then invoke original if no cached value.\n *\n * @protected\n * @param {Function} fn - Function to covert cacheable\n * @param {Object} [scope] - Scope of function call\n * @param {Object} [options] - Options\n * @return {Function} - Cached version of function\n */\nCache.prototype.makeCacheable = function(fn, scope, options) {\n  var cache = this;\n  options = options || {};\n  var $fn = function() {\n    var args = Array.prototype.slice.apply(arguments);\n    var callback = args.pop();\n    if (!_.isFunction(callback)) {\n      args.push(callback);\n    }\n    var key = _.isString(options.key) ? options.key :\n              _.isFunction(options.key) ? options.key.apply(scope, args) :\n              createCacheKey(options.namespace, args);\n    var entry = cache.get(key);\n    if (!_.isFunction(callback)) { // if callback is not given in last arg, return cached result (immediate).\n      var value = entry.get();\n      if (!value) { throw new Error('Function call result is not cached yet.'); }\n      if (value.error) { throw value.error; }\n      return value.result;\n    }\n    entry.get(function(value) {\n      callback(value.error, value.result);\n    });\n    if (!entry.fetching) { // only when no other client is calling function\n      entry.fetching = true;\n      args.push(function(err, result) {\n        entry.set({ error: err, result: result });\n      });\n      fn.apply(scope || this, args);\n    }\n  };\n  $fn.clear = function() {\n    var key = _.isString(options.key) ? options.key :\n              _.isFunction(options.key) ? options.key.apply(scope, arguments) :\n              createCacheKey(options.namespace, arguments);\n    cache.clear(key);\n  };\n  return $fn;\n};\n\n\nmodule.exports = Cache;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsZUFBZSxtQkFBTyxDQUFDLHNFQUFVO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxtRUFBYTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsMkJBQTJCO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1DQUFtQztBQUMzRCxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRCxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlDQUF5QztBQUNuRSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RCxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCLHNDQUFzQztBQUNoRSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0EsMEJBQTBCLCtCQUErQjtBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esc0JBQXNCLGtDQUFrQztBQUN4RCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRCxTQUFTO0FBQ1Q7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvY2FjaGUuanM/OWUyMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIE1hbmFnZXMgYXN5bmNocm9ub3VzIG1ldGhvZCByZXNwb25zZSBjYWNoZVxuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyksXG4gICAgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgIF8gICAgICA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyk7XG5cbi8qKlxuICogQ2xhc3MgZm9yIG1hbmFnaW5nIGNhY2hlIGVudHJ5XG4gKlxuICogQHByaXZhdGVcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAdGVtcGxhdGUgVFxuICovXG52YXIgQ2FjaGVFbnRyeSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmZldGNoaW5nID0gZmFsc2U7XG59O1xuXG5pbmhlcml0cyhDYWNoZUVudHJ5LCBldmVudHMuRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBHZXQgdmFsdWUgaW4gdGhlIGNhY2hlIGVudHJ5XG4gKlxuICogQHBhcmFtIHtDYWxsYmFjay48VD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvbiBjYWxsYmFja2VkIHRoZSBjYWNoZSBlbnRyeSB1cGRhdGVkXG4gKiBAcmV0dXJucyB7VHx1bmRlZmluZWR9XG4gKi9cbkNhY2hlRW50cnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vbmNlKCd2YWx1ZScsIGNhbGxiYWNrKTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQodGhpcy5fdmFsdWUpKSB7XG4gICAgICB0aGlzLmVtaXQoJ3ZhbHVlJywgdGhpcy5fdmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgdmFsdWUgaW4gdGhlIGNhY2hlIGVudHJ5XG4gKlxuICogQHBhcmFtIHtUfSBbdmFsdWVdIC0gQSB2YWx1ZSBmb3IgY2FjaGluZ1xuICovXG5DYWNoZUVudHJ5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmVtaXQoJ3ZhbHVlJywgdGhpcy5fdmFsdWUpO1xufTtcblxuLyoqXG4gKiBDbGVhciBjYWNoZWQgdmFsdWVcbiAqL1xuQ2FjaGVFbnRyeS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5mZXRjaGluZyA9IGZhbHNlO1xuICBkZWxldGUgdGhpcy5fdmFsdWU7XG59O1xuXG5cbi8qKlxuICogQ2FjaGluZyBtYW5hZ2VyIGZvciBhc3luYyBtZXRob2RzXG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENhY2hlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2VudHJpZXMgPSB7fTtcbn07XG5cbi8qKlxuICogcmV0cml2ZSBjYWNoZSBlbnRyeSwgb3IgY3JlYXRlIGlmIG5vdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldIC0gS2V5IG9mIGNhY2hlIGVudHJ5XG4gKiBAcmV0dXJucyB7Q2FjaGVFbnRyeX1cbiAqL1xuQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICBpZiAoa2V5ICYmIHRoaXMuX2VudHJpZXNba2V5XSkge1xuICAgIHJldHVybiB0aGlzLl9lbnRyaWVzW2tleV07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVudHJ5ID0gbmV3IENhY2hlRW50cnkoKTtcbiAgICB0aGlzLl9lbnRyaWVzW2tleV0gPSBlbnRyeTtcbiAgICByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbi8qKlxuICogY2xlYXIgY2FjaGUgZW50cmllcyBwcmVmaXggbWF0Y2hpbmcgZ2l2ZW4ga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gW2tleV0gLSBLZXkgcHJlZml4IG9mIGNhY2hlIGVudHJ5IHRvIGNsZWFyXG4gKi9cbkNhY2hlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKGtleSkge1xuICBmb3IgKHZhciBrIGluIHRoaXMuX2VudHJpZXMpIHtcbiAgICBpZiAoIWtleSB8fCBrLmluZGV4T2Yoa2V5KSA9PT0gMCkge1xuICAgICAgdGhpcy5fZW50cmllc1trXS5jbGVhcigpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBjcmVhdGUgYW5kIHJldHVybiBjYWNoZSBrZXkgZnJvbSBuYW1lc3BhY2UgYW5kIHNlcmlhbGl6ZWQgYXJndW1lbnRzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGVLZXkobmFtZXNwYWNlLCBhcmdzKSB7XG4gIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJncyk7XG4gIHJldHVybiBuYW1lc3BhY2UgKyAnKCcgKyBfLm1hcChhcmdzLCBmdW5jdGlvbihhKXsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpOyB9KS5qb2luKCcsJykgKyAnKSc7XG59XG5cbi8qKlxuICogRW5hYmxlIGNhY2hpbmcgZm9yIGFzeW5jIGNhbGwgZm4gdG8gaW50ZXJjZXB0IHRoZSByZXNwb25zZSBhbmQgc3RvcmUgaXQgdG8gY2FjaGUuXG4gKiBUaGUgb3JpZ2luYWwgYXN5bmMgY2FsbGwgZm4gaXMgYWx3YXlzIGludm9rZWQuXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBGdW5jdGlvbiB0byBjb3ZlcnQgY2FjaGVhYmxlXG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIFNjb3BlIG9mIGZ1bmN0aW9uIGNhbGxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSBDYWNoZWQgdmVyc2lvbiBvZiBmdW5jdGlvblxuICovXG5DYWNoZS5wcm90b3R5cGUubWFrZVJlc3BvbnNlQ2FjaGVhYmxlID0gZnVuY3Rpb24oZm4sIHNjb3BlLCBvcHRpb25zKSB7XG4gIHZhciBjYWNoZSA9IHRoaXM7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKTtcbiAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIGtleXMgPSBfLmlzU3RyaW5nKG9wdGlvbnMua2V5KSA/IG9wdGlvbnMua2V5IDpcbiAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihvcHRpb25zLmtleSkgPyBvcHRpb25zLmtleS5hcHBseShzY29wZSwgYXJncykgOlxuICAgICAgICAgICAgICAgY3JlYXRlQ2FjaGVLZXkob3B0aW9ucy5uYW1lc3BhY2UsIGFyZ3MpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkgeyBrZXlzID0gWyBrZXlzIF07IH1cbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgZW50cnkgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgIGVudHJ5LmZldGNoaW5nID0gdHJ1ZTtcbiAgICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgfSlcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGFyZ3MucHVzaChmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5sZW5ndGggPT0gZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xuICAgICAgICAgICAgZW50cnkuc2V0KHsgZXJyb3I6IGVyciwgcmVzdWx0OiByZXN1bHRbaW5kZXhdIH0pO1xuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgZW50cnkuc2V0KHsgZXJyb3I6IGVyciwgcmVzdWx0OiByZXN1bHQgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciByZXQsIGVycm9yO1xuICAgIHRyeSB7XG4gICAgICByZXQgPSBmbi5hcHBseShzY29wZSB8fCB0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGVycm9yID0gZTtcbiAgICB9XG4gICAgaWYgKHJldCAmJiBfLmlzRnVuY3Rpb24ocmV0LnRoZW4pKSB7IC8vIGlmIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBwcm9taXNlXG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiByZXQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5sZW5ndGggPT0gZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XG4gICAgICAgICAgICAgIGVudHJ5LnNldCh7IGVycm9yOiB1bmRlZmluZWQsIHJlc3VsdDogcmVzdWx0W2luZGV4XSB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgZW50cnkuc2V0KHsgZXJyb3I6IHVuZGVmaW5lZCwgcmVzdWx0OiByZXN1bHQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXJyKSAmJiBlcnIubGVuZ3RoID09IGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xuICAgICAgICAgICAgICBlbnRyeS5zZXQoeyBlcnJvcjogZXJyW2luZGV4XSwgcmVzdWx0OiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIGVudHJ5LnNldCh7IGVycm9yOiBlcnIsIHJlc3VsdDogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXQpICYmIHJldC5sZW5ndGggPT0gZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcbiAgICAgICAgICBlbnRyeS5zZXQoeyBlcnJvcjogZXJyb3IsIHJlc3VsdDogcmV0W2luZGV4XSB9KTtcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICBlbnRyeS5zZXQoeyBlcnJvcjogZXJyb3IsIHJlc3VsdDogcmV0IH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcikgeyB0aHJvdyBlcnJvcjsgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEVuYWJsZSBjYWNoaW5nIGZvciBhc3luYyBjYWxsIGZuIHRvIGxvb2t1cCB0aGUgcmVzcG9uc2UgY2FjaGUgZmlyc3QsIHRoZW4gaW52b2tlIG9yaWdpbmFsIGlmIG5vIGNhY2hlZCB2YWx1ZS5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIEZ1bmN0aW9uIHRvIGNvdmVydCBjYWNoZWFibGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIC0gU2NvcGUgb2YgZnVuY3Rpb24gY2FsbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIENhY2hlZCB2ZXJzaW9uIG9mIGZ1bmN0aW9uXG4gKi9cbkNhY2hlLnByb3RvdHlwZS5tYWtlQ2FjaGVhYmxlID0gZnVuY3Rpb24oZm4sIHNjb3BlLCBvcHRpb25zKSB7XG4gIHZhciBjYWNoZSA9IHRoaXM7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgJGZuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKTtcbiAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgdmFyIGtleSA9IF8uaXNTdHJpbmcob3B0aW9ucy5rZXkpID8gb3B0aW9ucy5rZXkgOlxuICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24ob3B0aW9ucy5rZXkpID8gb3B0aW9ucy5rZXkuYXBwbHkoc2NvcGUsIGFyZ3MpIDpcbiAgICAgICAgICAgICAgY3JlYXRlQ2FjaGVLZXkob3B0aW9ucy5uYW1lc3BhY2UsIGFyZ3MpO1xuICAgIHZhciBlbnRyeSA9IGNhY2hlLmdldChrZXkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkgeyAvLyBpZiBjYWxsYmFjayBpcyBub3QgZ2l2ZW4gaW4gbGFzdCBhcmcsIHJldHVybiBjYWNoZWQgcmVzdWx0IChpbW1lZGlhdGUpLlxuICAgICAgdmFyIHZhbHVlID0gZW50cnkuZ2V0KCk7XG4gICAgICBpZiAoIXZhbHVlKSB7IHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY2FsbCByZXN1bHQgaXMgbm90IGNhY2hlZCB5ZXQuJyk7IH1cbiAgICAgIGlmICh2YWx1ZS5lcnJvcikgeyB0aHJvdyB2YWx1ZS5lcnJvcjsgfVxuICAgICAgcmV0dXJuIHZhbHVlLnJlc3VsdDtcbiAgICB9XG4gICAgZW50cnkuZ2V0KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjYWxsYmFjayh2YWx1ZS5lcnJvciwgdmFsdWUucmVzdWx0KTtcbiAgICB9KTtcbiAgICBpZiAoIWVudHJ5LmZldGNoaW5nKSB7IC8vIG9ubHkgd2hlbiBubyBvdGhlciBjbGllbnQgaXMgY2FsbGluZyBmdW5jdGlvblxuICAgICAgZW50cnkuZmV0Y2hpbmcgPSB0cnVlO1xuICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGVudHJ5LnNldCh7IGVycm9yOiBlcnIsIHJlc3VsdDogcmVzdWx0IH0pO1xuICAgICAgfSk7XG4gICAgICBmbi5hcHBseShzY29wZSB8fCB0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH07XG4gICRmbi5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrZXkgPSBfLmlzU3RyaW5nKG9wdGlvbnMua2V5KSA/IG9wdGlvbnMua2V5IDpcbiAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKG9wdGlvbnMua2V5KSA/IG9wdGlvbnMua2V5LmFwcGx5KHNjb3BlLCBhcmd1bWVudHMpIDpcbiAgICAgICAgICAgICAgY3JlYXRlQ2FjaGVLZXkob3B0aW9ucy5uYW1lc3BhY2UsIGFyZ3VtZW50cyk7XG4gICAgY2FjaGUuY2xlYXIoa2V5KTtcbiAgfTtcbiAgcmV0dXJuICRmbjtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/cache.js":
/*!*******************************************!*\
  !*** ./node_modules/jsforce/lib/cache.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages asynchronous method response cache\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar events = __webpack_require__(/*! events */ \"events\"),\n    inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\"),\n    _      = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\");\n\n/**\n * Class for managing cache entry\n *\n * @private\n * @class\n * @constructor\n * @template T\n */\nvar CacheEntry = function() {\n  this.fetching = false;\n};\n\ninherits(CacheEntry, events.EventEmitter);\n\n/**\n * Get value in the cache entry\n *\n * @param {Callback.<T>} [callback] - Callback function callbacked the cache entry updated\n * @returns {T|undefined}\n */\nCacheEntry.prototype.get = function(callback) {\n  if (!callback) {\n    return this._value;\n  } else {\n    this.once('value', callback);\n    if (!_.isUndefined(this._value)) {\n      this.emit('value', this._value);\n    }\n  }\n};\n\n/**\n * Set value in the cache entry\n *\n * @param {T} [value] - A value for caching\n */\nCacheEntry.prototype.set = function(value) {\n  this._value = value;\n  this.emit('value', this._value);\n};\n\n/**\n * Clear cached value\n */\nCacheEntry.prototype.clear = function() {\n  this.fetching = false;\n  delete this._value;\n};\n\n\n/**\n * Caching manager for async methods\n *\n * @class\n * @constructor\n */\nvar Cache = function() {\n  this._entries = {};\n};\n\n/**\n * retrive cache entry, or create if not exists.\n *\n * @param {String} [key] - Key of cache entry\n * @returns {CacheEntry}\n */\nCache.prototype.get = function(key) {\n  if (key && this._entries[key]) {\n    return this._entries[key];\n  } else {\n    var entry = new CacheEntry();\n    this._entries[key] = entry;\n    return entry;\n  }\n};\n\n/**\n * clear cache entries prefix matching given key\n * @param {String} [key] - Key prefix of cache entry to clear\n */\nCache.prototype.clear = function(key) {\n  for (var k in this._entries) {\n    if (!key || k.indexOf(key) === 0) {\n      this._entries[k].clear();\n    }\n  }\n};\n\n/**\n * create and return cache key from namespace and serialized arguments.\n * @private\n */\nfunction createCacheKey(namespace, args) {\n  args = Array.prototype.slice.apply(args);\n  return namespace + '(' + _.map(args, function(a){ return JSON.stringify(a); }).join(',') + ')';\n}\n\n/**\n * Enable caching for async call fn to intercept the response and store it to cache.\n * The original async calll fn is always invoked.\n *\n * @protected\n * @param {Function} fn - Function to covert cacheable\n * @param {Object} [scope] - Scope of function call\n * @param {Object} [options] - Options\n * @return {Function} - Cached version of function\n */\nCache.prototype.makeResponseCacheable = function(fn, scope, options) {\n  var cache = this;\n  options = options || {};\n  return function() {\n    var args = Array.prototype.slice.apply(arguments);\n    var callback = args.pop();\n    if (!_.isFunction(callback)) {\n      args.push(callback);\n      callback = null;\n    }\n    var keys = _.isString(options.key) ? options.key :\n               _.isFunction(options.key) ? options.key.apply(scope, args) :\n               createCacheKey(options.namespace, args);\n    if (!Array.isArray(keys)) { keys = [ keys ]; }\n    var entries = [];\n    keys.forEach(function (key) {\n      var entry = cache.get(key);\n      entry.fetching = true;\n      entries.push(entry);\n    })\n    if (callback) {\n      args.push(function(err, result) {\n        if (Array.isArray(result) && result.length == entries.length) {\n          entries.forEach(function (entry, index) {\n            entry.set({ error: err, result: result[index] });\n          })\n        } else {\n          entries.forEach(function (entry) {\n            entry.set({ error: err, result: result });\n          });\n        }\n        callback(err, result);\n      });\n    }\n    var ret, error;\n    try {\n      ret = fn.apply(scope || this, args);\n    } catch(e) {\n      error = e;\n    }\n    if (ret && _.isFunction(ret.then)) { // if the returned value is promise\n      if (!callback) {\n        return ret.then(function(result) {\n          if (Array.isArray(result) && result.length == entries.length) {\n            entries.forEach(function (entry, index) {\n              entry.set({ error: undefined, result: result[index] });\n            })\n          } else {\n            entries.forEach(function (entry) {\n              entry.set({ error: undefined, result: result });\n            });\n          }\n          return result;\n        }, function(err) {\n          if (Array.isArray(err) && err.length == entries.length) {\n            entries.forEach(function (entry, index) {\n              entry.set({ error: err[index], result: undefined });\n            })\n          } else {\n            entries.forEach(function (entry) {\n              entry.set({ error: err, result: undefined });\n            });\n          }\n          throw err;\n        });\n      } else {\n        return ret;\n      }\n    } else {\n      if (Array.isArray(ret) && ret.length == entries.length) {\n        entries.forEach(function (entry, index) {\n          entry.set({ error: error, result: ret[index] });\n        })\n      } else {\n        entries.forEach(function (entry) {\n          entry.set({ error: error, result: ret });\n        });\n      }\n      if (error) { throw error; }\n      return ret;\n    }\n  };\n};\n\n/**\n * Enable caching for async call fn to lookup the response cache first, then invoke original if no cached value.\n *\n * @protected\n * @param {Function} fn - Function to covert cacheable\n * @param {Object} [scope] - Scope of function call\n * @param {Object} [options] - Options\n * @return {Function} - Cached version of function\n */\nCache.prototype.makeCacheable = function(fn, scope, options) {\n  var cache = this;\n  options = options || {};\n  var $fn = function() {\n    var args = Array.prototype.slice.apply(arguments);\n    var callback = args.pop();\n    if (!_.isFunction(callback)) {\n      args.push(callback);\n    }\n    var key = _.isString(options.key) ? options.key :\n              _.isFunction(options.key) ? options.key.apply(scope, args) :\n              createCacheKey(options.namespace, args);\n    var entry = cache.get(key);\n    if (!_.isFunction(callback)) { // if callback is not given in last arg, return cached result (immediate).\n      var value = entry.get();\n      if (!value) { throw new Error('Function call result is not cached yet.'); }\n      if (value.error) { throw value.error; }\n      return value.result;\n    }\n    entry.get(function(value) {\n      callback(value.error, value.result);\n    });\n    if (!entry.fetching) { // only when no other client is calling function\n      entry.fetching = true;\n      args.push(function(err, result) {\n        entry.set({ error: err, result: result });\n      });\n      fn.apply(scope || this, args);\n    }\n  };\n  $fn.clear = function() {\n    var key = _.isString(options.key) ? options.key :\n              _.isFunction(options.key) ? options.key.apply(scope, arguments) :\n              createCacheKey(options.namespace, arguments);\n    cache.clear(key);\n  };\n  return $fn;\n};\n\n\nmodule.exports = Cache;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvY2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQywyREFBVTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsd0RBQWE7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDJCQUEyQjtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQ0FBbUM7QUFDM0QsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5Q0FBeUM7QUFDbkUsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBCQUEwQixzQ0FBc0M7QUFDaEUsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBLDBCQUEwQiwrQkFBK0I7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHNCQUFzQixrQ0FBa0M7QUFDeEQsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQsU0FBUztBQUNUO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxvQkFBb0I7QUFDcEIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2NhY2hlLmpzPzFlNzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBNYW5hZ2VzIGFzeW5jaHJvbm91cyBtZXRob2QgcmVzcG9uc2UgY2FjaGVcbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpLFxuICAgIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKSxcbiAgICBfICAgICAgPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpO1xuXG4vKipcbiAqIENsYXNzIGZvciBtYW5hZ2luZyBjYWNoZSBlbnRyeVxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRlbXBsYXRlIFRcbiAqL1xudmFyIENhY2hlRW50cnkgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5mZXRjaGluZyA9IGZhbHNlO1xufTtcblxuaW5oZXJpdHMoQ2FjaGVFbnRyeSwgZXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogR2V0IHZhbHVlIGluIHRoZSBjYWNoZSBlbnRyeVxuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb24gY2FsbGJhY2tlZCB0aGUgY2FjaGUgZW50cnkgdXBkYXRlZFxuICogQHJldHVybnMge1R8dW5kZWZpbmVkfVxuICovXG5DYWNoZUVudHJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub25jZSgndmFsdWUnLCBjYWxsYmFjayk7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRoaXMuX3ZhbHVlKSkge1xuICAgICAgdGhpcy5lbWl0KCd2YWx1ZScsIHRoaXMuX3ZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IHZhbHVlIGluIHRoZSBjYWNoZSBlbnRyeVxuICpcbiAqIEBwYXJhbSB7VH0gW3ZhbHVlXSAtIEEgdmFsdWUgZm9yIGNhY2hpbmdcbiAqL1xuQ2FjaGVFbnRyeS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5lbWl0KCd2YWx1ZScsIHRoaXMuX3ZhbHVlKTtcbn07XG5cbi8qKlxuICogQ2xlYXIgY2FjaGVkIHZhbHVlXG4gKi9cbkNhY2hlRW50cnkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZmV0Y2hpbmcgPSBmYWxzZTtcbiAgZGVsZXRlIHRoaXMuX3ZhbHVlO1xufTtcblxuXG4vKipcbiAqIENhY2hpbmcgbWFuYWdlciBmb3IgYXN5bmMgbWV0aG9kc1xuICpcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9lbnRyaWVzID0ge307XG59O1xuXG4vKipcbiAqIHJldHJpdmUgY2FjaGUgZW50cnksIG9yIGNyZWF0ZSBpZiBub3QgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XSAtIEtleSBvZiBjYWNoZSBlbnRyeVxuICogQHJldHVybnMge0NhY2hlRW50cnl9XG4gKi9cbkNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgaWYgKGtleSAmJiB0aGlzLl9lbnRyaWVzW2tleV0pIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cmllc1trZXldO1xuICB9IGVsc2Uge1xuICAgIHZhciBlbnRyeSA9IG5ldyBDYWNoZUVudHJ5KCk7XG4gICAgdGhpcy5fZW50cmllc1trZXldID0gZW50cnk7XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG4vKipcbiAqIGNsZWFyIGNhY2hlIGVudHJpZXMgcHJlZml4IG1hdGNoaW5nIGdpdmVuIGtleVxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldIC0gS2V5IHByZWZpeCBvZiBjYWNoZSBlbnRyeSB0byBjbGVhclxuICovXG5DYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbihrZXkpIHtcbiAgZm9yICh2YXIgayBpbiB0aGlzLl9lbnRyaWVzKSB7XG4gICAgaWYgKCFrZXkgfHwgay5pbmRleE9mKGtleSkgPT09IDApIHtcbiAgICAgIHRoaXMuX2VudHJpZXNba10uY2xlYXIoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogY3JlYXRlIGFuZCByZXR1cm4gY2FjaGUga2V5IGZyb20gbmFtZXNwYWNlIGFuZCBzZXJpYWxpemVkIGFyZ3VtZW50cy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlS2V5KG5hbWVzcGFjZSwgYXJncykge1xuICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3MpO1xuICByZXR1cm4gbmFtZXNwYWNlICsgJygnICsgXy5tYXAoYXJncywgZnVuY3Rpb24oYSl7IHJldHVybiBKU09OLnN0cmluZ2lmeShhKTsgfSkuam9pbignLCcpICsgJyknO1xufVxuXG4vKipcbiAqIEVuYWJsZSBjYWNoaW5nIGZvciBhc3luYyBjYWxsIGZuIHRvIGludGVyY2VwdCB0aGUgcmVzcG9uc2UgYW5kIHN0b3JlIGl0IHRvIGNhY2hlLlxuICogVGhlIG9yaWdpbmFsIGFzeW5jIGNhbGxsIGZuIGlzIGFsd2F5cyBpbnZva2VkLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gRnVuY3Rpb24gdG8gY292ZXJ0IGNhY2hlYWJsZVxuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSBTY29wZSBvZiBmdW5jdGlvbiBjYWxsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259IC0gQ2FjaGVkIHZlcnNpb24gb2YgZnVuY3Rpb25cbiAqL1xuQ2FjaGUucHJvdG90eXBlLm1ha2VSZXNwb25zZUNhY2hlYWJsZSA9IGZ1bmN0aW9uKGZuLCBzY29wZSwgb3B0aW9ucykge1xuICB2YXIgY2FjaGUgPSB0aGlzO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cyk7XG4gICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XG4gICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICAgIHZhciBrZXlzID0gXy5pc1N0cmluZyhvcHRpb25zLmtleSkgPyBvcHRpb25zLmtleSA6XG4gICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24ob3B0aW9ucy5rZXkpID8gb3B0aW9ucy5rZXkuYXBwbHkoc2NvcGUsIGFyZ3MpIDpcbiAgICAgICAgICAgICAgIGNyZWF0ZUNhY2hlS2V5KG9wdGlvbnMubmFtZXNwYWNlLCBhcmdzKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHsga2V5cyA9IFsga2V5cyBdOyB9XG4gICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGVudHJ5ID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBlbnRyeS5mZXRjaGluZyA9IHRydWU7XG4gICAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgIH0pXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBhcmdzLnB1c2goZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoID09IGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGVudHJ5LnNldCh7IGVycm9yOiBlcnIsIHJlc3VsdDogcmVzdWx0W2luZGV4XSB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIGVudHJ5LnNldCh7IGVycm9yOiBlcnIsIHJlc3VsdDogcmVzdWx0IH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgcmV0LCBlcnJvcjtcbiAgICB0cnkge1xuICAgICAgcmV0ID0gZm4uYXBwbHkoc2NvcGUgfHwgdGhpcywgYXJncyk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBlcnJvciA9IGU7XG4gICAgfVxuICAgIGlmIChyZXQgJiYgXy5pc0Z1bmN0aW9uKHJldC50aGVuKSkgeyAvLyBpZiB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgcHJvbWlzZVxuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gcmV0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoID09IGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xuICAgICAgICAgICAgICBlbnRyeS5zZXQoeyBlcnJvcjogdW5kZWZpbmVkLCByZXN1bHQ6IHJlc3VsdFtpbmRleF0gfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIGVudHJ5LnNldCh7IGVycm9yOiB1bmRlZmluZWQsIHJlc3VsdDogcmVzdWx0IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVycikgJiYgZXJyLmxlbmd0aCA9PSBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgZW50cnkuc2V0KHsgZXJyb3I6IGVycltpbmRleF0sIHJlc3VsdDogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICBlbnRyeS5zZXQoeyBlcnJvcjogZXJyLCByZXN1bHQ6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmV0KSAmJiByZXQubGVuZ3RoID09IGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XG4gICAgICAgICAgZW50cnkuc2V0KHsgZXJyb3I6IGVycm9yLCByZXN1bHQ6IHJldFtpbmRleF0gfSk7XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgZW50cnkuc2V0KHsgZXJyb3I6IGVycm9yLCByZXN1bHQ6IHJldCB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IpIHsgdGhyb3cgZXJyb3I7IH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBFbmFibGUgY2FjaGluZyBmb3IgYXN5bmMgY2FsbCBmbiB0byBsb29rdXAgdGhlIHJlc3BvbnNlIGNhY2hlIGZpcnN0LCB0aGVuIGludm9rZSBvcmlnaW5hbCBpZiBubyBjYWNoZWQgdmFsdWUuXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBGdW5jdGlvbiB0byBjb3ZlcnQgY2FjaGVhYmxlXG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIFNjb3BlIG9mIGZ1bmN0aW9uIGNhbGxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSBDYWNoZWQgdmVyc2lvbiBvZiBmdW5jdGlvblxuICovXG5DYWNoZS5wcm90b3R5cGUubWFrZUNhY2hlYWJsZSA9IGZ1bmN0aW9uKGZuLCBzY29wZSwgb3B0aW9ucykge1xuICB2YXIgY2FjaGUgPSB0aGlzO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyICRmbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cyk7XG4gICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIHZhciBrZXkgPSBfLmlzU3RyaW5nKG9wdGlvbnMua2V5KSA/IG9wdGlvbnMua2V5IDpcbiAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKG9wdGlvbnMua2V5KSA/IG9wdGlvbnMua2V5LmFwcGx5KHNjb3BlLCBhcmdzKSA6XG4gICAgICAgICAgICAgIGNyZWF0ZUNhY2hlS2V5KG9wdGlvbnMubmFtZXNwYWNlLCBhcmdzKTtcbiAgICB2YXIgZW50cnkgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHsgLy8gaWYgY2FsbGJhY2sgaXMgbm90IGdpdmVuIGluIGxhc3QgYXJnLCByZXR1cm4gY2FjaGVkIHJlc3VsdCAoaW1tZWRpYXRlKS5cbiAgICAgIHZhciB2YWx1ZSA9IGVudHJ5LmdldCgpO1xuICAgICAgaWYgKCF2YWx1ZSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGNhbGwgcmVzdWx0IGlzIG5vdCBjYWNoZWQgeWV0LicpOyB9XG4gICAgICBpZiAodmFsdWUuZXJyb3IpIHsgdGhyb3cgdmFsdWUuZXJyb3I7IH1cbiAgICAgIHJldHVybiB2YWx1ZS5yZXN1bHQ7XG4gICAgfVxuICAgIGVudHJ5LmdldChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgY2FsbGJhY2sodmFsdWUuZXJyb3IsIHZhbHVlLnJlc3VsdCk7XG4gICAgfSk7XG4gICAgaWYgKCFlbnRyeS5mZXRjaGluZykgeyAvLyBvbmx5IHdoZW4gbm8gb3RoZXIgY2xpZW50IGlzIGNhbGxpbmcgZnVuY3Rpb25cbiAgICAgIGVudHJ5LmZldGNoaW5nID0gdHJ1ZTtcbiAgICAgIGFyZ3MucHVzaChmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAgICBlbnRyeS5zZXQoeyBlcnJvcjogZXJyLCByZXN1bHQ6IHJlc3VsdCB9KTtcbiAgICAgIH0pO1xuICAgICAgZm4uYXBwbHkoc2NvcGUgfHwgdGhpcywgYXJncyk7XG4gICAgfVxuICB9O1xuICAkZm4uY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIga2V5ID0gXy5pc1N0cmluZyhvcHRpb25zLmtleSkgPyBvcHRpb25zLmtleSA6XG4gICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihvcHRpb25zLmtleSkgPyBvcHRpb25zLmtleS5hcHBseShzY29wZSwgYXJndW1lbnRzKSA6XG4gICAgICAgICAgICAgIGNyZWF0ZUNhY2hlS2V5KG9wdGlvbnMubmFtZXNwYWNlLCBhcmd1bWVudHMpO1xuICAgIGNhY2hlLmNsZWFyKGtleSk7XG4gIH07XG4gIHJldHVybiAkZm47XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ2FjaGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/cache.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/connection.js":
/*!************************************************!*\
  !*** ./node_modules/jsforce/lib/connection.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global Buffer */\n/**\n * @file Connection class to keep the API session information and manage requests\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar events  = __webpack_require__(/*! events */ \"events\"),\n    inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\"),\n    _       = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    Promise = __webpack_require__(/*! ./promise */ \"(action-browser)/./node_modules/jsforce/lib/promise.js\"),\n    Logger  = __webpack_require__(/*! ./logger */ \"(action-browser)/./node_modules/jsforce/lib/logger.js\"),\n    OAuth2  = __webpack_require__(/*! ./oauth2 */ \"(action-browser)/./node_modules/jsforce/lib/oauth2.js\"),\n    Query   = __webpack_require__(/*! ./query */ \"(action-browser)/./node_modules/jsforce/lib/query.js\"),\n    SObject = __webpack_require__(/*! ./sobject */ \"(action-browser)/./node_modules/jsforce/lib/sobject.js\"),\n    QuickAction = __webpack_require__(/*! ./quick-action */ \"(action-browser)/./node_modules/jsforce/lib/quick-action.js\"),\n    HttpApi = __webpack_require__(/*! ./http-api */ \"(action-browser)/./node_modules/jsforce/lib/http-api.js\"),\n    Transport = __webpack_require__(/*! ./transport */ \"(action-browser)/./node_modules/jsforce/lib/transport.js\"),\n    Process = __webpack_require__(/*! ./process */ \"(action-browser)/./node_modules/jsforce/lib/process.js\"),\n    Cache   = __webpack_require__(/*! ./cache */ \"(action-browser)/./node_modules/jsforce/lib/cache.js\");\n\nvar defaults = {\n  loginUrl: \"https://login.salesforce.com\",\n  instanceUrl: \"\",\n  version: \"42.0\"\n};\n\n/*\n * Constant of maximum records num in DML operation (update/delete)\n */\nvar MAX_DML_COUNT = 200;\n\n/*\n * Constant of maximum number of requests that can be batched\n */\nvar MAX_BATCH_REQUESTS = 25;\n\n/**\n * Connection class to keep the API session information and manage requests\n *\n * @constructor\n * @extends events.EventEmitter\n * @param {Object} [options] - Connection options\n * @param {OAuth2|Object} [options.oauth2] - OAuth2 instance or options to be passed to OAuth2 constructor\n * @param {String} [options.logLevel] - Output logging level (DEBUG|INFO|WARN|ERROR|FATAL)\n * @param {String} [options.version] - Salesforce API Version (without \"v\" prefix)\n * @param {Number} [options.maxRequest] - Max number of requests allowed in parallel call\n * @param {String} [options.loginUrl] - Salesforce Login Server URL (e.g. https://login.salesforce.com/)\n * @param {String} [options.instanceUrl] - Salesforce Instance URL (e.g. https://na1.salesforce.com/)\n * @param {String} [options.serverUrl] - Salesforce SOAP service endpoint URL (e.g. https://na1.salesforce.com/services/Soap/u/28.0)\n * @param {String} [options.accessToken] - Salesforce OAuth2 access token\n * @param {String} [options.sessionId] - Salesforce session ID\n * @param {String} [options.refreshToken] - Salesforce OAuth2 refresh token\n * @param {String|Object} [options.signedRequest] - Salesforce Canvas signed request (Raw Base64 string, JSON string, or deserialized JSON)\n * @param {String} [options.proxyUrl] - Cross-domain proxy server URL, used in browser client, non Visualforce app.\n * @param {String} [options.httpProxy] - URL of HTTP proxy server, used in server client.\n * @param {Object} [options.callOptions] - Call options used in each SOAP/REST API request. See manual.\n */\nvar Connection = module.exports = function(options) {\n  options = options || {};\n\n  this._logger = new Logger(options.logLevel);\n\n  var oauth2 = options.oauth2 || {\n    loginUrl : options.loginUrl,\n    clientId : options.clientId,\n    clientSecret : options.clientSecret,\n    redirectUri : options.redirectUri,\n    proxyUrl: options.proxyUrl,\n    httpProxy: options.httpProxy\n  };\n\n  /**\n   * OAuth2 object\n   * @member {OAuth2} Connection#oauth2\n   */\n  this.oauth2 = oauth2 = oauth2 instanceof OAuth2 ? oauth2 : new OAuth2(oauth2);\n\n  this.loginUrl = options.loginUrl || oauth2.loginUrl || defaults.loginUrl;\n  this.version = options.version || defaults.version;\n  this.maxRequest = options.maxRequest || this.maxRequest || 10;\n\n  /** @private */\n  if (options.proxyUrl) {\n    this._transport = new Transport.ProxyTransport(options.proxyUrl);\n  } else if (options.httpProxy) {\n    this._transport = new Transport.HttpProxyTransport(options.httpProxy);\n  } else {\n    this._transport = new Transport();\n  }\n\n  this.callOptions = options.callOptions;\n\n  /*\n   * Fire connection:new event to notify jsforce plugin modules\n   */\n  var jsforce = __webpack_require__(/*! ./core */ \"(action-browser)/./node_modules/jsforce/lib/core.js\");\n  jsforce.emit('connection:new', this);\n\n  /**\n   * Streaming API object\n   * @member {Streaming} Connection#streaming\n   */\n  // this.streaming = new Streaming(this);\n  /**\n   * Bulk API object\n   * @member {Bulk} Connection#bulk\n   */\n  // this.bulk = new Bulk(this);\n  /**\n   * Tooling API object\n   * @member {Tooling} Connection#tooling\n   */\n  // this.tooling = new Tooling(this);\n  /**\n   * Analytics API object\n   * @member {Analytics} Connection#analytics\n   */\n  // this.analytics = new Analytics(this);\n  /**\n   * Chatter API object\n   * @member {Chatter} Connection#chatter\n   */\n  // this.chatter = new Chatter(this);\n  /**\n   * Metadata API object\n   * @member {Metadata} Connection#metadata\n   */\n  // this.metadata = new Metadata(this);\n\n  /**\n   * SOAP API object\n   * @member {SoapApi} Connection#soap\n   */\n  // this.soap = new SoapApi(this);\n\n  /**\n   * Apex REST API object\n   * @member {Apex} Connection#apex\n   */\n  // this.apex = new Apex(this);\n\n  /**\n   * @member {Process} Connection#process\n   */\n  this.process = new Process(this);\n\n  /**\n   * Cache object for result\n   * @member {Cache} Connection#cache\n   */\n  this.cache = new Cache();\n\n  // Allow to delegate connection refresh to outer function\n  var self = this;\n  var refreshFn = options.refreshFn;\n  if (!refreshFn && this.oauth2.clientId) {\n    refreshFn = oauthRefreshFn;\n  }\n  if (refreshFn) {\n    this._refreshDelegate = new HttpApi.SessionRefreshDelegate(this, refreshFn);\n  }\n\n  var cacheOptions = {\n    key: function(type) { \n      return type \n        ? type.type ? \"describe.\" + type.type : \"describe.\" + type\n        : \"describe\"; \n    }\n  };\n  this.describe$ = this.cache.makeCacheable(this.describe, this, cacheOptions);\n  this.describe = this.cache.makeResponseCacheable(this.describe, this, cacheOptions);\n  this.describeSObject$ = this.describe$;\n  this.describeSObject = this.describe;\n\n  var batchCacheOptions = {\n    key: function(options) {\n      var types = options.types;\n      var autofetch = options.autofetch || false;\n      var typesToFetch = types.length > MAX_BATCH_REQUESTS \n        ? (autofetch ? types : types.slice(0, MAX_BATCH_REQUESTS))\n        : types;\n      var keys = [];\n      typesToFetch.forEach(function (type) { keys.push('describe.' + type); });\n      return keys;\n    }\n  };\n  this.batchDescribe = this.cache.makeResponseCacheable(this.batchDescribe, this, batchCacheOptions);\n  this.batchDescribeSObjects = this.batchDescribe;\n\n  cacheOptions = { key: 'describeGlobal' };\n  this.describeGlobal$ = this.cache.makeCacheable(this.describeGlobal, this, cacheOptions);\n  this.describeGlobal = this.cache.makeResponseCacheable(this.describeGlobal, this, cacheOptions);\n\n  this.initialize(options);\n};\n\ninherits(Connection, events.EventEmitter);\n\n/**\n * Initialize connection.\n *\n * @protected\n * @param {Object} options - Initialization options\n * @param {String} [options.instanceUrl] - Salesforce Instance URL (e.g. https://na1.salesforce.com/)\n * @param {String} [options.serverUrl] - Salesforce SOAP service endpoint URL (e.g. https://na1.salesforce.com/services/Soap/u/28.0)\n * @param {String} [options.accessToken] - Salesforce OAuth2 access token\n * @param {String} [options.sessionId] - Salesforce session ID\n * @param {String} [options.refreshToken] - Salesforce OAuth2 refresh token\n * @param {String|Object} [options.signedRequest] - Salesforce Canvas signed request (Raw Base64 string, JSON string, or deserialized JSON)\n * @param {UserInfo} [options.userInfo] - Logged in user information\n */\nConnection.prototype.initialize = function(options) {\n  if (!options.instanceUrl && options.serverUrl) {\n    options.instanceUrl = options.serverUrl.split('/').slice(0, 3).join('/');\n  }\n  this.instanceUrl = options.instanceUrl || options.serverUrl || this.instanceUrl || defaults.instanceUrl;\n\n  this.accessToken = options.sessionId || options.accessToken || this.accessToken;\n  this.refreshToken = options.refreshToken || this.refreshToken;\n  if (this.refreshToken && !this._refreshDelegate) {\n    throw new Error(\"Refresh token is specified without oauth2 client information or refresh function\");\n  }\n\n  this.signedRequest = options.signedRequest && parseSignedRequest(options.signedRequest);\n  if (this.signedRequest) {\n    this.accessToken = this.signedRequest.client.oauthToken;\n    if (Transport.CanvasTransport.supported) {\n      this._transport = new Transport.CanvasTransport(this.signedRequest);\n    }\n  }\n\n  if (options.userInfo) {\n    this.userInfo = options.userInfo;\n  }\n\n  this.limitInfo = {};\n\n  this.sobjects = {};\n  this.cache.clear();\n  this.cache.get('describeGlobal').removeAllListeners('value');\n  this.cache.get('describeGlobal').on('value', _.bind(function(res) {\n    if (res.result) {\n      var types = _.map(res.result.sobjects, function(so) { return so.name; });\n      types.forEach(this.sobject, this);\n    }\n  }, this));\n\n  if (this.tooling) {\n    this.tooling.initialize();\n  }\n\n  this._sessionType = options.sessionId ? \"soap\" : \"oauth2\";\n\n};\n\n/** @private **/\nfunction oauthRefreshFn(conn, callback) {\n  conn.oauth2.refreshToken(conn.refreshToken, function(err, res) {\n    if (err) { return callback(err); }\n    var userInfo = parseIdUrl(res.id);\n    conn.initialize({\n      instanceUrl : res.instance_url,\n      accessToken : res.access_token,\n      userInfo : userInfo\n    });\n    callback(null, res.access_token, res);\n  });\n}\n\n/** @private **/\nfunction parseSignedRequest(sr) {\n  if (_.isString(sr)) {\n    if (sr[0] === '{') { // might be JSON\n      return JSON.parse(sr);\n    } else { // might be original base64-encoded signed request\n      var msg = sr.split('.').pop(); // retrieve latter part\n      var json = Buffer.from(msg, 'base64').toString('utf-8');\n      return JSON.parse(json);\n    }\n    return null;\n  }\n  return sr;\n}\n\n\n/** @private **/\nConnection.prototype._baseUrl = function() {\n  return [ this.instanceUrl, \"services/data\", \"v\" + this.version ].join('/');\n};\n\n/**\n * Convert path to absolute url\n * @private\n */\nConnection.prototype._normalizeUrl = function(url) {\n  if (url[0] === '/') {\n    if (url.indexOf('/services/') === 0) {\n      return this.instanceUrl + url;\n    } else {\n      return this._baseUrl() + url;\n    }\n  } else {\n    return url;\n  }\n};\n\n/**\n * Send REST API request with given HTTP request info, with connected session information.\n *\n * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')\n * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')\n * , or relative path from version root ('/sobjects/Account/describe').\n *\n * @param {String|Object} request - HTTP request object or URL to GET request\n * @param {String} request.method - HTTP method URL to send HTTP request\n * @param {String} request.url - URL to send HTTP request\n * @param {Object} [request.headers] - HTTP request headers in hash object (key-value)\n * @param {Object} [options] - HTTP API request options\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nConnection.prototype.request = function(request, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  options = options || {};\n  var self = this;\n\n  // if request is simple string, regard it as url in GET method\n  if (_.isString(request)) {\n    request = { method: 'GET', url: request };\n  }\n  // if url is given in relative path, prepend base url or instance url before.\n  request.url = this._normalizeUrl(request.url);\n\n  var httpApi = new HttpApi(this, options);\n\n  // log api usage and its quota\n  httpApi.on('response', function(response) {\n    if (response.headers && response.headers[\"sforce-limit-info\"]) {\n      var apiUsage = response.headers[\"sforce-limit-info\"].match(/api\\-usage=(\\d+)\\/(\\d+)/);\n      if (apiUsage) {\n        self.limitInfo = {\n          apiUsage: {\n            used: parseInt(apiUsage[1], 10),\n            limit: parseInt(apiUsage[2], 10)\n          }\n        };\n      }\n    }\n  });\n  return httpApi.request(request).thenCall(callback);\n};\n\n/**\n * Send HTTP GET request\n *\n * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')\n * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')\n * , or relative path from version root ('/sobjects/Account/describe').\n *\n * @param {String} url - Endpoint URL to request HTTP GET\n * @param {Object} [options] - HTTP API request options\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nConnection.prototype.requestGet = function(url, options, callback) {\n  var request = {\n    method: \"GET\",\n    url: url\n  };\n  return this.request(request, options, callback);\n};\n\n\n/**\n * Send HTTP POST request with JSON body, with connected session information\n *\n * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')\n * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')\n * , or relative path from version root ('/sobjects/Account/describe').\n *\n * @param {String} url - Endpoint URL to request HTTP POST\n * @param {Object} body - Any JS object which can be serialized to JSON\n * @param {Object} [options] - HTTP API request options\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nConnection.prototype.requestPost = function(url, body, options, callback) {\n  var request = {\n    method: \"POST\",\n    url: url,\n    body: JSON.stringify(body),\n    headers: { \"content-type\": \"application/json\" }\n  };\n  return this.request(request, options, callback);\n};\n\n/**\n * Send HTTP PUT request with JSON body, with connected session information\n *\n * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')\n * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')\n * , or relative path from version root ('/sobjects/Account/describe').\n *\n * @param {String} url - Endpoint URL to request HTTP PUT\n * @param {Object} body - Any JS object which can be serialized to JSON\n * @param {Object} [options] - HTTP API request options\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nConnection.prototype.requestPut = function(url, body, options, callback) {\n  var request = {\n    method: \"PUT\",\n    url: url,\n    body: JSON.stringify(body),\n    headers: { \"content-type\": \"application/json\" }\n  };\n  return this.request(request, options, callback);\n};\n\n/**\n * Send HTTP PATCH request with JSON body\n *\n * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')\n * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')\n * , or relative path from version root ('/sobjects/Account/describe').\n *\n * @param {String} url - Endpoint URL to request HTTP PATCH\n * @param {Object} body - Any JS object which can be serialized to JSON\n * @param {Object} [options] - HTTP API request options\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nConnection.prototype.requestPatch = function(url, body, options, callback) {\n  var request = {\n    method: \"PATCH\",\n    url: url,\n    body: JSON.stringify(body),\n    headers: { \"content-type\": \"application/json\" }\n  };\n  return this.request(request, options, callback);\n};\n\n/**\n * Send HTTP DELETE request\n *\n * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')\n * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')\n * , or relative path from version root ('/sobjects/Account/describe').\n *\n * @param {String} url - Endpoint URL to request HTTP DELETE\n * @param {Object} [options] - HTTP API request options\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nConnection.prototype.requestDelete = function(url, options, callback) {\n  var request = {\n    method: \"DELETE\",\n    url: url\n  };\n  return this.request(request, options, callback);\n};\n\n\n/** @private */\nfunction formatDate(date) {\n  function pad(number) {\n    if (number < 10) {\n      return '0' + number;\n    }\n    return number;\n  }\n\n  return date.getUTCFullYear() +\n    '-' + pad(date.getUTCMonth() + 1) +\n    '-' + pad(date.getUTCDate()) +\n    'T' + pad(date.getUTCHours()) +\n    ':' + pad(date.getUTCMinutes()) +\n    ':' + pad(date.getUTCSeconds()) +\n    '+00:00';\n}\n\n\n/** @private **/\nfunction parseIdUrl(idUrl) {\n  var idUrls = idUrl.split(\"/\");\n  var userId = idUrls.pop(), orgId = idUrls.pop();\n  return {\n    id: userId,\n    organizationId: orgId,\n    url: idUrl\n  };\n}\n\n/**\n * @callback Callback\n * @type {Function}\n * @param {Error} err - Callback error\n * @param {T} response - Callback response\n * @template T\n */\n\n/**\n * @typedef {Object} QueryResult\n * @prop {Boolean} done - Flag if the query is fetched all records or not\n * @prop {String} [nextRecordsUrl] - URL locator for next record set, (available when done = false)\n * @prop {Number} totalSize - Total size for query\n * @prop {Array.<Record>} [records] - Array of records fetched\n */\n\n/**\n * Execute query by using SOQL\n *\n * @param {String} soql - SOQL string\n * @param {Object} [options] - Query options\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<QueryResult>} [callback] - Callback function\n * @returns {Query.<QueryResult>}\n */\nConnection.prototype.query = function(soql, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var query = new Query(this, soql, options);\n  if (callback) {\n    query.run(callback);\n  }\n  return query;\n};\n\n/**\n * Execute query by using SOQL, including deleted records\n *\n * @param {String} soql - SOQL string\n * @param {Object} [options] - Query options\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<QueryResult>} [callback] - Callback function\n * @returns {Query.<QueryResult>}\n */\nConnection.prototype.queryAll = function(soql, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var query = new Query(this, soql, options);\n  query.scanAll(true);\n  if (callback) {\n    query.run(callback);\n  }\n  return query;\n};\n\n/**\n * Query next record set by using query locator\n *\n * @param {String} locator - Next record set locator\n * @param {Object} [options] - Query options\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<QueryResult>} [callback] - Callback function\n * @returns {Query.<QueryResult>}\n */\nConnection.prototype.queryMore = function(locator, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var query = new Query(this, { locator: locator }, options);\n  if (callback) {\n    query.run(callback);\n  }\n  return query;\n};\n\n/** @private */\nConnection.prototype._ensureVersion = function(majorVersion) {\n  var versions = this.version.split('.');\n  return parseInt(versions[0], 10) >= majorVersion;\n}\n\n/** @private */\nConnection.prototype._supports = function(feature) {\n  switch (feature) {\n    case 'sobject-collection':\n      return this._ensureVersion(42);\n    default:\n      return false;\n  }\n}\n\n/**\n * Retrieve specified records\n *\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A record ID or array of record IDs\n * @param {Object} [options] - Options for rest api.\n * @param {Array.<String>} [options.fields] - Fetching field names in retrieving record\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<Record|Array.<Record>>} [callback] - Callback function\n * @returns {Promise.<Record|Array.<Record>>}\n */\nConnection.prototype.retrieve = function(type, ids, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  return (\n    _.isArray(ids) ?\n      (this._supports('sobject-collection') ? // check whether SObject collection API is supported\n        this._retrieveMany(type, ids, options) :\n        this._retrieveParallel(type, ids, options)) :\n      this._retrieveSingle(type, ids, options)\n  ).thenCall(callback);\n};\n\n/** @private */\nConnection.prototype._retrieveSingle = function(type, id, options) {\n  if (!id) {\n    return Promise.reject(new Error('Invalid record ID. Specify valid record ID value'));\n  }\n  var url = [ this._baseUrl(), \"sobjects\", type, id ].join('/');\n  if (options.fields) {\n    url += '?fields=' + options.fields.join(',');\n  }\n  return this.request({\n    method: 'GET',\n    url: url,\n    headers: options.headers,\n  });\n};\n\n/** @private */\nConnection.prototype._retrieveParallel = function(type, ids, options) {\n  if (ids.length > this.maxRequest) {\n    return Promise.reject(new Error(\"Exceeded max limit of concurrent call\"));\n  }\n  var self = this;\n  return Promise.all(\n    ids.map(function(id) {\n      return self._retrieveSingle(type, id, options).catch(function(err) {\n        if (options.allOrNone || err.errorCode !== 'NOT_FOUND') {\n          throw err;\n        }\n        return null;\n      });\n    })\n  );\n};\n\n/** @private */\nConnection.prototype._retrieveMany = function(type, ids, options) {\n  if (ids.length === 0) {\n    return Promise.resolve([]);\n  }\n  var url = [ this._baseUrl(), \"composite\", \"sobjects\", type ].join('/');\n  var self = this;\n  return (\n    options.fields ?\n      Promise.resolve(options.fields) :\n      new Promise(function(resolve, reject) {\n        self.describe$(type, function(err, so) {\n          if (err) {\n            reject(err);\n          } else {\n            var fields = so.fields.map(function(field) {\n              return field.name;\n            });\n            resolve(fields);\n          }\n        });\n      })\n  ).then(function(fields) {\n    return self.request({\n      method : 'POST',\n      url : url,\n      body : JSON.stringify({\n        ids : ids,\n        fields : fields\n      }),\n      headers : _.defaults(options.headers || {}, {\n        \"Content-Type\" : \"application/json\"\n      })\n    });\n  });\n};\n\n\n/**\n * @typedef RecordResult\n * @prop {Boolean} success - The result is succeessful or not\n * @prop {String} [id] - Record ID\n * @prop {Array.<Object>} [errors] - Errors (available when success = false)\n */\n\n/** @private */\nConnection.prototype._toRecordResult = function(id, err) {\n  var error = {\n    statusCode: err.errorCode,\n    message: err.message\n  };\n  if (err.content) { error.content = err.content; } // preserve External id duplication message\n  if (err.fields) { error.fields = err.fields; } // preserve DML exception occurred fields\n  var result = {\n    success: false,\n    errors: [error]\n  };\n  if (id) { result.id = id; }\n  return result;\n};\n\n/**\n * Synonym of Connection#create()\n *\n * @method Connection#insert\n * @param {String} type - SObject Type\n * @param {Object|Array.<Object>} records - A record or array of records to create\n * @param {Object} [options] - Options for rest api.\n * @param {Boolean} [options.allOrNone] - If true, any failed records in a call cause all changes for the call to be rolled back\n * @param {Boolean} [options.allowRecursive] - If true, when records goes over the max num of collection API (=200), records are divided into several chunks and requested recursively.\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Create records\n *\n * @method Connection#create\n * @param {String} type - SObject Type\n * @param {Record|Array.<Record>} records - A record or array of records to create\n * @param {Object} [options] - Options for rest api.\n * @param {Boolean} [options.allOrNone] - If true, any failed records in a call cause all changes for the call to be rolled back\n * @param {Boolean} [options.allowRecursive] - If true, when records goes over the max num of collection API (=200), records are divided into several chunks and requested recursively.\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nConnection.prototype.insert =\nConnection.prototype.create = function(type, records, options, callback) {\n  if (!_.isString(type)) {\n    // reverse order\n    callback = options;\n    options = records;\n    records = type;\n    type = null;\n  }\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  return (\n    _.isArray(records) ?\n      (this._supports('sobject-collection') ? // check whether SObject collection API is supported\n        this._createMany(type, records, options) :\n        this._createParallel(type, records, options)) :\n      this._createSingle(type, records, options)\n  ).thenCall(callback);\n};\n\n/** @private */\nConnection.prototype._createSingle = function(type, record, options) {\n  var sobjectType = type || (record.attributes && record.attributes.type) || record.type;\n  if (!sobjectType) {\n    return Promise.reject(new Error('No SObject Type defined in record'));\n  }\n  record = _.clone(record);\n  delete record.Id;\n  delete record.type;\n  delete record.attributes;\n  var url = [ this._baseUrl(), \"sobjects\", sobjectType ].join('/');\n  return this.request({\n    method : 'POST',\n    url : url,\n    body : JSON.stringify(record),\n    headers : _.defaults(options.headers || {}, {\n      \"Content-Type\" : \"application/json\"\n    })\n  });\n};\n\n/** @private */\nConnection.prototype._createParallel = function(type, records, options) {\n  if (records.length > this.maxRequest) {\n    return Promise.reject(new Error(\"Exceeded max limit of concurrent call\"));\n  }\n  var self = this;\n  return Promise.all(\n    records.map(function(record) {\n      return self._createSingle(type, record, options).catch(function(err) {\n        // be aware that allOrNone in parallel mode will not revert the other successful requests\n        // it only raises error when met at least one failed request.\n        if (options.allOrNone || !err.errorCode) {\n          throw err;\n        }\n        return this._toRecordResult(null, err);\n      });\n    })\n  );\n};\n\n/** @private */\nConnection.prototype._createMany = function(type, records, options) {\n  if (records.length === 0) {\n    return Promise.resolve([]);\n  }\n  if (records.length > MAX_DML_COUNT && options.allowRecursive) {\n    var self = this;\n    return self._createMany(type, records.slice(0, MAX_DML_COUNT), options).then(function(rets1) {\n      return self._createMany(type, records.slice(MAX_DML_COUNT), options).then(function(rets2) {\n        return rets1.concat(rets2);\n      });\n    });\n  }\n  records = _.map(records, function(record) {\n    var sobjectType = type || (record.attributes && record.attributes.type) || record.type;\n    if (!sobjectType) {\n      return Promise.reject(new Error('No SObject Type defined in record'));\n    }\n    record = _.clone(record);\n    delete record.Id;\n    delete record.type;\n    record.attributes = { type : sobjectType };\n    return record;\n  });\n  var url = [ this._baseUrl(), \"composite\", \"sobjects\" ].join('/');\n  return this.request({\n    method : 'POST',\n    url : url,\n    body : JSON.stringify({\n      allOrNone : options.allOrNone || false,\n      records : records\n    }),\n    headers : _.defaults(options.headers || {}, {\n      \"Content-Type\" : \"application/json\"\n    })\n  });\n};\n\n/**\n * Update records\n *\n * @param {String} type - SObject Type\n * @param {Record|Array.<Record>} records - A record or array of records to update\n * @param {Object} [options] - Options for rest api.\n * @param {Boolean} [options.allOrNone] - If true, any failed records in a call cause all changes for the call to be rolled back\n * @param {Boolean} [options.allowRecursive] - If true, when records goes over the max num of collection API (=200), records are divided into several chunks and requested recursively.\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nConnection.prototype.update = function(type, records, options, callback) {\n  if (!_.isString(type)) {\n    // reverse order\n    callback = options;\n    options = records;\n    records = type;\n    type = null;\n  }\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  return (\n    _.isArray(records) ?\n      (this._supports('sobject-collection') ? // check whether SObject collection API is supported\n        this._updateMany(type, records, options) :\n        this._updateParallel(type, records, options)) :\n      this._updateSingle(type, records, options)\n  ).thenCall(callback);\n};\n\n/** @private */\nConnection.prototype._updateSingle = function(type, record, options) {\n  var id = record.Id;\n  if (!id) {\n    return Promise.reject(new Error('Record id is not found in record.'));\n  }\n  var sobjectType = type || (record.attributes && record.attributes.type) || record.type;\n  if (!sobjectType) {\n    return Promise.reject(new Error('No SObject Type defined in record'));\n  }\n  record = _.clone(record);\n  delete record.Id;\n  delete record.type;\n  delete record.attributes;\n  var url = [ this._baseUrl(), \"sobjects\", sobjectType, id ].join('/');\n  return this.request({\n    method : 'PATCH',\n    url : url,\n    body : JSON.stringify(record),\n    headers : _.defaults(options.headers || {}, {\n      \"Content-Type\" : \"application/json\"\n    })\n  }, {\n    noContentResponse: { id : id, success : true, errors : [] }\n  });\n};\n\n/** @private */\nConnection.prototype._updateParallel = function(type, records, options) {\n  if (records.length > this.maxRequest) {\n    return Promise.reject(new Error(\"Exceeded max limit of concurrent call\"));\n  }\n  var self = this;\n  return Promise.all(\n    records.map(function(record) {\n      return self._updateSingle(type, record, options).catch(function(err) {\n        // be aware that allOrNone in parallel mode will not revert the other successful requests\n        // it only raises error when met at least one failed request.\n        if (options.allOrNone || !err.errorCode) {\n          throw err;\n        }\n        return this._toRecordResult(record.Id, err);\n      });\n    })\n  );\n};\n\n/** @private */\nConnection.prototype._updateMany = function(type, records, options) {\n  if (records.length === 0) {\n    return Promise.resolve([]);\n  }\n  if (records.length > MAX_DML_COUNT && options.allowRecursive) {\n    var self = this;\n    return self._updateMany(type, records.slice(0, MAX_DML_COUNT), options).then(function(rets1) {\n      return self._updateMany(type, records.slice(MAX_DML_COUNT), options).then(function(rets2) {\n        return rets1.concat(rets2);\n      });\n    });\n  }\n  records = _.map(records, function(record) {\n    var id = record.Id;\n    if (!id) {\n      throw new Error('Record id is not found in record.');\n    }\n    var sobjectType = type || (record.attributes && record.attributes.type) || record.type;\n    if (!sobjectType) {\n      throw new Error('No SObject Type defined in record');\n    }\n    record = _.clone(record);\n    delete record.Id;\n    record.id = id;\n    delete record.type;\n    record.attributes = { type : sobjectType };\n    return record;\n  });\n  var url = [ this._baseUrl(), \"composite\", \"sobjects\" ].join('/');\n  return this.request({\n    method : 'PATCH',\n    url : url,\n    body : JSON.stringify({\n      allOrNone : options.allOrNone || false,\n      records : records\n    }),\n    headers : _.defaults(options.headers || {}, {\n      \"Content-Type\" : \"application/json\"\n    })\n  });\n};\n\n/**\n * Upsert records\n *\n * @param {String} type - SObject Type\n * @param {Record|Array.<Record>} records - Record or array of records to upsert\n * @param {String} extIdField - External ID field name\n * @param {Object} [options] - Options for rest api.\n * @param {Boolean} [options.allOrNone] - If true, any failed records in a call cause all changes for the call to be rolled back\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nConnection.prototype.upsert = function(type, records, extIdField, options, callback) {\n  // You can omit \"type\" argument, when the record includes type information.\n  if (!_.isString(type)) {\n    // reverse order\n    callback = options;\n    options = extIdField;\n    extIdField = records;\n    records = type;\n    type = null;\n  }\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  var self = this;\n  var isArray = _.isArray(records);\n  records = isArray ? records : [ records ];\n  if (records.length > this.maxRequest) {\n    return Promise.reject(new Error(\"Exceeded max limit of concurrent call\")).thenCall(callback);\n  }\n  return Promise.all(\n    _.map(records, function(record) {\n      var sobjectType = type || (record.attributes && record.attributes.type) || record.type;\n      var extId = record[extIdField];\n      record = _.clone(record);\n      delete record[extIdField];\n      delete record.type;\n      delete record.attributes;\n\n      var url = [ self._baseUrl(), \"sobjects\", sobjectType, extIdField, extId ].join('/');\n      return self.request({\n        method : 'PATCH',\n        url : url,\n        body : JSON.stringify(record),\n        headers : _.defaults(options.headers || {}, {\n          \"Content-Type\" : \"application/json\"\n        })\n      }, {\n        noContentResponse: { success : true, errors : [] }\n      })\n      .catch(function(err) {\n        // be aware that `allOrNone` option in upsert method will not revert the other successful requests\n        // it only raises error when met at least one failed request.\n        if (!isArray || options.allOrNone || !err.errorCode) { throw err; }\n        return self._toRecordResult(null, err);\n      })\n    })\n  ).then(function(results) {\n    return !isArray && _.isArray(results) ? results[0] : results;\n  }).thenCall(callback);\n};\n\n/**\n * Synonym of Connection#destroy()\n *\n * @method Connection#delete\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Object} [options] - Options for rest api.\n * @param {Boolean} [options.allOrNone] - If true, any failed records in a call cause all changes for the call to be rolled back\n * @param {Boolean} [options.allowRecursive] - If true, when ids goes over the max num of collection API (=200), ids are divided into several chunks and requested recursively.\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Synonym of Connection#destroy()\n *\n * @method Connection#del\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Object} [options] - Options for rest api.\n * @param {Boolean} [options.allOrNone] - If true, any failed records in a call cause all changes for the call to be rolled back\n * @param {Boolean} [options.allowRecursive] - If true, when ids goes over the max num of collection API (=200), ids are divided into several chunks and requested recursively.\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Delete records\n *\n * @method Connection#destroy\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Object} [options] - Options for rest api.\n * @param {Boolean} [options.allOrNone] - If true, any failed records in a call cause all changes for the call to be rolled back\n * @param {Boolean} [options.allowRecursive] - If true, when ids goes over the max num of collection API (=200), ids are divided into several chunks and requested recursively.\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nConnection.prototype[\"delete\"] =\nConnection.prototype.del =\nConnection.prototype.destroy = function(type, ids, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  return (\n    _.isArray(ids) ?\n      (this._supports('sobject-collection') ? // check whether SObject collection API is supported\n        this._destroyMany(type, ids, options) :\n        this._destroyParallel(type, ids, options)) :\n      this._destroySingle(type, ids, options)\n  ).thenCall(callback);\n};\n\n/** @private */\nConnection.prototype._destroySingle = function(type, id, options) {\n  var url = [ this._baseUrl(), \"sobjects\", type, id ].join('/');\n  return this.request({\n    method : 'DELETE',\n    url : url,\n    headers: options.headers || null\n  }, {\n    noContentResponse: { id : id, success : true, errors : [] }\n  });\n};\n\n/** @private */\nConnection.prototype._destroyParallel = function(type, ids, options) {\n  if (ids.length > this.maxRequest) {\n    return Promise.reject(new Error(\"Exceeded max limit of concurrent call\"));\n  }\n  var self = this;\n  return Promise.all(\n    ids.map(function(id) {\n      return self._destroySingle(type, id, options).catch(function(err) {\n        // be aware that `allOrNone` option in parallel mode will not revert the other successful requests\n        // it only raises error when met at least one failed request.\n        if (options.allOrNone || !err.errorCode) {\n          throw err;\n        }\n        return this._toRecordResult(id, err);\n      });\n    })\n  );\n};\n\n\n/** @private */\nConnection.prototype._destroyMany = function(type, ids, options) {\n  if (ids.length === 0) {\n    return Promise.resolve([]);\n  }\n  if (ids.length > MAX_DML_COUNT && options.allowRecursive) {\n    var self = this;\n    return self._destroyMany(type, ids.slice(0, MAX_DML_COUNT), options).then(function(rets1) {\n      return self._destroyMany(type, ids.slice(MAX_DML_COUNT), options).then(function(rets2) {\n        return rets1.concat(rets2);\n      });\n    });\n  }\n  var url = [ this._baseUrl(), \"composite\", \"sobjects?ids=\" ].join('/') + ids.join(',');\n  if (options.allOrNone) {\n    url += '&allOrNone=true';\n  }\n  return this.request({\n    method : 'DELETE',\n    url : url,\n    headers: options.headers || null\n  });\n};\n\n/**\n * Execute search by SOSL\n *\n * @param {String} sosl - SOSL string\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\nConnection.prototype.search = function(sosl, callback) {\n  var url = this._baseUrl() + \"/search?q=\" + encodeURIComponent(sosl);\n  return this.request(url).thenCall(callback);\n};\n\n/**\n * Result returned by describeSObject call\n *\n * @typedef {Object} DescribeSObjectResult\n */\n/**\n * Parameter for describeSObject call\n * \n * @typedef {Object} DescribeSObjectOptions\n */\n/**\n * Synonym of Connection#describe()\n *\n * @method Connection#describeSObject\n * @param {String|DescribeSObjectOptions} type - SObject Type or options object\n * @param {String} type.type - The name of the SObject\n * @param {String} type.ifModifiedSince - Date value for If-Modified-Since header; undefined resolved if not modified after this date\n * @param {Callback.<DescribeSObjectResult>} [callback] - Callback function\n * @returns {Promise.<DescribeSObjectResult>}\n */\n/**\n * Describe SObject metadata\n *\n * @method Connection#describe\n * @param {String|DescribeSObjectOptions} type - SObject Type or options object\n * @param {String} type.type - The name of the SObject\n * @param {String} type.ifModifiedSince - Date value for If-Modified-Since header; undefined resolved if not modified after this date\n * @param {Callback.<DescribeSObjectResult>} [callback] - Callback function\n * @returns {Promise.<DescribeSObjectResult>}\n */\nConnection.prototype.describe =\nConnection.prototype.describeSObject = function(type, callback) {\n  var name = type.type ? type.type : type;\n  var url = [ this._baseUrl(), \"sobjects\", name, \"describe\" ].join('/');\n  var headers = type.ifModifiedSince \n    ? { 'If-Modified-Since': type.ifModifiedSince } \n    : {};\n  return this.request({\n    method: 'GET',\n    url: url,\n    headers: headers\n  }).then(function (resp) {\n    if (resp === '') {\n      return Promise.resolve(undefined);\n    } else {\n      return Promise.resolve(resp);\n    }\n  }).thenCall(callback);\n};\n\n/**\n * Result returned by batchDescribeSObjects call\n *\n * @typedef {Object[]} DescribeSObjectResult\n */\n/**\n * Parameter for describeSObject call\n * \n * @typedef {Object} BatchDescribeSObjectOptions\n */\n/**\n * Synonym of Connection#batchDescribe()\n *\n * @method Connection#batchDescribeSObjects\n * @param {BatchDescribeSObjectOptions} options - options for function\n * @param {String[]} options.types - names of objects to fetch\n * @param {Boolean} options.autofetch - whether to automatically fetch metadata for large numbers of \n *                         types (one batch request returns a maximum of 25 results); when true, will make \n *                         subsequent requests until all object metadata is fetched; when false (default), \n *                         will make one batch request for maximum of 25 results\n * @param {number} options.maxConcurrentRequests - maximum number of concurrent requests sent to the org; \n *                         default and maximum is 15\n * @param {Callback.<DescribeSObjectResult[]>} [callback] - Callback function\n * @returns {Promise.<DescribeSObjectResult[]>}\n */\n/**\n * Batch describe SObject metadata\n *\n * @method Connection#batchDescribe\n * @param {BatchDescribeSObjectOptions} options - options for function\n * @param {String[]} options.types - names of objects to fetch\n * @param {Boolean} options.autofetch - whether to automatically fetch metadata for large numbers of \n *                         types (one batch request returns a maximum of 25 results); when true, will make \n *                         subsequent requests until all object metadata is fetched; when false (default), \n *                         will make one batch request for maximum of 25 results\n * @param {number} options.maxConcurrentRequests - maximum number of concurrent requests sent to the org; \n *                         default and maximum is 15\n * @param {Callback.<DescribeSObjectResult[]>} [callback] - Callback function\n * @returns {Promise.<DescribeSObjectResult[]>}\n */\nConnection.prototype.batchDescribe = Connection.prototype.batchDescribeSObjects = function (\n  options,\n  callback\n) {\n  var self = this;\n  var types = options.types;\n  var autofetch = options.autofetch || false;\n  var maxConcurrentRequests = Math.min((options.maxConcurrentRequests || 15), 15);\n  var batches = [];\n  do {\n    var batch = types.length > MAX_BATCH_REQUESTS ? types.slice(0, MAX_BATCH_REQUESTS) : types;\n    batches.push(batch);\n    types = types.length > MAX_BATCH_REQUESTS ? types.slice(MAX_BATCH_REQUESTS) : [];\n  } while (types.length > 0 && autofetch);\n  var requestBatches = [];\n  do {\n    var requestBatch = batches.length > maxConcurrentRequests ? batches.slice(0, maxConcurrentRequests) : batches;\n    requestBatches.push(requestBatch);\n    batches = batches.length > maxConcurrentRequests ? batches.slice(maxConcurrentRequests) : [];\n  } while (batches.length > 0);\n  return self.doBatchDescribeRequestBatches(requestBatches)\n    .thenCall(callback);\n};\n\nConnection.prototype.doBatchDescribeRequestBatches = function(requestBatches) {\n  // make each batch of requests sequentially to avoid org limits of max concurrent requests\n  var self = this;\n  var sobjects = [];\n  var firstBatch = requestBatches.shift();\n  return self.doBatchOfBatchDescribeRequests(firstBatch).then(\n    function (sobjectArray) {\n      sobjectArray.forEach(function (sobject) { sobjects.push(sobject); });\n      if (requestBatches.length > 0) {\n        return self.doBatchDescribeRequestBatches(requestBatches).then(\n          function (results) {\n            results.forEach(function (result) { sobjects.push(result); });\n            return Promise.resolve(sobjects);\n          }\n        )\n      } else {\n        return Promise.resolve(sobjects);\n      }\n    }\n  )\n}\n\n/** private */\nConnection.prototype.doBatchOfBatchDescribeRequests = function(requestBatch) {\n  // make up to maxConcurrentRequest requests in parallel\n  var self = this;\n  return Promise.all(\n    requestBatch.map(function (batch) { return self.doBatchDescribeRequest(batch); } )\n  ).then(function (results) {\n    var sobjects = [];\n    results.forEach(function (sobjectArray) {\n      sobjectArray.forEach(function (sobject) { sobjects.push(sobject); })\n    });\n    return Promise.resolve(sobjects);\n});\n}\n\n/** private */\nConnection.prototype.doBatchDescribeRequest = function(types) {\n  var self = this;\n  var sobjects = [];\n  var url = [self._baseUrl(), \"composite/batch\"].join(\"/\");\n  var version = \"v\" + self.version;\n  var batchRequests = [];\n  types.forEach(function (type) {\n    batchRequests.push({\n      method: \"GET\",\n      url: [version, \"sobjects\", type, \"describe\"].join(\"/\")\n    });\n  });\n  return this.request({\n    method: \"POST\",\n    url: url,\n    body: JSON.stringify({ batchRequests: batchRequests }),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  }).then(function (response) {\n    if (response.results) {\n      var i = 0;\n      for (var i = 0; i < response.results.length; i++) {\n        var subResp = response.results[i];\n        if (Array.isArray(subResp.result)) {\n          if (subResp.result[0].errorCode && subResp.result[0].message) {\n            this._logger.error(\n              'Error: ' + subResp.result[0].errorCode + ' ' +  \n              subResp.result[0].message + ' - ' + typesToFetch[i]\n            );\n          }\n        } else {\n          sobjects.push(subResp.result);\n        }\n      }\n    }\n    return Promise.resolve(sobjects);\n  }); \n}\n\n/**\n * Result returned by describeGlobal call\n *\n * @typedef {Object} DescribeGlobalResult\n */\n/**\n * Describe global SObjects\n *\n * @param {Callback.<DescribeGlobalResult>} [callback] - Callback function\n * @returns {Promise.<DescribeGlobalResult>}\n */\nConnection.prototype.describeGlobal = function(callback) {\n  var url = this._baseUrl() + \"/sobjects\";\n  return this.request(url).thenCall(callback);\n};\n\n\n/**\n * Get SObject instance\n *\n * @param {String} type - SObject Type\n * @returns {SObject}\n */\nConnection.prototype.sobject = function(type) {\n  this.sobjects = this.sobjects || {};\n  var sobject = this.sobjects[type] =\n    this.sobjects[type] || new SObject(this, type);\n  return sobject;\n};\n\n/**\n * Get identity information of current user\n *\n * @param {Object} [options] - Identity call options\n * @param {Object} [options.headers] - Additional HTTP request headers sent in identity request\n * @param {Callback.<IdentityInfo>} [callback] - Callback function\n * @returns {Promise.<IdentityInfo>}\n */\nConnection.prototype.identity = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  var self = this;\n  var idUrl = this.userInfo && this.userInfo.url;\n  return Promise.resolve(\n    idUrl ?\n    { identity: idUrl } :\n    this.request({ method: 'GET', url: this._baseUrl(), headers: options.headers })\n  ).then(function(res) {\n    var url = res.identity;\n    return self.request({ method: 'GET', url: url });\n  }).then(function(res) {\n    self.userInfo = {\n      id: res.user_id,\n      organizationId: res.organization_id,\n      url: res.id\n    };\n    return res;\n  }).thenCall(callback);\n};\n\n/**\n * @typedef UserInfo\n * @prop {String} id - User ID\n * @prop {String} organizationId - Organization ID\n * @prop {String} url - Identity URL of the user\n */\n\n/**\n * Authorize (using oauth2 web server flow)\n *\n * @param {String} code - Authorization code\n * @param {Object} [params] - Optional parameters to send in token retrieval\n * @param {String} [params.code_verifier] - Code verifier value (RFC 7636 - Proof Key of Code Exchange)\n * @param {Callback.<UserInfo>} [callback] - Callback function\n * @returns {Promise.<UserInfo>}\n */\nConnection.prototype.authorize = function(code, params, callback) {\n  if (typeof params === 'function') {\n    callback = params;\n    params = {};\n  }\n  var self = this;\n  var logger = this._logger;\n\n  return this.oauth2.requestToken(code, params).then(function(res) {\n    var userInfo = parseIdUrl(res.id);\n    self.initialize({\n      instanceUrl : res.instance_url,\n      accessToken : res.access_token,\n      refreshToken : res.refresh_token,\n      userInfo: userInfo\n    });\n    logger.debug(\"<login> completed. user id = \" + userInfo.id + \", org id = \" + userInfo.organizationId);\n    return userInfo;\n\n  }).thenCall(callback);\n\n};\n\n\n/**\n * Login to Salesforce\n *\n * @param {String} username - Salesforce username\n * @param {String} password - Salesforce password (and security token, if required)\n * @param {Callback.<UserInfo>} [callback] - Callback function\n * @returns {Promise.<UserInfo>}\n */\nConnection.prototype.login = function(username, password, callback) {\n  // register refreshDelegate for session expiration\n  this._refreshDelegate = new HttpApi.SessionRefreshDelegate(this, createUsernamePasswordRefreshFn(username, password));\n  if (this.oauth2 && this.oauth2.clientId && this.oauth2.clientSecret) {\n    return this.loginByOAuth2(username, password, callback);\n  } else {\n    return this.loginBySoap(username, password, callback);\n  }\n};\n\n/** @private **/\nfunction createUsernamePasswordRefreshFn(username, password) {\n  return function(conn, callback) {\n    conn.login(username, password, function(err) {\n      if (err) { return callback(err); }\n      callback(null, conn.accessToken);\n    });\n  };\n}\n\n/**\n * Login by OAuth2 username & password flow\n *\n * @param {String} username - Salesforce username\n * @param {String} password - Salesforce password (and security token, if required)\n * @param {Callback.<UserInfo>} [callback] - Callback function\n * @returns {Promise.<UserInfo>}\n */\nConnection.prototype.loginByOAuth2 = function(username, password, callback) {\n  var self = this;\n  var logger = this._logger;\n  return this.oauth2.authenticate(username, password).then(function(res) {\n    var userInfo = parseIdUrl(res.id);\n    self.initialize({\n      instanceUrl : res.instance_url,\n      accessToken : res.access_token,\n      userInfo: userInfo\n    });\n    logger.debug(\"<login> completed. user id = \" + userInfo.id + \", org id = \" + userInfo.organizationId);\n    return userInfo;\n\n  }).thenCall(callback);\n\n};\n\n/**\n * @private\n */\nfunction esc(str) {\n  return str && String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;')\n                           .replace(/>/g, '&gt;').replace(/\"/g, '&quot;');\n}\n\n/**\n * Login by SOAP web service API\n *\n * @param {String} username - Salesforce username\n * @param {String} password - Salesforce password (and security token, if required)\n * @param {Callback.<UserInfo>} [callback] - Callback function\n * @returns {Promise.<UserInfo>}\n */\nConnection.prototype.loginBySoap = function(username, password, callback) {\n  var self = this;\n  var logger = this._logger;\n  var body = [\n    '<se:Envelope xmlns:se=\"http://schemas.xmlsoap.org/soap/envelope/\">',\n      '<se:Header/>',\n      '<se:Body>',\n        '<login xmlns=\"urn:partner.soap.sforce.com\">',\n          '<username>' + esc(username) + '</username>',\n          '<password>' + esc(password) + '</password>',\n        '</login>',\n      '</se:Body>',\n    '</se:Envelope>'\n  ].join('');\n\n  var soapLoginEndpoint = [ this.loginUrl, \"services/Soap/u\", this.version ].join('/');\n\n  return this._transport.httpRequest({\n    method : 'POST',\n    url : soapLoginEndpoint,\n    body : body,\n    headers : {\n      \"Content-Type\" : \"text/xml\",\n      \"SOAPAction\" : '\"\"'\n    }\n  }).then(function(response) {\n    var m;\n    if (response.statusCode >= 400) {\n      m = response.body.match(/<faultstring>([^<]+)<\\/faultstring>/);\n      var faultstring = m && m[1];\n      throw new Error(faultstring || response.body);\n    }\n    logger.debug(\"SOAP response = \" + response.body);\n    m = response.body.match(/<serverUrl>([^<]+)<\\/serverUrl>/);\n    var serverUrl = m && m[1];\n    m = response.body.match(/<sessionId>([^<]+)<\\/sessionId>/);\n    var sessionId = m && m[1];\n    m = response.body.match(/<userId>([^<]+)<\\/userId>/);\n    var userId = m && m[1];\n    m = response.body.match(/<organizationId>([^<]+)<\\/organizationId>/);\n    var orgId = m && m[1];\n    var idUrl = soapLoginEndpoint.split('/').slice(0, 3).join('/');\n    idUrl += \"/id/\" + orgId + \"/\" + userId;\n    var userInfo = {\n      id: userId,\n      organizationId: orgId,\n      url: idUrl\n    };\n    self.initialize({\n      serverUrl: serverUrl.split('/').slice(0, 3).join('/'),\n      sessionId: sessionId,\n      userInfo: userInfo\n    });\n    logger.debug(\"<login> completed. user id = \" + userId + \", org id = \" + orgId);\n    return userInfo;\n\n  }).thenCall(callback);\n\n};\n\n/**\n * Logout the current session \n *\n * @param {Boolean} [revoke] - Revokes API Access if set to true\n * @param {Callback.<undefined>} [callback] - Callback function\n * @returns {Promise.<undefined>}\n */\nConnection.prototype.logout = function(revoke, callback) {\n  if (typeof revoke === 'function') {\n    callback = revoke;\n    revoke = false;\n  }\n\n  if (this._sessionType === \"oauth2\") {\n    return this.logoutByOAuth2(revoke, callback);\n  } else {\n    return this.logoutBySoap(revoke, callback);\n  }\n};\n\n/**\n * Logout the current session by revoking access token via OAuth2 session revoke\n *\n * @param {Boolean} [revoke] - Revokes API Access if set to true\n * @param {Callback.<undefined>} [callback] - Callback function\n * @returns {Promise.<undefined>}\n */\nConnection.prototype.logoutByOAuth2 = function(revoke, callback) {\n  if (typeof revoke === 'function') {\n    callback = revoke;\n    revoke = false;\n  }\n  var self = this;\n  var logger = this._logger;\n\n  return this.oauth2.revokeToken(revoke ? this.refreshToken : this.accessToken).then(function() {\n    // Destroy the session bound to this connection\n    self.accessToken = null;\n    self.userInfo = null;\n    self.refreshToken = null;\n    self.instanceUrl = null;\n    self.cache.clear();\n\n    // nothing useful returned by logout API, just return\n    return undefined;\n  }).thenCall(callback);\n};\n\n\n/**\n * Logout the session by using SOAP web service API\n *\n * @param {Boolean} [revoke] - Revokes API Access if set to true\n * @param {Callback.<undefined>} [callback] - Callback function\n * @returns {Promise.<undefined>}\n */\nConnection.prototype.logoutBySoap = function(revoke, callback) {\n  if (typeof revoke === 'function') {\n    callback = revoke;\n    revoke = false;\n  }\n  var self = this;\n  var logger = this._logger;\n\n  var body = [\n    '<se:Envelope xmlns:se=\"http://schemas.xmlsoap.org/soap/envelope/\">',\n      '<se:Header>',\n        '<SessionHeader xmlns=\"urn:partner.soap.sforce.com\">',\n          '<sessionId>' + esc(revoke ? this.refreshToken : this.accessToken) + '</sessionId>',\n        '</SessionHeader>',\n      '</se:Header>',\n      '<se:Body>',\n        '<logout xmlns=\"urn:partner.soap.sforce.com\"/>',\n      '</se:Body>',\n    '</se:Envelope>'\n  ].join('');\n\n  return this._transport.httpRequest({\n    method : 'POST',\n    url : [ this.instanceUrl, \"services/Soap/u\", this.version ].join('/'),\n    body : body,\n    headers : {\n      \"Content-Type\" : \"text/xml\",\n      \"SOAPAction\" : '\"\"'\n    }\n  }).then(function(response) {\n    logger.debug(\"SOAP statusCode = \" + response.statusCode + \", response = \" + response.body);\n    if (response.statusCode >= 400) {\n      var m = response.body.match(/<faultstring>([^<]+)<\\/faultstring>/);\n      var faultstring = m && m[1];\n      throw new Error(faultstring || response.body);\n    }\n\n    // Destroy the session bound to this connection\n    self.accessToken = null;\n    self.userInfo = null;\n    self.refreshToken = null;\n    self.instanceUrl = null;\n    self.cache.clear();\n\n    // nothing useful returned by logout API, just return\n    return undefined;\n\n  }).thenCall(callback);\n};\n\n/**\n * List recently viewed records\n *\n * @param {String} [type] - SObject type\n * @param {Number} [limit] - Limit num to fetch\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\nConnection.prototype.recent = function(type, limit, callback) {\n  if (!_.isString(type)) {\n    callback = limit;\n    limit = type;\n    type = undefined;\n  }\n  if (!_.isNumber(limit)) {\n    callback = limit;\n    limit = undefined;\n  }\n  var url;\n  if (type) {\n    url = [ this._baseUrl(), \"sobjects\", type ].join('/');\n    return this.request(url).then(function(res) {\n      return limit ? res.recentItems.slice(0, limit) : res.recentItems;\n    }).thenCall(callback);\n  } else {\n    url = this._baseUrl() + \"/recent\";\n    if (limit) {\n      url += \"?limit=\" + limit;\n    }\n    return this.request(url).thenCall(callback);\n  }\n\n};\n\n/**\n * @typedef {Object} UpdatedRecordsInfo\n * @prop {String} latestDateCovered - The timestamp of the last date covered.\n * @prop {Array.<String>} ids - Updated record IDs.\n */\n\n/**\n * Retrieve updated records\n *\n * @param {String} type - SObject Type\n * @param {String|Date} start - start date or string representing the start of the interval\n * @param {String|Date} end - start date or string representing the end of the interval must be > start\n * @param {Callback.<UpdatedRecordsInfo>} [callback] - Callback function\n * @returns {Promise.<UpdatedRecordsInfo>}\n */\nConnection.prototype.updated = function (type, start, end, callback) {\n  var url = [ this._baseUrl(), \"sobjects\", type, \"updated\" ].join('/');\n\n  if (typeof start === 'string') {\n    start = new Date(start);\n  }\n\n  if (start instanceof Date) {\n    start = formatDate(start);\n  }\n\n  if (start) {\n    url += \"?start=\" + encodeURIComponent(start);\n  }\n\n  if (typeof end === 'string') {\n    end = new Date(end);\n  }\n\n  if (end instanceof Date) {\n    end = formatDate(end);\n  }\n\n  if (end) {\n    url += \"&end=\" + encodeURIComponent(end);\n  }\n\n  return this.request(url).thenCall(callback);\n};\n\n/**\n * @typedef {Object} DeletedRecordsInfo\n * @prop {String} earliestDateAvailable - The timestamp of the earliest date available\n * @prop {String} latestDateCovered - The timestamp of the last date covered\n * @prop {Array.<Object>} deletedRecords - Updated records\n * @prop {String} deletedRecords.id - Record ID\n * @prop {String} deletedRecords.deletedDate - The timestamp when this record was deleted\n */\n\n/**\n * Retrieve deleted records\n *\n * @param {String} type - SObject Type\n * @param {String|Date} start - start date or string representing the start of the interval\n * @param {String|Date} end - start date or string representing the end of the interval\n * @param {Callback.<DeletedRecordsInfo>} [callback] - Callback function\n * @returns {Promise.<DeletedRecordsInfo>}\n */\nConnection.prototype.deleted = function (type, start, end, callback) {\n  var url = [ this._baseUrl(), \"sobjects\", type, \"deleted\" ].join('/');\n\n  if (typeof start === 'string') {\n    start = new Date(start);\n  }\n\n  if (start instanceof Date) {\n    start = formatDate(start);\n  }\n\n  if (start) {\n    url += \"?start=\" + encodeURIComponent(start);\n  }\n\n  if (typeof end === 'string') {\n    end = new Date(end);\n  }\n\n  if (end instanceof Date) {\n    end = formatDate(end);\n  }\n\n  if (end) {\n    url += \"&end=\" + encodeURIComponent(end);\n  }\n\n  return this.request(url).thenCall(callback);\n};\n\n\n/**\n * @typedef {Object} TabsInfo - See the API document for detail structure\n */\n\n/**\n * Returns a list of all tabs\n *\n * @param {Callback.<TabsInfo>} [callback] - Callback function\n * @returns {Promise.<TabsInfo>}\n */\nConnection.prototype.tabs = function(callback) {\n  var url = [ this._baseUrl(), \"tabs\" ].join('/');\n  return this.request(url).thenCall(callback);\n};\n\n\n/**\n * @typedef {Object} LimitsInfo - See the API document for detail structure\n */\n\n/**\n * Returns curren system limit in the organization\n *\n * @param {Callback.<LimitsInfo>} [callback] - Callback function\n * @returns {Promise.<LimitsInfo>}\n */\nConnection.prototype.limits = function(callback) {\n  var url = [ this._baseUrl(), \"limits\" ].join('/');\n  return this.request(url).thenCall(callback);\n};\n\n\n/**\n * @typedef {Object} ThemeInfo - See the API document for detail structure\n */\n\n/**\n * Returns a theme info\n *\n * @param {Callback.<ThemeInfo>} [callback] - Callback function\n * @returns {Promise.<ThemeInfo>}\n */\nConnection.prototype.theme = function(callback) {\n  var url = [ this._baseUrl(), \"theme\" ].join('/');\n  return this.request(url).thenCall(callback);\n};\n\n/**\n * Returns all registered global quick actions\n *\n * @param {Callback.<Array.<QuickAction~QuickActionInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<QuickAction~QuickActionInfo>>}\n */\nConnection.prototype.quickActions = function(callback) {\n  return this.request(\"/quickActions\").thenCall(callback);\n};\n\n/**\n * Get reference for specified global quick aciton\n *\n * @param {String} actionName - Name of the global quick action\n * @returns {QuickAction}\n */\nConnection.prototype.quickAction = function(actionName) {\n  return new QuickAction(this, \"/quickActions/\" + actionName);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9jb25uZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHNCQUFRO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyxzRUFBVTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsbUVBQWE7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLHlFQUFXO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyx1RUFBVTtBQUNoQyxjQUFjLG1CQUFPLENBQUMsdUVBQVU7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLHFFQUFTO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyx5RUFBVztBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBZ0I7QUFDMUMsY0FBYyxtQkFBTyxDQUFDLDJFQUFZO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLDZFQUFhO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyx5RUFBVztBQUNqQyxjQUFjLG1CQUFPLENBQUMscUVBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQVE7QUFDaEM7O0FBRUE7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQ0FBZ0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0EsTUFBTSxPQUFPO0FBQ2IscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsR0FBRztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxnQkFBZ0I7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyx3QkFBd0I7QUFDbkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHdCQUF3QjtBQUNuQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyx3QkFBd0I7QUFDbkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtDQUFrQztBQUM3QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnREFBZ0Q7QUFDaEQ7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxnQkFBZ0I7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtCQUErQjtBQUNwRCxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLDhDQUE4QztBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhDQUE4QztBQUM5QztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLDhDQUE4QztBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILHlCQUF5QjtBQUN6QixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhDQUE4QztBQUM5QztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLDhDQUE4QztBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLDZCQUE2QjtBQUM3QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLDhDQUE4QztBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyw4Q0FBOEM7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QjtBQUN6QixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVEsZ0VBQWdFO0FBQ25GLFdBQVcsa0NBQWtDO0FBQzdDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUSxnRUFBZ0U7QUFDbkYsV0FBVyxrQ0FBa0M7QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsVUFBVTtBQUNyQixXQUFXLFNBQVM7QUFDcEIsc0ZBQXNGO0FBQ3RGLHFGQUFxRjtBQUNyRjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsb0NBQW9DO0FBQy9DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEMsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQixzRkFBc0Y7QUFDdEYscUZBQXFGO0FBQ3JGO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxvQ0FBb0M7QUFDL0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx3QkFBd0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw2Q0FBNkM7QUFDckY7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlCQUF5QjtBQUN6RSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhCQUE4QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyx5QkFBeUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtCQUFrQjtBQUN4QixtQkFBbUIsK0RBQStEO0FBQ2xGO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzQkFBc0I7QUFDdEUsK0NBQStDLHdCQUF3QjtBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxzQkFBc0I7QUFDakMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxzQkFBc0I7QUFDakMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsc0JBQXNCO0FBQ2pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxnQkFBZ0I7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsV0FBVywrQkFBK0I7QUFDMUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxnQkFBZ0I7QUFDMUIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLCtCQUErQjtBQUMxQyxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnREFBZ0Q7QUFDM0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2Nvbm5lY3Rpb24uanM/MmZlZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBCdWZmZXIgKi9cbi8qKlxuICogQGZpbGUgQ29ubmVjdGlvbiBjbGFzcyB0byBrZWVwIHRoZSBBUEkgc2Vzc2lvbiBpbmZvcm1hdGlvbiBhbmQgbWFuYWdlIHJlcXVlc3RzXG4gKiBAYXV0aG9yIFNoaW5pY2hpIFRvbWl0YSA8c2hpbmljaGkudG9taXRhQGdtYWlsLmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudHMgID0gcmVxdWlyZSgnZXZlbnRzJyksXG4gICAgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgIF8gICAgICAgPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL3Byb21pc2UnKSxcbiAgICBMb2dnZXIgID0gcmVxdWlyZSgnLi9sb2dnZXInKSxcbiAgICBPQXV0aDIgID0gcmVxdWlyZSgnLi9vYXV0aDInKSxcbiAgICBRdWVyeSAgID0gcmVxdWlyZSgnLi9xdWVyeScpLFxuICAgIFNPYmplY3QgPSByZXF1aXJlKCcuL3NvYmplY3QnKSxcbiAgICBRdWlja0FjdGlvbiA9IHJlcXVpcmUoJy4vcXVpY2stYWN0aW9uJyksXG4gICAgSHR0cEFwaSA9IHJlcXVpcmUoJy4vaHR0cC1hcGknKSxcbiAgICBUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpLFxuICAgIFByb2Nlc3MgPSByZXF1aXJlKCcuL3Byb2Nlc3MnKSxcbiAgICBDYWNoZSAgID0gcmVxdWlyZSgnLi9jYWNoZScpO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGxvZ2luVXJsOiBcImh0dHBzOi8vbG9naW4uc2FsZXNmb3JjZS5jb21cIixcbiAgaW5zdGFuY2VVcmw6IFwiXCIsXG4gIHZlcnNpb246IFwiNDIuMFwiXG59O1xuXG4vKlxuICogQ29uc3RhbnQgb2YgbWF4aW11bSByZWNvcmRzIG51bSBpbiBETUwgb3BlcmF0aW9uICh1cGRhdGUvZGVsZXRlKVxuICovXG52YXIgTUFYX0RNTF9DT1VOVCA9IDIwMDtcblxuLypcbiAqIENvbnN0YW50IG9mIG1heGltdW0gbnVtYmVyIG9mIHJlcXVlc3RzIHRoYXQgY2FuIGJlIGJhdGNoZWRcbiAqL1xudmFyIE1BWF9CQVRDSF9SRVFVRVNUUyA9IDI1O1xuXG4vKipcbiAqIENvbm5lY3Rpb24gY2xhc3MgdG8ga2VlcCB0aGUgQVBJIHNlc3Npb24gaW5mb3JtYXRpb24gYW5kIG1hbmFnZSByZXF1ZXN0c1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHBhcmFtIHtPQXV0aDJ8T2JqZWN0fSBbb3B0aW9ucy5vYXV0aDJdIC0gT0F1dGgyIGluc3RhbmNlIG9yIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIE9BdXRoMiBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmxvZ0xldmVsXSAtIE91dHB1dCBsb2dnaW5nIGxldmVsIChERUJVR3xJTkZPfFdBUk58RVJST1J8RkFUQUwpXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudmVyc2lvbl0gLSBTYWxlc2ZvcmNlIEFQSSBWZXJzaW9uICh3aXRob3V0IFwidlwiIHByZWZpeClcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhSZXF1ZXN0XSAtIE1heCBudW1iZXIgb2YgcmVxdWVzdHMgYWxsb3dlZCBpbiBwYXJhbGxlbCBjYWxsXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubG9naW5VcmxdIC0gU2FsZXNmb3JjZSBMb2dpbiBTZXJ2ZXIgVVJMIChlLmcuIGh0dHBzOi8vbG9naW4uc2FsZXNmb3JjZS5jb20vKVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmluc3RhbmNlVXJsXSAtIFNhbGVzZm9yY2UgSW5zdGFuY2UgVVJMIChlLmcuIGh0dHBzOi8vbmExLnNhbGVzZm9yY2UuY29tLylcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zZXJ2ZXJVcmxdIC0gU2FsZXNmb3JjZSBTT0FQIHNlcnZpY2UgZW5kcG9pbnQgVVJMIChlLmcuIGh0dHBzOi8vbmExLnNhbGVzZm9yY2UuY29tL3NlcnZpY2VzL1NvYXAvdS8yOC4wKVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFjY2Vzc1Rva2VuXSAtIFNhbGVzZm9yY2UgT0F1dGgyIGFjY2VzcyB0b2tlblxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNlc3Npb25JZF0gLSBTYWxlc2ZvcmNlIHNlc3Npb24gSURcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZWZyZXNoVG9rZW5dIC0gU2FsZXNmb3JjZSBPQXV0aDIgcmVmcmVzaCB0b2tlblxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBbb3B0aW9ucy5zaWduZWRSZXF1ZXN0XSAtIFNhbGVzZm9yY2UgQ2FudmFzIHNpZ25lZCByZXF1ZXN0IChSYXcgQmFzZTY0IHN0cmluZywgSlNPTiBzdHJpbmcsIG9yIGRlc2VyaWFsaXplZCBKU09OKVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnByb3h5VXJsXSAtIENyb3NzLWRvbWFpbiBwcm94eSBzZXJ2ZXIgVVJMLCB1c2VkIGluIGJyb3dzZXIgY2xpZW50LCBub24gVmlzdWFsZm9yY2UgYXBwLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmh0dHBQcm94eV0gLSBVUkwgb2YgSFRUUCBwcm94eSBzZXJ2ZXIsIHVzZWQgaW4gc2VydmVyIGNsaWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jYWxsT3B0aW9uc10gLSBDYWxsIG9wdGlvbnMgdXNlZCBpbiBlYWNoIFNPQVAvUkVTVCBBUEkgcmVxdWVzdC4gU2VlIG1hbnVhbC5cbiAqL1xudmFyIENvbm5lY3Rpb24gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihvcHRpb25zLmxvZ0xldmVsKTtcblxuICB2YXIgb2F1dGgyID0gb3B0aW9ucy5vYXV0aDIgfHwge1xuICAgIGxvZ2luVXJsIDogb3B0aW9ucy5sb2dpblVybCxcbiAgICBjbGllbnRJZCA6IG9wdGlvbnMuY2xpZW50SWQsXG4gICAgY2xpZW50U2VjcmV0IDogb3B0aW9ucy5jbGllbnRTZWNyZXQsXG4gICAgcmVkaXJlY3RVcmkgOiBvcHRpb25zLnJlZGlyZWN0VXJpLFxuICAgIHByb3h5VXJsOiBvcHRpb25zLnByb3h5VXJsLFxuICAgIGh0dHBQcm94eTogb3B0aW9ucy5odHRwUHJveHlcbiAgfTtcblxuICAvKipcbiAgICogT0F1dGgyIG9iamVjdFxuICAgKiBAbWVtYmVyIHtPQXV0aDJ9IENvbm5lY3Rpb24jb2F1dGgyXG4gICAqL1xuICB0aGlzLm9hdXRoMiA9IG9hdXRoMiA9IG9hdXRoMiBpbnN0YW5jZW9mIE9BdXRoMiA/IG9hdXRoMiA6IG5ldyBPQXV0aDIob2F1dGgyKTtcblxuICB0aGlzLmxvZ2luVXJsID0gb3B0aW9ucy5sb2dpblVybCB8fCBvYXV0aDIubG9naW5VcmwgfHwgZGVmYXVsdHMubG9naW5Vcmw7XG4gIHRoaXMudmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbiB8fCBkZWZhdWx0cy52ZXJzaW9uO1xuICB0aGlzLm1heFJlcXVlc3QgPSBvcHRpb25zLm1heFJlcXVlc3QgfHwgdGhpcy5tYXhSZXF1ZXN0IHx8IDEwO1xuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBpZiAob3B0aW9ucy5wcm94eVVybCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG5ldyBUcmFuc3BvcnQuUHJveHlUcmFuc3BvcnQob3B0aW9ucy5wcm94eVVybCk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5odHRwUHJveHkpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0Lkh0dHBQcm94eVRyYW5zcG9ydChvcHRpb25zLmh0dHBQcm94eSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydCgpO1xuICB9XG5cbiAgdGhpcy5jYWxsT3B0aW9ucyA9IG9wdGlvbnMuY2FsbE9wdGlvbnM7XG5cbiAgLypcbiAgICogRmlyZSBjb25uZWN0aW9uOm5ldyBldmVudCB0byBub3RpZnkganNmb3JjZSBwbHVnaW4gbW9kdWxlc1xuICAgKi9cbiAgdmFyIGpzZm9yY2UgPSByZXF1aXJlKCcuL2NvcmUnKTtcbiAganNmb3JjZS5lbWl0KCdjb25uZWN0aW9uOm5ldycsIHRoaXMpO1xuXG4gIC8qKlxuICAgKiBTdHJlYW1pbmcgQVBJIG9iamVjdFxuICAgKiBAbWVtYmVyIHtTdHJlYW1pbmd9IENvbm5lY3Rpb24jc3RyZWFtaW5nXG4gICAqL1xuICAvLyB0aGlzLnN0cmVhbWluZyA9IG5ldyBTdHJlYW1pbmcodGhpcyk7XG4gIC8qKlxuICAgKiBCdWxrIEFQSSBvYmplY3RcbiAgICogQG1lbWJlciB7QnVsa30gQ29ubmVjdGlvbiNidWxrXG4gICAqL1xuICAvLyB0aGlzLmJ1bGsgPSBuZXcgQnVsayh0aGlzKTtcbiAgLyoqXG4gICAqIFRvb2xpbmcgQVBJIG9iamVjdFxuICAgKiBAbWVtYmVyIHtUb29saW5nfSBDb25uZWN0aW9uI3Rvb2xpbmdcbiAgICovXG4gIC8vIHRoaXMudG9vbGluZyA9IG5ldyBUb29saW5nKHRoaXMpO1xuICAvKipcbiAgICogQW5hbHl0aWNzIEFQSSBvYmplY3RcbiAgICogQG1lbWJlciB7QW5hbHl0aWNzfSBDb25uZWN0aW9uI2FuYWx5dGljc1xuICAgKi9cbiAgLy8gdGhpcy5hbmFseXRpY3MgPSBuZXcgQW5hbHl0aWNzKHRoaXMpO1xuICAvKipcbiAgICogQ2hhdHRlciBBUEkgb2JqZWN0XG4gICAqIEBtZW1iZXIge0NoYXR0ZXJ9IENvbm5lY3Rpb24jY2hhdHRlclxuICAgKi9cbiAgLy8gdGhpcy5jaGF0dGVyID0gbmV3IENoYXR0ZXIodGhpcyk7XG4gIC8qKlxuICAgKiBNZXRhZGF0YSBBUEkgb2JqZWN0XG4gICAqIEBtZW1iZXIge01ldGFkYXRhfSBDb25uZWN0aW9uI21ldGFkYXRhXG4gICAqL1xuICAvLyB0aGlzLm1ldGFkYXRhID0gbmV3IE1ldGFkYXRhKHRoaXMpO1xuXG4gIC8qKlxuICAgKiBTT0FQIEFQSSBvYmplY3RcbiAgICogQG1lbWJlciB7U29hcEFwaX0gQ29ubmVjdGlvbiNzb2FwXG4gICAqL1xuICAvLyB0aGlzLnNvYXAgPSBuZXcgU29hcEFwaSh0aGlzKTtcblxuICAvKipcbiAgICogQXBleCBSRVNUIEFQSSBvYmplY3RcbiAgICogQG1lbWJlciB7QXBleH0gQ29ubmVjdGlvbiNhcGV4XG4gICAqL1xuICAvLyB0aGlzLmFwZXggPSBuZXcgQXBleCh0aGlzKTtcblxuICAvKipcbiAgICogQG1lbWJlciB7UHJvY2Vzc30gQ29ubmVjdGlvbiNwcm9jZXNzXG4gICAqL1xuICB0aGlzLnByb2Nlc3MgPSBuZXcgUHJvY2Vzcyh0aGlzKTtcblxuICAvKipcbiAgICogQ2FjaGUgb2JqZWN0IGZvciByZXN1bHRcbiAgICogQG1lbWJlciB7Q2FjaGV9IENvbm5lY3Rpb24jY2FjaGVcbiAgICovXG4gIHRoaXMuY2FjaGUgPSBuZXcgQ2FjaGUoKTtcblxuICAvLyBBbGxvdyB0byBkZWxlZ2F0ZSBjb25uZWN0aW9uIHJlZnJlc2ggdG8gb3V0ZXIgZnVuY3Rpb25cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcmVmcmVzaEZuID0gb3B0aW9ucy5yZWZyZXNoRm47XG4gIGlmICghcmVmcmVzaEZuICYmIHRoaXMub2F1dGgyLmNsaWVudElkKSB7XG4gICAgcmVmcmVzaEZuID0gb2F1dGhSZWZyZXNoRm47XG4gIH1cbiAgaWYgKHJlZnJlc2hGbikge1xuICAgIHRoaXMuX3JlZnJlc2hEZWxlZ2F0ZSA9IG5ldyBIdHRwQXBpLlNlc3Npb25SZWZyZXNoRGVsZWdhdGUodGhpcywgcmVmcmVzaEZuKTtcbiAgfVxuXG4gIHZhciBjYWNoZU9wdGlvbnMgPSB7XG4gICAga2V5OiBmdW5jdGlvbih0eXBlKSB7IFxuICAgICAgcmV0dXJuIHR5cGUgXG4gICAgICAgID8gdHlwZS50eXBlID8gXCJkZXNjcmliZS5cIiArIHR5cGUudHlwZSA6IFwiZGVzY3JpYmUuXCIgKyB0eXBlXG4gICAgICAgIDogXCJkZXNjcmliZVwiOyBcbiAgICB9XG4gIH07XG4gIHRoaXMuZGVzY3JpYmUkID0gdGhpcy5jYWNoZS5tYWtlQ2FjaGVhYmxlKHRoaXMuZGVzY3JpYmUsIHRoaXMsIGNhY2hlT3B0aW9ucyk7XG4gIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmNhY2hlLm1ha2VSZXNwb25zZUNhY2hlYWJsZSh0aGlzLmRlc2NyaWJlLCB0aGlzLCBjYWNoZU9wdGlvbnMpO1xuICB0aGlzLmRlc2NyaWJlU09iamVjdCQgPSB0aGlzLmRlc2NyaWJlJDtcbiAgdGhpcy5kZXNjcmliZVNPYmplY3QgPSB0aGlzLmRlc2NyaWJlO1xuXG4gIHZhciBiYXRjaENhY2hlT3B0aW9ucyA9IHtcbiAgICBrZXk6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciB0eXBlcyA9IG9wdGlvbnMudHlwZXM7XG4gICAgICB2YXIgYXV0b2ZldGNoID0gb3B0aW9ucy5hdXRvZmV0Y2ggfHwgZmFsc2U7XG4gICAgICB2YXIgdHlwZXNUb0ZldGNoID0gdHlwZXMubGVuZ3RoID4gTUFYX0JBVENIX1JFUVVFU1RTIFxuICAgICAgICA/IChhdXRvZmV0Y2ggPyB0eXBlcyA6IHR5cGVzLnNsaWNlKDAsIE1BWF9CQVRDSF9SRVFVRVNUUykpXG4gICAgICAgIDogdHlwZXM7XG4gICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgdHlwZXNUb0ZldGNoLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHsga2V5cy5wdXNoKCdkZXNjcmliZS4nICsgdHlwZSk7IH0pO1xuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICB9O1xuICB0aGlzLmJhdGNoRGVzY3JpYmUgPSB0aGlzLmNhY2hlLm1ha2VSZXNwb25zZUNhY2hlYWJsZSh0aGlzLmJhdGNoRGVzY3JpYmUsIHRoaXMsIGJhdGNoQ2FjaGVPcHRpb25zKTtcbiAgdGhpcy5iYXRjaERlc2NyaWJlU09iamVjdHMgPSB0aGlzLmJhdGNoRGVzY3JpYmU7XG5cbiAgY2FjaGVPcHRpb25zID0geyBrZXk6ICdkZXNjcmliZUdsb2JhbCcgfTtcbiAgdGhpcy5kZXNjcmliZUdsb2JhbCQgPSB0aGlzLmNhY2hlLm1ha2VDYWNoZWFibGUodGhpcy5kZXNjcmliZUdsb2JhbCwgdGhpcywgY2FjaGVPcHRpb25zKTtcbiAgdGhpcy5kZXNjcmliZUdsb2JhbCA9IHRoaXMuY2FjaGUubWFrZVJlc3BvbnNlQ2FjaGVhYmxlKHRoaXMuZGVzY3JpYmVHbG9iYWwsIHRoaXMsIGNhY2hlT3B0aW9ucyk7XG5cbiAgdGhpcy5pbml0aWFsaXplKG9wdGlvbnMpO1xufTtcblxuaW5oZXJpdHMoQ29ubmVjdGlvbiwgZXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBjb25uZWN0aW9uLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gSW5pdGlhbGl6YXRpb24gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmluc3RhbmNlVXJsXSAtIFNhbGVzZm9yY2UgSW5zdGFuY2UgVVJMIChlLmcuIGh0dHBzOi8vbmExLnNhbGVzZm9yY2UuY29tLylcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zZXJ2ZXJVcmxdIC0gU2FsZXNmb3JjZSBTT0FQIHNlcnZpY2UgZW5kcG9pbnQgVVJMIChlLmcuIGh0dHBzOi8vbmExLnNhbGVzZm9yY2UuY29tL3NlcnZpY2VzL1NvYXAvdS8yOC4wKVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFjY2Vzc1Rva2VuXSAtIFNhbGVzZm9yY2UgT0F1dGgyIGFjY2VzcyB0b2tlblxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNlc3Npb25JZF0gLSBTYWxlc2ZvcmNlIHNlc3Npb24gSURcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZWZyZXNoVG9rZW5dIC0gU2FsZXNmb3JjZSBPQXV0aDIgcmVmcmVzaCB0b2tlblxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBbb3B0aW9ucy5zaWduZWRSZXF1ZXN0XSAtIFNhbGVzZm9yY2UgQ2FudmFzIHNpZ25lZCByZXF1ZXN0IChSYXcgQmFzZTY0IHN0cmluZywgSlNPTiBzdHJpbmcsIG9yIGRlc2VyaWFsaXplZCBKU09OKVxuICogQHBhcmFtIHtVc2VySW5mb30gW29wdGlvbnMudXNlckluZm9dIC0gTG9nZ2VkIGluIHVzZXIgaW5mb3JtYXRpb25cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zLmluc3RhbmNlVXJsICYmIG9wdGlvbnMuc2VydmVyVXJsKSB7XG4gICAgb3B0aW9ucy5pbnN0YW5jZVVybCA9IG9wdGlvbnMuc2VydmVyVXJsLnNwbGl0KCcvJykuc2xpY2UoMCwgMykuam9pbignLycpO1xuICB9XG4gIHRoaXMuaW5zdGFuY2VVcmwgPSBvcHRpb25zLmluc3RhbmNlVXJsIHx8IG9wdGlvbnMuc2VydmVyVXJsIHx8IHRoaXMuaW5zdGFuY2VVcmwgfHwgZGVmYXVsdHMuaW5zdGFuY2VVcmw7XG5cbiAgdGhpcy5hY2Nlc3NUb2tlbiA9IG9wdGlvbnMuc2Vzc2lvbklkIHx8IG9wdGlvbnMuYWNjZXNzVG9rZW4gfHwgdGhpcy5hY2Nlc3NUb2tlbjtcbiAgdGhpcy5yZWZyZXNoVG9rZW4gPSBvcHRpb25zLnJlZnJlc2hUb2tlbiB8fCB0aGlzLnJlZnJlc2hUb2tlbjtcbiAgaWYgKHRoaXMucmVmcmVzaFRva2VuICYmICF0aGlzLl9yZWZyZXNoRGVsZWdhdGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWZyZXNoIHRva2VuIGlzIHNwZWNpZmllZCB3aXRob3V0IG9hdXRoMiBjbGllbnQgaW5mb3JtYXRpb24gb3IgcmVmcmVzaCBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHRoaXMuc2lnbmVkUmVxdWVzdCA9IG9wdGlvbnMuc2lnbmVkUmVxdWVzdCAmJiBwYXJzZVNpZ25lZFJlcXVlc3Qob3B0aW9ucy5zaWduZWRSZXF1ZXN0KTtcbiAgaWYgKHRoaXMuc2lnbmVkUmVxdWVzdCkge1xuICAgIHRoaXMuYWNjZXNzVG9rZW4gPSB0aGlzLnNpZ25lZFJlcXVlc3QuY2xpZW50Lm9hdXRoVG9rZW47XG4gICAgaWYgKFRyYW5zcG9ydC5DYW52YXNUcmFuc3BvcnQuc3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl90cmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0LkNhbnZhc1RyYW5zcG9ydCh0aGlzLnNpZ25lZFJlcXVlc3QpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnVzZXJJbmZvKSB7XG4gICAgdGhpcy51c2VySW5mbyA9IG9wdGlvbnMudXNlckluZm87XG4gIH1cblxuICB0aGlzLmxpbWl0SW5mbyA9IHt9O1xuXG4gIHRoaXMuc29iamVjdHMgPSB7fTtcbiAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICB0aGlzLmNhY2hlLmdldCgnZGVzY3JpYmVHbG9iYWwnKS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3ZhbHVlJyk7XG4gIHRoaXMuY2FjaGUuZ2V0KCdkZXNjcmliZUdsb2JhbCcpLm9uKCd2YWx1ZScsIF8uYmluZChmdW5jdGlvbihyZXMpIHtcbiAgICBpZiAocmVzLnJlc3VsdCkge1xuICAgICAgdmFyIHR5cGVzID0gXy5tYXAocmVzLnJlc3VsdC5zb2JqZWN0cywgZnVuY3Rpb24oc28pIHsgcmV0dXJuIHNvLm5hbWU7IH0pO1xuICAgICAgdHlwZXMuZm9yRWFjaCh0aGlzLnNvYmplY3QsIHRoaXMpO1xuICAgIH1cbiAgfSwgdGhpcykpO1xuXG4gIGlmICh0aGlzLnRvb2xpbmcpIHtcbiAgICB0aGlzLnRvb2xpbmcuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgdGhpcy5fc2Vzc2lvblR5cGUgPSBvcHRpb25zLnNlc3Npb25JZCA/IFwic29hcFwiIDogXCJvYXV0aDJcIjtcblxufTtcblxuLyoqIEBwcml2YXRlICoqL1xuZnVuY3Rpb24gb2F1dGhSZWZyZXNoRm4oY29ubiwgY2FsbGJhY2spIHtcbiAgY29ubi5vYXV0aDIucmVmcmVzaFRva2VuKGNvbm4ucmVmcmVzaFRva2VuLCBmdW5jdGlvbihlcnIsIHJlcykge1xuICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH1cbiAgICB2YXIgdXNlckluZm8gPSBwYXJzZUlkVXJsKHJlcy5pZCk7XG4gICAgY29ubi5pbml0aWFsaXplKHtcbiAgICAgIGluc3RhbmNlVXJsIDogcmVzLmluc3RhbmNlX3VybCxcbiAgICAgIGFjY2Vzc1Rva2VuIDogcmVzLmFjY2Vzc190b2tlbixcbiAgICAgIHVzZXJJbmZvIDogdXNlckluZm9cbiAgICB9KTtcbiAgICBjYWxsYmFjayhudWxsLCByZXMuYWNjZXNzX3Rva2VuLCByZXMpO1xuICB9KTtcbn1cblxuLyoqIEBwcml2YXRlICoqL1xuZnVuY3Rpb24gcGFyc2VTaWduZWRSZXF1ZXN0KHNyKSB7XG4gIGlmIChfLmlzU3RyaW5nKHNyKSkge1xuICAgIGlmIChzclswXSA9PT0gJ3snKSB7IC8vIG1pZ2h0IGJlIEpTT05cbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHNyKTtcbiAgICB9IGVsc2UgeyAvLyBtaWdodCBiZSBvcmlnaW5hbCBiYXNlNjQtZW5jb2RlZCBzaWduZWQgcmVxdWVzdFxuICAgICAgdmFyIG1zZyA9IHNyLnNwbGl0KCcuJykucG9wKCk7IC8vIHJldHJpZXZlIGxhdHRlciBwYXJ0XG4gICAgICB2YXIganNvbiA9IEJ1ZmZlci5mcm9tKG1zZywgJ2Jhc2U2NCcpLnRvU3RyaW5nKCd1dGYtOCcpO1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBzcjtcbn1cblxuXG4vKiogQHByaXZhdGUgKiovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fYmFzZVVybCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gWyB0aGlzLmluc3RhbmNlVXJsLCBcInNlcnZpY2VzL2RhdGFcIiwgXCJ2XCIgKyB0aGlzLnZlcnNpb24gXS5qb2luKCcvJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgcGF0aCB0byBhYnNvbHV0ZSB1cmxcbiAqIEBwcml2YXRlXG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9ub3JtYWxpemVVcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgaWYgKHVybFswXSA9PT0gJy8nKSB7XG4gICAgaWYgKHVybC5pbmRleE9mKCcvc2VydmljZXMvJykgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlVXJsICsgdXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fYmFzZVVybCgpICsgdXJsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG59O1xuXG4vKipcbiAqIFNlbmQgUkVTVCBBUEkgcmVxdWVzdCB3aXRoIGdpdmVuIEhUVFAgcmVxdWVzdCBpbmZvLCB3aXRoIGNvbm5lY3RlZCBzZXNzaW9uIGluZm9ybWF0aW9uLlxuICpcbiAqIEVuZHBvaW50IFVSTCBjYW4gYmUgYWJzb2x1dGUgVVJMICgnaHR0cHM6Ly9uYTEuc2FsZXNmb3JjZS5jb20vc2VydmljZXMvZGF0YS92MzIuMC9zb2JqZWN0cy9BY2NvdW50L2Rlc2NyaWJlJylcbiAqICwgcmVsYXRpdmUgcGF0aCBmcm9tIHJvb3QgKCcvc2VydmljZXMvZGF0YS92MzIuMC9zb2JqZWN0cy9BY2NvdW50L2Rlc2NyaWJlJylcbiAqICwgb3IgcmVsYXRpdmUgcGF0aCBmcm9tIHZlcnNpb24gcm9vdCAoJy9zb2JqZWN0cy9BY2NvdW50L2Rlc2NyaWJlJykuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSByZXF1ZXN0IC0gSFRUUCByZXF1ZXN0IG9iamVjdCBvciBVUkwgdG8gR0VUIHJlcXVlc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0Lm1ldGhvZCAtIEhUVFAgbWV0aG9kIFVSTCB0byBzZW5kIEhUVFAgcmVxdWVzdFxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3QudXJsIC0gVVJMIHRvIHNlbmQgSFRUUCByZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3QuaGVhZGVyc10gLSBIVFRQIHJlcXVlc3QgaGVhZGVycyBpbiBoYXNoIG9iamVjdCAoa2V5LXZhbHVlKVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEhUVFAgQVBJIHJlcXVlc3Qgb3B0aW9uc1xuICogQHBhcmFtIHtDYWxsYmFjay48T2JqZWN0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48T2JqZWN0Pn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3QsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIGlmIHJlcXVlc3QgaXMgc2ltcGxlIHN0cmluZywgcmVnYXJkIGl0IGFzIHVybCBpbiBHRVQgbWV0aG9kXG4gIGlmIChfLmlzU3RyaW5nKHJlcXVlc3QpKSB7XG4gICAgcmVxdWVzdCA9IHsgbWV0aG9kOiAnR0VUJywgdXJsOiByZXF1ZXN0IH07XG4gIH1cbiAgLy8gaWYgdXJsIGlzIGdpdmVuIGluIHJlbGF0aXZlIHBhdGgsIHByZXBlbmQgYmFzZSB1cmwgb3IgaW5zdGFuY2UgdXJsIGJlZm9yZS5cbiAgcmVxdWVzdC51cmwgPSB0aGlzLl9ub3JtYWxpemVVcmwocmVxdWVzdC51cmwpO1xuXG4gIHZhciBodHRwQXBpID0gbmV3IEh0dHBBcGkodGhpcywgb3B0aW9ucyk7XG5cbiAgLy8gbG9nIGFwaSB1c2FnZSBhbmQgaXRzIHF1b3RhXG4gIGh0dHBBcGkub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2UuaGVhZGVycyAmJiByZXNwb25zZS5oZWFkZXJzW1wic2ZvcmNlLWxpbWl0LWluZm9cIl0pIHtcbiAgICAgIHZhciBhcGlVc2FnZSA9IHJlc3BvbnNlLmhlYWRlcnNbXCJzZm9yY2UtbGltaXQtaW5mb1wiXS5tYXRjaCgvYXBpXFwtdXNhZ2U9KFxcZCspXFwvKFxcZCspLyk7XG4gICAgICBpZiAoYXBpVXNhZ2UpIHtcbiAgICAgICAgc2VsZi5saW1pdEluZm8gPSB7XG4gICAgICAgICAgYXBpVXNhZ2U6IHtcbiAgICAgICAgICAgIHVzZWQ6IHBhcnNlSW50KGFwaVVzYWdlWzFdLCAxMCksXG4gICAgICAgICAgICBsaW1pdDogcGFyc2VJbnQoYXBpVXNhZ2VbMl0sIDEwKVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaHR0cEFwaS5yZXF1ZXN0KHJlcXVlc3QpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2VuZCBIVFRQIEdFVCByZXF1ZXN0XG4gKlxuICogRW5kcG9pbnQgVVJMIGNhbiBiZSBhYnNvbHV0ZSBVUkwgKCdodHRwczovL25hMS5zYWxlc2ZvcmNlLmNvbS9zZXJ2aWNlcy9kYXRhL3YzMi4wL3NvYmplY3RzL0FjY291bnQvZGVzY3JpYmUnKVxuICogLCByZWxhdGl2ZSBwYXRoIGZyb20gcm9vdCAoJy9zZXJ2aWNlcy9kYXRhL3YzMi4wL3NvYmplY3RzL0FjY291bnQvZGVzY3JpYmUnKVxuICogLCBvciByZWxhdGl2ZSBwYXRoIGZyb20gdmVyc2lvbiByb290ICgnL3NvYmplY3RzL0FjY291bnQvZGVzY3JpYmUnKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gRW5kcG9pbnQgVVJMIHRvIHJlcXVlc3QgSFRUUCBHRVRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBIVFRQIEFQSSByZXF1ZXN0IG9wdGlvbnNcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE9iamVjdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnJlcXVlc3RHZXQgPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciByZXF1ZXN0ID0ge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICB1cmw6IHVybFxuICB9O1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHJlcXVlc3QsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cblxuLyoqXG4gKiBTZW5kIEhUVFAgUE9TVCByZXF1ZXN0IHdpdGggSlNPTiBib2R5LCB3aXRoIGNvbm5lY3RlZCBzZXNzaW9uIGluZm9ybWF0aW9uXG4gKlxuICogRW5kcG9pbnQgVVJMIGNhbiBiZSBhYnNvbHV0ZSBVUkwgKCdodHRwczovL25hMS5zYWxlc2ZvcmNlLmNvbS9zZXJ2aWNlcy9kYXRhL3YzMi4wL3NvYmplY3RzL0FjY291bnQvZGVzY3JpYmUnKVxuICogLCByZWxhdGl2ZSBwYXRoIGZyb20gcm9vdCAoJy9zZXJ2aWNlcy9kYXRhL3YzMi4wL3NvYmplY3RzL0FjY291bnQvZGVzY3JpYmUnKVxuICogLCBvciByZWxhdGl2ZSBwYXRoIGZyb20gdmVyc2lvbiByb290ICgnL3NvYmplY3RzL0FjY291bnQvZGVzY3JpYmUnKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gRW5kcG9pbnQgVVJMIHRvIHJlcXVlc3QgSFRUUCBQT1NUXG4gKiBAcGFyYW0ge09iamVjdH0gYm9keSAtIEFueSBKUyBvYmplY3Qgd2hpY2ggY2FuIGJlIHNlcmlhbGl6ZWQgdG8gSlNPTlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEhUVFAgQVBJIHJlcXVlc3Qgb3B0aW9uc1xuICogQHBhcmFtIHtDYWxsYmFjay48T2JqZWN0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48T2JqZWN0Pn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUucmVxdWVzdFBvc3QgPSBmdW5jdGlvbih1cmwsIGJvZHksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciByZXF1ZXN0ID0ge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiB1cmwsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgaGVhZGVyczogeyBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9XG4gIH07XG4gIHJldHVybiB0aGlzLnJlcXVlc3QocmVxdWVzdCwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTZW5kIEhUVFAgUFVUIHJlcXVlc3Qgd2l0aCBKU09OIGJvZHksIHdpdGggY29ubmVjdGVkIHNlc3Npb24gaW5mb3JtYXRpb25cbiAqXG4gKiBFbmRwb2ludCBVUkwgY2FuIGJlIGFic29sdXRlIFVSTCAoJ2h0dHBzOi8vbmExLnNhbGVzZm9yY2UuY29tL3NlcnZpY2VzL2RhdGEvdjMyLjAvc29iamVjdHMvQWNjb3VudC9kZXNjcmliZScpXG4gKiAsIHJlbGF0aXZlIHBhdGggZnJvbSByb290ICgnL3NlcnZpY2VzL2RhdGEvdjMyLjAvc29iamVjdHMvQWNjb3VudC9kZXNjcmliZScpXG4gKiAsIG9yIHJlbGF0aXZlIHBhdGggZnJvbSB2ZXJzaW9uIHJvb3QgKCcvc29iamVjdHMvQWNjb3VudC9kZXNjcmliZScpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBFbmRwb2ludCBVUkwgdG8gcmVxdWVzdCBIVFRQIFBVVFxuICogQHBhcmFtIHtPYmplY3R9IGJvZHkgLSBBbnkgSlMgb2JqZWN0IHdoaWNoIGNhbiBiZSBzZXJpYWxpemVkIHRvIEpTT05cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBIVFRQIEFQSSByZXF1ZXN0IG9wdGlvbnNcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE9iamVjdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnJlcXVlc3RQdXQgPSBmdW5jdGlvbih1cmwsIGJvZHksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciByZXF1ZXN0ID0ge1xuICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICB1cmw6IHVybCxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICBoZWFkZXJzOiB7IFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH1cbiAgfTtcbiAgcmV0dXJuIHRoaXMucmVxdWVzdChyZXF1ZXN0LCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFNlbmQgSFRUUCBQQVRDSCByZXF1ZXN0IHdpdGggSlNPTiBib2R5XG4gKlxuICogRW5kcG9pbnQgVVJMIGNhbiBiZSBhYnNvbHV0ZSBVUkwgKCdodHRwczovL25hMS5zYWxlc2ZvcmNlLmNvbS9zZXJ2aWNlcy9kYXRhL3YzMi4wL3NvYmplY3RzL0FjY291bnQvZGVzY3JpYmUnKVxuICogLCByZWxhdGl2ZSBwYXRoIGZyb20gcm9vdCAoJy9zZXJ2aWNlcy9kYXRhL3YzMi4wL3NvYmplY3RzL0FjY291bnQvZGVzY3JpYmUnKVxuICogLCBvciByZWxhdGl2ZSBwYXRoIGZyb20gdmVyc2lvbiByb290ICgnL3NvYmplY3RzL0FjY291bnQvZGVzY3JpYmUnKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gRW5kcG9pbnQgVVJMIHRvIHJlcXVlc3QgSFRUUCBQQVRDSFxuICogQHBhcmFtIHtPYmplY3R9IGJvZHkgLSBBbnkgSlMgb2JqZWN0IHdoaWNoIGNhbiBiZSBzZXJpYWxpemVkIHRvIEpTT05cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBIVFRQIEFQSSByZXF1ZXN0IG9wdGlvbnNcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE9iamVjdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnJlcXVlc3RQYXRjaCA9IGZ1bmN0aW9uKHVybCwgYm9keSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHJlcXVlc3QgPSB7XG4gICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgdXJsOiB1cmwsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgaGVhZGVyczogeyBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9XG4gIH07XG4gIHJldHVybiB0aGlzLnJlcXVlc3QocmVxdWVzdCwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTZW5kIEhUVFAgREVMRVRFIHJlcXVlc3RcbiAqXG4gKiBFbmRwb2ludCBVUkwgY2FuIGJlIGFic29sdXRlIFVSTCAoJ2h0dHBzOi8vbmExLnNhbGVzZm9yY2UuY29tL3NlcnZpY2VzL2RhdGEvdjMyLjAvc29iamVjdHMvQWNjb3VudC9kZXNjcmliZScpXG4gKiAsIHJlbGF0aXZlIHBhdGggZnJvbSByb290ICgnL3NlcnZpY2VzL2RhdGEvdjMyLjAvc29iamVjdHMvQWNjb3VudC9kZXNjcmliZScpXG4gKiAsIG9yIHJlbGF0aXZlIHBhdGggZnJvbSB2ZXJzaW9uIHJvb3QgKCcvc29iamVjdHMvQWNjb3VudC9kZXNjcmliZScpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBFbmRwb2ludCBVUkwgdG8gcmVxdWVzdCBIVFRQIERFTEVURVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEhUVFAgQVBJIHJlcXVlc3Qgb3B0aW9uc1xuICogQHBhcmFtIHtDYWxsYmFjay48T2JqZWN0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48T2JqZWN0Pn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUucmVxdWVzdERlbGV0ZSA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHJlcXVlc3QgPSB7XG4gICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgIHVybDogdXJsXG4gIH07XG4gIHJldHVybiB0aGlzLnJlcXVlc3QocmVxdWVzdCwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuXG4vKiogQHByaXZhdGUgKi9cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICBmdW5jdGlvbiBwYWQobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDEwKSB7XG4gICAgICByZXR1cm4gJzAnICsgbnVtYmVyO1xuICAgIH1cbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArXG4gICAgJy0nICsgcGFkKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpICtcbiAgICAnLScgKyBwYWQoZGF0ZS5nZXRVVENEYXRlKCkpICtcbiAgICAnVCcgKyBwYWQoZGF0ZS5nZXRVVENIb3VycygpKSArXG4gICAgJzonICsgcGFkKGRhdGUuZ2V0VVRDTWludXRlcygpKSArXG4gICAgJzonICsgcGFkKGRhdGUuZ2V0VVRDU2Vjb25kcygpKSArXG4gICAgJyswMDowMCc7XG59XG5cblxuLyoqIEBwcml2YXRlICoqL1xuZnVuY3Rpb24gcGFyc2VJZFVybChpZFVybCkge1xuICB2YXIgaWRVcmxzID0gaWRVcmwuc3BsaXQoXCIvXCIpO1xuICB2YXIgdXNlcklkID0gaWRVcmxzLnBvcCgpLCBvcmdJZCA9IGlkVXJscy5wb3AoKTtcbiAgcmV0dXJuIHtcbiAgICBpZDogdXNlcklkLFxuICAgIG9yZ2FuaXphdGlvbklkOiBvcmdJZCxcbiAgICB1cmw6IGlkVXJsXG4gIH07XG59XG5cbi8qKlxuICogQGNhbGxiYWNrIENhbGxiYWNrXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBDYWxsYmFjayBlcnJvclxuICogQHBhcmFtIHtUfSByZXNwb25zZSAtIENhbGxiYWNrIHJlc3BvbnNlXG4gKiBAdGVtcGxhdGUgVFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUXVlcnlSZXN1bHRcbiAqIEBwcm9wIHtCb29sZWFufSBkb25lIC0gRmxhZyBpZiB0aGUgcXVlcnkgaXMgZmV0Y2hlZCBhbGwgcmVjb3JkcyBvciBub3RcbiAqIEBwcm9wIHtTdHJpbmd9IFtuZXh0UmVjb3Jkc1VybF0gLSBVUkwgbG9jYXRvciBmb3IgbmV4dCByZWNvcmQgc2V0LCAoYXZhaWxhYmxlIHdoZW4gZG9uZSA9IGZhbHNlKVxuICogQHByb3Age051bWJlcn0gdG90YWxTaXplIC0gVG90YWwgc2l6ZSBmb3IgcXVlcnlcbiAqIEBwcm9wIHtBcnJheS48UmVjb3JkPn0gW3JlY29yZHNdIC0gQXJyYXkgb2YgcmVjb3JkcyBmZXRjaGVkXG4gKi9cblxuLyoqXG4gKiBFeGVjdXRlIHF1ZXJ5IGJ5IHVzaW5nIFNPUUxcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc29xbCAtIFNPUUwgc3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gUXVlcnkgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBIVFRQIHJlcXVlc3QgaGVhZGVycyBzZW50IGluIHF1ZXJ5IHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFF1ZXJ5UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UXVlcnkuPFF1ZXJ5UmVzdWx0Pn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbihzb3FsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgcXVlcnkgPSBuZXcgUXVlcnkodGhpcywgc29xbCwgb3B0aW9ucyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHF1ZXJ5LnJ1bihjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIHF1ZXJ5IGJ5IHVzaW5nIFNPUUwsIGluY2x1ZGluZyBkZWxldGVkIHJlY29yZHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc29xbCAtIFNPUUwgc3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gUXVlcnkgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBIVFRQIHJlcXVlc3QgaGVhZGVycyBzZW50IGluIHF1ZXJ5IHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFF1ZXJ5UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UXVlcnkuPFF1ZXJ5UmVzdWx0Pn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUucXVlcnlBbGwgPSBmdW5jdGlvbihzb3FsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgcXVlcnkgPSBuZXcgUXVlcnkodGhpcywgc29xbCwgb3B0aW9ucyk7XG4gIHF1ZXJ5LnNjYW5BbGwodHJ1ZSk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHF1ZXJ5LnJ1bihjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBRdWVyeSBuZXh0IHJlY29yZCBzZXQgYnkgdXNpbmcgcXVlcnkgbG9jYXRvclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsb2NhdG9yIC0gTmV4dCByZWNvcmQgc2V0IGxvY2F0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBRdWVyeSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gLSBBZGRpdGlvbmFsIEhUVFAgcmVxdWVzdCBoZWFkZXJzIHNlbnQgaW4gcXVlcnkgcmVxdWVzdFxuICogQHBhcmFtIHtDYWxsYmFjay48UXVlcnlSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtRdWVyeS48UXVlcnlSZXN1bHQ+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5xdWVyeU1vcmUgPSBmdW5jdGlvbihsb2NhdG9yLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgcXVlcnkgPSBuZXcgUXVlcnkodGhpcywgeyBsb2NhdG9yOiBsb2NhdG9yIH0sIG9wdGlvbnMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBxdWVyeS5ydW4oY2FsbGJhY2spO1xuICB9XG4gIHJldHVybiBxdWVyeTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2Vuc3VyZVZlcnNpb24gPSBmdW5jdGlvbihtYWpvclZlcnNpb24pIHtcbiAgdmFyIHZlcnNpb25zID0gdGhpcy52ZXJzaW9uLnNwbGl0KCcuJyk7XG4gIHJldHVybiBwYXJzZUludCh2ZXJzaW9uc1swXSwgMTApID49IG1ham9yVmVyc2lvbjtcbn1cblxuLyoqIEBwcml2YXRlICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fc3VwcG9ydHMgPSBmdW5jdGlvbihmZWF0dXJlKSB7XG4gIHN3aXRjaCAoZmVhdHVyZSkge1xuICAgIGNhc2UgJ3NvYmplY3QtY29sbGVjdGlvbic6XG4gICAgICByZXR1cm4gdGhpcy5fZW5zdXJlVmVyc2lvbig0Mik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHJpZXZlIHNwZWNpZmllZCByZWNvcmRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IFR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBpZHMgLSBBIHJlY29yZCBJRCBvciBhcnJheSBvZiByZWNvcmQgSURzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgcmVzdCBhcGkuXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBbb3B0aW9ucy5maWVsZHNdIC0gRmV0Y2hpbmcgZmllbGQgbmFtZXMgaW4gcmV0cmlldmluZyByZWNvcmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgSFRUUCByZXF1ZXN0IGhlYWRlcnMgc2VudCBpbiByZXRyaWV2ZSByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmR8QXJyYXkuPFJlY29yZD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmR8QXJyYXkuPFJlY29yZD4+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5yZXRyaWV2ZSA9IGZ1bmN0aW9uKHR5cGUsIGlkcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgcmV0dXJuIChcbiAgICBfLmlzQXJyYXkoaWRzKSA/XG4gICAgICAodGhpcy5fc3VwcG9ydHMoJ3NvYmplY3QtY29sbGVjdGlvbicpID8gLy8gY2hlY2sgd2hldGhlciBTT2JqZWN0IGNvbGxlY3Rpb24gQVBJIGlzIHN1cHBvcnRlZFxuICAgICAgICB0aGlzLl9yZXRyaWV2ZU1hbnkodHlwZSwgaWRzLCBvcHRpb25zKSA6XG4gICAgICAgIHRoaXMuX3JldHJpZXZlUGFyYWxsZWwodHlwZSwgaWRzLCBvcHRpb25zKSkgOlxuICAgICAgdGhpcy5fcmV0cmlldmVTaW5nbGUodHlwZSwgaWRzLCBvcHRpb25zKVxuICApLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuX3JldHJpZXZlU2luZ2xlID0gZnVuY3Rpb24odHlwZSwgaWQsIG9wdGlvbnMpIHtcbiAgaWYgKCFpZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0ludmFsaWQgcmVjb3JkIElELiBTcGVjaWZ5IHZhbGlkIHJlY29yZCBJRCB2YWx1ZScpKTtcbiAgfVxuICB2YXIgdXJsID0gWyB0aGlzLl9iYXNlVXJsKCksIFwic29iamVjdHNcIiwgdHlwZSwgaWQgXS5qb2luKCcvJyk7XG4gIGlmIChvcHRpb25zLmZpZWxkcykge1xuICAgIHVybCArPSAnP2ZpZWxkcz0nICsgb3B0aW9ucy5maWVsZHMuam9pbignLCcpO1xuICB9XG4gIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiB1cmwsXG4gICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICB9KTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuX3JldHJpZXZlUGFyYWxsZWwgPSBmdW5jdGlvbih0eXBlLCBpZHMsIG9wdGlvbnMpIHtcbiAgaWYgKGlkcy5sZW5ndGggPiB0aGlzLm1heFJlcXVlc3QpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiRXhjZWVkZWQgbWF4IGxpbWl0IG9mIGNvbmN1cnJlbnQgY2FsbFwiKSk7XG4gIH1cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgaWRzLm1hcChmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIHNlbGYuX3JldHJpZXZlU2luZ2xlKHR5cGUsIGlkLCBvcHRpb25zKS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsT3JOb25lIHx8IGVyci5lcnJvckNvZGUgIT09ICdOT1RfRk9VTkQnKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgfSlcbiAgKTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuX3JldHJpZXZlTWFueSA9IGZ1bmN0aW9uKHR5cGUsIGlkcywgb3B0aW9ucykge1xuICBpZiAoaWRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICB9XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Jhc2VVcmwoKSwgXCJjb21wb3NpdGVcIiwgXCJzb2JqZWN0c1wiLCB0eXBlIF0uam9pbignLycpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiAoXG4gICAgb3B0aW9ucy5maWVsZHMgP1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMuZmllbGRzKSA6XG4gICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5kZXNjcmliZSQodHlwZSwgZnVuY3Rpb24oZXJyLCBzbykge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZmllbGRzID0gc28uZmllbGRzLm1hcChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmllbGQubmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzb2x2ZShmaWVsZHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KVxuICApLnRoZW4oZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgcmV0dXJuIHNlbGYucmVxdWVzdCh7XG4gICAgICBtZXRob2QgOiAnUE9TVCcsXG4gICAgICB1cmwgOiB1cmwsXG4gICAgICBib2R5IDogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBpZHMgOiBpZHMsXG4gICAgICAgIGZpZWxkcyA6IGZpZWxkc1xuICAgICAgfSksXG4gICAgICBoZWFkZXJzIDogXy5kZWZhdWx0cyhvcHRpb25zLmhlYWRlcnMgfHwge30sIHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIiA6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBAdHlwZWRlZiBSZWNvcmRSZXN1bHRcbiAqIEBwcm9wIHtCb29sZWFufSBzdWNjZXNzIC0gVGhlIHJlc3VsdCBpcyBzdWNjZWVzc2Z1bCBvciBub3RcbiAqIEBwcm9wIHtTdHJpbmd9IFtpZF0gLSBSZWNvcmQgSURcbiAqIEBwcm9wIHtBcnJheS48T2JqZWN0Pn0gW2Vycm9yc10gLSBFcnJvcnMgKGF2YWlsYWJsZSB3aGVuIHN1Y2Nlc3MgPSBmYWxzZSlcbiAqL1xuXG4vKiogQHByaXZhdGUgKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl90b1JlY29yZFJlc3VsdCA9IGZ1bmN0aW9uKGlkLCBlcnIpIHtcbiAgdmFyIGVycm9yID0ge1xuICAgIHN0YXR1c0NvZGU6IGVyci5lcnJvckNvZGUsXG4gICAgbWVzc2FnZTogZXJyLm1lc3NhZ2VcbiAgfTtcbiAgaWYgKGVyci5jb250ZW50KSB7IGVycm9yLmNvbnRlbnQgPSBlcnIuY29udGVudDsgfSAvLyBwcmVzZXJ2ZSBFeHRlcm5hbCBpZCBkdXBsaWNhdGlvbiBtZXNzYWdlXG4gIGlmIChlcnIuZmllbGRzKSB7IGVycm9yLmZpZWxkcyA9IGVyci5maWVsZHM7IH0gLy8gcHJlc2VydmUgRE1MIGV4Y2VwdGlvbiBvY2N1cnJlZCBmaWVsZHNcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICBlcnJvcnM6IFtlcnJvcl1cbiAgfTtcbiAgaWYgKGlkKSB7IHJlc3VsdC5pZCA9IGlkOyB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFN5bm9ueW0gb2YgQ29ubmVjdGlvbiNjcmVhdGUoKVxuICpcbiAqIEBtZXRob2QgQ29ubmVjdGlvbiNpbnNlcnRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gU09iamVjdCBUeXBlXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheS48T2JqZWN0Pn0gcmVjb3JkcyAtIEEgcmVjb3JkIG9yIGFycmF5IG9mIHJlY29yZHMgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgcmVzdCBhcGkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbE9yTm9uZV0gLSBJZiB0cnVlLCBhbnkgZmFpbGVkIHJlY29yZHMgaW4gYSBjYWxsIGNhdXNlIGFsbCBjaGFuZ2VzIGZvciB0aGUgY2FsbCB0byBiZSByb2xsZWQgYmFja1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1JlY3Vyc2l2ZV0gLSBJZiB0cnVlLCB3aGVuIHJlY29yZHMgZ29lcyBvdmVyIHRoZSBtYXggbnVtIG9mIGNvbGxlY3Rpb24gQVBJICg9MjAwKSwgcmVjb3JkcyBhcmUgZGl2aWRlZCBpbnRvIHNldmVyYWwgY2h1bmtzIGFuZCByZXF1ZXN0ZWQgcmVjdXJzaXZlbHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gLSBBZGRpdGlvbmFsIEhUVFAgcmVxdWVzdCBoZWFkZXJzIHNlbnQgaW4gcmV0cmlldmUgcmVxdWVzdFxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuLyoqXG4gKiBDcmVhdGUgcmVjb3Jkc1xuICpcbiAqIEBtZXRob2QgQ29ubmVjdGlvbiNjcmVhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gU09iamVjdCBUeXBlXG4gKiBAcGFyYW0ge1JlY29yZHxBcnJheS48UmVjb3JkPn0gcmVjb3JkcyAtIEEgcmVjb3JkIG9yIGFycmF5IG9mIHJlY29yZHMgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgcmVzdCBhcGkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbE9yTm9uZV0gLSBJZiB0cnVlLCBhbnkgZmFpbGVkIHJlY29yZHMgaW4gYSBjYWxsIGNhdXNlIGFsbCBjaGFuZ2VzIGZvciB0aGUgY2FsbCB0byBiZSByb2xsZWQgYmFja1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1JlY3Vyc2l2ZV0gLSBJZiB0cnVlLCB3aGVuIHJlY29yZHMgZ29lcyBvdmVyIHRoZSBtYXggbnVtIG9mIGNvbGxlY3Rpb24gQVBJICg9MjAwKSwgcmVjb3JkcyBhcmUgZGl2aWRlZCBpbnRvIHNldmVyYWwgY2h1bmtzIGFuZCByZXF1ZXN0ZWQgcmVjdXJzaXZlbHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gLSBBZGRpdGlvbmFsIEhUVFAgcmVxdWVzdCBoZWFkZXJzIHNlbnQgaW4gcmV0cmlldmUgcmVxdWVzdFxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuaW5zZXJ0ID1cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHR5cGUsIHJlY29yZHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICghXy5pc1N0cmluZyh0eXBlKSkge1xuICAgIC8vIHJldmVyc2Ugb3JkZXJcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHJlY29yZHM7XG4gICAgcmVjb3JkcyA9IHR5cGU7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgcmV0dXJuIChcbiAgICBfLmlzQXJyYXkocmVjb3JkcykgP1xuICAgICAgKHRoaXMuX3N1cHBvcnRzKCdzb2JqZWN0LWNvbGxlY3Rpb24nKSA/IC8vIGNoZWNrIHdoZXRoZXIgU09iamVjdCBjb2xsZWN0aW9uIEFQSSBpcyBzdXBwb3J0ZWRcbiAgICAgICAgdGhpcy5fY3JlYXRlTWFueSh0eXBlLCByZWNvcmRzLCBvcHRpb25zKSA6XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBhcmFsbGVsKHR5cGUsIHJlY29yZHMsIG9wdGlvbnMpKSA6XG4gICAgICB0aGlzLl9jcmVhdGVTaW5nbGUodHlwZSwgcmVjb3Jkcywgb3B0aW9ucylcbiAgKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9jcmVhdGVTaW5nbGUgPSBmdW5jdGlvbih0eXBlLCByZWNvcmQsIG9wdGlvbnMpIHtcbiAgdmFyIHNvYmplY3RUeXBlID0gdHlwZSB8fCAocmVjb3JkLmF0dHJpYnV0ZXMgJiYgcmVjb3JkLmF0dHJpYnV0ZXMudHlwZSkgfHwgcmVjb3JkLnR5cGU7XG4gIGlmICghc29iamVjdFR5cGUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdObyBTT2JqZWN0IFR5cGUgZGVmaW5lZCBpbiByZWNvcmQnKSk7XG4gIH1cbiAgcmVjb3JkID0gXy5jbG9uZShyZWNvcmQpO1xuICBkZWxldGUgcmVjb3JkLklkO1xuICBkZWxldGUgcmVjb3JkLnR5cGU7XG4gIGRlbGV0ZSByZWNvcmQuYXR0cmlidXRlcztcbiAgdmFyIHVybCA9IFsgdGhpcy5fYmFzZVVybCgpLCBcInNvYmplY3RzXCIsIHNvYmplY3RUeXBlIF0uam9pbignLycpO1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHtcbiAgICBtZXRob2QgOiAnUE9TVCcsXG4gICAgdXJsIDogdXJsLFxuICAgIGJvZHkgOiBKU09OLnN0cmluZ2lmeShyZWNvcmQpLFxuICAgIGhlYWRlcnMgOiBfLmRlZmF1bHRzKG9wdGlvbnMuaGVhZGVycyB8fCB7fSwge1xuICAgICAgXCJDb250ZW50LVR5cGVcIiA6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9jcmVhdGVQYXJhbGxlbCA9IGZ1bmN0aW9uKHR5cGUsIHJlY29yZHMsIG9wdGlvbnMpIHtcbiAgaWYgKHJlY29yZHMubGVuZ3RoID4gdGhpcy5tYXhSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkV4Y2VlZGVkIG1heCBsaW1pdCBvZiBjb25jdXJyZW50IGNhbGxcIikpO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIHJlY29yZHMubWFwKGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgcmV0dXJuIHNlbGYuX2NyZWF0ZVNpbmdsZSh0eXBlLCByZWNvcmQsIG9wdGlvbnMpLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAvLyBiZSBhd2FyZSB0aGF0IGFsbE9yTm9uZSBpbiBwYXJhbGxlbCBtb2RlIHdpbGwgbm90IHJldmVydCB0aGUgb3RoZXIgc3VjY2Vzc2Z1bCByZXF1ZXN0c1xuICAgICAgICAvLyBpdCBvbmx5IHJhaXNlcyBlcnJvciB3aGVuIG1ldCBhdCBsZWFzdCBvbmUgZmFpbGVkIHJlcXVlc3QuXG4gICAgICAgIGlmIChvcHRpb25zLmFsbE9yTm9uZSB8fCAhZXJyLmVycm9yQ29kZSkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdG9SZWNvcmRSZXN1bHQobnVsbCwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pXG4gICk7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9jcmVhdGVNYW55ID0gZnVuY3Rpb24odHlwZSwgcmVjb3Jkcywgb3B0aW9ucykge1xuICBpZiAocmVjb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgfVxuICBpZiAocmVjb3Jkcy5sZW5ndGggPiBNQVhfRE1MX0NPVU5UICYmIG9wdGlvbnMuYWxsb3dSZWN1cnNpdmUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHNlbGYuX2NyZWF0ZU1hbnkodHlwZSwgcmVjb3Jkcy5zbGljZSgwLCBNQVhfRE1MX0NPVU5UKSwgb3B0aW9ucykudGhlbihmdW5jdGlvbihyZXRzMSkge1xuICAgICAgcmV0dXJuIHNlbGYuX2NyZWF0ZU1hbnkodHlwZSwgcmVjb3Jkcy5zbGljZShNQVhfRE1MX0NPVU5UKSwgb3B0aW9ucykudGhlbihmdW5jdGlvbihyZXRzMikge1xuICAgICAgICByZXR1cm4gcmV0czEuY29uY2F0KHJldHMyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlY29yZHMgPSBfLm1hcChyZWNvcmRzLCBmdW5jdGlvbihyZWNvcmQpIHtcbiAgICB2YXIgc29iamVjdFR5cGUgPSB0eXBlIHx8IChyZWNvcmQuYXR0cmlidXRlcyAmJiByZWNvcmQuYXR0cmlidXRlcy50eXBlKSB8fCByZWNvcmQudHlwZTtcbiAgICBpZiAoIXNvYmplY3RUeXBlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdObyBTT2JqZWN0IFR5cGUgZGVmaW5lZCBpbiByZWNvcmQnKSk7XG4gICAgfVxuICAgIHJlY29yZCA9IF8uY2xvbmUocmVjb3JkKTtcbiAgICBkZWxldGUgcmVjb3JkLklkO1xuICAgIGRlbGV0ZSByZWNvcmQudHlwZTtcbiAgICByZWNvcmQuYXR0cmlidXRlcyA9IHsgdHlwZSA6IHNvYmplY3RUeXBlIH07XG4gICAgcmV0dXJuIHJlY29yZDtcbiAgfSk7XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Jhc2VVcmwoKSwgXCJjb21wb3NpdGVcIiwgXCJzb2JqZWN0c1wiIF0uam9pbignLycpO1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHtcbiAgICBtZXRob2QgOiAnUE9TVCcsXG4gICAgdXJsIDogdXJsLFxuICAgIGJvZHkgOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBhbGxPck5vbmUgOiBvcHRpb25zLmFsbE9yTm9uZSB8fCBmYWxzZSxcbiAgICAgIHJlY29yZHMgOiByZWNvcmRzXG4gICAgfSksXG4gICAgaGVhZGVycyA6IF8uZGVmYXVsdHMob3B0aW9ucy5oZWFkZXJzIHx8IHt9LCB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiIDogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9KVxuICB9KTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHJlY29yZHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtSZWNvcmR8QXJyYXkuPFJlY29yZD59IHJlY29yZHMgLSBBIHJlY29yZCBvciBhcnJheSBvZiByZWNvcmRzIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHJlc3QgYXBpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxPck5vbmVdIC0gSWYgdHJ1ZSwgYW55IGZhaWxlZCByZWNvcmRzIGluIGEgY2FsbCBjYXVzZSBhbGwgY2hhbmdlcyBmb3IgdGhlIGNhbGwgdG8gYmUgcm9sbGVkIGJhY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dSZWN1cnNpdmVdIC0gSWYgdHJ1ZSwgd2hlbiByZWNvcmRzIGdvZXMgb3ZlciB0aGUgbWF4IG51bSBvZiBjb2xsZWN0aW9uIEFQSSAoPTIwMCksIHJlY29yZHMgYXJlIGRpdmlkZWQgaW50byBzZXZlcmFsIGNodW5rcyBhbmQgcmVxdWVzdGVkIHJlY3Vyc2l2ZWx5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBIVFRQIHJlcXVlc3QgaGVhZGVycyBzZW50IGluIHJldHJpZXZlIHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHR5cGUsIHJlY29yZHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICghXy5pc1N0cmluZyh0eXBlKSkge1xuICAgIC8vIHJldmVyc2Ugb3JkZXJcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHJlY29yZHM7XG4gICAgcmVjb3JkcyA9IHR5cGU7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgcmV0dXJuIChcbiAgICBfLmlzQXJyYXkocmVjb3JkcykgP1xuICAgICAgKHRoaXMuX3N1cHBvcnRzKCdzb2JqZWN0LWNvbGxlY3Rpb24nKSA/IC8vIGNoZWNrIHdoZXRoZXIgU09iamVjdCBjb2xsZWN0aW9uIEFQSSBpcyBzdXBwb3J0ZWRcbiAgICAgICAgdGhpcy5fdXBkYXRlTWFueSh0eXBlLCByZWNvcmRzLCBvcHRpb25zKSA6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBhcmFsbGVsKHR5cGUsIHJlY29yZHMsIG9wdGlvbnMpKSA6XG4gICAgICB0aGlzLl91cGRhdGVTaW5nbGUodHlwZSwgcmVjb3Jkcywgb3B0aW9ucylcbiAgKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl91cGRhdGVTaW5nbGUgPSBmdW5jdGlvbih0eXBlLCByZWNvcmQsIG9wdGlvbnMpIHtcbiAgdmFyIGlkID0gcmVjb3JkLklkO1xuICBpZiAoIWlkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignUmVjb3JkIGlkIGlzIG5vdCBmb3VuZCBpbiByZWNvcmQuJykpO1xuICB9XG4gIHZhciBzb2JqZWN0VHlwZSA9IHR5cGUgfHwgKHJlY29yZC5hdHRyaWJ1dGVzICYmIHJlY29yZC5hdHRyaWJ1dGVzLnR5cGUpIHx8IHJlY29yZC50eXBlO1xuICBpZiAoIXNvYmplY3RUeXBlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTm8gU09iamVjdCBUeXBlIGRlZmluZWQgaW4gcmVjb3JkJykpO1xuICB9XG4gIHJlY29yZCA9IF8uY2xvbmUocmVjb3JkKTtcbiAgZGVsZXRlIHJlY29yZC5JZDtcbiAgZGVsZXRlIHJlY29yZC50eXBlO1xuICBkZWxldGUgcmVjb3JkLmF0dHJpYnV0ZXM7XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Jhc2VVcmwoKSwgXCJzb2JqZWN0c1wiLCBzb2JqZWN0VHlwZSwgaWQgXS5qb2luKCcvJyk7XG4gIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgIG1ldGhvZCA6ICdQQVRDSCcsXG4gICAgdXJsIDogdXJsLFxuICAgIGJvZHkgOiBKU09OLnN0cmluZ2lmeShyZWNvcmQpLFxuICAgIGhlYWRlcnMgOiBfLmRlZmF1bHRzKG9wdGlvbnMuaGVhZGVycyB8fCB7fSwge1xuICAgICAgXCJDb250ZW50LVR5cGVcIiA6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSlcbiAgfSwge1xuICAgIG5vQ29udGVudFJlc3BvbnNlOiB7IGlkIDogaWQsIHN1Y2Nlc3MgOiB0cnVlLCBlcnJvcnMgOiBbXSB9XG4gIH0pO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fdXBkYXRlUGFyYWxsZWwgPSBmdW5jdGlvbih0eXBlLCByZWNvcmRzLCBvcHRpb25zKSB7XG4gIGlmIChyZWNvcmRzLmxlbmd0aCA+IHRoaXMubWF4UmVxdWVzdCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJFeGNlZWRlZCBtYXggbGltaXQgb2YgY29uY3VycmVudCBjYWxsXCIpKTtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICByZWNvcmRzLm1hcChmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgIHJldHVybiBzZWxmLl91cGRhdGVTaW5nbGUodHlwZSwgcmVjb3JkLCBvcHRpb25zKS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgLy8gYmUgYXdhcmUgdGhhdCBhbGxPck5vbmUgaW4gcGFyYWxsZWwgbW9kZSB3aWxsIG5vdCByZXZlcnQgdGhlIG90aGVyIHN1Y2Nlc3NmdWwgcmVxdWVzdHNcbiAgICAgICAgLy8gaXQgb25seSByYWlzZXMgZXJyb3Igd2hlbiBtZXQgYXQgbGVhc3Qgb25lIGZhaWxlZCByZXF1ZXN0LlxuICAgICAgICBpZiAob3B0aW9ucy5hbGxPck5vbmUgfHwgIWVyci5lcnJvckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvUmVjb3JkUmVzdWx0KHJlY29yZC5JZCwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pXG4gICk7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl91cGRhdGVNYW55ID0gZnVuY3Rpb24odHlwZSwgcmVjb3Jkcywgb3B0aW9ucykge1xuICBpZiAocmVjb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgfVxuICBpZiAocmVjb3Jkcy5sZW5ndGggPiBNQVhfRE1MX0NPVU5UICYmIG9wdGlvbnMuYWxsb3dSZWN1cnNpdmUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHNlbGYuX3VwZGF0ZU1hbnkodHlwZSwgcmVjb3Jkcy5zbGljZSgwLCBNQVhfRE1MX0NPVU5UKSwgb3B0aW9ucykudGhlbihmdW5jdGlvbihyZXRzMSkge1xuICAgICAgcmV0dXJuIHNlbGYuX3VwZGF0ZU1hbnkodHlwZSwgcmVjb3Jkcy5zbGljZShNQVhfRE1MX0NPVU5UKSwgb3B0aW9ucykudGhlbihmdW5jdGlvbihyZXRzMikge1xuICAgICAgICByZXR1cm4gcmV0czEuY29uY2F0KHJldHMyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlY29yZHMgPSBfLm1hcChyZWNvcmRzLCBmdW5jdGlvbihyZWNvcmQpIHtcbiAgICB2YXIgaWQgPSByZWNvcmQuSWQ7XG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWNvcmQgaWQgaXMgbm90IGZvdW5kIGluIHJlY29yZC4nKTtcbiAgICB9XG4gICAgdmFyIHNvYmplY3RUeXBlID0gdHlwZSB8fCAocmVjb3JkLmF0dHJpYnV0ZXMgJiYgcmVjb3JkLmF0dHJpYnV0ZXMudHlwZSkgfHwgcmVjb3JkLnR5cGU7XG4gICAgaWYgKCFzb2JqZWN0VHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBTT2JqZWN0IFR5cGUgZGVmaW5lZCBpbiByZWNvcmQnKTtcbiAgICB9XG4gICAgcmVjb3JkID0gXy5jbG9uZShyZWNvcmQpO1xuICAgIGRlbGV0ZSByZWNvcmQuSWQ7XG4gICAgcmVjb3JkLmlkID0gaWQ7XG4gICAgZGVsZXRlIHJlY29yZC50eXBlO1xuICAgIHJlY29yZC5hdHRyaWJ1dGVzID0geyB0eXBlIDogc29iamVjdFR5cGUgfTtcbiAgICByZXR1cm4gcmVjb3JkO1xuICB9KTtcbiAgdmFyIHVybCA9IFsgdGhpcy5fYmFzZVVybCgpLCBcImNvbXBvc2l0ZVwiLCBcInNvYmplY3RzXCIgXS5qb2luKCcvJyk7XG4gIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgIG1ldGhvZCA6ICdQQVRDSCcsXG4gICAgdXJsIDogdXJsLFxuICAgIGJvZHkgOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBhbGxPck5vbmUgOiBvcHRpb25zLmFsbE9yTm9uZSB8fCBmYWxzZSxcbiAgICAgIHJlY29yZHMgOiByZWNvcmRzXG4gICAgfSksXG4gICAgaGVhZGVycyA6IF8uZGVmYXVsdHMob3B0aW9ucy5oZWFkZXJzIHx8IHt9LCB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiIDogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9KVxuICB9KTtcbn07XG5cbi8qKlxuICogVXBzZXJ0IHJlY29yZHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtSZWNvcmR8QXJyYXkuPFJlY29yZD59IHJlY29yZHMgLSBSZWNvcmQgb3IgYXJyYXkgb2YgcmVjb3JkcyB0byB1cHNlcnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHRJZEZpZWxkIC0gRXh0ZXJuYWwgSUQgZmllbGQgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHJlc3QgYXBpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxPck5vbmVdIC0gSWYgdHJ1ZSwgYW55IGZhaWxlZCByZWNvcmRzIGluIGEgY2FsbCBjYXVzZSBhbGwgY2hhbmdlcyBmb3IgdGhlIGNhbGwgdG8gYmUgcm9sbGVkIGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgSFRUUCByZXF1ZXN0IGhlYWRlcnMgc2VudCBpbiByZXRyaWV2ZSByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2tcbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS51cHNlcnQgPSBmdW5jdGlvbih0eXBlLCByZWNvcmRzLCBleHRJZEZpZWxkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyBZb3UgY2FuIG9taXQgXCJ0eXBlXCIgYXJndW1lbnQsIHdoZW4gdGhlIHJlY29yZCBpbmNsdWRlcyB0eXBlIGluZm9ybWF0aW9uLlxuICBpZiAoIV8uaXNTdHJpbmcodHlwZSkpIHtcbiAgICAvLyByZXZlcnNlIG9yZGVyXG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBleHRJZEZpZWxkO1xuICAgIGV4dElkRmllbGQgPSByZWNvcmRzO1xuICAgIHJlY29yZHMgPSB0eXBlO1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGlzQXJyYXkgPSBfLmlzQXJyYXkocmVjb3Jkcyk7XG4gIHJlY29yZHMgPSBpc0FycmF5ID8gcmVjb3JkcyA6IFsgcmVjb3JkcyBdO1xuICBpZiAocmVjb3Jkcy5sZW5ndGggPiB0aGlzLm1heFJlcXVlc3QpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiRXhjZWVkZWQgbWF4IGxpbWl0IG9mIGNvbmN1cnJlbnQgY2FsbFwiKSkudGhlbkNhbGwoY2FsbGJhY2spO1xuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICBfLm1hcChyZWNvcmRzLCBmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgIHZhciBzb2JqZWN0VHlwZSA9IHR5cGUgfHwgKHJlY29yZC5hdHRyaWJ1dGVzICYmIHJlY29yZC5hdHRyaWJ1dGVzLnR5cGUpIHx8IHJlY29yZC50eXBlO1xuICAgICAgdmFyIGV4dElkID0gcmVjb3JkW2V4dElkRmllbGRdO1xuICAgICAgcmVjb3JkID0gXy5jbG9uZShyZWNvcmQpO1xuICAgICAgZGVsZXRlIHJlY29yZFtleHRJZEZpZWxkXTtcbiAgICAgIGRlbGV0ZSByZWNvcmQudHlwZTtcbiAgICAgIGRlbGV0ZSByZWNvcmQuYXR0cmlidXRlcztcblxuICAgICAgdmFyIHVybCA9IFsgc2VsZi5fYmFzZVVybCgpLCBcInNvYmplY3RzXCIsIHNvYmplY3RUeXBlLCBleHRJZEZpZWxkLCBleHRJZCBdLmpvaW4oJy8nKTtcbiAgICAgIHJldHVybiBzZWxmLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2QgOiAnUEFUQ0gnLFxuICAgICAgICB1cmwgOiB1cmwsXG4gICAgICAgIGJvZHkgOiBKU09OLnN0cmluZ2lmeShyZWNvcmQpLFxuICAgICAgICBoZWFkZXJzIDogXy5kZWZhdWx0cyhvcHRpb25zLmhlYWRlcnMgfHwge30sIHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiIDogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSlcbiAgICAgIH0sIHtcbiAgICAgICAgbm9Db250ZW50UmVzcG9uc2U6IHsgc3VjY2VzcyA6IHRydWUsIGVycm9ycyA6IFtdIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIC8vIGJlIGF3YXJlIHRoYXQgYGFsbE9yTm9uZWAgb3B0aW9uIGluIHVwc2VydCBtZXRob2Qgd2lsbCBub3QgcmV2ZXJ0IHRoZSBvdGhlciBzdWNjZXNzZnVsIHJlcXVlc3RzXG4gICAgICAgIC8vIGl0IG9ubHkgcmFpc2VzIGVycm9yIHdoZW4gbWV0IGF0IGxlYXN0IG9uZSBmYWlsZWQgcmVxdWVzdC5cbiAgICAgICAgaWYgKCFpc0FycmF5IHx8IG9wdGlvbnMuYWxsT3JOb25lIHx8ICFlcnIuZXJyb3JDb2RlKSB7IHRocm93IGVycjsgfVxuICAgICAgICByZXR1cm4gc2VsZi5fdG9SZWNvcmRSZXN1bHQobnVsbCwgZXJyKTtcbiAgICAgIH0pXG4gICAgfSlcbiAgKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICByZXR1cm4gIWlzQXJyYXkgJiYgXy5pc0FycmF5KHJlc3VsdHMpID8gcmVzdWx0c1swXSA6IHJlc3VsdHM7XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU3lub255bSBvZiBDb25uZWN0aW9uI2Rlc3Ryb3koKVxuICpcbiAqIEBtZXRob2QgQ29ubmVjdGlvbiNkZWxldGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gU09iamVjdCBUeXBlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaWRzIC0gQSBJRCBvciBhcnJheSBvZiBJRHMgdG8gZGVsZXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgcmVzdCBhcGkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbE9yTm9uZV0gLSBJZiB0cnVlLCBhbnkgZmFpbGVkIHJlY29yZHMgaW4gYSBjYWxsIGNhdXNlIGFsbCBjaGFuZ2VzIGZvciB0aGUgY2FsbCB0byBiZSByb2xsZWQgYmFja1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1JlY3Vyc2l2ZV0gLSBJZiB0cnVlLCB3aGVuIGlkcyBnb2VzIG92ZXIgdGhlIG1heCBudW0gb2YgY29sbGVjdGlvbiBBUEkgKD0yMDApLCBpZHMgYXJlIGRpdmlkZWQgaW50byBzZXZlcmFsIGNodW5rcyBhbmQgcmVxdWVzdGVkIHJlY3Vyc2l2ZWx5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBIVFRQIHJlcXVlc3QgaGVhZGVycyBzZW50IGluIHJldHJpZXZlIHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFja1xuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cbi8qKlxuICogU3lub255bSBvZiBDb25uZWN0aW9uI2Rlc3Ryb3koKVxuICpcbiAqIEBtZXRob2QgQ29ubmVjdGlvbiNkZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gU09iamVjdCBUeXBlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaWRzIC0gQSBJRCBvciBhcnJheSBvZiBJRHMgdG8gZGVsZXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgcmVzdCBhcGkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbE9yTm9uZV0gLSBJZiB0cnVlLCBhbnkgZmFpbGVkIHJlY29yZHMgaW4gYSBjYWxsIGNhdXNlIGFsbCBjaGFuZ2VzIGZvciB0aGUgY2FsbCB0byBiZSByb2xsZWQgYmFja1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1JlY3Vyc2l2ZV0gLSBJZiB0cnVlLCB3aGVuIGlkcyBnb2VzIG92ZXIgdGhlIG1heCBudW0gb2YgY29sbGVjdGlvbiBBUEkgKD0yMDApLCBpZHMgYXJlIGRpdmlkZWQgaW50byBzZXZlcmFsIGNodW5rcyBhbmQgcmVxdWVzdGVkIHJlY3Vyc2l2ZWx5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBIVFRQIHJlcXVlc3QgaGVhZGVycyBzZW50IGluIHJldHJpZXZlIHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFja1xuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cbi8qKlxuICogRGVsZXRlIHJlY29yZHNcbiAqXG4gKiBAbWV0aG9kIENvbm5lY3Rpb24jZGVzdHJveVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IFR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBpZHMgLSBBIElEIG9yIGFycmF5IG9mIElEcyB0byBkZWxldGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciByZXN0IGFwaS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsT3JOb25lXSAtIElmIHRydWUsIGFueSBmYWlsZWQgcmVjb3JkcyBpbiBhIGNhbGwgY2F1c2UgYWxsIGNoYW5nZXMgZm9yIHRoZSBjYWxsIHRvIGJlIHJvbGxlZCBiYWNrXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93UmVjdXJzaXZlXSAtIElmIHRydWUsIHdoZW4gaWRzIGdvZXMgb3ZlciB0aGUgbWF4IG51bSBvZiBjb2xsZWN0aW9uIEFQSSAoPTIwMCksIGlkcyBhcmUgZGl2aWRlZCBpbnRvIHNldmVyYWwgY2h1bmtzIGFuZCByZXF1ZXN0ZWQgcmVjdXJzaXZlbHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gLSBBZGRpdGlvbmFsIEhUVFAgcmVxdWVzdCBoZWFkZXJzIHNlbnQgaW4gcmV0cmlldmUgcmVxdWVzdFxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGVbXCJkZWxldGVcIl0gPVxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZGVsID1cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbih0eXBlLCBpZHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHJldHVybiAoXG4gICAgXy5pc0FycmF5KGlkcykgP1xuICAgICAgKHRoaXMuX3N1cHBvcnRzKCdzb2JqZWN0LWNvbGxlY3Rpb24nKSA/IC8vIGNoZWNrIHdoZXRoZXIgU09iamVjdCBjb2xsZWN0aW9uIEFQSSBpcyBzdXBwb3J0ZWRcbiAgICAgICAgdGhpcy5fZGVzdHJveU1hbnkodHlwZSwgaWRzLCBvcHRpb25zKSA6XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lQYXJhbGxlbCh0eXBlLCBpZHMsIG9wdGlvbnMpKSA6XG4gICAgICB0aGlzLl9kZXN0cm95U2luZ2xlKHR5cGUsIGlkcywgb3B0aW9ucylcbiAgKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9kZXN0cm95U2luZ2xlID0gZnVuY3Rpb24odHlwZSwgaWQsIG9wdGlvbnMpIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fYmFzZVVybCgpLCBcInNvYmplY3RzXCIsIHR5cGUsIGlkIF0uam9pbignLycpO1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHtcbiAgICBtZXRob2QgOiAnREVMRVRFJyxcbiAgICB1cmwgOiB1cmwsXG4gICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzIHx8IG51bGxcbiAgfSwge1xuICAgIG5vQ29udGVudFJlc3BvbnNlOiB7IGlkIDogaWQsIHN1Y2Nlc3MgOiB0cnVlLCBlcnJvcnMgOiBbXSB9XG4gIH0pO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fZGVzdHJveVBhcmFsbGVsID0gZnVuY3Rpb24odHlwZSwgaWRzLCBvcHRpb25zKSB7XG4gIGlmIChpZHMubGVuZ3RoID4gdGhpcy5tYXhSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkV4Y2VlZGVkIG1heCBsaW1pdCBvZiBjb25jdXJyZW50IGNhbGxcIikpO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGlkcy5tYXAoZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiBzZWxmLl9kZXN0cm95U2luZ2xlKHR5cGUsIGlkLCBvcHRpb25zKS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgLy8gYmUgYXdhcmUgdGhhdCBgYWxsT3JOb25lYCBvcHRpb24gaW4gcGFyYWxsZWwgbW9kZSB3aWxsIG5vdCByZXZlcnQgdGhlIG90aGVyIHN1Y2Nlc3NmdWwgcmVxdWVzdHNcbiAgICAgICAgLy8gaXQgb25seSByYWlzZXMgZXJyb3Igd2hlbiBtZXQgYXQgbGVhc3Qgb25lIGZhaWxlZCByZXF1ZXN0LlxuICAgICAgICBpZiAob3B0aW9ucy5hbGxPck5vbmUgfHwgIWVyci5lcnJvckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvUmVjb3JkUmVzdWx0KGlkLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfSlcbiAgKTtcbn07XG5cblxuLyoqIEBwcml2YXRlICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fZGVzdHJveU1hbnkgPSBmdW5jdGlvbih0eXBlLCBpZHMsIG9wdGlvbnMpIHtcbiAgaWYgKGlkcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgfVxuICBpZiAoaWRzLmxlbmd0aCA+IE1BWF9ETUxfQ09VTlQgJiYgb3B0aW9ucy5hbGxvd1JlY3Vyc2l2ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gc2VsZi5fZGVzdHJveU1hbnkodHlwZSwgaWRzLnNsaWNlKDAsIE1BWF9ETUxfQ09VTlQpLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uKHJldHMxKSB7XG4gICAgICByZXR1cm4gc2VsZi5fZGVzdHJveU1hbnkodHlwZSwgaWRzLnNsaWNlKE1BWF9ETUxfQ09VTlQpLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uKHJldHMyKSB7XG4gICAgICAgIHJldHVybiByZXRzMS5jb25jYXQocmV0czIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdmFyIHVybCA9IFsgdGhpcy5fYmFzZVVybCgpLCBcImNvbXBvc2l0ZVwiLCBcInNvYmplY3RzP2lkcz1cIiBdLmpvaW4oJy8nKSArIGlkcy5qb2luKCcsJyk7XG4gIGlmIChvcHRpb25zLmFsbE9yTm9uZSkge1xuICAgIHVybCArPSAnJmFsbE9yTm9uZT10cnVlJztcbiAgfVxuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHtcbiAgICBtZXRob2QgOiAnREVMRVRFJyxcbiAgICB1cmwgOiB1cmwsXG4gICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzIHx8IG51bGxcbiAgfSk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgc2VhcmNoIGJ5IFNPU0xcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc29zbCAtIFNPU0wgc3RyaW5nXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24oc29zbCwgY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IHRoaXMuX2Jhc2VVcmwoKSArIFwiL3NlYXJjaD9xPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHNvc2wpO1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZXN1bHQgcmV0dXJuZWQgYnkgZGVzY3JpYmVTT2JqZWN0IGNhbGxcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZXNjcmliZVNPYmplY3RSZXN1bHRcbiAqL1xuLyoqXG4gKiBQYXJhbWV0ZXIgZm9yIGRlc2NyaWJlU09iamVjdCBjYWxsXG4gKiBcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlc2NyaWJlU09iamVjdE9wdGlvbnNcbiAqL1xuLyoqXG4gKiBTeW5vbnltIG9mIENvbm5lY3Rpb24jZGVzY3JpYmUoKVxuICpcbiAqIEBtZXRob2QgQ29ubmVjdGlvbiNkZXNjcmliZVNPYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfERlc2NyaWJlU09iamVjdE9wdGlvbnN9IHR5cGUgLSBTT2JqZWN0IFR5cGUgb3Igb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlLnR5cGUgLSBUaGUgbmFtZSBvZiB0aGUgU09iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUuaWZNb2RpZmllZFNpbmNlIC0gRGF0ZSB2YWx1ZSBmb3IgSWYtTW9kaWZpZWQtU2luY2UgaGVhZGVyOyB1bmRlZmluZWQgcmVzb2x2ZWQgaWYgbm90IG1vZGlmaWVkIGFmdGVyIHRoaXMgZGF0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48RGVzY3JpYmVTT2JqZWN0UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48RGVzY3JpYmVTT2JqZWN0UmVzdWx0Pn1cbiAqL1xuLyoqXG4gKiBEZXNjcmliZSBTT2JqZWN0IG1ldGFkYXRhXG4gKlxuICogQG1ldGhvZCBDb25uZWN0aW9uI2Rlc2NyaWJlXG4gKiBAcGFyYW0ge1N0cmluZ3xEZXNjcmliZVNPYmplY3RPcHRpb25zfSB0eXBlIC0gU09iamVjdCBUeXBlIG9yIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZS50eXBlIC0gVGhlIG5hbWUgb2YgdGhlIFNPYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlLmlmTW9kaWZpZWRTaW5jZSAtIERhdGUgdmFsdWUgZm9yIElmLU1vZGlmaWVkLVNpbmNlIGhlYWRlcjsgdW5kZWZpbmVkIHJlc29sdmVkIGlmIG5vdCBtb2RpZmllZCBhZnRlciB0aGlzIGRhdGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPERlc2NyaWJlU09iamVjdFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPERlc2NyaWJlU09iamVjdFJlc3VsdD59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRlc2NyaWJlID1cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRlc2NyaWJlU09iamVjdCA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gIHZhciBuYW1lID0gdHlwZS50eXBlID8gdHlwZS50eXBlIDogdHlwZTtcbiAgdmFyIHVybCA9IFsgdGhpcy5fYmFzZVVybCgpLCBcInNvYmplY3RzXCIsIG5hbWUsIFwiZGVzY3JpYmVcIiBdLmpvaW4oJy8nKTtcbiAgdmFyIGhlYWRlcnMgPSB0eXBlLmlmTW9kaWZpZWRTaW5jZSBcbiAgICA/IHsgJ0lmLU1vZGlmaWVkLVNpbmNlJzogdHlwZS5pZk1vZGlmaWVkU2luY2UgfSBcbiAgICA6IHt9O1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogdXJsLFxuICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgfSkudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgIGlmIChyZXNwID09PSAnJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3ApO1xuICAgIH1cbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZXN1bHQgcmV0dXJuZWQgYnkgYmF0Y2hEZXNjcmliZVNPYmplY3RzIGNhbGxcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0W119IERlc2NyaWJlU09iamVjdFJlc3VsdFxuICovXG4vKipcbiAqIFBhcmFtZXRlciBmb3IgZGVzY3JpYmVTT2JqZWN0IGNhbGxcbiAqIFxuICogQHR5cGVkZWYge09iamVjdH0gQmF0Y2hEZXNjcmliZVNPYmplY3RPcHRpb25zXG4gKi9cbi8qKlxuICogU3lub255bSBvZiBDb25uZWN0aW9uI2JhdGNoRGVzY3JpYmUoKVxuICpcbiAqIEBtZXRob2QgQ29ubmVjdGlvbiNiYXRjaERlc2NyaWJlU09iamVjdHNcbiAqIEBwYXJhbSB7QmF0Y2hEZXNjcmliZVNPYmplY3RPcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgZnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nW119IG9wdGlvbnMudHlwZXMgLSBuYW1lcyBvZiBvYmplY3RzIHRvIGZldGNoXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuYXV0b2ZldGNoIC0gd2hldGhlciB0byBhdXRvbWF0aWNhbGx5IGZldGNoIG1ldGFkYXRhIGZvciBsYXJnZSBudW1iZXJzIG9mIFxuICogICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMgKG9uZSBiYXRjaCByZXF1ZXN0IHJldHVybnMgYSBtYXhpbXVtIG9mIDI1IHJlc3VsdHMpOyB3aGVuIHRydWUsIHdpbGwgbWFrZSBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNlcXVlbnQgcmVxdWVzdHMgdW50aWwgYWxsIG9iamVjdCBtZXRhZGF0YSBpcyBmZXRjaGVkOyB3aGVuIGZhbHNlIChkZWZhdWx0KSwgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIG1ha2Ugb25lIGJhdGNoIHJlcXVlc3QgZm9yIG1heGltdW0gb2YgMjUgcmVzdWx0c1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWF4Q29uY3VycmVudFJlcXVlc3RzIC0gbWF4aW11bSBudW1iZXIgb2YgY29uY3VycmVudCByZXF1ZXN0cyBzZW50IHRvIHRoZSBvcmc7IFxuICogICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCBhbmQgbWF4aW11bSBpcyAxNVxuICogQHBhcmFtIHtDYWxsYmFjay48RGVzY3JpYmVTT2JqZWN0UmVzdWx0W10+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxEZXNjcmliZVNPYmplY3RSZXN1bHRbXT59XG4gKi9cbi8qKlxuICogQmF0Y2ggZGVzY3JpYmUgU09iamVjdCBtZXRhZGF0YVxuICpcbiAqIEBtZXRob2QgQ29ubmVjdGlvbiNiYXRjaERlc2NyaWJlXG4gKiBAcGFyYW0ge0JhdGNoRGVzY3JpYmVTT2JqZWN0T3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBvcHRpb25zLnR5cGVzIC0gbmFtZXMgb2Ygb2JqZWN0cyB0byBmZXRjaFxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmF1dG9mZXRjaCAtIHdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBmZXRjaCBtZXRhZGF0YSBmb3IgbGFyZ2UgbnVtYmVycyBvZiBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzIChvbmUgYmF0Y2ggcmVxdWVzdCByZXR1cm5zIGEgbWF4aW11bSBvZiAyNSByZXN1bHRzKTsgd2hlbiB0cnVlLCB3aWxsIG1ha2UgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzZXF1ZW50IHJlcXVlc3RzIHVudGlsIGFsbCBvYmplY3QgbWV0YWRhdGEgaXMgZmV0Y2hlZDsgd2hlbiBmYWxzZSAoZGVmYXVsdCksIFxuICogICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBtYWtlIG9uZSBiYXRjaCByZXF1ZXN0IGZvciBtYXhpbXVtIG9mIDI1IHJlc3VsdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1heENvbmN1cnJlbnRSZXF1ZXN0cyAtIG1heGltdW0gbnVtYmVyIG9mIGNvbmN1cnJlbnQgcmVxdWVzdHMgc2VudCB0byB0aGUgb3JnOyBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgYW5kIG1heGltdW0gaXMgMTVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPERlc2NyaWJlU09iamVjdFJlc3VsdFtdPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48RGVzY3JpYmVTT2JqZWN0UmVzdWx0W10+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5iYXRjaERlc2NyaWJlID0gQ29ubmVjdGlvbi5wcm90b3R5cGUuYmF0Y2hEZXNjcmliZVNPYmplY3RzID0gZnVuY3Rpb24gKFxuICBvcHRpb25zLFxuICBjYWxsYmFja1xuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR5cGVzID0gb3B0aW9ucy50eXBlcztcbiAgdmFyIGF1dG9mZXRjaCA9IG9wdGlvbnMuYXV0b2ZldGNoIHx8IGZhbHNlO1xuICB2YXIgbWF4Q29uY3VycmVudFJlcXVlc3RzID0gTWF0aC5taW4oKG9wdGlvbnMubWF4Q29uY3VycmVudFJlcXVlc3RzIHx8IDE1KSwgMTUpO1xuICB2YXIgYmF0Y2hlcyA9IFtdO1xuICBkbyB7XG4gICAgdmFyIGJhdGNoID0gdHlwZXMubGVuZ3RoID4gTUFYX0JBVENIX1JFUVVFU1RTID8gdHlwZXMuc2xpY2UoMCwgTUFYX0JBVENIX1JFUVVFU1RTKSA6IHR5cGVzO1xuICAgIGJhdGNoZXMucHVzaChiYXRjaCk7XG4gICAgdHlwZXMgPSB0eXBlcy5sZW5ndGggPiBNQVhfQkFUQ0hfUkVRVUVTVFMgPyB0eXBlcy5zbGljZShNQVhfQkFUQ0hfUkVRVUVTVFMpIDogW107XG4gIH0gd2hpbGUgKHR5cGVzLmxlbmd0aCA+IDAgJiYgYXV0b2ZldGNoKTtcbiAgdmFyIHJlcXVlc3RCYXRjaGVzID0gW107XG4gIGRvIHtcbiAgICB2YXIgcmVxdWVzdEJhdGNoID0gYmF0Y2hlcy5sZW5ndGggPiBtYXhDb25jdXJyZW50UmVxdWVzdHMgPyBiYXRjaGVzLnNsaWNlKDAsIG1heENvbmN1cnJlbnRSZXF1ZXN0cykgOiBiYXRjaGVzO1xuICAgIHJlcXVlc3RCYXRjaGVzLnB1c2gocmVxdWVzdEJhdGNoKTtcbiAgICBiYXRjaGVzID0gYmF0Y2hlcy5sZW5ndGggPiBtYXhDb25jdXJyZW50UmVxdWVzdHMgPyBiYXRjaGVzLnNsaWNlKG1heENvbmN1cnJlbnRSZXF1ZXN0cykgOiBbXTtcbiAgfSB3aGlsZSAoYmF0Y2hlcy5sZW5ndGggPiAwKTtcbiAgcmV0dXJuIHNlbGYuZG9CYXRjaERlc2NyaWJlUmVxdWVzdEJhdGNoZXMocmVxdWVzdEJhdGNoZXMpXG4gICAgLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRvQmF0Y2hEZXNjcmliZVJlcXVlc3RCYXRjaGVzID0gZnVuY3Rpb24ocmVxdWVzdEJhdGNoZXMpIHtcbiAgLy8gbWFrZSBlYWNoIGJhdGNoIG9mIHJlcXVlc3RzIHNlcXVlbnRpYWxseSB0byBhdm9pZCBvcmcgbGltaXRzIG9mIG1heCBjb25jdXJyZW50IHJlcXVlc3RzXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNvYmplY3RzID0gW107XG4gIHZhciBmaXJzdEJhdGNoID0gcmVxdWVzdEJhdGNoZXMuc2hpZnQoKTtcbiAgcmV0dXJuIHNlbGYuZG9CYXRjaE9mQmF0Y2hEZXNjcmliZVJlcXVlc3RzKGZpcnN0QmF0Y2gpLnRoZW4oXG4gICAgZnVuY3Rpb24gKHNvYmplY3RBcnJheSkge1xuICAgICAgc29iamVjdEFycmF5LmZvckVhY2goZnVuY3Rpb24gKHNvYmplY3QpIHsgc29iamVjdHMucHVzaChzb2JqZWN0KTsgfSk7XG4gICAgICBpZiAocmVxdWVzdEJhdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gc2VsZi5kb0JhdGNoRGVzY3JpYmVSZXF1ZXN0QmF0Y2hlcyhyZXF1ZXN0QmF0Y2hlcykudGhlbihcbiAgICAgICAgICBmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHsgc29iamVjdHMucHVzaChyZXN1bHQpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc29iamVjdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzb2JqZWN0cyk7XG4gICAgICB9XG4gICAgfVxuICApXG59XG5cbi8qKiBwcml2YXRlICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5kb0JhdGNoT2ZCYXRjaERlc2NyaWJlUmVxdWVzdHMgPSBmdW5jdGlvbihyZXF1ZXN0QmF0Y2gpIHtcbiAgLy8gbWFrZSB1cCB0byBtYXhDb25jdXJyZW50UmVxdWVzdCByZXF1ZXN0cyBpbiBwYXJhbGxlbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICByZXF1ZXN0QmF0Y2gubWFwKGZ1bmN0aW9uIChiYXRjaCkgeyByZXR1cm4gc2VsZi5kb0JhdGNoRGVzY3JpYmVSZXF1ZXN0KGJhdGNoKTsgfSApXG4gICkudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgIHZhciBzb2JqZWN0cyA9IFtdO1xuICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAoc29iamVjdEFycmF5KSB7XG4gICAgICBzb2JqZWN0QXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoc29iamVjdCkgeyBzb2JqZWN0cy5wdXNoKHNvYmplY3QpOyB9KVxuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc29iamVjdHMpO1xufSk7XG59XG5cbi8qKiBwcml2YXRlICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5kb0JhdGNoRGVzY3JpYmVSZXF1ZXN0ID0gZnVuY3Rpb24odHlwZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc29iamVjdHMgPSBbXTtcbiAgdmFyIHVybCA9IFtzZWxmLl9iYXNlVXJsKCksIFwiY29tcG9zaXRlL2JhdGNoXCJdLmpvaW4oXCIvXCIpO1xuICB2YXIgdmVyc2lvbiA9IFwidlwiICsgc2VsZi52ZXJzaW9uO1xuICB2YXIgYmF0Y2hSZXF1ZXN0cyA9IFtdO1xuICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgYmF0Y2hSZXF1ZXN0cy5wdXNoKHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIHVybDogW3ZlcnNpb24sIFwic29iamVjdHNcIiwgdHlwZSwgXCJkZXNjcmliZVwiXS5qb2luKFwiL1wiKVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IHVybCxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGJhdGNoUmVxdWVzdHM6IGJhdGNoUmVxdWVzdHMgfSksXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLnJlc3VsdHMpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzcG9uc2UucmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3ViUmVzcCA9IHJlc3BvbnNlLnJlc3VsdHNbaV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN1YlJlc3AucmVzdWx0KSkge1xuICAgICAgICAgIGlmIChzdWJSZXNwLnJlc3VsdFswXS5lcnJvckNvZGUgJiYgc3ViUmVzcC5yZXN1bHRbMF0ubWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAnRXJyb3I6ICcgKyBzdWJSZXNwLnJlc3VsdFswXS5lcnJvckNvZGUgKyAnICcgKyAgXG4gICAgICAgICAgICAgIHN1YlJlc3AucmVzdWx0WzBdLm1lc3NhZ2UgKyAnIC0gJyArIHR5cGVzVG9GZXRjaFtpXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc29iamVjdHMucHVzaChzdWJSZXNwLnJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzb2JqZWN0cyk7XG4gIH0pOyBcbn1cblxuLyoqXG4gKiBSZXN1bHQgcmV0dXJuZWQgYnkgZGVzY3JpYmVHbG9iYWwgY2FsbFxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlc2NyaWJlR2xvYmFsUmVzdWx0XG4gKi9cbi8qKlxuICogRGVzY3JpYmUgZ2xvYmFsIFNPYmplY3RzXG4gKlxuICogQHBhcmFtIHtDYWxsYmFjay48RGVzY3JpYmVHbG9iYWxSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxEZXNjcmliZUdsb2JhbFJlc3VsdD59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRlc2NyaWJlR2xvYmFsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IHRoaXMuX2Jhc2VVcmwoKSArIFwiL3NvYmplY3RzXCI7XG4gIHJldHVybiB0aGlzLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG5cbi8qKlxuICogR2V0IFNPYmplY3QgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHJldHVybnMge1NPYmplY3R9XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnNvYmplY3QgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHRoaXMuc29iamVjdHMgPSB0aGlzLnNvYmplY3RzIHx8IHt9O1xuICB2YXIgc29iamVjdCA9IHRoaXMuc29iamVjdHNbdHlwZV0gPVxuICAgIHRoaXMuc29iamVjdHNbdHlwZV0gfHwgbmV3IFNPYmplY3QodGhpcywgdHlwZSk7XG4gIHJldHVybiBzb2JqZWN0O1xufTtcblxuLyoqXG4gKiBHZXQgaWRlbnRpdHkgaW5mb3JtYXRpb24gb2YgY3VycmVudCB1c2VyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIElkZW50aXR5IGNhbGwgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBIVFRQIHJlcXVlc3QgaGVhZGVycyBzZW50IGluIGlkZW50aXR5IHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPElkZW50aXR5SW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPElkZW50aXR5SW5mbz59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmlkZW50aXR5ID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgaWRVcmwgPSB0aGlzLnVzZXJJbmZvICYmIHRoaXMudXNlckluZm8udXJsO1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgIGlkVXJsID9cbiAgICB7IGlkZW50aXR5OiBpZFVybCB9IDpcbiAgICB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdHRVQnLCB1cmw6IHRoaXMuX2Jhc2VVcmwoKSwgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzIH0pXG4gICkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICB2YXIgdXJsID0gcmVzLmlkZW50aXR5O1xuICAgIHJldHVybiBzZWxmLnJlcXVlc3QoeyBtZXRob2Q6ICdHRVQnLCB1cmw6IHVybCB9KTtcbiAgfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICBzZWxmLnVzZXJJbmZvID0ge1xuICAgICAgaWQ6IHJlcy51c2VyX2lkLFxuICAgICAgb3JnYW5pemF0aW9uSWQ6IHJlcy5vcmdhbml6YXRpb25faWQsXG4gICAgICB1cmw6IHJlcy5pZFxuICAgIH07XG4gICAgcmV0dXJuIHJlcztcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBVc2VySW5mb1xuICogQHByb3Age1N0cmluZ30gaWQgLSBVc2VyIElEXG4gKiBAcHJvcCB7U3RyaW5nfSBvcmdhbml6YXRpb25JZCAtIE9yZ2FuaXphdGlvbiBJRFxuICogQHByb3Age1N0cmluZ30gdXJsIC0gSWRlbnRpdHkgVVJMIG9mIHRoZSB1c2VyXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemUgKHVzaW5nIG9hdXRoMiB3ZWIgc2VydmVyIGZsb3cpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvZGUgLSBBdXRob3JpemF0aW9uIGNvZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gc2VuZCBpbiB0b2tlbiByZXRyaWV2YWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLmNvZGVfdmVyaWZpZXJdIC0gQ29kZSB2ZXJpZmllciB2YWx1ZSAoUkZDIDc2MzYgLSBQcm9vZiBLZXkgb2YgQ29kZSBFeGNoYW5nZSlcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFVzZXJJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48VXNlckluZm8+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5hdXRob3JpemUgPSBmdW5jdGlvbihjb2RlLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgcGFyYW1zID0ge307XG4gIH1cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbG9nZ2VyID0gdGhpcy5fbG9nZ2VyO1xuXG4gIHJldHVybiB0aGlzLm9hdXRoMi5yZXF1ZXN0VG9rZW4oY29kZSwgcGFyYW1zKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgIHZhciB1c2VySW5mbyA9IHBhcnNlSWRVcmwocmVzLmlkKTtcbiAgICBzZWxmLmluaXRpYWxpemUoe1xuICAgICAgaW5zdGFuY2VVcmwgOiByZXMuaW5zdGFuY2VfdXJsLFxuICAgICAgYWNjZXNzVG9rZW4gOiByZXMuYWNjZXNzX3Rva2VuLFxuICAgICAgcmVmcmVzaFRva2VuIDogcmVzLnJlZnJlc2hfdG9rZW4sXG4gICAgICB1c2VySW5mbzogdXNlckluZm9cbiAgICB9KTtcbiAgICBsb2dnZXIuZGVidWcoXCI8bG9naW4+IGNvbXBsZXRlZC4gdXNlciBpZCA9IFwiICsgdXNlckluZm8uaWQgKyBcIiwgb3JnIGlkID0gXCIgKyB1c2VySW5mby5vcmdhbml6YXRpb25JZCk7XG4gICAgcmV0dXJuIHVzZXJJbmZvO1xuXG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcblxufTtcblxuXG4vKipcbiAqIExvZ2luIHRvIFNhbGVzZm9yY2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUgLSBTYWxlc2ZvcmNlIHVzZXJuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQgLSBTYWxlc2ZvcmNlIHBhc3N3b3JkIChhbmQgc2VjdXJpdHkgdG9rZW4sIGlmIHJlcXVpcmVkKVxuICogQHBhcmFtIHtDYWxsYmFjay48VXNlckluZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxVc2VySW5mbz59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmxvZ2luID0gZnVuY3Rpb24odXNlcm5hbWUsIHBhc3N3b3JkLCBjYWxsYmFjaykge1xuICAvLyByZWdpc3RlciByZWZyZXNoRGVsZWdhdGUgZm9yIHNlc3Npb24gZXhwaXJhdGlvblxuICB0aGlzLl9yZWZyZXNoRGVsZWdhdGUgPSBuZXcgSHR0cEFwaS5TZXNzaW9uUmVmcmVzaERlbGVnYXRlKHRoaXMsIGNyZWF0ZVVzZXJuYW1lUGFzc3dvcmRSZWZyZXNoRm4odXNlcm5hbWUsIHBhc3N3b3JkKSk7XG4gIGlmICh0aGlzLm9hdXRoMiAmJiB0aGlzLm9hdXRoMi5jbGllbnRJZCAmJiB0aGlzLm9hdXRoMi5jbGllbnRTZWNyZXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dpbkJ5T0F1dGgyKHVzZXJuYW1lLCBwYXNzd29yZCwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmxvZ2luQnlTb2FwKHVzZXJuYW1lLCBwYXNzd29yZCwgY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKiogQHByaXZhdGUgKiovXG5mdW5jdGlvbiBjcmVhdGVVc2VybmFtZVBhc3N3b3JkUmVmcmVzaEZuKHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29ubiwgY2FsbGJhY2spIHtcbiAgICBjb25uLmxvZ2luKHVzZXJuYW1lLCBwYXNzd29yZCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9XG4gICAgICBjYWxsYmFjayhudWxsLCBjb25uLmFjY2Vzc1Rva2VuKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBMb2dpbiBieSBPQXV0aDIgdXNlcm5hbWUgJiBwYXNzd29yZCBmbG93XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lIC0gU2FsZXNmb3JjZSB1c2VybmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhc3N3b3JkIC0gU2FsZXNmb3JjZSBwYXNzd29yZCAoYW5kIHNlY3VyaXR5IHRva2VuLCBpZiByZXF1aXJlZClcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFVzZXJJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48VXNlckluZm8+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5sb2dpbkJ5T0F1dGgyID0gZnVuY3Rpb24odXNlcm5hbWUsIHBhc3N3b3JkLCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsb2dnZXIgPSB0aGlzLl9sb2dnZXI7XG4gIHJldHVybiB0aGlzLm9hdXRoMi5hdXRoZW50aWNhdGUodXNlcm5hbWUsIHBhc3N3b3JkKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgIHZhciB1c2VySW5mbyA9IHBhcnNlSWRVcmwocmVzLmlkKTtcbiAgICBzZWxmLmluaXRpYWxpemUoe1xuICAgICAgaW5zdGFuY2VVcmwgOiByZXMuaW5zdGFuY2VfdXJsLFxuICAgICAgYWNjZXNzVG9rZW4gOiByZXMuYWNjZXNzX3Rva2VuLFxuICAgICAgdXNlckluZm86IHVzZXJJbmZvXG4gICAgfSk7XG4gICAgbG9nZ2VyLmRlYnVnKFwiPGxvZ2luPiBjb21wbGV0ZWQuIHVzZXIgaWQgPSBcIiArIHVzZXJJbmZvLmlkICsgXCIsIG9yZyBpZCA9IFwiICsgdXNlckluZm8ub3JnYW5pemF0aW9uSWQpO1xuICAgIHJldHVybiB1c2VySW5mbztcblxuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG5cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXNjKHN0cikge1xuICByZXR1cm4gc3RyICYmIFN0cmluZyhzdHIpLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn1cblxuLyoqXG4gKiBMb2dpbiBieSBTT0FQIHdlYiBzZXJ2aWNlIEFQSVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZSAtIFNhbGVzZm9yY2UgdXNlcm5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCAtIFNhbGVzZm9yY2UgcGFzc3dvcmQgKGFuZCBzZWN1cml0eSB0b2tlbiwgaWYgcmVxdWlyZWQpXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxVc2VySW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFVzZXJJbmZvPn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUubG9naW5CeVNvYXAgPSBmdW5jdGlvbih1c2VybmFtZSwgcGFzc3dvcmQsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxvZ2dlciA9IHRoaXMuX2xvZ2dlcjtcbiAgdmFyIGJvZHkgPSBbXG4gICAgJzxzZTpFbnZlbG9wZSB4bWxuczpzZT1cImh0dHA6Ly9zY2hlbWFzLnhtbHNvYXAub3JnL3NvYXAvZW52ZWxvcGUvXCI+JyxcbiAgICAgICc8c2U6SGVhZGVyLz4nLFxuICAgICAgJzxzZTpCb2R5PicsXG4gICAgICAgICc8bG9naW4geG1sbnM9XCJ1cm46cGFydG5lci5zb2FwLnNmb3JjZS5jb21cIj4nLFxuICAgICAgICAgICc8dXNlcm5hbWU+JyArIGVzYyh1c2VybmFtZSkgKyAnPC91c2VybmFtZT4nLFxuICAgICAgICAgICc8cGFzc3dvcmQ+JyArIGVzYyhwYXNzd29yZCkgKyAnPC9wYXNzd29yZD4nLFxuICAgICAgICAnPC9sb2dpbj4nLFxuICAgICAgJzwvc2U6Qm9keT4nLFxuICAgICc8L3NlOkVudmVsb3BlPidcbiAgXS5qb2luKCcnKTtcblxuICB2YXIgc29hcExvZ2luRW5kcG9pbnQgPSBbIHRoaXMubG9naW5VcmwsIFwic2VydmljZXMvU29hcC91XCIsIHRoaXMudmVyc2lvbiBdLmpvaW4oJy8nKTtcblxuICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lmh0dHBSZXF1ZXN0KHtcbiAgICBtZXRob2QgOiAnUE9TVCcsXG4gICAgdXJsIDogc29hcExvZ2luRW5kcG9pbnQsXG4gICAgYm9keSA6IGJvZHksXG4gICAgaGVhZGVycyA6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCIgOiBcInRleHQveG1sXCIsXG4gICAgICBcIlNPQVBBY3Rpb25cIiA6ICdcIlwiJ1xuICAgIH1cbiAgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIHZhciBtO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgbSA9IHJlc3BvbnNlLmJvZHkubWF0Y2goLzxmYXVsdHN0cmluZz4oW148XSspPFxcL2ZhdWx0c3RyaW5nPi8pO1xuICAgICAgdmFyIGZhdWx0c3RyaW5nID0gbSAmJiBtWzFdO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGZhdWx0c3RyaW5nIHx8IHJlc3BvbnNlLmJvZHkpO1xuICAgIH1cbiAgICBsb2dnZXIuZGVidWcoXCJTT0FQIHJlc3BvbnNlID0gXCIgKyByZXNwb25zZS5ib2R5KTtcbiAgICBtID0gcmVzcG9uc2UuYm9keS5tYXRjaCgvPHNlcnZlclVybD4oW148XSspPFxcL3NlcnZlclVybD4vKTtcbiAgICB2YXIgc2VydmVyVXJsID0gbSAmJiBtWzFdO1xuICAgIG0gPSByZXNwb25zZS5ib2R5Lm1hdGNoKC88c2Vzc2lvbklkPihbXjxdKyk8XFwvc2Vzc2lvbklkPi8pO1xuICAgIHZhciBzZXNzaW9uSWQgPSBtICYmIG1bMV07XG4gICAgbSA9IHJlc3BvbnNlLmJvZHkubWF0Y2goLzx1c2VySWQ+KFtePF0rKTxcXC91c2VySWQ+Lyk7XG4gICAgdmFyIHVzZXJJZCA9IG0gJiYgbVsxXTtcbiAgICBtID0gcmVzcG9uc2UuYm9keS5tYXRjaCgvPG9yZ2FuaXphdGlvbklkPihbXjxdKyk8XFwvb3JnYW5pemF0aW9uSWQ+Lyk7XG4gICAgdmFyIG9yZ0lkID0gbSAmJiBtWzFdO1xuICAgIHZhciBpZFVybCA9IHNvYXBMb2dpbkVuZHBvaW50LnNwbGl0KCcvJykuc2xpY2UoMCwgMykuam9pbignLycpO1xuICAgIGlkVXJsICs9IFwiL2lkL1wiICsgb3JnSWQgKyBcIi9cIiArIHVzZXJJZDtcbiAgICB2YXIgdXNlckluZm8gPSB7XG4gICAgICBpZDogdXNlcklkLFxuICAgICAgb3JnYW5pemF0aW9uSWQ6IG9yZ0lkLFxuICAgICAgdXJsOiBpZFVybFxuICAgIH07XG4gICAgc2VsZi5pbml0aWFsaXplKHtcbiAgICAgIHNlcnZlclVybDogc2VydmVyVXJsLnNwbGl0KCcvJykuc2xpY2UoMCwgMykuam9pbignLycpLFxuICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQsXG4gICAgICB1c2VySW5mbzogdXNlckluZm9cbiAgICB9KTtcbiAgICBsb2dnZXIuZGVidWcoXCI8bG9naW4+IGNvbXBsZXRlZC4gdXNlciBpZCA9IFwiICsgdXNlcklkICsgXCIsIG9yZyBpZCA9IFwiICsgb3JnSWQpO1xuICAgIHJldHVybiB1c2VySW5mbztcblxuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG5cbn07XG5cbi8qKlxuICogTG9nb3V0IHRoZSBjdXJyZW50IHNlc3Npb24gXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbcmV2b2tlXSAtIFJldm9rZXMgQVBJIEFjY2VzcyBpZiBzZXQgdG8gdHJ1ZVxuICogQHBhcmFtIHtDYWxsYmFjay48dW5kZWZpbmVkPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48dW5kZWZpbmVkPn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUubG9nb3V0ID0gZnVuY3Rpb24ocmV2b2tlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHJldm9rZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcmV2b2tlO1xuICAgIHJldm9rZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Nlc3Npb25UeXBlID09PSBcIm9hdXRoMlwiKSB7XG4gICAgcmV0dXJuIHRoaXMubG9nb3V0QnlPQXV0aDIocmV2b2tlLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMubG9nb3V0QnlTb2FwKHJldm9rZSwgY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIExvZ291dCB0aGUgY3VycmVudCBzZXNzaW9uIGJ5IHJldm9raW5nIGFjY2VzcyB0b2tlbiB2aWEgT0F1dGgyIHNlc3Npb24gcmV2b2tlXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbcmV2b2tlXSAtIFJldm9rZXMgQVBJIEFjY2VzcyBpZiBzZXQgdG8gdHJ1ZVxuICogQHBhcmFtIHtDYWxsYmFjay48dW5kZWZpbmVkPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48dW5kZWZpbmVkPn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUubG9nb3V0QnlPQXV0aDIgPSBmdW5jdGlvbihyZXZva2UsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgcmV2b2tlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSByZXZva2U7XG4gICAgcmV2b2tlID0gZmFsc2U7XG4gIH1cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbG9nZ2VyID0gdGhpcy5fbG9nZ2VyO1xuXG4gIHJldHVybiB0aGlzLm9hdXRoMi5yZXZva2VUb2tlbihyZXZva2UgPyB0aGlzLnJlZnJlc2hUb2tlbiA6IHRoaXMuYWNjZXNzVG9rZW4pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgLy8gRGVzdHJveSB0aGUgc2Vzc2lvbiBib3VuZCB0byB0aGlzIGNvbm5lY3Rpb25cbiAgICBzZWxmLmFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICBzZWxmLnVzZXJJbmZvID0gbnVsbDtcbiAgICBzZWxmLnJlZnJlc2hUb2tlbiA9IG51bGw7XG4gICAgc2VsZi5pbnN0YW5jZVVybCA9IG51bGw7XG4gICAgc2VsZi5jYWNoZS5jbGVhcigpO1xuXG4gICAgLy8gbm90aGluZyB1c2VmdWwgcmV0dXJuZWQgYnkgbG9nb3V0IEFQSSwganVzdCByZXR1cm5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG5cbi8qKlxuICogTG9nb3V0IHRoZSBzZXNzaW9uIGJ5IHVzaW5nIFNPQVAgd2ViIHNlcnZpY2UgQVBJXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbcmV2b2tlXSAtIFJldm9rZXMgQVBJIEFjY2VzcyBpZiBzZXQgdG8gdHJ1ZVxuICogQHBhcmFtIHtDYWxsYmFjay48dW5kZWZpbmVkPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48dW5kZWZpbmVkPn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUubG9nb3V0QnlTb2FwID0gZnVuY3Rpb24ocmV2b2tlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHJldm9rZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcmV2b2tlO1xuICAgIHJldm9rZSA9IGZhbHNlO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxvZ2dlciA9IHRoaXMuX2xvZ2dlcjtcblxuICB2YXIgYm9keSA9IFtcbiAgICAnPHNlOkVudmVsb3BlIHhtbG5zOnNlPVwiaHR0cDovL3NjaGVtYXMueG1sc29hcC5vcmcvc29hcC9lbnZlbG9wZS9cIj4nLFxuICAgICAgJzxzZTpIZWFkZXI+JyxcbiAgICAgICAgJzxTZXNzaW9uSGVhZGVyIHhtbG5zPVwidXJuOnBhcnRuZXIuc29hcC5zZm9yY2UuY29tXCI+JyxcbiAgICAgICAgICAnPHNlc3Npb25JZD4nICsgZXNjKHJldm9rZSA/IHRoaXMucmVmcmVzaFRva2VuIDogdGhpcy5hY2Nlc3NUb2tlbikgKyAnPC9zZXNzaW9uSWQ+JyxcbiAgICAgICAgJzwvU2Vzc2lvbkhlYWRlcj4nLFxuICAgICAgJzwvc2U6SGVhZGVyPicsXG4gICAgICAnPHNlOkJvZHk+JyxcbiAgICAgICAgJzxsb2dvdXQgeG1sbnM9XCJ1cm46cGFydG5lci5zb2FwLnNmb3JjZS5jb21cIi8+JyxcbiAgICAgICc8L3NlOkJvZHk+JyxcbiAgICAnPC9zZTpFbnZlbG9wZT4nXG4gIF0uam9pbignJyk7XG5cbiAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5odHRwUmVxdWVzdCh7XG4gICAgbWV0aG9kIDogJ1BPU1QnLFxuICAgIHVybCA6IFsgdGhpcy5pbnN0YW5jZVVybCwgXCJzZXJ2aWNlcy9Tb2FwL3VcIiwgdGhpcy52ZXJzaW9uIF0uam9pbignLycpLFxuICAgIGJvZHkgOiBib2R5LFxuICAgIGhlYWRlcnMgOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiIDogXCJ0ZXh0L3htbFwiLFxuICAgICAgXCJTT0FQQWN0aW9uXCIgOiAnXCJcIidcbiAgICB9XG4gIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICBsb2dnZXIuZGVidWcoXCJTT0FQIHN0YXR1c0NvZGUgPSBcIiArIHJlc3BvbnNlLnN0YXR1c0NvZGUgKyBcIiwgcmVzcG9uc2UgPSBcIiArIHJlc3BvbnNlLmJvZHkpO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgdmFyIG0gPSByZXNwb25zZS5ib2R5Lm1hdGNoKC88ZmF1bHRzdHJpbmc+KFtePF0rKTxcXC9mYXVsdHN0cmluZz4vKTtcbiAgICAgIHZhciBmYXVsdHN0cmluZyA9IG0gJiYgbVsxXTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmYXVsdHN0cmluZyB8fCByZXNwb25zZS5ib2R5KTtcbiAgICB9XG5cbiAgICAvLyBEZXN0cm95IHRoZSBzZXNzaW9uIGJvdW5kIHRvIHRoaXMgY29ubmVjdGlvblxuICAgIHNlbGYuYWNjZXNzVG9rZW4gPSBudWxsO1xuICAgIHNlbGYudXNlckluZm8gPSBudWxsO1xuICAgIHNlbGYucmVmcmVzaFRva2VuID0gbnVsbDtcbiAgICBzZWxmLmluc3RhbmNlVXJsID0gbnVsbDtcbiAgICBzZWxmLmNhY2hlLmNsZWFyKCk7XG5cbiAgICAvLyBub3RoaW5nIHVzZWZ1bCByZXR1cm5lZCBieSBsb2dvdXQgQVBJLCBqdXN0IHJldHVyblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBMaXN0IHJlY2VudGx5IHZpZXdlZCByZWNvcmRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAtIFNPYmplY3QgdHlwZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtsaW1pdF0gLSBMaW1pdCBudW0gdG8gZmV0Y2hcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5yZWNlbnQgPSBmdW5jdGlvbih0eXBlLCBsaW1pdCwgY2FsbGJhY2spIHtcbiAgaWYgKCFfLmlzU3RyaW5nKHR5cGUpKSB7XG4gICAgY2FsbGJhY2sgPSBsaW1pdDtcbiAgICBsaW1pdCA9IHR5cGU7XG4gICAgdHlwZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoIV8uaXNOdW1iZXIobGltaXQpKSB7XG4gICAgY2FsbGJhY2sgPSBsaW1pdDtcbiAgICBsaW1pdCA9IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgdXJsO1xuICBpZiAodHlwZSkge1xuICAgIHVybCA9IFsgdGhpcy5fYmFzZVVybCgpLCBcInNvYmplY3RzXCIsIHR5cGUgXS5qb2luKCcvJyk7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1cmwpLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICByZXR1cm4gbGltaXQgPyByZXMucmVjZW50SXRlbXMuc2xpY2UoMCwgbGltaXQpIDogcmVzLnJlY2VudEl0ZW1zO1xuICAgIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICB1cmwgPSB0aGlzLl9iYXNlVXJsKCkgKyBcIi9yZWNlbnRcIjtcbiAgICBpZiAobGltaXQpIHtcbiAgICAgIHVybCArPSBcIj9saW1pdD1cIiArIGxpbWl0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCkudGhlbkNhbGwoY2FsbGJhY2spO1xuICB9XG5cbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVXBkYXRlZFJlY29yZHNJbmZvXG4gKiBAcHJvcCB7U3RyaW5nfSBsYXRlc3REYXRlQ292ZXJlZCAtIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGxhc3QgZGF0ZSBjb3ZlcmVkLlxuICogQHByb3Age0FycmF5LjxTdHJpbmc+fSBpZHMgLSBVcGRhdGVkIHJlY29yZCBJRHMuXG4gKi9cblxuLyoqXG4gKiBSZXRyaWV2ZSB1cGRhdGVkIHJlY29yZHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtTdHJpbmd8RGF0ZX0gc3RhcnQgLSBzdGFydCBkYXRlIG9yIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IG9mIHRoZSBpbnRlcnZhbFxuICogQHBhcmFtIHtTdHJpbmd8RGF0ZX0gZW5kIC0gc3RhcnQgZGF0ZSBvciBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBlbmQgb2YgdGhlIGludGVydmFsIG11c3QgYmUgPiBzdGFydFxuICogQHBhcmFtIHtDYWxsYmFjay48VXBkYXRlZFJlY29yZHNJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48VXBkYXRlZFJlY29yZHNJbmZvPn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUudXBkYXRlZCA9IGZ1bmN0aW9uICh0eXBlLCBzdGFydCwgZW5kLCBjYWxsYmFjaykge1xuICB2YXIgdXJsID0gWyB0aGlzLl9iYXNlVXJsKCksIFwic29iamVjdHNcIiwgdHlwZSwgXCJ1cGRhdGVkXCIgXS5qb2luKCcvJyk7XG5cbiAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICBzdGFydCA9IG5ldyBEYXRlKHN0YXJ0KTtcbiAgfVxuXG4gIGlmIChzdGFydCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICBzdGFydCA9IGZvcm1hdERhdGUoc3RhcnQpO1xuICB9XG5cbiAgaWYgKHN0YXJ0KSB7XG4gICAgdXJsICs9IFwiP3N0YXJ0PVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0YXJ0KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgIGVuZCA9IG5ldyBEYXRlKGVuZCk7XG4gIH1cblxuICBpZiAoZW5kIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIGVuZCA9IGZvcm1hdERhdGUoZW5kKTtcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICB1cmwgKz0gXCImZW5kPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGVuZCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWxldGVkUmVjb3Jkc0luZm9cbiAqIEBwcm9wIHtTdHJpbmd9IGVhcmxpZXN0RGF0ZUF2YWlsYWJsZSAtIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGVhcmxpZXN0IGRhdGUgYXZhaWxhYmxlXG4gKiBAcHJvcCB7U3RyaW5nfSBsYXRlc3REYXRlQ292ZXJlZCAtIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGxhc3QgZGF0ZSBjb3ZlcmVkXG4gKiBAcHJvcCB7QXJyYXkuPE9iamVjdD59IGRlbGV0ZWRSZWNvcmRzIC0gVXBkYXRlZCByZWNvcmRzXG4gKiBAcHJvcCB7U3RyaW5nfSBkZWxldGVkUmVjb3Jkcy5pZCAtIFJlY29yZCBJRFxuICogQHByb3Age1N0cmluZ30gZGVsZXRlZFJlY29yZHMuZGVsZXRlZERhdGUgLSBUaGUgdGltZXN0YW1wIHdoZW4gdGhpcyByZWNvcmQgd2FzIGRlbGV0ZWRcbiAqL1xuXG4vKipcbiAqIFJldHJpZXZlIGRlbGV0ZWQgcmVjb3Jkc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gU09iamVjdCBUeXBlXG4gKiBAcGFyYW0ge1N0cmluZ3xEYXRlfSBzdGFydCAtIHN0YXJ0IGRhdGUgb3Igc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3RhcnQgb2YgdGhlIGludGVydmFsXG4gKiBAcGFyYW0ge1N0cmluZ3xEYXRlfSBlbmQgLSBzdGFydCBkYXRlIG9yIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVuZCBvZiB0aGUgaW50ZXJ2YWxcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPERlbGV0ZWRSZWNvcmRzSW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPERlbGV0ZWRSZWNvcmRzSW5mbz59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRlbGV0ZWQgPSBmdW5jdGlvbiAodHlwZSwgc3RhcnQsIGVuZCwgY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fYmFzZVVybCgpLCBcInNvYmplY3RzXCIsIHR5cGUsIFwiZGVsZXRlZFwiIF0uam9pbignLycpO1xuXG4gIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgc3RhcnQgPSBuZXcgRGF0ZShzdGFydCk7XG4gIH1cblxuICBpZiAoc3RhcnQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgc3RhcnQgPSBmb3JtYXREYXRlKHN0YXJ0KTtcbiAgfVxuXG4gIGlmIChzdGFydCkge1xuICAgIHVybCArPSBcIj9zdGFydD1cIiArIGVuY29kZVVSSUNvbXBvbmVudChzdGFydCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmQgPSBuZXcgRGF0ZShlbmQpO1xuICB9XG5cbiAgaWYgKGVuZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICBlbmQgPSBmb3JtYXREYXRlKGVuZCk7XG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgdXJsICs9IFwiJmVuZD1cIiArIGVuY29kZVVSSUNvbXBvbmVudChlbmQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucmVxdWVzdCh1cmwpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUYWJzSW5mbyAtIFNlZSB0aGUgQVBJIGRvY3VtZW50IGZvciBkZXRhaWwgc3RydWN0dXJlXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdGFic1xuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFRhYnNJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48VGFic0luZm8+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS50YWJzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fYmFzZVVybCgpLCBcInRhYnNcIiBdLmpvaW4oJy8nKTtcbiAgcmV0dXJuIHRoaXMucmVxdWVzdCh1cmwpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMaW1pdHNJbmZvIC0gU2VlIHRoZSBBUEkgZG9jdW1lbnQgZm9yIGRldGFpbCBzdHJ1Y3R1cmVcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgY3VycmVuIHN5c3RlbSBsaW1pdCBpbiB0aGUgb3JnYW5pemF0aW9uXG4gKlxuICogQHBhcmFtIHtDYWxsYmFjay48TGltaXRzSW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPExpbWl0c0luZm8+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5saW1pdHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgdXJsID0gWyB0aGlzLl9iYXNlVXJsKCksIFwibGltaXRzXCIgXS5qb2luKCcvJyk7XG4gIHJldHVybiB0aGlzLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGhlbWVJbmZvIC0gU2VlIHRoZSBBUEkgZG9jdW1lbnQgZm9yIGRldGFpbCBzdHJ1Y3R1cmVcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSB0aGVtZSBpbmZvXG4gKlxuICogQHBhcmFtIHtDYWxsYmFjay48VGhlbWVJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48VGhlbWVJbmZvPn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUudGhlbWUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgdXJsID0gWyB0aGlzLl9iYXNlVXJsKCksIFwidGhlbWVcIiBdLmpvaW4oJy8nKTtcbiAgcmV0dXJuIHRoaXMucmVxdWVzdCh1cmwpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgcmVnaXN0ZXJlZCBnbG9iYWwgcXVpY2sgYWN0aW9uc1xuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxRdWlja0FjdGlvbn5RdWlja0FjdGlvbkluZm8+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXkuPFF1aWNrQWN0aW9uflF1aWNrQWN0aW9uSW5mbz4+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5xdWlja0FjdGlvbnMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL3F1aWNrQWN0aW9uc1wiKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldCByZWZlcmVuY2UgZm9yIHNwZWNpZmllZCBnbG9iYWwgcXVpY2sgYWNpdG9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBnbG9iYWwgcXVpY2sgYWN0aW9uXG4gKiBAcmV0dXJucyB7UXVpY2tBY3Rpb259XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnF1aWNrQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uTmFtZSkge1xuICByZXR1cm4gbmV3IFF1aWNrQWN0aW9uKHRoaXMsIFwiL3F1aWNrQWN0aW9ucy9cIiArIGFjdGlvbk5hbWUpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/connection.js":
/*!************************************************!*\
  !*** ./node_modules/jsforce/lib/connection.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global Buffer */\n/**\n * @file Connection class to keep the API session information and manage requests\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar events  = __webpack_require__(/*! events */ \"events\"),\n    inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\"),\n    _       = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    Promise = __webpack_require__(/*! ./promise */ \"(rsc)/./node_modules/jsforce/lib/promise.js\"),\n    Logger  = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/jsforce/lib/logger.js\"),\n    OAuth2  = __webpack_require__(/*! ./oauth2 */ \"(rsc)/./node_modules/jsforce/lib/oauth2.js\"),\n    Query   = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/jsforce/lib/query.js\"),\n    SObject = __webpack_require__(/*! ./sobject */ \"(rsc)/./node_modules/jsforce/lib/sobject.js\"),\n    QuickAction = __webpack_require__(/*! ./quick-action */ \"(rsc)/./node_modules/jsforce/lib/quick-action.js\"),\n    HttpApi = __webpack_require__(/*! ./http-api */ \"(rsc)/./node_modules/jsforce/lib/http-api.js\"),\n    Transport = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/jsforce/lib/transport.js\"),\n    Process = __webpack_require__(/*! ./process */ \"(rsc)/./node_modules/jsforce/lib/process.js\"),\n    Cache   = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/jsforce/lib/cache.js\");\n\nvar defaults = {\n  loginUrl: \"https://login.salesforce.com\",\n  instanceUrl: \"\",\n  version: \"42.0\"\n};\n\n/*\n * Constant of maximum records num in DML operation (update/delete)\n */\nvar MAX_DML_COUNT = 200;\n\n/*\n * Constant of maximum number of requests that can be batched\n */\nvar MAX_BATCH_REQUESTS = 25;\n\n/**\n * Connection class to keep the API session information and manage requests\n *\n * @constructor\n * @extends events.EventEmitter\n * @param {Object} [options] - Connection options\n * @param {OAuth2|Object} [options.oauth2] - OAuth2 instance or options to be passed to OAuth2 constructor\n * @param {String} [options.logLevel] - Output logging level (DEBUG|INFO|WARN|ERROR|FATAL)\n * @param {String} [options.version] - Salesforce API Version (without \"v\" prefix)\n * @param {Number} [options.maxRequest] - Max number of requests allowed in parallel call\n * @param {String} [options.loginUrl] - Salesforce Login Server URL (e.g. https://login.salesforce.com/)\n * @param {String} [options.instanceUrl] - Salesforce Instance URL (e.g. https://na1.salesforce.com/)\n * @param {String} [options.serverUrl] - Salesforce SOAP service endpoint URL (e.g. https://na1.salesforce.com/services/Soap/u/28.0)\n * @param {String} [options.accessToken] - Salesforce OAuth2 access token\n * @param {String} [options.sessionId] - Salesforce session ID\n * @param {String} [options.refreshToken] - Salesforce OAuth2 refresh token\n * @param {String|Object} [options.signedRequest] - Salesforce Canvas signed request (Raw Base64 string, JSON string, or deserialized JSON)\n * @param {String} [options.proxyUrl] - Cross-domain proxy server URL, used in browser client, non Visualforce app.\n * @param {String} [options.httpProxy] - URL of HTTP proxy server, used in server client.\n * @param {Object} [options.callOptions] - Call options used in each SOAP/REST API request. See manual.\n */\nvar Connection = module.exports = function(options) {\n  options = options || {};\n\n  this._logger = new Logger(options.logLevel);\n\n  var oauth2 = options.oauth2 || {\n    loginUrl : options.loginUrl,\n    clientId : options.clientId,\n    clientSecret : options.clientSecret,\n    redirectUri : options.redirectUri,\n    proxyUrl: options.proxyUrl,\n    httpProxy: options.httpProxy\n  };\n\n  /**\n   * OAuth2 object\n   * @member {OAuth2} Connection#oauth2\n   */\n  this.oauth2 = oauth2 = oauth2 instanceof OAuth2 ? oauth2 : new OAuth2(oauth2);\n\n  this.loginUrl = options.loginUrl || oauth2.loginUrl || defaults.loginUrl;\n  this.version = options.version || defaults.version;\n  this.maxRequest = options.maxRequest || this.maxRequest || 10;\n\n  /** @private */\n  if (options.proxyUrl) {\n    this._transport = new Transport.ProxyTransport(options.proxyUrl);\n  } else if (options.httpProxy) {\n    this._transport = new Transport.HttpProxyTransport(options.httpProxy);\n  } else {\n    this._transport = new Transport();\n  }\n\n  this.callOptions = options.callOptions;\n\n  /*\n   * Fire connection:new event to notify jsforce plugin modules\n   */\n  var jsforce = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/jsforce/lib/core.js\");\n  jsforce.emit('connection:new', this);\n\n  /**\n   * Streaming API object\n   * @member {Streaming} Connection#streaming\n   */\n  // this.streaming = new Streaming(this);\n  /**\n   * Bulk API object\n   * @member {Bulk} Connection#bulk\n   */\n  // this.bulk = new Bulk(this);\n  /**\n   * Tooling API object\n   * @member {Tooling} Connection#tooling\n   */\n  // this.tooling = new Tooling(this);\n  /**\n   * Analytics API object\n   * @member {Analytics} Connection#analytics\n   */\n  // this.analytics = new Analytics(this);\n  /**\n   * Chatter API object\n   * @member {Chatter} Connection#chatter\n   */\n  // this.chatter = new Chatter(this);\n  /**\n   * Metadata API object\n   * @member {Metadata} Connection#metadata\n   */\n  // this.metadata = new Metadata(this);\n\n  /**\n   * SOAP API object\n   * @member {SoapApi} Connection#soap\n   */\n  // this.soap = new SoapApi(this);\n\n  /**\n   * Apex REST API object\n   * @member {Apex} Connection#apex\n   */\n  // this.apex = new Apex(this);\n\n  /**\n   * @member {Process} Connection#process\n   */\n  this.process = new Process(this);\n\n  /**\n   * Cache object for result\n   * @member {Cache} Connection#cache\n   */\n  this.cache = new Cache();\n\n  // Allow to delegate connection refresh to outer function\n  var self = this;\n  var refreshFn = options.refreshFn;\n  if (!refreshFn && this.oauth2.clientId) {\n    refreshFn = oauthRefreshFn;\n  }\n  if (refreshFn) {\n    this._refreshDelegate = new HttpApi.SessionRefreshDelegate(this, refreshFn);\n  }\n\n  var cacheOptions = {\n    key: function(type) { \n      return type \n        ? type.type ? \"describe.\" + type.type : \"describe.\" + type\n        : \"describe\"; \n    }\n  };\n  this.describe$ = this.cache.makeCacheable(this.describe, this, cacheOptions);\n  this.describe = this.cache.makeResponseCacheable(this.describe, this, cacheOptions);\n  this.describeSObject$ = this.describe$;\n  this.describeSObject = this.describe;\n\n  var batchCacheOptions = {\n    key: function(options) {\n      var types = options.types;\n      var autofetch = options.autofetch || false;\n      var typesToFetch = types.length > MAX_BATCH_REQUESTS \n        ? (autofetch ? types : types.slice(0, MAX_BATCH_REQUESTS))\n        : types;\n      var keys = [];\n      typesToFetch.forEach(function (type) { keys.push('describe.' + type); });\n      return keys;\n    }\n  };\n  this.batchDescribe = this.cache.makeResponseCacheable(this.batchDescribe, this, batchCacheOptions);\n  this.batchDescribeSObjects = this.batchDescribe;\n\n  cacheOptions = { key: 'describeGlobal' };\n  this.describeGlobal$ = this.cache.makeCacheable(this.describeGlobal, this, cacheOptions);\n  this.describeGlobal = this.cache.makeResponseCacheable(this.describeGlobal, this, cacheOptions);\n\n  this.initialize(options);\n};\n\ninherits(Connection, events.EventEmitter);\n\n/**\n * Initialize connection.\n *\n * @protected\n * @param {Object} options - Initialization options\n * @param {String} [options.instanceUrl] - Salesforce Instance URL (e.g. https://na1.salesforce.com/)\n * @param {String} [options.serverUrl] - Salesforce SOAP service endpoint URL (e.g. https://na1.salesforce.com/services/Soap/u/28.0)\n * @param {String} [options.accessToken] - Salesforce OAuth2 access token\n * @param {String} [options.sessionId] - Salesforce session ID\n * @param {String} [options.refreshToken] - Salesforce OAuth2 refresh token\n * @param {String|Object} [options.signedRequest] - Salesforce Canvas signed request (Raw Base64 string, JSON string, or deserialized JSON)\n * @param {UserInfo} [options.userInfo] - Logged in user information\n */\nConnection.prototype.initialize = function(options) {\n  if (!options.instanceUrl && options.serverUrl) {\n    options.instanceUrl = options.serverUrl.split('/').slice(0, 3).join('/');\n  }\n  this.instanceUrl = options.instanceUrl || options.serverUrl || this.instanceUrl || defaults.instanceUrl;\n\n  this.accessToken = options.sessionId || options.accessToken || this.accessToken;\n  this.refreshToken = options.refreshToken || this.refreshToken;\n  if (this.refreshToken && !this._refreshDelegate) {\n    throw new Error(\"Refresh token is specified without oauth2 client information or refresh function\");\n  }\n\n  this.signedRequest = options.signedRequest && parseSignedRequest(options.signedRequest);\n  if (this.signedRequest) {\n    this.accessToken = this.signedRequest.client.oauthToken;\n    if (Transport.CanvasTransport.supported) {\n      this._transport = new Transport.CanvasTransport(this.signedRequest);\n    }\n  }\n\n  if (options.userInfo) {\n    this.userInfo = options.userInfo;\n  }\n\n  this.limitInfo = {};\n\n  this.sobjects = {};\n  this.cache.clear();\n  this.cache.get('describeGlobal').removeAllListeners('value');\n  this.cache.get('describeGlobal').on('value', _.bind(function(res) {\n    if (res.result) {\n      var types = _.map(res.result.sobjects, function(so) { return so.name; });\n      types.forEach(this.sobject, this);\n    }\n  }, this));\n\n  if (this.tooling) {\n    this.tooling.initialize();\n  }\n\n  this._sessionType = options.sessionId ? \"soap\" : \"oauth2\";\n\n};\n\n/** @private **/\nfunction oauthRefreshFn(conn, callback) {\n  conn.oauth2.refreshToken(conn.refreshToken, function(err, res) {\n    if (err) { return callback(err); }\n    var userInfo = parseIdUrl(res.id);\n    conn.initialize({\n      instanceUrl : res.instance_url,\n      accessToken : res.access_token,\n      userInfo : userInfo\n    });\n    callback(null, res.access_token, res);\n  });\n}\n\n/** @private **/\nfunction parseSignedRequest(sr) {\n  if (_.isString(sr)) {\n    if (sr[0] === '{') { // might be JSON\n      return JSON.parse(sr);\n    } else { // might be original base64-encoded signed request\n      var msg = sr.split('.').pop(); // retrieve latter part\n      var json = Buffer.from(msg, 'base64').toString('utf-8');\n      return JSON.parse(json);\n    }\n    return null;\n  }\n  return sr;\n}\n\n\n/** @private **/\nConnection.prototype._baseUrl = function() {\n  return [ this.instanceUrl, \"services/data\", \"v\" + this.version ].join('/');\n};\n\n/**\n * Convert path to absolute url\n * @private\n */\nConnection.prototype._normalizeUrl = function(url) {\n  if (url[0] === '/') {\n    if (url.indexOf('/services/') === 0) {\n      return this.instanceUrl + url;\n    } else {\n      return this._baseUrl() + url;\n    }\n  } else {\n    return url;\n  }\n};\n\n/**\n * Send REST API request with given HTTP request info, with connected session information.\n *\n * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')\n * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')\n * , or relative path from version root ('/sobjects/Account/describe').\n *\n * @param {String|Object} request - HTTP request object or URL to GET request\n * @param {String} request.method - HTTP method URL to send HTTP request\n * @param {String} request.url - URL to send HTTP request\n * @param {Object} [request.headers] - HTTP request headers in hash object (key-value)\n * @param {Object} [options] - HTTP API request options\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nConnection.prototype.request = function(request, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  options = options || {};\n  var self = this;\n\n  // if request is simple string, regard it as url in GET method\n  if (_.isString(request)) {\n    request = { method: 'GET', url: request };\n  }\n  // if url is given in relative path, prepend base url or instance url before.\n  request.url = this._normalizeUrl(request.url);\n\n  var httpApi = new HttpApi(this, options);\n\n  // log api usage and its quota\n  httpApi.on('response', function(response) {\n    if (response.headers && response.headers[\"sforce-limit-info\"]) {\n      var apiUsage = response.headers[\"sforce-limit-info\"].match(/api\\-usage=(\\d+)\\/(\\d+)/);\n      if (apiUsage) {\n        self.limitInfo = {\n          apiUsage: {\n            used: parseInt(apiUsage[1], 10),\n            limit: parseInt(apiUsage[2], 10)\n          }\n        };\n      }\n    }\n  });\n  return httpApi.request(request).thenCall(callback);\n};\n\n/**\n * Send HTTP GET request\n *\n * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')\n * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')\n * , or relative path from version root ('/sobjects/Account/describe').\n *\n * @param {String} url - Endpoint URL to request HTTP GET\n * @param {Object} [options] - HTTP API request options\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nConnection.prototype.requestGet = function(url, options, callback) {\n  var request = {\n    method: \"GET\",\n    url: url\n  };\n  return this.request(request, options, callback);\n};\n\n\n/**\n * Send HTTP POST request with JSON body, with connected session information\n *\n * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')\n * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')\n * , or relative path from version root ('/sobjects/Account/describe').\n *\n * @param {String} url - Endpoint URL to request HTTP POST\n * @param {Object} body - Any JS object which can be serialized to JSON\n * @param {Object} [options] - HTTP API request options\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nConnection.prototype.requestPost = function(url, body, options, callback) {\n  var request = {\n    method: \"POST\",\n    url: url,\n    body: JSON.stringify(body),\n    headers: { \"content-type\": \"application/json\" }\n  };\n  return this.request(request, options, callback);\n};\n\n/**\n * Send HTTP PUT request with JSON body, with connected session information\n *\n * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')\n * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')\n * , or relative path from version root ('/sobjects/Account/describe').\n *\n * @param {String} url - Endpoint URL to request HTTP PUT\n * @param {Object} body - Any JS object which can be serialized to JSON\n * @param {Object} [options] - HTTP API request options\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nConnection.prototype.requestPut = function(url, body, options, callback) {\n  var request = {\n    method: \"PUT\",\n    url: url,\n    body: JSON.stringify(body),\n    headers: { \"content-type\": \"application/json\" }\n  };\n  return this.request(request, options, callback);\n};\n\n/**\n * Send HTTP PATCH request with JSON body\n *\n * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')\n * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')\n * , or relative path from version root ('/sobjects/Account/describe').\n *\n * @param {String} url - Endpoint URL to request HTTP PATCH\n * @param {Object} body - Any JS object which can be serialized to JSON\n * @param {Object} [options] - HTTP API request options\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nConnection.prototype.requestPatch = function(url, body, options, callback) {\n  var request = {\n    method: \"PATCH\",\n    url: url,\n    body: JSON.stringify(body),\n    headers: { \"content-type\": \"application/json\" }\n  };\n  return this.request(request, options, callback);\n};\n\n/**\n * Send HTTP DELETE request\n *\n * Endpoint URL can be absolute URL ('https://na1.salesforce.com/services/data/v32.0/sobjects/Account/describe')\n * , relative path from root ('/services/data/v32.0/sobjects/Account/describe')\n * , or relative path from version root ('/sobjects/Account/describe').\n *\n * @param {String} url - Endpoint URL to request HTTP DELETE\n * @param {Object} [options] - HTTP API request options\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nConnection.prototype.requestDelete = function(url, options, callback) {\n  var request = {\n    method: \"DELETE\",\n    url: url\n  };\n  return this.request(request, options, callback);\n};\n\n\n/** @private */\nfunction formatDate(date) {\n  function pad(number) {\n    if (number < 10) {\n      return '0' + number;\n    }\n    return number;\n  }\n\n  return date.getUTCFullYear() +\n    '-' + pad(date.getUTCMonth() + 1) +\n    '-' + pad(date.getUTCDate()) +\n    'T' + pad(date.getUTCHours()) +\n    ':' + pad(date.getUTCMinutes()) +\n    ':' + pad(date.getUTCSeconds()) +\n    '+00:00';\n}\n\n\n/** @private **/\nfunction parseIdUrl(idUrl) {\n  var idUrls = idUrl.split(\"/\");\n  var userId = idUrls.pop(), orgId = idUrls.pop();\n  return {\n    id: userId,\n    organizationId: orgId,\n    url: idUrl\n  };\n}\n\n/**\n * @callback Callback\n * @type {Function}\n * @param {Error} err - Callback error\n * @param {T} response - Callback response\n * @template T\n */\n\n/**\n * @typedef {Object} QueryResult\n * @prop {Boolean} done - Flag if the query is fetched all records or not\n * @prop {String} [nextRecordsUrl] - URL locator for next record set, (available when done = false)\n * @prop {Number} totalSize - Total size for query\n * @prop {Array.<Record>} [records] - Array of records fetched\n */\n\n/**\n * Execute query by using SOQL\n *\n * @param {String} soql - SOQL string\n * @param {Object} [options] - Query options\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<QueryResult>} [callback] - Callback function\n * @returns {Query.<QueryResult>}\n */\nConnection.prototype.query = function(soql, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var query = new Query(this, soql, options);\n  if (callback) {\n    query.run(callback);\n  }\n  return query;\n};\n\n/**\n * Execute query by using SOQL, including deleted records\n *\n * @param {String} soql - SOQL string\n * @param {Object} [options] - Query options\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<QueryResult>} [callback] - Callback function\n * @returns {Query.<QueryResult>}\n */\nConnection.prototype.queryAll = function(soql, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var query = new Query(this, soql, options);\n  query.scanAll(true);\n  if (callback) {\n    query.run(callback);\n  }\n  return query;\n};\n\n/**\n * Query next record set by using query locator\n *\n * @param {String} locator - Next record set locator\n * @param {Object} [options] - Query options\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<QueryResult>} [callback] - Callback function\n * @returns {Query.<QueryResult>}\n */\nConnection.prototype.queryMore = function(locator, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var query = new Query(this, { locator: locator }, options);\n  if (callback) {\n    query.run(callback);\n  }\n  return query;\n};\n\n/** @private */\nConnection.prototype._ensureVersion = function(majorVersion) {\n  var versions = this.version.split('.');\n  return parseInt(versions[0], 10) >= majorVersion;\n}\n\n/** @private */\nConnection.prototype._supports = function(feature) {\n  switch (feature) {\n    case 'sobject-collection':\n      return this._ensureVersion(42);\n    default:\n      return false;\n  }\n}\n\n/**\n * Retrieve specified records\n *\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A record ID or array of record IDs\n * @param {Object} [options] - Options for rest api.\n * @param {Array.<String>} [options.fields] - Fetching field names in retrieving record\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<Record|Array.<Record>>} [callback] - Callback function\n * @returns {Promise.<Record|Array.<Record>>}\n */\nConnection.prototype.retrieve = function(type, ids, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  return (\n    _.isArray(ids) ?\n      (this._supports('sobject-collection') ? // check whether SObject collection API is supported\n        this._retrieveMany(type, ids, options) :\n        this._retrieveParallel(type, ids, options)) :\n      this._retrieveSingle(type, ids, options)\n  ).thenCall(callback);\n};\n\n/** @private */\nConnection.prototype._retrieveSingle = function(type, id, options) {\n  if (!id) {\n    return Promise.reject(new Error('Invalid record ID. Specify valid record ID value'));\n  }\n  var url = [ this._baseUrl(), \"sobjects\", type, id ].join('/');\n  if (options.fields) {\n    url += '?fields=' + options.fields.join(',');\n  }\n  return this.request({\n    method: 'GET',\n    url: url,\n    headers: options.headers,\n  });\n};\n\n/** @private */\nConnection.prototype._retrieveParallel = function(type, ids, options) {\n  if (ids.length > this.maxRequest) {\n    return Promise.reject(new Error(\"Exceeded max limit of concurrent call\"));\n  }\n  var self = this;\n  return Promise.all(\n    ids.map(function(id) {\n      return self._retrieveSingle(type, id, options).catch(function(err) {\n        if (options.allOrNone || err.errorCode !== 'NOT_FOUND') {\n          throw err;\n        }\n        return null;\n      });\n    })\n  );\n};\n\n/** @private */\nConnection.prototype._retrieveMany = function(type, ids, options) {\n  if (ids.length === 0) {\n    return Promise.resolve([]);\n  }\n  var url = [ this._baseUrl(), \"composite\", \"sobjects\", type ].join('/');\n  var self = this;\n  return (\n    options.fields ?\n      Promise.resolve(options.fields) :\n      new Promise(function(resolve, reject) {\n        self.describe$(type, function(err, so) {\n          if (err) {\n            reject(err);\n          } else {\n            var fields = so.fields.map(function(field) {\n              return field.name;\n            });\n            resolve(fields);\n          }\n        });\n      })\n  ).then(function(fields) {\n    return self.request({\n      method : 'POST',\n      url : url,\n      body : JSON.stringify({\n        ids : ids,\n        fields : fields\n      }),\n      headers : _.defaults(options.headers || {}, {\n        \"Content-Type\" : \"application/json\"\n      })\n    });\n  });\n};\n\n\n/**\n * @typedef RecordResult\n * @prop {Boolean} success - The result is succeessful or not\n * @prop {String} [id] - Record ID\n * @prop {Array.<Object>} [errors] - Errors (available when success = false)\n */\n\n/** @private */\nConnection.prototype._toRecordResult = function(id, err) {\n  var error = {\n    statusCode: err.errorCode,\n    message: err.message\n  };\n  if (err.content) { error.content = err.content; } // preserve External id duplication message\n  if (err.fields) { error.fields = err.fields; } // preserve DML exception occurred fields\n  var result = {\n    success: false,\n    errors: [error]\n  };\n  if (id) { result.id = id; }\n  return result;\n};\n\n/**\n * Synonym of Connection#create()\n *\n * @method Connection#insert\n * @param {String} type - SObject Type\n * @param {Object|Array.<Object>} records - A record or array of records to create\n * @param {Object} [options] - Options for rest api.\n * @param {Boolean} [options.allOrNone] - If true, any failed records in a call cause all changes for the call to be rolled back\n * @param {Boolean} [options.allowRecursive] - If true, when records goes over the max num of collection API (=200), records are divided into several chunks and requested recursively.\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Create records\n *\n * @method Connection#create\n * @param {String} type - SObject Type\n * @param {Record|Array.<Record>} records - A record or array of records to create\n * @param {Object} [options] - Options for rest api.\n * @param {Boolean} [options.allOrNone] - If true, any failed records in a call cause all changes for the call to be rolled back\n * @param {Boolean} [options.allowRecursive] - If true, when records goes over the max num of collection API (=200), records are divided into several chunks and requested recursively.\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nConnection.prototype.insert =\nConnection.prototype.create = function(type, records, options, callback) {\n  if (!_.isString(type)) {\n    // reverse order\n    callback = options;\n    options = records;\n    records = type;\n    type = null;\n  }\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  return (\n    _.isArray(records) ?\n      (this._supports('sobject-collection') ? // check whether SObject collection API is supported\n        this._createMany(type, records, options) :\n        this._createParallel(type, records, options)) :\n      this._createSingle(type, records, options)\n  ).thenCall(callback);\n};\n\n/** @private */\nConnection.prototype._createSingle = function(type, record, options) {\n  var sobjectType = type || (record.attributes && record.attributes.type) || record.type;\n  if (!sobjectType) {\n    return Promise.reject(new Error('No SObject Type defined in record'));\n  }\n  record = _.clone(record);\n  delete record.Id;\n  delete record.type;\n  delete record.attributes;\n  var url = [ this._baseUrl(), \"sobjects\", sobjectType ].join('/');\n  return this.request({\n    method : 'POST',\n    url : url,\n    body : JSON.stringify(record),\n    headers : _.defaults(options.headers || {}, {\n      \"Content-Type\" : \"application/json\"\n    })\n  });\n};\n\n/** @private */\nConnection.prototype._createParallel = function(type, records, options) {\n  if (records.length > this.maxRequest) {\n    return Promise.reject(new Error(\"Exceeded max limit of concurrent call\"));\n  }\n  var self = this;\n  return Promise.all(\n    records.map(function(record) {\n      return self._createSingle(type, record, options).catch(function(err) {\n        // be aware that allOrNone in parallel mode will not revert the other successful requests\n        // it only raises error when met at least one failed request.\n        if (options.allOrNone || !err.errorCode) {\n          throw err;\n        }\n        return this._toRecordResult(null, err);\n      });\n    })\n  );\n};\n\n/** @private */\nConnection.prototype._createMany = function(type, records, options) {\n  if (records.length === 0) {\n    return Promise.resolve([]);\n  }\n  if (records.length > MAX_DML_COUNT && options.allowRecursive) {\n    var self = this;\n    return self._createMany(type, records.slice(0, MAX_DML_COUNT), options).then(function(rets1) {\n      return self._createMany(type, records.slice(MAX_DML_COUNT), options).then(function(rets2) {\n        return rets1.concat(rets2);\n      });\n    });\n  }\n  records = _.map(records, function(record) {\n    var sobjectType = type || (record.attributes && record.attributes.type) || record.type;\n    if (!sobjectType) {\n      return Promise.reject(new Error('No SObject Type defined in record'));\n    }\n    record = _.clone(record);\n    delete record.Id;\n    delete record.type;\n    record.attributes = { type : sobjectType };\n    return record;\n  });\n  var url = [ this._baseUrl(), \"composite\", \"sobjects\" ].join('/');\n  return this.request({\n    method : 'POST',\n    url : url,\n    body : JSON.stringify({\n      allOrNone : options.allOrNone || false,\n      records : records\n    }),\n    headers : _.defaults(options.headers || {}, {\n      \"Content-Type\" : \"application/json\"\n    })\n  });\n};\n\n/**\n * Update records\n *\n * @param {String} type - SObject Type\n * @param {Record|Array.<Record>} records - A record or array of records to update\n * @param {Object} [options] - Options for rest api.\n * @param {Boolean} [options.allOrNone] - If true, any failed records in a call cause all changes for the call to be rolled back\n * @param {Boolean} [options.allowRecursive] - If true, when records goes over the max num of collection API (=200), records are divided into several chunks and requested recursively.\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nConnection.prototype.update = function(type, records, options, callback) {\n  if (!_.isString(type)) {\n    // reverse order\n    callback = options;\n    options = records;\n    records = type;\n    type = null;\n  }\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  return (\n    _.isArray(records) ?\n      (this._supports('sobject-collection') ? // check whether SObject collection API is supported\n        this._updateMany(type, records, options) :\n        this._updateParallel(type, records, options)) :\n      this._updateSingle(type, records, options)\n  ).thenCall(callback);\n};\n\n/** @private */\nConnection.prototype._updateSingle = function(type, record, options) {\n  var id = record.Id;\n  if (!id) {\n    return Promise.reject(new Error('Record id is not found in record.'));\n  }\n  var sobjectType = type || (record.attributes && record.attributes.type) || record.type;\n  if (!sobjectType) {\n    return Promise.reject(new Error('No SObject Type defined in record'));\n  }\n  record = _.clone(record);\n  delete record.Id;\n  delete record.type;\n  delete record.attributes;\n  var url = [ this._baseUrl(), \"sobjects\", sobjectType, id ].join('/');\n  return this.request({\n    method : 'PATCH',\n    url : url,\n    body : JSON.stringify(record),\n    headers : _.defaults(options.headers || {}, {\n      \"Content-Type\" : \"application/json\"\n    })\n  }, {\n    noContentResponse: { id : id, success : true, errors : [] }\n  });\n};\n\n/** @private */\nConnection.prototype._updateParallel = function(type, records, options) {\n  if (records.length > this.maxRequest) {\n    return Promise.reject(new Error(\"Exceeded max limit of concurrent call\"));\n  }\n  var self = this;\n  return Promise.all(\n    records.map(function(record) {\n      return self._updateSingle(type, record, options).catch(function(err) {\n        // be aware that allOrNone in parallel mode will not revert the other successful requests\n        // it only raises error when met at least one failed request.\n        if (options.allOrNone || !err.errorCode) {\n          throw err;\n        }\n        return this._toRecordResult(record.Id, err);\n      });\n    })\n  );\n};\n\n/** @private */\nConnection.prototype._updateMany = function(type, records, options) {\n  if (records.length === 0) {\n    return Promise.resolve([]);\n  }\n  if (records.length > MAX_DML_COUNT && options.allowRecursive) {\n    var self = this;\n    return self._updateMany(type, records.slice(0, MAX_DML_COUNT), options).then(function(rets1) {\n      return self._updateMany(type, records.slice(MAX_DML_COUNT), options).then(function(rets2) {\n        return rets1.concat(rets2);\n      });\n    });\n  }\n  records = _.map(records, function(record) {\n    var id = record.Id;\n    if (!id) {\n      throw new Error('Record id is not found in record.');\n    }\n    var sobjectType = type || (record.attributes && record.attributes.type) || record.type;\n    if (!sobjectType) {\n      throw new Error('No SObject Type defined in record');\n    }\n    record = _.clone(record);\n    delete record.Id;\n    record.id = id;\n    delete record.type;\n    record.attributes = { type : sobjectType };\n    return record;\n  });\n  var url = [ this._baseUrl(), \"composite\", \"sobjects\" ].join('/');\n  return this.request({\n    method : 'PATCH',\n    url : url,\n    body : JSON.stringify({\n      allOrNone : options.allOrNone || false,\n      records : records\n    }),\n    headers : _.defaults(options.headers || {}, {\n      \"Content-Type\" : \"application/json\"\n    })\n  });\n};\n\n/**\n * Upsert records\n *\n * @param {String} type - SObject Type\n * @param {Record|Array.<Record>} records - Record or array of records to upsert\n * @param {String} extIdField - External ID field name\n * @param {Object} [options] - Options for rest api.\n * @param {Boolean} [options.allOrNone] - If true, any failed records in a call cause all changes for the call to be rolled back\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nConnection.prototype.upsert = function(type, records, extIdField, options, callback) {\n  // You can omit \"type\" argument, when the record includes type information.\n  if (!_.isString(type)) {\n    // reverse order\n    callback = options;\n    options = extIdField;\n    extIdField = records;\n    records = type;\n    type = null;\n  }\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  var self = this;\n  var isArray = _.isArray(records);\n  records = isArray ? records : [ records ];\n  if (records.length > this.maxRequest) {\n    return Promise.reject(new Error(\"Exceeded max limit of concurrent call\")).thenCall(callback);\n  }\n  return Promise.all(\n    _.map(records, function(record) {\n      var sobjectType = type || (record.attributes && record.attributes.type) || record.type;\n      var extId = record[extIdField];\n      record = _.clone(record);\n      delete record[extIdField];\n      delete record.type;\n      delete record.attributes;\n\n      var url = [ self._baseUrl(), \"sobjects\", sobjectType, extIdField, extId ].join('/');\n      return self.request({\n        method : 'PATCH',\n        url : url,\n        body : JSON.stringify(record),\n        headers : _.defaults(options.headers || {}, {\n          \"Content-Type\" : \"application/json\"\n        })\n      }, {\n        noContentResponse: { success : true, errors : [] }\n      })\n      .catch(function(err) {\n        // be aware that `allOrNone` option in upsert method will not revert the other successful requests\n        // it only raises error when met at least one failed request.\n        if (!isArray || options.allOrNone || !err.errorCode) { throw err; }\n        return self._toRecordResult(null, err);\n      })\n    })\n  ).then(function(results) {\n    return !isArray && _.isArray(results) ? results[0] : results;\n  }).thenCall(callback);\n};\n\n/**\n * Synonym of Connection#destroy()\n *\n * @method Connection#delete\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Object} [options] - Options for rest api.\n * @param {Boolean} [options.allOrNone] - If true, any failed records in a call cause all changes for the call to be rolled back\n * @param {Boolean} [options.allowRecursive] - If true, when ids goes over the max num of collection API (=200), ids are divided into several chunks and requested recursively.\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Synonym of Connection#destroy()\n *\n * @method Connection#del\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Object} [options] - Options for rest api.\n * @param {Boolean} [options.allOrNone] - If true, any failed records in a call cause all changes for the call to be rolled back\n * @param {Boolean} [options.allowRecursive] - If true, when ids goes over the max num of collection API (=200), ids are divided into several chunks and requested recursively.\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Delete records\n *\n * @method Connection#destroy\n * @param {String} type - SObject Type\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Object} [options] - Options for rest api.\n * @param {Boolean} [options.allOrNone] - If true, any failed records in a call cause all changes for the call to be rolled back\n * @param {Boolean} [options.allowRecursive] - If true, when ids goes over the max num of collection API (=200), ids are divided into several chunks and requested recursively.\n * @param {Object} [options.headers] - Additional HTTP request headers sent in retrieve request\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nConnection.prototype[\"delete\"] =\nConnection.prototype.del =\nConnection.prototype.destroy = function(type, ids, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  return (\n    _.isArray(ids) ?\n      (this._supports('sobject-collection') ? // check whether SObject collection API is supported\n        this._destroyMany(type, ids, options) :\n        this._destroyParallel(type, ids, options)) :\n      this._destroySingle(type, ids, options)\n  ).thenCall(callback);\n};\n\n/** @private */\nConnection.prototype._destroySingle = function(type, id, options) {\n  var url = [ this._baseUrl(), \"sobjects\", type, id ].join('/');\n  return this.request({\n    method : 'DELETE',\n    url : url,\n    headers: options.headers || null\n  }, {\n    noContentResponse: { id : id, success : true, errors : [] }\n  });\n};\n\n/** @private */\nConnection.prototype._destroyParallel = function(type, ids, options) {\n  if (ids.length > this.maxRequest) {\n    return Promise.reject(new Error(\"Exceeded max limit of concurrent call\"));\n  }\n  var self = this;\n  return Promise.all(\n    ids.map(function(id) {\n      return self._destroySingle(type, id, options).catch(function(err) {\n        // be aware that `allOrNone` option in parallel mode will not revert the other successful requests\n        // it only raises error when met at least one failed request.\n        if (options.allOrNone || !err.errorCode) {\n          throw err;\n        }\n        return this._toRecordResult(id, err);\n      });\n    })\n  );\n};\n\n\n/** @private */\nConnection.prototype._destroyMany = function(type, ids, options) {\n  if (ids.length === 0) {\n    return Promise.resolve([]);\n  }\n  if (ids.length > MAX_DML_COUNT && options.allowRecursive) {\n    var self = this;\n    return self._destroyMany(type, ids.slice(0, MAX_DML_COUNT), options).then(function(rets1) {\n      return self._destroyMany(type, ids.slice(MAX_DML_COUNT), options).then(function(rets2) {\n        return rets1.concat(rets2);\n      });\n    });\n  }\n  var url = [ this._baseUrl(), \"composite\", \"sobjects?ids=\" ].join('/') + ids.join(',');\n  if (options.allOrNone) {\n    url += '&allOrNone=true';\n  }\n  return this.request({\n    method : 'DELETE',\n    url : url,\n    headers: options.headers || null\n  });\n};\n\n/**\n * Execute search by SOSL\n *\n * @param {String} sosl - SOSL string\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\nConnection.prototype.search = function(sosl, callback) {\n  var url = this._baseUrl() + \"/search?q=\" + encodeURIComponent(sosl);\n  return this.request(url).thenCall(callback);\n};\n\n/**\n * Result returned by describeSObject call\n *\n * @typedef {Object} DescribeSObjectResult\n */\n/**\n * Parameter for describeSObject call\n * \n * @typedef {Object} DescribeSObjectOptions\n */\n/**\n * Synonym of Connection#describe()\n *\n * @method Connection#describeSObject\n * @param {String|DescribeSObjectOptions} type - SObject Type or options object\n * @param {String} type.type - The name of the SObject\n * @param {String} type.ifModifiedSince - Date value for If-Modified-Since header; undefined resolved if not modified after this date\n * @param {Callback.<DescribeSObjectResult>} [callback] - Callback function\n * @returns {Promise.<DescribeSObjectResult>}\n */\n/**\n * Describe SObject metadata\n *\n * @method Connection#describe\n * @param {String|DescribeSObjectOptions} type - SObject Type or options object\n * @param {String} type.type - The name of the SObject\n * @param {String} type.ifModifiedSince - Date value for If-Modified-Since header; undefined resolved if not modified after this date\n * @param {Callback.<DescribeSObjectResult>} [callback] - Callback function\n * @returns {Promise.<DescribeSObjectResult>}\n */\nConnection.prototype.describe =\nConnection.prototype.describeSObject = function(type, callback) {\n  var name = type.type ? type.type : type;\n  var url = [ this._baseUrl(), \"sobjects\", name, \"describe\" ].join('/');\n  var headers = type.ifModifiedSince \n    ? { 'If-Modified-Since': type.ifModifiedSince } \n    : {};\n  return this.request({\n    method: 'GET',\n    url: url,\n    headers: headers\n  }).then(function (resp) {\n    if (resp === '') {\n      return Promise.resolve(undefined);\n    } else {\n      return Promise.resolve(resp);\n    }\n  }).thenCall(callback);\n};\n\n/**\n * Result returned by batchDescribeSObjects call\n *\n * @typedef {Object[]} DescribeSObjectResult\n */\n/**\n * Parameter for describeSObject call\n * \n * @typedef {Object} BatchDescribeSObjectOptions\n */\n/**\n * Synonym of Connection#batchDescribe()\n *\n * @method Connection#batchDescribeSObjects\n * @param {BatchDescribeSObjectOptions} options - options for function\n * @param {String[]} options.types - names of objects to fetch\n * @param {Boolean} options.autofetch - whether to automatically fetch metadata for large numbers of \n *                         types (one batch request returns a maximum of 25 results); when true, will make \n *                         subsequent requests until all object metadata is fetched; when false (default), \n *                         will make one batch request for maximum of 25 results\n * @param {number} options.maxConcurrentRequests - maximum number of concurrent requests sent to the org; \n *                         default and maximum is 15\n * @param {Callback.<DescribeSObjectResult[]>} [callback] - Callback function\n * @returns {Promise.<DescribeSObjectResult[]>}\n */\n/**\n * Batch describe SObject metadata\n *\n * @method Connection#batchDescribe\n * @param {BatchDescribeSObjectOptions} options - options for function\n * @param {String[]} options.types - names of objects to fetch\n * @param {Boolean} options.autofetch - whether to automatically fetch metadata for large numbers of \n *                         types (one batch request returns a maximum of 25 results); when true, will make \n *                         subsequent requests until all object metadata is fetched; when false (default), \n *                         will make one batch request for maximum of 25 results\n * @param {number} options.maxConcurrentRequests - maximum number of concurrent requests sent to the org; \n *                         default and maximum is 15\n * @param {Callback.<DescribeSObjectResult[]>} [callback] - Callback function\n * @returns {Promise.<DescribeSObjectResult[]>}\n */\nConnection.prototype.batchDescribe = Connection.prototype.batchDescribeSObjects = function (\n  options,\n  callback\n) {\n  var self = this;\n  var types = options.types;\n  var autofetch = options.autofetch || false;\n  var maxConcurrentRequests = Math.min((options.maxConcurrentRequests || 15), 15);\n  var batches = [];\n  do {\n    var batch = types.length > MAX_BATCH_REQUESTS ? types.slice(0, MAX_BATCH_REQUESTS) : types;\n    batches.push(batch);\n    types = types.length > MAX_BATCH_REQUESTS ? types.slice(MAX_BATCH_REQUESTS) : [];\n  } while (types.length > 0 && autofetch);\n  var requestBatches = [];\n  do {\n    var requestBatch = batches.length > maxConcurrentRequests ? batches.slice(0, maxConcurrentRequests) : batches;\n    requestBatches.push(requestBatch);\n    batches = batches.length > maxConcurrentRequests ? batches.slice(maxConcurrentRequests) : [];\n  } while (batches.length > 0);\n  return self.doBatchDescribeRequestBatches(requestBatches)\n    .thenCall(callback);\n};\n\nConnection.prototype.doBatchDescribeRequestBatches = function(requestBatches) {\n  // make each batch of requests sequentially to avoid org limits of max concurrent requests\n  var self = this;\n  var sobjects = [];\n  var firstBatch = requestBatches.shift();\n  return self.doBatchOfBatchDescribeRequests(firstBatch).then(\n    function (sobjectArray) {\n      sobjectArray.forEach(function (sobject) { sobjects.push(sobject); });\n      if (requestBatches.length > 0) {\n        return self.doBatchDescribeRequestBatches(requestBatches).then(\n          function (results) {\n            results.forEach(function (result) { sobjects.push(result); });\n            return Promise.resolve(sobjects);\n          }\n        )\n      } else {\n        return Promise.resolve(sobjects);\n      }\n    }\n  )\n}\n\n/** private */\nConnection.prototype.doBatchOfBatchDescribeRequests = function(requestBatch) {\n  // make up to maxConcurrentRequest requests in parallel\n  var self = this;\n  return Promise.all(\n    requestBatch.map(function (batch) { return self.doBatchDescribeRequest(batch); } )\n  ).then(function (results) {\n    var sobjects = [];\n    results.forEach(function (sobjectArray) {\n      sobjectArray.forEach(function (sobject) { sobjects.push(sobject); })\n    });\n    return Promise.resolve(sobjects);\n});\n}\n\n/** private */\nConnection.prototype.doBatchDescribeRequest = function(types) {\n  var self = this;\n  var sobjects = [];\n  var url = [self._baseUrl(), \"composite/batch\"].join(\"/\");\n  var version = \"v\" + self.version;\n  var batchRequests = [];\n  types.forEach(function (type) {\n    batchRequests.push({\n      method: \"GET\",\n      url: [version, \"sobjects\", type, \"describe\"].join(\"/\")\n    });\n  });\n  return this.request({\n    method: \"POST\",\n    url: url,\n    body: JSON.stringify({ batchRequests: batchRequests }),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  }).then(function (response) {\n    if (response.results) {\n      var i = 0;\n      for (var i = 0; i < response.results.length; i++) {\n        var subResp = response.results[i];\n        if (Array.isArray(subResp.result)) {\n          if (subResp.result[0].errorCode && subResp.result[0].message) {\n            this._logger.error(\n              'Error: ' + subResp.result[0].errorCode + ' ' +  \n              subResp.result[0].message + ' - ' + typesToFetch[i]\n            );\n          }\n        } else {\n          sobjects.push(subResp.result);\n        }\n      }\n    }\n    return Promise.resolve(sobjects);\n  }); \n}\n\n/**\n * Result returned by describeGlobal call\n *\n * @typedef {Object} DescribeGlobalResult\n */\n/**\n * Describe global SObjects\n *\n * @param {Callback.<DescribeGlobalResult>} [callback] - Callback function\n * @returns {Promise.<DescribeGlobalResult>}\n */\nConnection.prototype.describeGlobal = function(callback) {\n  var url = this._baseUrl() + \"/sobjects\";\n  return this.request(url).thenCall(callback);\n};\n\n\n/**\n * Get SObject instance\n *\n * @param {String} type - SObject Type\n * @returns {SObject}\n */\nConnection.prototype.sobject = function(type) {\n  this.sobjects = this.sobjects || {};\n  var sobject = this.sobjects[type] =\n    this.sobjects[type] || new SObject(this, type);\n  return sobject;\n};\n\n/**\n * Get identity information of current user\n *\n * @param {Object} [options] - Identity call options\n * @param {Object} [options.headers] - Additional HTTP request headers sent in identity request\n * @param {Callback.<IdentityInfo>} [callback] - Callback function\n * @returns {Promise.<IdentityInfo>}\n */\nConnection.prototype.identity = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  var self = this;\n  var idUrl = this.userInfo && this.userInfo.url;\n  return Promise.resolve(\n    idUrl ?\n    { identity: idUrl } :\n    this.request({ method: 'GET', url: this._baseUrl(), headers: options.headers })\n  ).then(function(res) {\n    var url = res.identity;\n    return self.request({ method: 'GET', url: url });\n  }).then(function(res) {\n    self.userInfo = {\n      id: res.user_id,\n      organizationId: res.organization_id,\n      url: res.id\n    };\n    return res;\n  }).thenCall(callback);\n};\n\n/**\n * @typedef UserInfo\n * @prop {String} id - User ID\n * @prop {String} organizationId - Organization ID\n * @prop {String} url - Identity URL of the user\n */\n\n/**\n * Authorize (using oauth2 web server flow)\n *\n * @param {String} code - Authorization code\n * @param {Object} [params] - Optional parameters to send in token retrieval\n * @param {String} [params.code_verifier] - Code verifier value (RFC 7636 - Proof Key of Code Exchange)\n * @param {Callback.<UserInfo>} [callback] - Callback function\n * @returns {Promise.<UserInfo>}\n */\nConnection.prototype.authorize = function(code, params, callback) {\n  if (typeof params === 'function') {\n    callback = params;\n    params = {};\n  }\n  var self = this;\n  var logger = this._logger;\n\n  return this.oauth2.requestToken(code, params).then(function(res) {\n    var userInfo = parseIdUrl(res.id);\n    self.initialize({\n      instanceUrl : res.instance_url,\n      accessToken : res.access_token,\n      refreshToken : res.refresh_token,\n      userInfo: userInfo\n    });\n    logger.debug(\"<login> completed. user id = \" + userInfo.id + \", org id = \" + userInfo.organizationId);\n    return userInfo;\n\n  }).thenCall(callback);\n\n};\n\n\n/**\n * Login to Salesforce\n *\n * @param {String} username - Salesforce username\n * @param {String} password - Salesforce password (and security token, if required)\n * @param {Callback.<UserInfo>} [callback] - Callback function\n * @returns {Promise.<UserInfo>}\n */\nConnection.prototype.login = function(username, password, callback) {\n  // register refreshDelegate for session expiration\n  this._refreshDelegate = new HttpApi.SessionRefreshDelegate(this, createUsernamePasswordRefreshFn(username, password));\n  if (this.oauth2 && this.oauth2.clientId && this.oauth2.clientSecret) {\n    return this.loginByOAuth2(username, password, callback);\n  } else {\n    return this.loginBySoap(username, password, callback);\n  }\n};\n\n/** @private **/\nfunction createUsernamePasswordRefreshFn(username, password) {\n  return function(conn, callback) {\n    conn.login(username, password, function(err) {\n      if (err) { return callback(err); }\n      callback(null, conn.accessToken);\n    });\n  };\n}\n\n/**\n * Login by OAuth2 username & password flow\n *\n * @param {String} username - Salesforce username\n * @param {String} password - Salesforce password (and security token, if required)\n * @param {Callback.<UserInfo>} [callback] - Callback function\n * @returns {Promise.<UserInfo>}\n */\nConnection.prototype.loginByOAuth2 = function(username, password, callback) {\n  var self = this;\n  var logger = this._logger;\n  return this.oauth2.authenticate(username, password).then(function(res) {\n    var userInfo = parseIdUrl(res.id);\n    self.initialize({\n      instanceUrl : res.instance_url,\n      accessToken : res.access_token,\n      userInfo: userInfo\n    });\n    logger.debug(\"<login> completed. user id = \" + userInfo.id + \", org id = \" + userInfo.organizationId);\n    return userInfo;\n\n  }).thenCall(callback);\n\n};\n\n/**\n * @private\n */\nfunction esc(str) {\n  return str && String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;')\n                           .replace(/>/g, '&gt;').replace(/\"/g, '&quot;');\n}\n\n/**\n * Login by SOAP web service API\n *\n * @param {String} username - Salesforce username\n * @param {String} password - Salesforce password (and security token, if required)\n * @param {Callback.<UserInfo>} [callback] - Callback function\n * @returns {Promise.<UserInfo>}\n */\nConnection.prototype.loginBySoap = function(username, password, callback) {\n  var self = this;\n  var logger = this._logger;\n  var body = [\n    '<se:Envelope xmlns:se=\"http://schemas.xmlsoap.org/soap/envelope/\">',\n      '<se:Header/>',\n      '<se:Body>',\n        '<login xmlns=\"urn:partner.soap.sforce.com\">',\n          '<username>' + esc(username) + '</username>',\n          '<password>' + esc(password) + '</password>',\n        '</login>',\n      '</se:Body>',\n    '</se:Envelope>'\n  ].join('');\n\n  var soapLoginEndpoint = [ this.loginUrl, \"services/Soap/u\", this.version ].join('/');\n\n  return this._transport.httpRequest({\n    method : 'POST',\n    url : soapLoginEndpoint,\n    body : body,\n    headers : {\n      \"Content-Type\" : \"text/xml\",\n      \"SOAPAction\" : '\"\"'\n    }\n  }).then(function(response) {\n    var m;\n    if (response.statusCode >= 400) {\n      m = response.body.match(/<faultstring>([^<]+)<\\/faultstring>/);\n      var faultstring = m && m[1];\n      throw new Error(faultstring || response.body);\n    }\n    logger.debug(\"SOAP response = \" + response.body);\n    m = response.body.match(/<serverUrl>([^<]+)<\\/serverUrl>/);\n    var serverUrl = m && m[1];\n    m = response.body.match(/<sessionId>([^<]+)<\\/sessionId>/);\n    var sessionId = m && m[1];\n    m = response.body.match(/<userId>([^<]+)<\\/userId>/);\n    var userId = m && m[1];\n    m = response.body.match(/<organizationId>([^<]+)<\\/organizationId>/);\n    var orgId = m && m[1];\n    var idUrl = soapLoginEndpoint.split('/').slice(0, 3).join('/');\n    idUrl += \"/id/\" + orgId + \"/\" + userId;\n    var userInfo = {\n      id: userId,\n      organizationId: orgId,\n      url: idUrl\n    };\n    self.initialize({\n      serverUrl: serverUrl.split('/').slice(0, 3).join('/'),\n      sessionId: sessionId,\n      userInfo: userInfo\n    });\n    logger.debug(\"<login> completed. user id = \" + userId + \", org id = \" + orgId);\n    return userInfo;\n\n  }).thenCall(callback);\n\n};\n\n/**\n * Logout the current session \n *\n * @param {Boolean} [revoke] - Revokes API Access if set to true\n * @param {Callback.<undefined>} [callback] - Callback function\n * @returns {Promise.<undefined>}\n */\nConnection.prototype.logout = function(revoke, callback) {\n  if (typeof revoke === 'function') {\n    callback = revoke;\n    revoke = false;\n  }\n\n  if (this._sessionType === \"oauth2\") {\n    return this.logoutByOAuth2(revoke, callback);\n  } else {\n    return this.logoutBySoap(revoke, callback);\n  }\n};\n\n/**\n * Logout the current session by revoking access token via OAuth2 session revoke\n *\n * @param {Boolean} [revoke] - Revokes API Access if set to true\n * @param {Callback.<undefined>} [callback] - Callback function\n * @returns {Promise.<undefined>}\n */\nConnection.prototype.logoutByOAuth2 = function(revoke, callback) {\n  if (typeof revoke === 'function') {\n    callback = revoke;\n    revoke = false;\n  }\n  var self = this;\n  var logger = this._logger;\n\n  return this.oauth2.revokeToken(revoke ? this.refreshToken : this.accessToken).then(function() {\n    // Destroy the session bound to this connection\n    self.accessToken = null;\n    self.userInfo = null;\n    self.refreshToken = null;\n    self.instanceUrl = null;\n    self.cache.clear();\n\n    // nothing useful returned by logout API, just return\n    return undefined;\n  }).thenCall(callback);\n};\n\n\n/**\n * Logout the session by using SOAP web service API\n *\n * @param {Boolean} [revoke] - Revokes API Access if set to true\n * @param {Callback.<undefined>} [callback] - Callback function\n * @returns {Promise.<undefined>}\n */\nConnection.prototype.logoutBySoap = function(revoke, callback) {\n  if (typeof revoke === 'function') {\n    callback = revoke;\n    revoke = false;\n  }\n  var self = this;\n  var logger = this._logger;\n\n  var body = [\n    '<se:Envelope xmlns:se=\"http://schemas.xmlsoap.org/soap/envelope/\">',\n      '<se:Header>',\n        '<SessionHeader xmlns=\"urn:partner.soap.sforce.com\">',\n          '<sessionId>' + esc(revoke ? this.refreshToken : this.accessToken) + '</sessionId>',\n        '</SessionHeader>',\n      '</se:Header>',\n      '<se:Body>',\n        '<logout xmlns=\"urn:partner.soap.sforce.com\"/>',\n      '</se:Body>',\n    '</se:Envelope>'\n  ].join('');\n\n  return this._transport.httpRequest({\n    method : 'POST',\n    url : [ this.instanceUrl, \"services/Soap/u\", this.version ].join('/'),\n    body : body,\n    headers : {\n      \"Content-Type\" : \"text/xml\",\n      \"SOAPAction\" : '\"\"'\n    }\n  }).then(function(response) {\n    logger.debug(\"SOAP statusCode = \" + response.statusCode + \", response = \" + response.body);\n    if (response.statusCode >= 400) {\n      var m = response.body.match(/<faultstring>([^<]+)<\\/faultstring>/);\n      var faultstring = m && m[1];\n      throw new Error(faultstring || response.body);\n    }\n\n    // Destroy the session bound to this connection\n    self.accessToken = null;\n    self.userInfo = null;\n    self.refreshToken = null;\n    self.instanceUrl = null;\n    self.cache.clear();\n\n    // nothing useful returned by logout API, just return\n    return undefined;\n\n  }).thenCall(callback);\n};\n\n/**\n * List recently viewed records\n *\n * @param {String} [type] - SObject type\n * @param {Number} [limit] - Limit num to fetch\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\nConnection.prototype.recent = function(type, limit, callback) {\n  if (!_.isString(type)) {\n    callback = limit;\n    limit = type;\n    type = undefined;\n  }\n  if (!_.isNumber(limit)) {\n    callback = limit;\n    limit = undefined;\n  }\n  var url;\n  if (type) {\n    url = [ this._baseUrl(), \"sobjects\", type ].join('/');\n    return this.request(url).then(function(res) {\n      return limit ? res.recentItems.slice(0, limit) : res.recentItems;\n    }).thenCall(callback);\n  } else {\n    url = this._baseUrl() + \"/recent\";\n    if (limit) {\n      url += \"?limit=\" + limit;\n    }\n    return this.request(url).thenCall(callback);\n  }\n\n};\n\n/**\n * @typedef {Object} UpdatedRecordsInfo\n * @prop {String} latestDateCovered - The timestamp of the last date covered.\n * @prop {Array.<String>} ids - Updated record IDs.\n */\n\n/**\n * Retrieve updated records\n *\n * @param {String} type - SObject Type\n * @param {String|Date} start - start date or string representing the start of the interval\n * @param {String|Date} end - start date or string representing the end of the interval must be > start\n * @param {Callback.<UpdatedRecordsInfo>} [callback] - Callback function\n * @returns {Promise.<UpdatedRecordsInfo>}\n */\nConnection.prototype.updated = function (type, start, end, callback) {\n  var url = [ this._baseUrl(), \"sobjects\", type, \"updated\" ].join('/');\n\n  if (typeof start === 'string') {\n    start = new Date(start);\n  }\n\n  if (start instanceof Date) {\n    start = formatDate(start);\n  }\n\n  if (start) {\n    url += \"?start=\" + encodeURIComponent(start);\n  }\n\n  if (typeof end === 'string') {\n    end = new Date(end);\n  }\n\n  if (end instanceof Date) {\n    end = formatDate(end);\n  }\n\n  if (end) {\n    url += \"&end=\" + encodeURIComponent(end);\n  }\n\n  return this.request(url).thenCall(callback);\n};\n\n/**\n * @typedef {Object} DeletedRecordsInfo\n * @prop {String} earliestDateAvailable - The timestamp of the earliest date available\n * @prop {String} latestDateCovered - The timestamp of the last date covered\n * @prop {Array.<Object>} deletedRecords - Updated records\n * @prop {String} deletedRecords.id - Record ID\n * @prop {String} deletedRecords.deletedDate - The timestamp when this record was deleted\n */\n\n/**\n * Retrieve deleted records\n *\n * @param {String} type - SObject Type\n * @param {String|Date} start - start date or string representing the start of the interval\n * @param {String|Date} end - start date or string representing the end of the interval\n * @param {Callback.<DeletedRecordsInfo>} [callback] - Callback function\n * @returns {Promise.<DeletedRecordsInfo>}\n */\nConnection.prototype.deleted = function (type, start, end, callback) {\n  var url = [ this._baseUrl(), \"sobjects\", type, \"deleted\" ].join('/');\n\n  if (typeof start === 'string') {\n    start = new Date(start);\n  }\n\n  if (start instanceof Date) {\n    start = formatDate(start);\n  }\n\n  if (start) {\n    url += \"?start=\" + encodeURIComponent(start);\n  }\n\n  if (typeof end === 'string') {\n    end = new Date(end);\n  }\n\n  if (end instanceof Date) {\n    end = formatDate(end);\n  }\n\n  if (end) {\n    url += \"&end=\" + encodeURIComponent(end);\n  }\n\n  return this.request(url).thenCall(callback);\n};\n\n\n/**\n * @typedef {Object} TabsInfo - See the API document for detail structure\n */\n\n/**\n * Returns a list of all tabs\n *\n * @param {Callback.<TabsInfo>} [callback] - Callback function\n * @returns {Promise.<TabsInfo>}\n */\nConnection.prototype.tabs = function(callback) {\n  var url = [ this._baseUrl(), \"tabs\" ].join('/');\n  return this.request(url).thenCall(callback);\n};\n\n\n/**\n * @typedef {Object} LimitsInfo - See the API document for detail structure\n */\n\n/**\n * Returns curren system limit in the organization\n *\n * @param {Callback.<LimitsInfo>} [callback] - Callback function\n * @returns {Promise.<LimitsInfo>}\n */\nConnection.prototype.limits = function(callback) {\n  var url = [ this._baseUrl(), \"limits\" ].join('/');\n  return this.request(url).thenCall(callback);\n};\n\n\n/**\n * @typedef {Object} ThemeInfo - See the API document for detail structure\n */\n\n/**\n * Returns a theme info\n *\n * @param {Callback.<ThemeInfo>} [callback] - Callback function\n * @returns {Promise.<ThemeInfo>}\n */\nConnection.prototype.theme = function(callback) {\n  var url = [ this._baseUrl(), \"theme\" ].join('/');\n  return this.request(url).thenCall(callback);\n};\n\n/**\n * Returns all registered global quick actions\n *\n * @param {Callback.<Array.<QuickAction~QuickActionInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<QuickAction~QuickActionInfo>>}\n */\nConnection.prototype.quickActions = function(callback) {\n  return this.request(\"/quickActions\").thenCall(callback);\n};\n\n/**\n * Get reference for specified global quick aciton\n *\n * @param {String} actionName - Name of the global quick action\n * @returns {QuickAction}\n */\nConnection.prototype.quickAction = function(actionName) {\n  return new QuickAction(this, \"/quickActions/\" + actionName);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvY29ubmVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxzQkFBUTtBQUM5QixlQUFlLG1CQUFPLENBQUMsMkRBQVU7QUFDakMsY0FBYyxtQkFBTyxDQUFDLHdEQUFhO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyw4REFBVztBQUNqQyxjQUFjLG1CQUFPLENBQUMsNERBQVU7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLDREQUFVO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQywwREFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsOERBQVc7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsd0VBQWdCO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyxnRUFBWTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBYTtBQUNyQyxjQUFjLG1CQUFPLENBQUMsOERBQVc7QUFDakMsY0FBYyxtQkFBTyxDQUFDLDBEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHdEQUFRO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBOztBQUVBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0NBQWdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBLE1BQU0sT0FBTztBQUNiLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsT0FBTztBQUNsQixXQUFXLEdBQUc7QUFDZDtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsU0FBUztBQUNuQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsZ0JBQWdCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsd0JBQXdCO0FBQ25DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyx3QkFBd0I7QUFDbkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsd0JBQXdCO0FBQ25DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxrQ0FBa0M7QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0RBQWdEO0FBQ2hEO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsZ0JBQWdCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQsb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLDhDQUE4QztBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyw4Q0FBOEM7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw4Q0FBOEM7QUFDOUM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyw4Q0FBOEM7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCx5QkFBeUI7QUFDekIsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw4Q0FBOEM7QUFDOUM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyw4Q0FBOEM7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCw2QkFBNkI7QUFDN0IsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyw4Q0FBOEM7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLDhDQUE4QztBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUI7QUFDekIsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRLGdFQUFnRTtBQUNuRixXQUFXLGtDQUFrQztBQUM3QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVEsZ0VBQWdFO0FBQ25GLFdBQVcsa0NBQWtDO0FBQzdDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QyxXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCLHNGQUFzRjtBQUN0RixxRkFBcUY7QUFDckY7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLG9DQUFvQztBQUMvQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsVUFBVTtBQUNyQixXQUFXLFNBQVM7QUFDcEIsc0ZBQXNGO0FBQ3RGLHFGQUFxRjtBQUNyRjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsb0NBQW9DO0FBQy9DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlCQUF5QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsd0JBQXdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkNBQTZDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUI7QUFDekUsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcseUJBQXlCO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrQkFBa0I7QUFDeEIsbUJBQW1CLCtEQUErRDtBQUNsRjtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEdBQUc7O0FBRUg7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsc0JBQXNCO0FBQ3RFLCtDQUErQyx3QkFBd0I7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsc0JBQXNCO0FBQ2pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsc0JBQXNCO0FBQ2pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLHNCQUFzQjtBQUNqQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsZ0JBQWdCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsK0JBQStCO0FBQzFDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsV0FBVywrQkFBK0I7QUFDMUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQWdEO0FBQzNELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9jb25uZWN0aW9uLmpzPzU1ODciXSwic291cmNlc0NvbnRlbnQiOlsiLypnbG9iYWwgQnVmZmVyICovXG4vKipcbiAqIEBmaWxlIENvbm5lY3Rpb24gY2xhc3MgdG8ga2VlcCB0aGUgQVBJIHNlc3Npb24gaW5mb3JtYXRpb24gYW5kIG1hbmFnZSByZXF1ZXN0c1xuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRzICA9IHJlcXVpcmUoJ2V2ZW50cycpLFxuICAgIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKSxcbiAgICBfICAgICAgID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9wcm9taXNlJyksXG4gICAgTG9nZ2VyICA9IHJlcXVpcmUoJy4vbG9nZ2VyJyksXG4gICAgT0F1dGgyICA9IHJlcXVpcmUoJy4vb2F1dGgyJyksXG4gICAgUXVlcnkgICA9IHJlcXVpcmUoJy4vcXVlcnknKSxcbiAgICBTT2JqZWN0ID0gcmVxdWlyZSgnLi9zb2JqZWN0JyksXG4gICAgUXVpY2tBY3Rpb24gPSByZXF1aXJlKCcuL3F1aWNrLWFjdGlvbicpLFxuICAgIEh0dHBBcGkgPSByZXF1aXJlKCcuL2h0dHAtYXBpJyksXG4gICAgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKSxcbiAgICBQcm9jZXNzID0gcmVxdWlyZSgnLi9wcm9jZXNzJyksXG4gICAgQ2FjaGUgICA9IHJlcXVpcmUoJy4vY2FjaGUnKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBsb2dpblVybDogXCJodHRwczovL2xvZ2luLnNhbGVzZm9yY2UuY29tXCIsXG4gIGluc3RhbmNlVXJsOiBcIlwiLFxuICB2ZXJzaW9uOiBcIjQyLjBcIlxufTtcblxuLypcbiAqIENvbnN0YW50IG9mIG1heGltdW0gcmVjb3JkcyBudW0gaW4gRE1MIG9wZXJhdGlvbiAodXBkYXRlL2RlbGV0ZSlcbiAqL1xudmFyIE1BWF9ETUxfQ09VTlQgPSAyMDA7XG5cbi8qXG4gKiBDb25zdGFudCBvZiBtYXhpbXVtIG51bWJlciBvZiByZXF1ZXN0cyB0aGF0IGNhbiBiZSBiYXRjaGVkXG4gKi9cbnZhciBNQVhfQkFUQ0hfUkVRVUVTVFMgPSAyNTtcblxuLyoqXG4gKiBDb25uZWN0aW9uIGNsYXNzIHRvIGtlZXAgdGhlIEFQSSBzZXNzaW9uIGluZm9ybWF0aW9uIGFuZCBtYW5hZ2UgcmVxdWVzdHNcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7T0F1dGgyfE9iamVjdH0gW29wdGlvbnMub2F1dGgyXSAtIE9BdXRoMiBpbnN0YW5jZSBvciBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byBPQXV0aDIgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5sb2dMZXZlbF0gLSBPdXRwdXQgbG9nZ2luZyBsZXZlbCAoREVCVUd8SU5GT3xXQVJOfEVSUk9SfEZBVEFMKVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnZlcnNpb25dIC0gU2FsZXNmb3JjZSBBUEkgVmVyc2lvbiAod2l0aG91dCBcInZcIiBwcmVmaXgpXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UmVxdWVzdF0gLSBNYXggbnVtYmVyIG9mIHJlcXVlc3RzIGFsbG93ZWQgaW4gcGFyYWxsZWwgY2FsbFxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmxvZ2luVXJsXSAtIFNhbGVzZm9yY2UgTG9naW4gU2VydmVyIFVSTCAoZS5nLiBodHRwczovL2xvZ2luLnNhbGVzZm9yY2UuY29tLylcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pbnN0YW5jZVVybF0gLSBTYWxlc2ZvcmNlIEluc3RhbmNlIFVSTCAoZS5nLiBodHRwczovL25hMS5zYWxlc2ZvcmNlLmNvbS8pXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc2VydmVyVXJsXSAtIFNhbGVzZm9yY2UgU09BUCBzZXJ2aWNlIGVuZHBvaW50IFVSTCAoZS5nLiBodHRwczovL25hMS5zYWxlc2ZvcmNlLmNvbS9zZXJ2aWNlcy9Tb2FwL3UvMjguMClcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hY2Nlc3NUb2tlbl0gLSBTYWxlc2ZvcmNlIE9BdXRoMiBhY2Nlc3MgdG9rZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zZXNzaW9uSWRdIC0gU2FsZXNmb3JjZSBzZXNzaW9uIElEXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVmcmVzaFRva2VuXSAtIFNhbGVzZm9yY2UgT0F1dGgyIHJlZnJlc2ggdG9rZW5cbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gW29wdGlvbnMuc2lnbmVkUmVxdWVzdF0gLSBTYWxlc2ZvcmNlIENhbnZhcyBzaWduZWQgcmVxdWVzdCAoUmF3IEJhc2U2NCBzdHJpbmcsIEpTT04gc3RyaW5nLCBvciBkZXNlcmlhbGl6ZWQgSlNPTilcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm94eVVybF0gLSBDcm9zcy1kb21haW4gcHJveHkgc2VydmVyIFVSTCwgdXNlZCBpbiBicm93c2VyIGNsaWVudCwgbm9uIFZpc3VhbGZvcmNlIGFwcC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5odHRwUHJveHldIC0gVVJMIG9mIEhUVFAgcHJveHkgc2VydmVyLCB1c2VkIGluIHNlcnZlciBjbGllbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY2FsbE9wdGlvbnNdIC0gQ2FsbCBvcHRpb25zIHVzZWQgaW4gZWFjaCBTT0FQL1JFU1QgQVBJIHJlcXVlc3QuIFNlZSBtYW51YWwuXG4gKi9cbnZhciBDb25uZWN0aW9uID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIob3B0aW9ucy5sb2dMZXZlbCk7XG5cbiAgdmFyIG9hdXRoMiA9IG9wdGlvbnMub2F1dGgyIHx8IHtcbiAgICBsb2dpblVybCA6IG9wdGlvbnMubG9naW5VcmwsXG4gICAgY2xpZW50SWQgOiBvcHRpb25zLmNsaWVudElkLFxuICAgIGNsaWVudFNlY3JldCA6IG9wdGlvbnMuY2xpZW50U2VjcmV0LFxuICAgIHJlZGlyZWN0VXJpIDogb3B0aW9ucy5yZWRpcmVjdFVyaSxcbiAgICBwcm94eVVybDogb3B0aW9ucy5wcm94eVVybCxcbiAgICBodHRwUHJveHk6IG9wdGlvbnMuaHR0cFByb3h5XG4gIH07XG5cbiAgLyoqXG4gICAqIE9BdXRoMiBvYmplY3RcbiAgICogQG1lbWJlciB7T0F1dGgyfSBDb25uZWN0aW9uI29hdXRoMlxuICAgKi9cbiAgdGhpcy5vYXV0aDIgPSBvYXV0aDIgPSBvYXV0aDIgaW5zdGFuY2VvZiBPQXV0aDIgPyBvYXV0aDIgOiBuZXcgT0F1dGgyKG9hdXRoMik7XG5cbiAgdGhpcy5sb2dpblVybCA9IG9wdGlvbnMubG9naW5VcmwgfHwgb2F1dGgyLmxvZ2luVXJsIHx8IGRlZmF1bHRzLmxvZ2luVXJsO1xuICB0aGlzLnZlcnNpb24gPSBvcHRpb25zLnZlcnNpb24gfHwgZGVmYXVsdHMudmVyc2lvbjtcbiAgdGhpcy5tYXhSZXF1ZXN0ID0gb3B0aW9ucy5tYXhSZXF1ZXN0IHx8IHRoaXMubWF4UmVxdWVzdCB8fCAxMDtcblxuICAvKiogQHByaXZhdGUgKi9cbiAgaWYgKG9wdGlvbnMucHJveHlVcmwpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0LlByb3h5VHJhbnNwb3J0KG9wdGlvbnMucHJveHlVcmwpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuaHR0cFByb3h5KSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydC5IdHRwUHJveHlUcmFuc3BvcnQob3B0aW9ucy5odHRwUHJveHkpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG5ldyBUcmFuc3BvcnQoKTtcbiAgfVxuXG4gIHRoaXMuY2FsbE9wdGlvbnMgPSBvcHRpb25zLmNhbGxPcHRpb25zO1xuXG4gIC8qXG4gICAqIEZpcmUgY29ubmVjdGlvbjpuZXcgZXZlbnQgdG8gbm90aWZ5IGpzZm9yY2UgcGx1Z2luIG1vZHVsZXNcbiAgICovXG4gIHZhciBqc2ZvcmNlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG4gIGpzZm9yY2UuZW1pdCgnY29ubmVjdGlvbjpuZXcnLCB0aGlzKTtcblxuICAvKipcbiAgICogU3RyZWFtaW5nIEFQSSBvYmplY3RcbiAgICogQG1lbWJlciB7U3RyZWFtaW5nfSBDb25uZWN0aW9uI3N0cmVhbWluZ1xuICAgKi9cbiAgLy8gdGhpcy5zdHJlYW1pbmcgPSBuZXcgU3RyZWFtaW5nKHRoaXMpO1xuICAvKipcbiAgICogQnVsayBBUEkgb2JqZWN0XG4gICAqIEBtZW1iZXIge0J1bGt9IENvbm5lY3Rpb24jYnVsa1xuICAgKi9cbiAgLy8gdGhpcy5idWxrID0gbmV3IEJ1bGsodGhpcyk7XG4gIC8qKlxuICAgKiBUb29saW5nIEFQSSBvYmplY3RcbiAgICogQG1lbWJlciB7VG9vbGluZ30gQ29ubmVjdGlvbiN0b29saW5nXG4gICAqL1xuICAvLyB0aGlzLnRvb2xpbmcgPSBuZXcgVG9vbGluZyh0aGlzKTtcbiAgLyoqXG4gICAqIEFuYWx5dGljcyBBUEkgb2JqZWN0XG4gICAqIEBtZW1iZXIge0FuYWx5dGljc30gQ29ubmVjdGlvbiNhbmFseXRpY3NcbiAgICovXG4gIC8vIHRoaXMuYW5hbHl0aWNzID0gbmV3IEFuYWx5dGljcyh0aGlzKTtcbiAgLyoqXG4gICAqIENoYXR0ZXIgQVBJIG9iamVjdFxuICAgKiBAbWVtYmVyIHtDaGF0dGVyfSBDb25uZWN0aW9uI2NoYXR0ZXJcbiAgICovXG4gIC8vIHRoaXMuY2hhdHRlciA9IG5ldyBDaGF0dGVyKHRoaXMpO1xuICAvKipcbiAgICogTWV0YWRhdGEgQVBJIG9iamVjdFxuICAgKiBAbWVtYmVyIHtNZXRhZGF0YX0gQ29ubmVjdGlvbiNtZXRhZGF0YVxuICAgKi9cbiAgLy8gdGhpcy5tZXRhZGF0YSA9IG5ldyBNZXRhZGF0YSh0aGlzKTtcblxuICAvKipcbiAgICogU09BUCBBUEkgb2JqZWN0XG4gICAqIEBtZW1iZXIge1NvYXBBcGl9IENvbm5lY3Rpb24jc29hcFxuICAgKi9cbiAgLy8gdGhpcy5zb2FwID0gbmV3IFNvYXBBcGkodGhpcyk7XG5cbiAgLyoqXG4gICAqIEFwZXggUkVTVCBBUEkgb2JqZWN0XG4gICAqIEBtZW1iZXIge0FwZXh9IENvbm5lY3Rpb24jYXBleFxuICAgKi9cbiAgLy8gdGhpcy5hcGV4ID0gbmV3IEFwZXgodGhpcyk7XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge1Byb2Nlc3N9IENvbm5lY3Rpb24jcHJvY2Vzc1xuICAgKi9cbiAgdGhpcy5wcm9jZXNzID0gbmV3IFByb2Nlc3ModGhpcyk7XG5cbiAgLyoqXG4gICAqIENhY2hlIG9iamVjdCBmb3IgcmVzdWx0XG4gICAqIEBtZW1iZXIge0NhY2hlfSBDb25uZWN0aW9uI2NhY2hlXG4gICAqL1xuICB0aGlzLmNhY2hlID0gbmV3IENhY2hlKCk7XG5cbiAgLy8gQWxsb3cgdG8gZGVsZWdhdGUgY29ubmVjdGlvbiByZWZyZXNoIHRvIG91dGVyIGZ1bmN0aW9uXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJlZnJlc2hGbiA9IG9wdGlvbnMucmVmcmVzaEZuO1xuICBpZiAoIXJlZnJlc2hGbiAmJiB0aGlzLm9hdXRoMi5jbGllbnRJZCkge1xuICAgIHJlZnJlc2hGbiA9IG9hdXRoUmVmcmVzaEZuO1xuICB9XG4gIGlmIChyZWZyZXNoRm4pIHtcbiAgICB0aGlzLl9yZWZyZXNoRGVsZWdhdGUgPSBuZXcgSHR0cEFwaS5TZXNzaW9uUmVmcmVzaERlbGVnYXRlKHRoaXMsIHJlZnJlc2hGbik7XG4gIH1cblxuICB2YXIgY2FjaGVPcHRpb25zID0ge1xuICAgIGtleTogZnVuY3Rpb24odHlwZSkgeyBcbiAgICAgIHJldHVybiB0eXBlIFxuICAgICAgICA/IHR5cGUudHlwZSA/IFwiZGVzY3JpYmUuXCIgKyB0eXBlLnR5cGUgOiBcImRlc2NyaWJlLlwiICsgdHlwZVxuICAgICAgICA6IFwiZGVzY3JpYmVcIjsgXG4gICAgfVxuICB9O1xuICB0aGlzLmRlc2NyaWJlJCA9IHRoaXMuY2FjaGUubWFrZUNhY2hlYWJsZSh0aGlzLmRlc2NyaWJlLCB0aGlzLCBjYWNoZU9wdGlvbnMpO1xuICB0aGlzLmRlc2NyaWJlID0gdGhpcy5jYWNoZS5tYWtlUmVzcG9uc2VDYWNoZWFibGUodGhpcy5kZXNjcmliZSwgdGhpcywgY2FjaGVPcHRpb25zKTtcbiAgdGhpcy5kZXNjcmliZVNPYmplY3QkID0gdGhpcy5kZXNjcmliZSQ7XG4gIHRoaXMuZGVzY3JpYmVTT2JqZWN0ID0gdGhpcy5kZXNjcmliZTtcblxuICB2YXIgYmF0Y2hDYWNoZU9wdGlvbnMgPSB7XG4gICAga2V5OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgdHlwZXMgPSBvcHRpb25zLnR5cGVzO1xuICAgICAgdmFyIGF1dG9mZXRjaCA9IG9wdGlvbnMuYXV0b2ZldGNoIHx8IGZhbHNlO1xuICAgICAgdmFyIHR5cGVzVG9GZXRjaCA9IHR5cGVzLmxlbmd0aCA+IE1BWF9CQVRDSF9SRVFVRVNUUyBcbiAgICAgICAgPyAoYXV0b2ZldGNoID8gdHlwZXMgOiB0eXBlcy5zbGljZSgwLCBNQVhfQkFUQ0hfUkVRVUVTVFMpKVxuICAgICAgICA6IHR5cGVzO1xuICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgIHR5cGVzVG9GZXRjaC5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7IGtleXMucHVzaCgnZGVzY3JpYmUuJyArIHR5cGUpOyB9KTtcbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5iYXRjaERlc2NyaWJlID0gdGhpcy5jYWNoZS5tYWtlUmVzcG9uc2VDYWNoZWFibGUodGhpcy5iYXRjaERlc2NyaWJlLCB0aGlzLCBiYXRjaENhY2hlT3B0aW9ucyk7XG4gIHRoaXMuYmF0Y2hEZXNjcmliZVNPYmplY3RzID0gdGhpcy5iYXRjaERlc2NyaWJlO1xuXG4gIGNhY2hlT3B0aW9ucyA9IHsga2V5OiAnZGVzY3JpYmVHbG9iYWwnIH07XG4gIHRoaXMuZGVzY3JpYmVHbG9iYWwkID0gdGhpcy5jYWNoZS5tYWtlQ2FjaGVhYmxlKHRoaXMuZGVzY3JpYmVHbG9iYWwsIHRoaXMsIGNhY2hlT3B0aW9ucyk7XG4gIHRoaXMuZGVzY3JpYmVHbG9iYWwgPSB0aGlzLmNhY2hlLm1ha2VSZXNwb25zZUNhY2hlYWJsZSh0aGlzLmRlc2NyaWJlR2xvYmFsLCB0aGlzLCBjYWNoZU9wdGlvbnMpO1xuXG4gIHRoaXMuaW5pdGlhbGl6ZShvcHRpb25zKTtcbn07XG5cbmluaGVyaXRzKENvbm5lY3Rpb24sIGV2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIEluaXRpYWxpemUgY29ubmVjdGlvbi5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEluaXRpYWxpemF0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pbnN0YW5jZVVybF0gLSBTYWxlc2ZvcmNlIEluc3RhbmNlIFVSTCAoZS5nLiBodHRwczovL25hMS5zYWxlc2ZvcmNlLmNvbS8pXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc2VydmVyVXJsXSAtIFNhbGVzZm9yY2UgU09BUCBzZXJ2aWNlIGVuZHBvaW50IFVSTCAoZS5nLiBodHRwczovL25hMS5zYWxlc2ZvcmNlLmNvbS9zZXJ2aWNlcy9Tb2FwL3UvMjguMClcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hY2Nlc3NUb2tlbl0gLSBTYWxlc2ZvcmNlIE9BdXRoMiBhY2Nlc3MgdG9rZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zZXNzaW9uSWRdIC0gU2FsZXNmb3JjZSBzZXNzaW9uIElEXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVmcmVzaFRva2VuXSAtIFNhbGVzZm9yY2UgT0F1dGgyIHJlZnJlc2ggdG9rZW5cbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gW29wdGlvbnMuc2lnbmVkUmVxdWVzdF0gLSBTYWxlc2ZvcmNlIENhbnZhcyBzaWduZWQgcmVxdWVzdCAoUmF3IEJhc2U2NCBzdHJpbmcsIEpTT04gc3RyaW5nLCBvciBkZXNlcmlhbGl6ZWQgSlNPTilcbiAqIEBwYXJhbSB7VXNlckluZm99IFtvcHRpb25zLnVzZXJJbmZvXSAtIExvZ2dlZCBpbiB1c2VyIGluZm9ybWF0aW9uXG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucy5pbnN0YW5jZVVybCAmJiBvcHRpb25zLnNlcnZlclVybCkge1xuICAgIG9wdGlvbnMuaW5zdGFuY2VVcmwgPSBvcHRpb25zLnNlcnZlclVybC5zcGxpdCgnLycpLnNsaWNlKDAsIDMpLmpvaW4oJy8nKTtcbiAgfVxuICB0aGlzLmluc3RhbmNlVXJsID0gb3B0aW9ucy5pbnN0YW5jZVVybCB8fCBvcHRpb25zLnNlcnZlclVybCB8fCB0aGlzLmluc3RhbmNlVXJsIHx8IGRlZmF1bHRzLmluc3RhbmNlVXJsO1xuXG4gIHRoaXMuYWNjZXNzVG9rZW4gPSBvcHRpb25zLnNlc3Npb25JZCB8fCBvcHRpb25zLmFjY2Vzc1Rva2VuIHx8IHRoaXMuYWNjZXNzVG9rZW47XG4gIHRoaXMucmVmcmVzaFRva2VuID0gb3B0aW9ucy5yZWZyZXNoVG9rZW4gfHwgdGhpcy5yZWZyZXNoVG9rZW47XG4gIGlmICh0aGlzLnJlZnJlc2hUb2tlbiAmJiAhdGhpcy5fcmVmcmVzaERlbGVnYXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVmcmVzaCB0b2tlbiBpcyBzcGVjaWZpZWQgd2l0aG91dCBvYXV0aDIgY2xpZW50IGluZm9ybWF0aW9uIG9yIHJlZnJlc2ggZnVuY3Rpb25cIik7XG4gIH1cblxuICB0aGlzLnNpZ25lZFJlcXVlc3QgPSBvcHRpb25zLnNpZ25lZFJlcXVlc3QgJiYgcGFyc2VTaWduZWRSZXF1ZXN0KG9wdGlvbnMuc2lnbmVkUmVxdWVzdCk7XG4gIGlmICh0aGlzLnNpZ25lZFJlcXVlc3QpIHtcbiAgICB0aGlzLmFjY2Vzc1Rva2VuID0gdGhpcy5zaWduZWRSZXF1ZXN0LmNsaWVudC5vYXV0aFRva2VuO1xuICAgIGlmIChUcmFuc3BvcnQuQ2FudmFzVHJhbnNwb3J0LnN1cHBvcnRlZCkge1xuICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydC5DYW52YXNUcmFuc3BvcnQodGhpcy5zaWduZWRSZXF1ZXN0KTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy51c2VySW5mbykge1xuICAgIHRoaXMudXNlckluZm8gPSBvcHRpb25zLnVzZXJJbmZvO1xuICB9XG5cbiAgdGhpcy5saW1pdEluZm8gPSB7fTtcblxuICB0aGlzLnNvYmplY3RzID0ge307XG4gIHRoaXMuY2FjaGUuY2xlYXIoKTtcbiAgdGhpcy5jYWNoZS5nZXQoJ2Rlc2NyaWJlR2xvYmFsJykucmVtb3ZlQWxsTGlzdGVuZXJzKCd2YWx1ZScpO1xuICB0aGlzLmNhY2hlLmdldCgnZGVzY3JpYmVHbG9iYWwnKS5vbigndmFsdWUnLCBfLmJpbmQoZnVuY3Rpb24ocmVzKSB7XG4gICAgaWYgKHJlcy5yZXN1bHQpIHtcbiAgICAgIHZhciB0eXBlcyA9IF8ubWFwKHJlcy5yZXN1bHQuc29iamVjdHMsIGZ1bmN0aW9uKHNvKSB7IHJldHVybiBzby5uYW1lOyB9KTtcbiAgICAgIHR5cGVzLmZvckVhY2godGhpcy5zb2JqZWN0LCB0aGlzKTtcbiAgICB9XG4gIH0sIHRoaXMpKTtcblxuICBpZiAodGhpcy50b29saW5nKSB7XG4gICAgdGhpcy50b29saW5nLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIHRoaXMuX3Nlc3Npb25UeXBlID0gb3B0aW9ucy5zZXNzaW9uSWQgPyBcInNvYXBcIiA6IFwib2F1dGgyXCI7XG5cbn07XG5cbi8qKiBAcHJpdmF0ZSAqKi9cbmZ1bmN0aW9uIG9hdXRoUmVmcmVzaEZuKGNvbm4sIGNhbGxiYWNrKSB7XG4gIGNvbm4ub2F1dGgyLnJlZnJlc2hUb2tlbihjb25uLnJlZnJlc2hUb2tlbiwgZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9XG4gICAgdmFyIHVzZXJJbmZvID0gcGFyc2VJZFVybChyZXMuaWQpO1xuICAgIGNvbm4uaW5pdGlhbGl6ZSh7XG4gICAgICBpbnN0YW5jZVVybCA6IHJlcy5pbnN0YW5jZV91cmwsXG4gICAgICBhY2Nlc3NUb2tlbiA6IHJlcy5hY2Nlc3NfdG9rZW4sXG4gICAgICB1c2VySW5mbyA6IHVzZXJJbmZvXG4gICAgfSk7XG4gICAgY2FsbGJhY2sobnVsbCwgcmVzLmFjY2Vzc190b2tlbiwgcmVzKTtcbiAgfSk7XG59XG5cbi8qKiBAcHJpdmF0ZSAqKi9cbmZ1bmN0aW9uIHBhcnNlU2lnbmVkUmVxdWVzdChzcikge1xuICBpZiAoXy5pc1N0cmluZyhzcikpIHtcbiAgICBpZiAoc3JbMF0gPT09ICd7JykgeyAvLyBtaWdodCBiZSBKU09OXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShzcik7XG4gICAgfSBlbHNlIHsgLy8gbWlnaHQgYmUgb3JpZ2luYWwgYmFzZTY0LWVuY29kZWQgc2lnbmVkIHJlcXVlc3RcbiAgICAgIHZhciBtc2cgPSBzci5zcGxpdCgnLicpLnBvcCgpOyAvLyByZXRyaWV2ZSBsYXR0ZXIgcGFydFxuICAgICAgdmFyIGpzb24gPSBCdWZmZXIuZnJvbShtc2csICdiYXNlNjQnKS50b1N0cmluZygndXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gc3I7XG59XG5cblxuLyoqIEBwcml2YXRlICoqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2Jhc2VVcmwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFsgdGhpcy5pbnN0YW5jZVVybCwgXCJzZXJ2aWNlcy9kYXRhXCIsIFwidlwiICsgdGhpcy52ZXJzaW9uIF0uam9pbignLycpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHBhdGggdG8gYWJzb2x1dGUgdXJsXG4gKiBAcHJpdmF0ZVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fbm9ybWFsaXplVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gIGlmICh1cmxbMF0gPT09ICcvJykge1xuICAgIGlmICh1cmwuaW5kZXhPZignL3NlcnZpY2VzLycpID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZVVybCArIHVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VVcmwoKSArIHVybDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kIFJFU1QgQVBJIHJlcXVlc3Qgd2l0aCBnaXZlbiBIVFRQIHJlcXVlc3QgaW5mbywgd2l0aCBjb25uZWN0ZWQgc2Vzc2lvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBFbmRwb2ludCBVUkwgY2FuIGJlIGFic29sdXRlIFVSTCAoJ2h0dHBzOi8vbmExLnNhbGVzZm9yY2UuY29tL3NlcnZpY2VzL2RhdGEvdjMyLjAvc29iamVjdHMvQWNjb3VudC9kZXNjcmliZScpXG4gKiAsIHJlbGF0aXZlIHBhdGggZnJvbSByb290ICgnL3NlcnZpY2VzL2RhdGEvdjMyLjAvc29iamVjdHMvQWNjb3VudC9kZXNjcmliZScpXG4gKiAsIG9yIHJlbGF0aXZlIHBhdGggZnJvbSB2ZXJzaW9uIHJvb3QgKCcvc29iamVjdHMvQWNjb3VudC9kZXNjcmliZScpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcmVxdWVzdCAtIEhUVFAgcmVxdWVzdCBvYmplY3Qgb3IgVVJMIHRvIEdFVCByZXF1ZXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdC5tZXRob2QgLSBIVFRQIG1ldGhvZCBVUkwgdG8gc2VuZCBIVFRQIHJlcXVlc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0LnVybCAtIFVSTCB0byBzZW5kIEhUVFAgcmVxdWVzdFxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0LmhlYWRlcnNdIC0gSFRUUCByZXF1ZXN0IGhlYWRlcnMgaW4gaGFzaCBvYmplY3QgKGtleS12YWx1ZSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBIVFRQIEFQSSByZXF1ZXN0IG9wdGlvbnNcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE9iamVjdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBpZiByZXF1ZXN0IGlzIHNpbXBsZSBzdHJpbmcsIHJlZ2FyZCBpdCBhcyB1cmwgaW4gR0VUIG1ldGhvZFxuICBpZiAoXy5pc1N0cmluZyhyZXF1ZXN0KSkge1xuICAgIHJlcXVlc3QgPSB7IG1ldGhvZDogJ0dFVCcsIHVybDogcmVxdWVzdCB9O1xuICB9XG4gIC8vIGlmIHVybCBpcyBnaXZlbiBpbiByZWxhdGl2ZSBwYXRoLCBwcmVwZW5kIGJhc2UgdXJsIG9yIGluc3RhbmNlIHVybCBiZWZvcmUuXG4gIHJlcXVlc3QudXJsID0gdGhpcy5fbm9ybWFsaXplVXJsKHJlcXVlc3QudXJsKTtcblxuICB2YXIgaHR0cEFwaSA9IG5ldyBIdHRwQXBpKHRoaXMsIG9wdGlvbnMpO1xuXG4gIC8vIGxvZyBhcGkgdXNhZ2UgYW5kIGl0cyBxdW90YVxuICBodHRwQXBpLm9uKCdyZXNwb25zZScsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMgJiYgcmVzcG9uc2UuaGVhZGVyc1tcInNmb3JjZS1saW1pdC1pbmZvXCJdKSB7XG4gICAgICB2YXIgYXBpVXNhZ2UgPSByZXNwb25zZS5oZWFkZXJzW1wic2ZvcmNlLWxpbWl0LWluZm9cIl0ubWF0Y2goL2FwaVxcLXVzYWdlPShcXGQrKVxcLyhcXGQrKS8pO1xuICAgICAgaWYgKGFwaVVzYWdlKSB7XG4gICAgICAgIHNlbGYubGltaXRJbmZvID0ge1xuICAgICAgICAgIGFwaVVzYWdlOiB7XG4gICAgICAgICAgICB1c2VkOiBwYXJzZUludChhcGlVc2FnZVsxXSwgMTApLFxuICAgICAgICAgICAgbGltaXQ6IHBhcnNlSW50KGFwaVVzYWdlWzJdLCAxMClcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGh0dHBBcGkucmVxdWVzdChyZXF1ZXN0KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFNlbmQgSFRUUCBHRVQgcmVxdWVzdFxuICpcbiAqIEVuZHBvaW50IFVSTCBjYW4gYmUgYWJzb2x1dGUgVVJMICgnaHR0cHM6Ly9uYTEuc2FsZXNmb3JjZS5jb20vc2VydmljZXMvZGF0YS92MzIuMC9zb2JqZWN0cy9BY2NvdW50L2Rlc2NyaWJlJylcbiAqICwgcmVsYXRpdmUgcGF0aCBmcm9tIHJvb3QgKCcvc2VydmljZXMvZGF0YS92MzIuMC9zb2JqZWN0cy9BY2NvdW50L2Rlc2NyaWJlJylcbiAqICwgb3IgcmVsYXRpdmUgcGF0aCBmcm9tIHZlcnNpb24gcm9vdCAoJy9zb2JqZWN0cy9BY2NvdW50L2Rlc2NyaWJlJykuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIEVuZHBvaW50IFVSTCB0byByZXF1ZXN0IEhUVFAgR0VUXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gSFRUUCBBUEkgcmVxdWVzdCBvcHRpb25zXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxPYmplY3Q+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxPYmplY3Q+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0R2V0ID0gZnVuY3Rpb24odXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgcmVxdWVzdCA9IHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgdXJsOiB1cmxcbiAgfTtcbiAgcmV0dXJuIHRoaXMucmVxdWVzdChyZXF1ZXN0LCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG5cbi8qKlxuICogU2VuZCBIVFRQIFBPU1QgcmVxdWVzdCB3aXRoIEpTT04gYm9keSwgd2l0aCBjb25uZWN0ZWQgc2Vzc2lvbiBpbmZvcm1hdGlvblxuICpcbiAqIEVuZHBvaW50IFVSTCBjYW4gYmUgYWJzb2x1dGUgVVJMICgnaHR0cHM6Ly9uYTEuc2FsZXNmb3JjZS5jb20vc2VydmljZXMvZGF0YS92MzIuMC9zb2JqZWN0cy9BY2NvdW50L2Rlc2NyaWJlJylcbiAqICwgcmVsYXRpdmUgcGF0aCBmcm9tIHJvb3QgKCcvc2VydmljZXMvZGF0YS92MzIuMC9zb2JqZWN0cy9BY2NvdW50L2Rlc2NyaWJlJylcbiAqICwgb3IgcmVsYXRpdmUgcGF0aCBmcm9tIHZlcnNpb24gcm9vdCAoJy9zb2JqZWN0cy9BY2NvdW50L2Rlc2NyaWJlJykuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIEVuZHBvaW50IFVSTCB0byByZXF1ZXN0IEhUVFAgUE9TVFxuICogQHBhcmFtIHtPYmplY3R9IGJvZHkgLSBBbnkgSlMgb2JqZWN0IHdoaWNoIGNhbiBiZSBzZXJpYWxpemVkIHRvIEpTT05cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBIVFRQIEFQSSByZXF1ZXN0IG9wdGlvbnNcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE9iamVjdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnJlcXVlc3RQb3N0ID0gZnVuY3Rpb24odXJsLCBib2R5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgcmVxdWVzdCA9IHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogdXJsLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgIGhlYWRlcnM6IHsgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfVxuICB9O1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHJlcXVlc3QsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2VuZCBIVFRQIFBVVCByZXF1ZXN0IHdpdGggSlNPTiBib2R5LCB3aXRoIGNvbm5lY3RlZCBzZXNzaW9uIGluZm9ybWF0aW9uXG4gKlxuICogRW5kcG9pbnQgVVJMIGNhbiBiZSBhYnNvbHV0ZSBVUkwgKCdodHRwczovL25hMS5zYWxlc2ZvcmNlLmNvbS9zZXJ2aWNlcy9kYXRhL3YzMi4wL3NvYmplY3RzL0FjY291bnQvZGVzY3JpYmUnKVxuICogLCByZWxhdGl2ZSBwYXRoIGZyb20gcm9vdCAoJy9zZXJ2aWNlcy9kYXRhL3YzMi4wL3NvYmplY3RzL0FjY291bnQvZGVzY3JpYmUnKVxuICogLCBvciByZWxhdGl2ZSBwYXRoIGZyb20gdmVyc2lvbiByb290ICgnL3NvYmplY3RzL0FjY291bnQvZGVzY3JpYmUnKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gRW5kcG9pbnQgVVJMIHRvIHJlcXVlc3QgSFRUUCBQVVRcbiAqIEBwYXJhbSB7T2JqZWN0fSBib2R5IC0gQW55IEpTIG9iamVjdCB3aGljaCBjYW4gYmUgc2VyaWFsaXplZCB0byBKU09OXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gSFRUUCBBUEkgcmVxdWVzdCBvcHRpb25zXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxPYmplY3Q+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxPYmplY3Q+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0UHV0ID0gZnVuY3Rpb24odXJsLCBib2R5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgcmVxdWVzdCA9IHtcbiAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgdXJsOiB1cmwsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgaGVhZGVyczogeyBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9XG4gIH07XG4gIHJldHVybiB0aGlzLnJlcXVlc3QocmVxdWVzdCwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTZW5kIEhUVFAgUEFUQ0ggcmVxdWVzdCB3aXRoIEpTT04gYm9keVxuICpcbiAqIEVuZHBvaW50IFVSTCBjYW4gYmUgYWJzb2x1dGUgVVJMICgnaHR0cHM6Ly9uYTEuc2FsZXNmb3JjZS5jb20vc2VydmljZXMvZGF0YS92MzIuMC9zb2JqZWN0cy9BY2NvdW50L2Rlc2NyaWJlJylcbiAqICwgcmVsYXRpdmUgcGF0aCBmcm9tIHJvb3QgKCcvc2VydmljZXMvZGF0YS92MzIuMC9zb2JqZWN0cy9BY2NvdW50L2Rlc2NyaWJlJylcbiAqICwgb3IgcmVsYXRpdmUgcGF0aCBmcm9tIHZlcnNpb24gcm9vdCAoJy9zb2JqZWN0cy9BY2NvdW50L2Rlc2NyaWJlJykuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIEVuZHBvaW50IFVSTCB0byByZXF1ZXN0IEhUVFAgUEFUQ0hcbiAqIEBwYXJhbSB7T2JqZWN0fSBib2R5IC0gQW55IEpTIG9iamVjdCB3aGljaCBjYW4gYmUgc2VyaWFsaXplZCB0byBKU09OXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gSFRUUCBBUEkgcmVxdWVzdCBvcHRpb25zXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxPYmplY3Q+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxPYmplY3Q+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0UGF0Y2ggPSBmdW5jdGlvbih1cmwsIGJvZHksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciByZXF1ZXN0ID0ge1xuICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgIHVybDogdXJsLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgIGhlYWRlcnM6IHsgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfVxuICB9O1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHJlcXVlc3QsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2VuZCBIVFRQIERFTEVURSByZXF1ZXN0XG4gKlxuICogRW5kcG9pbnQgVVJMIGNhbiBiZSBhYnNvbHV0ZSBVUkwgKCdodHRwczovL25hMS5zYWxlc2ZvcmNlLmNvbS9zZXJ2aWNlcy9kYXRhL3YzMi4wL3NvYmplY3RzL0FjY291bnQvZGVzY3JpYmUnKVxuICogLCByZWxhdGl2ZSBwYXRoIGZyb20gcm9vdCAoJy9zZXJ2aWNlcy9kYXRhL3YzMi4wL3NvYmplY3RzL0FjY291bnQvZGVzY3JpYmUnKVxuICogLCBvciByZWxhdGl2ZSBwYXRoIGZyb20gdmVyc2lvbiByb290ICgnL3NvYmplY3RzL0FjY291bnQvZGVzY3JpYmUnKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gRW5kcG9pbnQgVVJMIHRvIHJlcXVlc3QgSFRUUCBERUxFVEVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBIVFRQIEFQSSByZXF1ZXN0IG9wdGlvbnNcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE9iamVjdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnJlcXVlc3REZWxldGUgPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciByZXF1ZXN0ID0ge1xuICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICB1cmw6IHVybFxuICB9O1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHJlcXVlc3QsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cblxuLyoqIEBwcml2YXRlICovXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgZnVuY3Rpb24gcGFkKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPCAxMCkge1xuICAgICAgcmV0dXJuICcwJyArIG51bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIHJldHVybiBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgK1xuICAgICctJyArIHBhZChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSArXG4gICAgJy0nICsgcGFkKGRhdGUuZ2V0VVRDRGF0ZSgpKSArXG4gICAgJ1QnICsgcGFkKGRhdGUuZ2V0VVRDSG91cnMoKSkgK1xuICAgICc6JyArIHBhZChkYXRlLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICc6JyArIHBhZChkYXRlLmdldFVUQ1NlY29uZHMoKSkgK1xuICAgICcrMDA6MDAnO1xufVxuXG5cbi8qKiBAcHJpdmF0ZSAqKi9cbmZ1bmN0aW9uIHBhcnNlSWRVcmwoaWRVcmwpIHtcbiAgdmFyIGlkVXJscyA9IGlkVXJsLnNwbGl0KFwiL1wiKTtcbiAgdmFyIHVzZXJJZCA9IGlkVXJscy5wb3AoKSwgb3JnSWQgPSBpZFVybHMucG9wKCk7XG4gIHJldHVybiB7XG4gICAgaWQ6IHVzZXJJZCxcbiAgICBvcmdhbml6YXRpb25JZDogb3JnSWQsXG4gICAgdXJsOiBpZFVybFxuICB9O1xufVxuXG4vKipcbiAqIEBjYWxsYmFjayBDYWxsYmFja1xuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gQ2FsbGJhY2sgZXJyb3JcbiAqIEBwYXJhbSB7VH0gcmVzcG9uc2UgLSBDYWxsYmFjayByZXNwb25zZVxuICogQHRlbXBsYXRlIFRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFF1ZXJ5UmVzdWx0XG4gKiBAcHJvcCB7Qm9vbGVhbn0gZG9uZSAtIEZsYWcgaWYgdGhlIHF1ZXJ5IGlzIGZldGNoZWQgYWxsIHJlY29yZHMgb3Igbm90XG4gKiBAcHJvcCB7U3RyaW5nfSBbbmV4dFJlY29yZHNVcmxdIC0gVVJMIGxvY2F0b3IgZm9yIG5leHQgcmVjb3JkIHNldCwgKGF2YWlsYWJsZSB3aGVuIGRvbmUgPSBmYWxzZSlcbiAqIEBwcm9wIHtOdW1iZXJ9IHRvdGFsU2l6ZSAtIFRvdGFsIHNpemUgZm9yIHF1ZXJ5XG4gKiBAcHJvcCB7QXJyYXkuPFJlY29yZD59IFtyZWNvcmRzXSAtIEFycmF5IG9mIHJlY29yZHMgZmV0Y2hlZFxuICovXG5cbi8qKlxuICogRXhlY3V0ZSBxdWVyeSBieSB1c2luZyBTT1FMXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNvcWwgLSBTT1FMIHN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFF1ZXJ5IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgSFRUUCByZXF1ZXN0IGhlYWRlcnMgc2VudCBpbiBxdWVyeSByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxRdWVyeVJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1F1ZXJ5LjxRdWVyeVJlc3VsdD59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24oc29xbCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHRoaXMsIHNvcWwsIG9wdGlvbnMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBxdWVyeS5ydW4oY2FsbGJhY2spO1xuICB9XG4gIHJldHVybiBxdWVyeTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBxdWVyeSBieSB1c2luZyBTT1FMLCBpbmNsdWRpbmcgZGVsZXRlZCByZWNvcmRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNvcWwgLSBTT1FMIHN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFF1ZXJ5IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgSFRUUCByZXF1ZXN0IGhlYWRlcnMgc2VudCBpbiBxdWVyeSByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxRdWVyeVJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1F1ZXJ5LjxRdWVyeVJlc3VsdD59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnF1ZXJ5QWxsID0gZnVuY3Rpb24oc29xbCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHRoaXMsIHNvcWwsIG9wdGlvbnMpO1xuICBxdWVyeS5zY2FuQWxsKHRydWUpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBxdWVyeS5ydW4oY2FsbGJhY2spO1xuICB9XG4gIHJldHVybiBxdWVyeTtcbn07XG5cbi8qKlxuICogUXVlcnkgbmV4dCByZWNvcmQgc2V0IGJ5IHVzaW5nIHF1ZXJ5IGxvY2F0b3JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbG9jYXRvciAtIE5leHQgcmVjb3JkIHNldCBsb2NhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gUXVlcnkgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBIVFRQIHJlcXVlc3QgaGVhZGVycyBzZW50IGluIHF1ZXJ5IHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFF1ZXJ5UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UXVlcnkuPFF1ZXJ5UmVzdWx0Pn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUucXVlcnlNb3JlID0gZnVuY3Rpb24obG9jYXRvciwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHRoaXMsIHsgbG9jYXRvcjogbG9jYXRvciB9LCBvcHRpb25zKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgcXVlcnkucnVuKGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gcXVlcnk7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9lbnN1cmVWZXJzaW9uID0gZnVuY3Rpb24obWFqb3JWZXJzaW9uKSB7XG4gIHZhciB2ZXJzaW9ucyA9IHRoaXMudmVyc2lvbi5zcGxpdCgnLicpO1xuICByZXR1cm4gcGFyc2VJbnQodmVyc2lvbnNbMF0sIDEwKSA+PSBtYWpvclZlcnNpb247XG59XG5cbi8qKiBAcHJpdmF0ZSAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuX3N1cHBvcnRzID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICBzd2l0Y2ggKGZlYXR1cmUpIHtcbiAgICBjYXNlICdzb2JqZWN0LWNvbGxlY3Rpb24nOlxuICAgICAgcmV0dXJuIHRoaXMuX2Vuc3VyZVZlcnNpb24oNDIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZSBzcGVjaWZpZWQgcmVjb3Jkc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gU09iamVjdCBUeXBlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaWRzIC0gQSByZWNvcmQgSUQgb3IgYXJyYXkgb2YgcmVjb3JkIElEc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHJlc3QgYXBpLlxuICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gW29wdGlvbnMuZmllbGRzXSAtIEZldGNoaW5nIGZpZWxkIG5hbWVzIGluIHJldHJpZXZpbmcgcmVjb3JkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gLSBBZGRpdGlvbmFsIEhUVFAgcmVxdWVzdCBoZWFkZXJzIHNlbnQgaW4gcmV0cmlldmUgcmVxdWVzdFxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkfEFycmF5LjxSZWNvcmQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkfEFycmF5LjxSZWNvcmQ+Pn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUucmV0cmlldmUgPSBmdW5jdGlvbih0eXBlLCBpZHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHJldHVybiAoXG4gICAgXy5pc0FycmF5KGlkcykgP1xuICAgICAgKHRoaXMuX3N1cHBvcnRzKCdzb2JqZWN0LWNvbGxlY3Rpb24nKSA/IC8vIGNoZWNrIHdoZXRoZXIgU09iamVjdCBjb2xsZWN0aW9uIEFQSSBpcyBzdXBwb3J0ZWRcbiAgICAgICAgdGhpcy5fcmV0cmlldmVNYW55KHR5cGUsIGlkcywgb3B0aW9ucykgOlxuICAgICAgICB0aGlzLl9yZXRyaWV2ZVBhcmFsbGVsKHR5cGUsIGlkcywgb3B0aW9ucykpIDpcbiAgICAgIHRoaXMuX3JldHJpZXZlU2luZ2xlKHR5cGUsIGlkcywgb3B0aW9ucylcbiAgKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9yZXRyaWV2ZVNpbmdsZSA9IGZ1bmN0aW9uKHR5cGUsIGlkLCBvcHRpb25zKSB7XG4gIGlmICghaWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIHJlY29yZCBJRC4gU3BlY2lmeSB2YWxpZCByZWNvcmQgSUQgdmFsdWUnKSk7XG4gIH1cbiAgdmFyIHVybCA9IFsgdGhpcy5fYmFzZVVybCgpLCBcInNvYmplY3RzXCIsIHR5cGUsIGlkIF0uam9pbignLycpO1xuICBpZiAob3B0aW9ucy5maWVsZHMpIHtcbiAgICB1cmwgKz0gJz9maWVsZHM9JyArIG9wdGlvbnMuZmllbGRzLmpvaW4oJywnKTtcbiAgfVxuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogdXJsLFxuICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyxcbiAgfSk7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9yZXRyaWV2ZVBhcmFsbGVsID0gZnVuY3Rpb24odHlwZSwgaWRzLCBvcHRpb25zKSB7XG4gIGlmIChpZHMubGVuZ3RoID4gdGhpcy5tYXhSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkV4Y2VlZGVkIG1heCBsaW1pdCBvZiBjb25jdXJyZW50IGNhbGxcIikpO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGlkcy5tYXAoZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiBzZWxmLl9yZXRyaWV2ZVNpbmdsZSh0eXBlLCBpZCwgb3B0aW9ucykuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFsbE9yTm9uZSB8fCBlcnIuZXJyb3JDb2RlICE9PSAnTk9UX0ZPVU5EJykge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgIH0pXG4gICk7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9yZXRyaWV2ZU1hbnkgPSBmdW5jdGlvbih0eXBlLCBpZHMsIG9wdGlvbnMpIHtcbiAgaWYgKGlkcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgfVxuICB2YXIgdXJsID0gWyB0aGlzLl9iYXNlVXJsKCksIFwiY29tcG9zaXRlXCIsIFwic29iamVjdHNcIiwgdHlwZSBdLmpvaW4oJy8nKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gKFxuICAgIG9wdGlvbnMuZmllbGRzID9cbiAgICAgIFByb21pc2UucmVzb2x2ZShvcHRpb25zLmZpZWxkcykgOlxuICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYuZGVzY3JpYmUkKHR5cGUsIGZ1bmN0aW9uKGVyciwgc28pIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IHNvLmZpZWxkcy5tYXAoZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkLm5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc29sdmUoZmllbGRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgKS50aGVuKGZ1bmN0aW9uKGZpZWxkcykge1xuICAgIHJldHVybiBzZWxmLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kIDogJ1BPU1QnLFxuICAgICAgdXJsIDogdXJsLFxuICAgICAgYm9keSA6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgaWRzIDogaWRzLFxuICAgICAgICBmaWVsZHMgOiBmaWVsZHNcbiAgICAgIH0pLFxuICAgICAgaGVhZGVycyA6IF8uZGVmYXVsdHMob3B0aW9ucy5oZWFkZXJzIHx8IHt9LCB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCIgOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogQHR5cGVkZWYgUmVjb3JkUmVzdWx0XG4gKiBAcHJvcCB7Qm9vbGVhbn0gc3VjY2VzcyAtIFRoZSByZXN1bHQgaXMgc3VjY2Vlc3NmdWwgb3Igbm90XG4gKiBAcHJvcCB7U3RyaW5nfSBbaWRdIC0gUmVjb3JkIElEXG4gKiBAcHJvcCB7QXJyYXkuPE9iamVjdD59IFtlcnJvcnNdIC0gRXJyb3JzIChhdmFpbGFibGUgd2hlbiBzdWNjZXNzID0gZmFsc2UpXG4gKi9cblxuLyoqIEBwcml2YXRlICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fdG9SZWNvcmRSZXN1bHQgPSBmdW5jdGlvbihpZCwgZXJyKSB7XG4gIHZhciBlcnJvciA9IHtcbiAgICBzdGF0dXNDb2RlOiBlcnIuZXJyb3JDb2RlLFxuICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlXG4gIH07XG4gIGlmIChlcnIuY29udGVudCkgeyBlcnJvci5jb250ZW50ID0gZXJyLmNvbnRlbnQ7IH0gLy8gcHJlc2VydmUgRXh0ZXJuYWwgaWQgZHVwbGljYXRpb24gbWVzc2FnZVxuICBpZiAoZXJyLmZpZWxkcykgeyBlcnJvci5maWVsZHMgPSBlcnIuZmllbGRzOyB9IC8vIHByZXNlcnZlIERNTCBleGNlcHRpb24gb2NjdXJyZWQgZmllbGRzXG4gIHZhciByZXN1bHQgPSB7XG4gICAgc3VjY2VzczogZmFsc2UsXG4gICAgZXJyb3JzOiBbZXJyb3JdXG4gIH07XG4gIGlmIChpZCkgeyByZXN1bHQuaWQgPSBpZDsgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTeW5vbnltIG9mIENvbm5lY3Rpb24jY3JlYXRlKClcbiAqXG4gKiBAbWV0aG9kIENvbm5lY3Rpb24jaW5zZXJ0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtPYmplY3R8QXJyYXkuPE9iamVjdD59IHJlY29yZHMgLSBBIHJlY29yZCBvciBhcnJheSBvZiByZWNvcmRzIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHJlc3QgYXBpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxPck5vbmVdIC0gSWYgdHJ1ZSwgYW55IGZhaWxlZCByZWNvcmRzIGluIGEgY2FsbCBjYXVzZSBhbGwgY2hhbmdlcyBmb3IgdGhlIGNhbGwgdG8gYmUgcm9sbGVkIGJhY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dSZWN1cnNpdmVdIC0gSWYgdHJ1ZSwgd2hlbiByZWNvcmRzIGdvZXMgb3ZlciB0aGUgbWF4IG51bSBvZiBjb2xsZWN0aW9uIEFQSSAoPTIwMCksIHJlY29yZHMgYXJlIGRpdmlkZWQgaW50byBzZXZlcmFsIGNodW5rcyBhbmQgcmVxdWVzdGVkIHJlY3Vyc2l2ZWx5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBIVFRQIHJlcXVlc3QgaGVhZGVycyBzZW50IGluIHJldHJpZXZlIHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cbi8qKlxuICogQ3JlYXRlIHJlY29yZHNcbiAqXG4gKiBAbWV0aG9kIENvbm5lY3Rpb24jY3JlYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtSZWNvcmR8QXJyYXkuPFJlY29yZD59IHJlY29yZHMgLSBBIHJlY29yZCBvciBhcnJheSBvZiByZWNvcmRzIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHJlc3QgYXBpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxPck5vbmVdIC0gSWYgdHJ1ZSwgYW55IGZhaWxlZCByZWNvcmRzIGluIGEgY2FsbCBjYXVzZSBhbGwgY2hhbmdlcyBmb3IgdGhlIGNhbGwgdG8gYmUgcm9sbGVkIGJhY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dSZWN1cnNpdmVdIC0gSWYgdHJ1ZSwgd2hlbiByZWNvcmRzIGdvZXMgb3ZlciB0aGUgbWF4IG51bSBvZiBjb2xsZWN0aW9uIEFQSSAoPTIwMCksIHJlY29yZHMgYXJlIGRpdmlkZWQgaW50byBzZXZlcmFsIGNodW5rcyBhbmQgcmVxdWVzdGVkIHJlY3Vyc2l2ZWx5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBIVFRQIHJlcXVlc3QgaGVhZGVycyBzZW50IGluIHJldHJpZXZlIHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmluc2VydCA9XG5Db25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbih0eXBlLCByZWNvcmRzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoIV8uaXNTdHJpbmcodHlwZSkpIHtcbiAgICAvLyByZXZlcnNlIG9yZGVyXG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSByZWNvcmRzO1xuICAgIHJlY29yZHMgPSB0eXBlO1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHJldHVybiAoXG4gICAgXy5pc0FycmF5KHJlY29yZHMpID9cbiAgICAgICh0aGlzLl9zdXBwb3J0cygnc29iamVjdC1jb2xsZWN0aW9uJykgPyAvLyBjaGVjayB3aGV0aGVyIFNPYmplY3QgY29sbGVjdGlvbiBBUEkgaXMgc3VwcG9ydGVkXG4gICAgICAgIHRoaXMuX2NyZWF0ZU1hbnkodHlwZSwgcmVjb3Jkcywgb3B0aW9ucykgOlxuICAgICAgICB0aGlzLl9jcmVhdGVQYXJhbGxlbCh0eXBlLCByZWNvcmRzLCBvcHRpb25zKSkgOlxuICAgICAgdGhpcy5fY3JlYXRlU2luZ2xlKHR5cGUsIHJlY29yZHMsIG9wdGlvbnMpXG4gICkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fY3JlYXRlU2luZ2xlID0gZnVuY3Rpb24odHlwZSwgcmVjb3JkLCBvcHRpb25zKSB7XG4gIHZhciBzb2JqZWN0VHlwZSA9IHR5cGUgfHwgKHJlY29yZC5hdHRyaWJ1dGVzICYmIHJlY29yZC5hdHRyaWJ1dGVzLnR5cGUpIHx8IHJlY29yZC50eXBlO1xuICBpZiAoIXNvYmplY3RUeXBlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTm8gU09iamVjdCBUeXBlIGRlZmluZWQgaW4gcmVjb3JkJykpO1xuICB9XG4gIHJlY29yZCA9IF8uY2xvbmUocmVjb3JkKTtcbiAgZGVsZXRlIHJlY29yZC5JZDtcbiAgZGVsZXRlIHJlY29yZC50eXBlO1xuICBkZWxldGUgcmVjb3JkLmF0dHJpYnV0ZXM7XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Jhc2VVcmwoKSwgXCJzb2JqZWN0c1wiLCBzb2JqZWN0VHlwZSBdLmpvaW4oJy8nKTtcbiAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgbWV0aG9kIDogJ1BPU1QnLFxuICAgIHVybCA6IHVybCxcbiAgICBib2R5IDogSlNPTi5zdHJpbmdpZnkocmVjb3JkKSxcbiAgICBoZWFkZXJzIDogXy5kZWZhdWx0cyhvcHRpb25zLmhlYWRlcnMgfHwge30sIHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCIgOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0pXG4gIH0pO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fY3JlYXRlUGFyYWxsZWwgPSBmdW5jdGlvbih0eXBlLCByZWNvcmRzLCBvcHRpb25zKSB7XG4gIGlmIChyZWNvcmRzLmxlbmd0aCA+IHRoaXMubWF4UmVxdWVzdCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJFeGNlZWRlZCBtYXggbGltaXQgb2YgY29uY3VycmVudCBjYWxsXCIpKTtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICByZWNvcmRzLm1hcChmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgIHJldHVybiBzZWxmLl9jcmVhdGVTaW5nbGUodHlwZSwgcmVjb3JkLCBvcHRpb25zKS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgLy8gYmUgYXdhcmUgdGhhdCBhbGxPck5vbmUgaW4gcGFyYWxsZWwgbW9kZSB3aWxsIG5vdCByZXZlcnQgdGhlIG90aGVyIHN1Y2Nlc3NmdWwgcmVxdWVzdHNcbiAgICAgICAgLy8gaXQgb25seSByYWlzZXMgZXJyb3Igd2hlbiBtZXQgYXQgbGVhc3Qgb25lIGZhaWxlZCByZXF1ZXN0LlxuICAgICAgICBpZiAob3B0aW9ucy5hbGxPck5vbmUgfHwgIWVyci5lcnJvckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvUmVjb3JkUmVzdWx0KG51bGwsIGVycik7XG4gICAgICB9KTtcbiAgICB9KVxuICApO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fY3JlYXRlTWFueSA9IGZ1bmN0aW9uKHR5cGUsIHJlY29yZHMsIG9wdGlvbnMpIHtcbiAgaWYgKHJlY29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gIH1cbiAgaWYgKHJlY29yZHMubGVuZ3RoID4gTUFYX0RNTF9DT1VOVCAmJiBvcHRpb25zLmFsbG93UmVjdXJzaXZlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBzZWxmLl9jcmVhdGVNYW55KHR5cGUsIHJlY29yZHMuc2xpY2UoMCwgTUFYX0RNTF9DT1VOVCksIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24ocmV0czEpIHtcbiAgICAgIHJldHVybiBzZWxmLl9jcmVhdGVNYW55KHR5cGUsIHJlY29yZHMuc2xpY2UoTUFYX0RNTF9DT1VOVCksIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24ocmV0czIpIHtcbiAgICAgICAgcmV0dXJuIHJldHMxLmNvbmNhdChyZXRzMik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZWNvcmRzID0gXy5tYXAocmVjb3JkcywgZnVuY3Rpb24ocmVjb3JkKSB7XG4gICAgdmFyIHNvYmplY3RUeXBlID0gdHlwZSB8fCAocmVjb3JkLmF0dHJpYnV0ZXMgJiYgcmVjb3JkLmF0dHJpYnV0ZXMudHlwZSkgfHwgcmVjb3JkLnR5cGU7XG4gICAgaWYgKCFzb2JqZWN0VHlwZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTm8gU09iamVjdCBUeXBlIGRlZmluZWQgaW4gcmVjb3JkJykpO1xuICAgIH1cbiAgICByZWNvcmQgPSBfLmNsb25lKHJlY29yZCk7XG4gICAgZGVsZXRlIHJlY29yZC5JZDtcbiAgICBkZWxldGUgcmVjb3JkLnR5cGU7XG4gICAgcmVjb3JkLmF0dHJpYnV0ZXMgPSB7IHR5cGUgOiBzb2JqZWN0VHlwZSB9O1xuICAgIHJldHVybiByZWNvcmQ7XG4gIH0pO1xuICB2YXIgdXJsID0gWyB0aGlzLl9iYXNlVXJsKCksIFwiY29tcG9zaXRlXCIsIFwic29iamVjdHNcIiBdLmpvaW4oJy8nKTtcbiAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgbWV0aG9kIDogJ1BPU1QnLFxuICAgIHVybCA6IHVybCxcbiAgICBib2R5IDogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgYWxsT3JOb25lIDogb3B0aW9ucy5hbGxPck5vbmUgfHwgZmFsc2UsXG4gICAgICByZWNvcmRzIDogcmVjb3Jkc1xuICAgIH0pLFxuICAgIGhlYWRlcnMgOiBfLmRlZmF1bHRzKG9wdGlvbnMuaGVhZGVycyB8fCB7fSwge1xuICAgICAgXCJDb250ZW50LVR5cGVcIiA6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSByZWNvcmRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IFR5cGVcbiAqIEBwYXJhbSB7UmVjb3JkfEFycmF5LjxSZWNvcmQ+fSByZWNvcmRzIC0gQSByZWNvcmQgb3IgYXJyYXkgb2YgcmVjb3JkcyB0byB1cGRhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciByZXN0IGFwaS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsT3JOb25lXSAtIElmIHRydWUsIGFueSBmYWlsZWQgcmVjb3JkcyBpbiBhIGNhbGwgY2F1c2UgYWxsIGNoYW5nZXMgZm9yIHRoZSBjYWxsIHRvIGJlIHJvbGxlZCBiYWNrXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93UmVjdXJzaXZlXSAtIElmIHRydWUsIHdoZW4gcmVjb3JkcyBnb2VzIG92ZXIgdGhlIG1heCBudW0gb2YgY29sbGVjdGlvbiBBUEkgKD0yMDApLCByZWNvcmRzIGFyZSBkaXZpZGVkIGludG8gc2V2ZXJhbCBjaHVua3MgYW5kIHJlcXVlc3RlZCByZWN1cnNpdmVseS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgSFRUUCByZXF1ZXN0IGhlYWRlcnMgc2VudCBpbiByZXRyaWV2ZSByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbih0eXBlLCByZWNvcmRzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoIV8uaXNTdHJpbmcodHlwZSkpIHtcbiAgICAvLyByZXZlcnNlIG9yZGVyXG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSByZWNvcmRzO1xuICAgIHJlY29yZHMgPSB0eXBlO1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHJldHVybiAoXG4gICAgXy5pc0FycmF5KHJlY29yZHMpID9cbiAgICAgICh0aGlzLl9zdXBwb3J0cygnc29iamVjdC1jb2xsZWN0aW9uJykgPyAvLyBjaGVjayB3aGV0aGVyIFNPYmplY3QgY29sbGVjdGlvbiBBUEkgaXMgc3VwcG9ydGVkXG4gICAgICAgIHRoaXMuX3VwZGF0ZU1hbnkodHlwZSwgcmVjb3Jkcywgb3B0aW9ucykgOlxuICAgICAgICB0aGlzLl91cGRhdGVQYXJhbGxlbCh0eXBlLCByZWNvcmRzLCBvcHRpb25zKSkgOlxuICAgICAgdGhpcy5fdXBkYXRlU2luZ2xlKHR5cGUsIHJlY29yZHMsIG9wdGlvbnMpXG4gICkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fdXBkYXRlU2luZ2xlID0gZnVuY3Rpb24odHlwZSwgcmVjb3JkLCBvcHRpb25zKSB7XG4gIHZhciBpZCA9IHJlY29yZC5JZDtcbiAgaWYgKCFpZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1JlY29yZCBpZCBpcyBub3QgZm91bmQgaW4gcmVjb3JkLicpKTtcbiAgfVxuICB2YXIgc29iamVjdFR5cGUgPSB0eXBlIHx8IChyZWNvcmQuYXR0cmlidXRlcyAmJiByZWNvcmQuYXR0cmlidXRlcy50eXBlKSB8fCByZWNvcmQudHlwZTtcbiAgaWYgKCFzb2JqZWN0VHlwZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ05vIFNPYmplY3QgVHlwZSBkZWZpbmVkIGluIHJlY29yZCcpKTtcbiAgfVxuICByZWNvcmQgPSBfLmNsb25lKHJlY29yZCk7XG4gIGRlbGV0ZSByZWNvcmQuSWQ7XG4gIGRlbGV0ZSByZWNvcmQudHlwZTtcbiAgZGVsZXRlIHJlY29yZC5hdHRyaWJ1dGVzO1xuICB2YXIgdXJsID0gWyB0aGlzLl9iYXNlVXJsKCksIFwic29iamVjdHNcIiwgc29iamVjdFR5cGUsIGlkIF0uam9pbignLycpO1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHtcbiAgICBtZXRob2QgOiAnUEFUQ0gnLFxuICAgIHVybCA6IHVybCxcbiAgICBib2R5IDogSlNPTi5zdHJpbmdpZnkocmVjb3JkKSxcbiAgICBoZWFkZXJzIDogXy5kZWZhdWx0cyhvcHRpb25zLmhlYWRlcnMgfHwge30sIHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCIgOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0pXG4gIH0sIHtcbiAgICBub0NvbnRlbnRSZXNwb25zZTogeyBpZCA6IGlkLCBzdWNjZXNzIDogdHJ1ZSwgZXJyb3JzIDogW10gfVxuICB9KTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuX3VwZGF0ZVBhcmFsbGVsID0gZnVuY3Rpb24odHlwZSwgcmVjb3Jkcywgb3B0aW9ucykge1xuICBpZiAocmVjb3Jkcy5sZW5ndGggPiB0aGlzLm1heFJlcXVlc3QpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiRXhjZWVkZWQgbWF4IGxpbWl0IG9mIGNvbmN1cnJlbnQgY2FsbFwiKSk7XG4gIH1cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgcmVjb3Jkcy5tYXAoZnVuY3Rpb24ocmVjb3JkKSB7XG4gICAgICByZXR1cm4gc2VsZi5fdXBkYXRlU2luZ2xlKHR5cGUsIHJlY29yZCwgb3B0aW9ucykuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIC8vIGJlIGF3YXJlIHRoYXQgYWxsT3JOb25lIGluIHBhcmFsbGVsIG1vZGUgd2lsbCBub3QgcmV2ZXJ0IHRoZSBvdGhlciBzdWNjZXNzZnVsIHJlcXVlc3RzXG4gICAgICAgIC8vIGl0IG9ubHkgcmFpc2VzIGVycm9yIHdoZW4gbWV0IGF0IGxlYXN0IG9uZSBmYWlsZWQgcmVxdWVzdC5cbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsT3JOb25lIHx8ICFlcnIuZXJyb3JDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90b1JlY29yZFJlc3VsdChyZWNvcmQuSWQsIGVycik7XG4gICAgICB9KTtcbiAgICB9KVxuICApO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fdXBkYXRlTWFueSA9IGZ1bmN0aW9uKHR5cGUsIHJlY29yZHMsIG9wdGlvbnMpIHtcbiAgaWYgKHJlY29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gIH1cbiAgaWYgKHJlY29yZHMubGVuZ3RoID4gTUFYX0RNTF9DT1VOVCAmJiBvcHRpb25zLmFsbG93UmVjdXJzaXZlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBzZWxmLl91cGRhdGVNYW55KHR5cGUsIHJlY29yZHMuc2xpY2UoMCwgTUFYX0RNTF9DT1VOVCksIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24ocmV0czEpIHtcbiAgICAgIHJldHVybiBzZWxmLl91cGRhdGVNYW55KHR5cGUsIHJlY29yZHMuc2xpY2UoTUFYX0RNTF9DT1VOVCksIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24ocmV0czIpIHtcbiAgICAgICAgcmV0dXJuIHJldHMxLmNvbmNhdChyZXRzMik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZWNvcmRzID0gXy5tYXAocmVjb3JkcywgZnVuY3Rpb24ocmVjb3JkKSB7XG4gICAgdmFyIGlkID0gcmVjb3JkLklkO1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVjb3JkIGlkIGlzIG5vdCBmb3VuZCBpbiByZWNvcmQuJyk7XG4gICAgfVxuICAgIHZhciBzb2JqZWN0VHlwZSA9IHR5cGUgfHwgKHJlY29yZC5hdHRyaWJ1dGVzICYmIHJlY29yZC5hdHRyaWJ1dGVzLnR5cGUpIHx8IHJlY29yZC50eXBlO1xuICAgIGlmICghc29iamVjdFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gU09iamVjdCBUeXBlIGRlZmluZWQgaW4gcmVjb3JkJyk7XG4gICAgfVxuICAgIHJlY29yZCA9IF8uY2xvbmUocmVjb3JkKTtcbiAgICBkZWxldGUgcmVjb3JkLklkO1xuICAgIHJlY29yZC5pZCA9IGlkO1xuICAgIGRlbGV0ZSByZWNvcmQudHlwZTtcbiAgICByZWNvcmQuYXR0cmlidXRlcyA9IHsgdHlwZSA6IHNvYmplY3RUeXBlIH07XG4gICAgcmV0dXJuIHJlY29yZDtcbiAgfSk7XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Jhc2VVcmwoKSwgXCJjb21wb3NpdGVcIiwgXCJzb2JqZWN0c1wiIF0uam9pbignLycpO1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHtcbiAgICBtZXRob2QgOiAnUEFUQ0gnLFxuICAgIHVybCA6IHVybCxcbiAgICBib2R5IDogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgYWxsT3JOb25lIDogb3B0aW9ucy5hbGxPck5vbmUgfHwgZmFsc2UsXG4gICAgICByZWNvcmRzIDogcmVjb3Jkc1xuICAgIH0pLFxuICAgIGhlYWRlcnMgOiBfLmRlZmF1bHRzKG9wdGlvbnMuaGVhZGVycyB8fCB7fSwge1xuICAgICAgXCJDb250ZW50LVR5cGVcIiA6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vKipcbiAqIFVwc2VydCByZWNvcmRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IFR5cGVcbiAqIEBwYXJhbSB7UmVjb3JkfEFycmF5LjxSZWNvcmQ+fSByZWNvcmRzIC0gUmVjb3JkIG9yIGFycmF5IG9mIHJlY29yZHMgdG8gdXBzZXJ0XG4gKiBAcGFyYW0ge1N0cmluZ30gZXh0SWRGaWVsZCAtIEV4dGVybmFsIElEIGZpZWxkIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciByZXN0IGFwaS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsT3JOb25lXSAtIElmIHRydWUsIGFueSBmYWlsZWQgcmVjb3JkcyBpbiBhIGNhbGwgY2F1c2UgYWxsIGNoYW5nZXMgZm9yIHRoZSBjYWxsIHRvIGJlIHJvbGxlZCBiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gLSBBZGRpdGlvbmFsIEhUVFAgcmVxdWVzdCBoZWFkZXJzIHNlbnQgaW4gcmV0cmlldmUgcmVxdWVzdFxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUudXBzZXJ0ID0gZnVuY3Rpb24odHlwZSwgcmVjb3JkcywgZXh0SWRGaWVsZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgLy8gWW91IGNhbiBvbWl0IFwidHlwZVwiIGFyZ3VtZW50LCB3aGVuIHRoZSByZWNvcmQgaW5jbHVkZXMgdHlwZSBpbmZvcm1hdGlvbi5cbiAgaWYgKCFfLmlzU3RyaW5nKHR5cGUpKSB7XG4gICAgLy8gcmV2ZXJzZSBvcmRlclxuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gZXh0SWRGaWVsZDtcbiAgICBleHRJZEZpZWxkID0gcmVjb3JkcztcbiAgICByZWNvcmRzID0gdHlwZTtcbiAgICB0eXBlID0gbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBpc0FycmF5ID0gXy5pc0FycmF5KHJlY29yZHMpO1xuICByZWNvcmRzID0gaXNBcnJheSA/IHJlY29yZHMgOiBbIHJlY29yZHMgXTtcbiAgaWYgKHJlY29yZHMubGVuZ3RoID4gdGhpcy5tYXhSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkV4Y2VlZGVkIG1heCBsaW1pdCBvZiBjb25jdXJyZW50IGNhbGxcIikpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgXy5tYXAocmVjb3JkcywgZnVuY3Rpb24ocmVjb3JkKSB7XG4gICAgICB2YXIgc29iamVjdFR5cGUgPSB0eXBlIHx8IChyZWNvcmQuYXR0cmlidXRlcyAmJiByZWNvcmQuYXR0cmlidXRlcy50eXBlKSB8fCByZWNvcmQudHlwZTtcbiAgICAgIHZhciBleHRJZCA9IHJlY29yZFtleHRJZEZpZWxkXTtcbiAgICAgIHJlY29yZCA9IF8uY2xvbmUocmVjb3JkKTtcbiAgICAgIGRlbGV0ZSByZWNvcmRbZXh0SWRGaWVsZF07XG4gICAgICBkZWxldGUgcmVjb3JkLnR5cGU7XG4gICAgICBkZWxldGUgcmVjb3JkLmF0dHJpYnV0ZXM7XG5cbiAgICAgIHZhciB1cmwgPSBbIHNlbGYuX2Jhc2VVcmwoKSwgXCJzb2JqZWN0c1wiLCBzb2JqZWN0VHlwZSwgZXh0SWRGaWVsZCwgZXh0SWQgXS5qb2luKCcvJyk7XG4gICAgICByZXR1cm4gc2VsZi5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kIDogJ1BBVENIJyxcbiAgICAgICAgdXJsIDogdXJsLFxuICAgICAgICBib2R5IDogSlNPTi5zdHJpbmdpZnkocmVjb3JkKSxcbiAgICAgICAgaGVhZGVycyA6IF8uZGVmYXVsdHMob3B0aW9ucy5oZWFkZXJzIHx8IHt9LCB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIiA6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0pXG4gICAgICB9LCB7XG4gICAgICAgIG5vQ29udGVudFJlc3BvbnNlOiB7IHN1Y2Nlc3MgOiB0cnVlLCBlcnJvcnMgOiBbXSB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAvLyBiZSBhd2FyZSB0aGF0IGBhbGxPck5vbmVgIG9wdGlvbiBpbiB1cHNlcnQgbWV0aG9kIHdpbGwgbm90IHJldmVydCB0aGUgb3RoZXIgc3VjY2Vzc2Z1bCByZXF1ZXN0c1xuICAgICAgICAvLyBpdCBvbmx5IHJhaXNlcyBlcnJvciB3aGVuIG1ldCBhdCBsZWFzdCBvbmUgZmFpbGVkIHJlcXVlc3QuXG4gICAgICAgIGlmICghaXNBcnJheSB8fCBvcHRpb25zLmFsbE9yTm9uZSB8fCAhZXJyLmVycm9yQ29kZSkgeyB0aHJvdyBlcnI7IH1cbiAgICAgICAgcmV0dXJuIHNlbGYuX3RvUmVjb3JkUmVzdWx0KG51bGwsIGVycik7XG4gICAgICB9KVxuICAgIH0pXG4gICkudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgcmV0dXJuICFpc0FycmF5ICYmIF8uaXNBcnJheShyZXN1bHRzKSA/IHJlc3VsdHNbMF0gOiByZXN1bHRzO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFN5bm9ueW0gb2YgQ29ubmVjdGlvbiNkZXN0cm95KClcbiAqXG4gKiBAbWV0aG9kIENvbm5lY3Rpb24jZGVsZXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGlkcyAtIEEgSUQgb3IgYXJyYXkgb2YgSURzIHRvIGRlbGV0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHJlc3QgYXBpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxPck5vbmVdIC0gSWYgdHJ1ZSwgYW55IGZhaWxlZCByZWNvcmRzIGluIGEgY2FsbCBjYXVzZSBhbGwgY2hhbmdlcyBmb3IgdGhlIGNhbGwgdG8gYmUgcm9sbGVkIGJhY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dSZWN1cnNpdmVdIC0gSWYgdHJ1ZSwgd2hlbiBpZHMgZ29lcyBvdmVyIHRoZSBtYXggbnVtIG9mIGNvbGxlY3Rpb24gQVBJICg9MjAwKSwgaWRzIGFyZSBkaXZpZGVkIGludG8gc2V2ZXJhbCBjaHVua3MgYW5kIHJlcXVlc3RlZCByZWN1cnNpdmVseS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgSFRUUCByZXF1ZXN0IGhlYWRlcnMgc2VudCBpbiByZXRyaWV2ZSByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2tcbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG4vKipcbiAqIFN5bm9ueW0gb2YgQ29ubmVjdGlvbiNkZXN0cm95KClcbiAqXG4gKiBAbWV0aG9kIENvbm5lY3Rpb24jZGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGlkcyAtIEEgSUQgb3IgYXJyYXkgb2YgSURzIHRvIGRlbGV0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHJlc3QgYXBpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxPck5vbmVdIC0gSWYgdHJ1ZSwgYW55IGZhaWxlZCByZWNvcmRzIGluIGEgY2FsbCBjYXVzZSBhbGwgY2hhbmdlcyBmb3IgdGhlIGNhbGwgdG8gYmUgcm9sbGVkIGJhY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dSZWN1cnNpdmVdIC0gSWYgdHJ1ZSwgd2hlbiBpZHMgZ29lcyBvdmVyIHRoZSBtYXggbnVtIG9mIGNvbGxlY3Rpb24gQVBJICg9MjAwKSwgaWRzIGFyZSBkaXZpZGVkIGludG8gc2V2ZXJhbCBjaHVua3MgYW5kIHJlcXVlc3RlZCByZWN1cnNpdmVseS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgSFRUUCByZXF1ZXN0IGhlYWRlcnMgc2VudCBpbiByZXRyaWV2ZSByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2tcbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG4vKipcbiAqIERlbGV0ZSByZWNvcmRzXG4gKlxuICogQG1ldGhvZCBDb25uZWN0aW9uI2Rlc3Ryb3lcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gU09iamVjdCBUeXBlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaWRzIC0gQSBJRCBvciBhcnJheSBvZiBJRHMgdG8gZGVsZXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgcmVzdCBhcGkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbE9yTm9uZV0gLSBJZiB0cnVlLCBhbnkgZmFpbGVkIHJlY29yZHMgaW4gYSBjYWxsIGNhdXNlIGFsbCBjaGFuZ2VzIGZvciB0aGUgY2FsbCB0byBiZSByb2xsZWQgYmFja1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1JlY3Vyc2l2ZV0gLSBJZiB0cnVlLCB3aGVuIGlkcyBnb2VzIG92ZXIgdGhlIG1heCBudW0gb2YgY29sbGVjdGlvbiBBUEkgKD0yMDApLCBpZHMgYXJlIGRpdmlkZWQgaW50byBzZXZlcmFsIGNodW5rcyBhbmQgcmVxdWVzdGVkIHJlY3Vyc2l2ZWx5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBIVFRQIHJlcXVlc3QgaGVhZGVycyBzZW50IGluIHJldHJpZXZlIHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFja1xuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlW1wiZGVsZXRlXCJdID1cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRlbCA9XG5Db25uZWN0aW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24odHlwZSwgaWRzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICByZXR1cm4gKFxuICAgIF8uaXNBcnJheShpZHMpID9cbiAgICAgICh0aGlzLl9zdXBwb3J0cygnc29iamVjdC1jb2xsZWN0aW9uJykgPyAvLyBjaGVjayB3aGV0aGVyIFNPYmplY3QgY29sbGVjdGlvbiBBUEkgaXMgc3VwcG9ydGVkXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lNYW55KHR5cGUsIGlkcywgb3B0aW9ucykgOlxuICAgICAgICB0aGlzLl9kZXN0cm95UGFyYWxsZWwodHlwZSwgaWRzLCBvcHRpb25zKSkgOlxuICAgICAgdGhpcy5fZGVzdHJveVNpbmdsZSh0eXBlLCBpZHMsIG9wdGlvbnMpXG4gICkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fZGVzdHJveVNpbmdsZSA9IGZ1bmN0aW9uKHR5cGUsIGlkLCBvcHRpb25zKSB7XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Jhc2VVcmwoKSwgXCJzb2JqZWN0c1wiLCB0eXBlLCBpZCBdLmpvaW4oJy8nKTtcbiAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgbWV0aG9kIDogJ0RFTEVURScsXG4gICAgdXJsIDogdXJsLFxuICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyB8fCBudWxsXG4gIH0sIHtcbiAgICBub0NvbnRlbnRSZXNwb25zZTogeyBpZCA6IGlkLCBzdWNjZXNzIDogdHJ1ZSwgZXJyb3JzIDogW10gfVxuICB9KTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2Rlc3Ryb3lQYXJhbGxlbCA9IGZ1bmN0aW9uKHR5cGUsIGlkcywgb3B0aW9ucykge1xuICBpZiAoaWRzLmxlbmd0aCA+IHRoaXMubWF4UmVxdWVzdCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJFeGNlZWRlZCBtYXggbGltaXQgb2YgY29uY3VycmVudCBjYWxsXCIpKTtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICBpZHMubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gc2VsZi5fZGVzdHJveVNpbmdsZSh0eXBlLCBpZCwgb3B0aW9ucykuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIC8vIGJlIGF3YXJlIHRoYXQgYGFsbE9yTm9uZWAgb3B0aW9uIGluIHBhcmFsbGVsIG1vZGUgd2lsbCBub3QgcmV2ZXJ0IHRoZSBvdGhlciBzdWNjZXNzZnVsIHJlcXVlc3RzXG4gICAgICAgIC8vIGl0IG9ubHkgcmFpc2VzIGVycm9yIHdoZW4gbWV0IGF0IGxlYXN0IG9uZSBmYWlsZWQgcmVxdWVzdC5cbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsT3JOb25lIHx8ICFlcnIuZXJyb3JDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90b1JlY29yZFJlc3VsdChpZCwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pXG4gICk7XG59O1xuXG5cbi8qKiBAcHJpdmF0ZSAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2Rlc3Ryb3lNYW55ID0gZnVuY3Rpb24odHlwZSwgaWRzLCBvcHRpb25zKSB7XG4gIGlmIChpZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gIH1cbiAgaWYgKGlkcy5sZW5ndGggPiBNQVhfRE1MX0NPVU5UICYmIG9wdGlvbnMuYWxsb3dSZWN1cnNpdmUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHNlbGYuX2Rlc3Ryb3lNYW55KHR5cGUsIGlkcy5zbGljZSgwLCBNQVhfRE1MX0NPVU5UKSwgb3B0aW9ucykudGhlbihmdW5jdGlvbihyZXRzMSkge1xuICAgICAgcmV0dXJuIHNlbGYuX2Rlc3Ryb3lNYW55KHR5cGUsIGlkcy5zbGljZShNQVhfRE1MX0NPVU5UKSwgb3B0aW9ucykudGhlbihmdW5jdGlvbihyZXRzMikge1xuICAgICAgICByZXR1cm4gcmV0czEuY29uY2F0KHJldHMyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Jhc2VVcmwoKSwgXCJjb21wb3NpdGVcIiwgXCJzb2JqZWN0cz9pZHM9XCIgXS5qb2luKCcvJykgKyBpZHMuam9pbignLCcpO1xuICBpZiAob3B0aW9ucy5hbGxPck5vbmUpIHtcbiAgICB1cmwgKz0gJyZhbGxPck5vbmU9dHJ1ZSc7XG4gIH1cbiAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgbWV0aG9kIDogJ0RFTEVURScsXG4gICAgdXJsIDogdXJsLFxuICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyB8fCBudWxsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIHNlYXJjaCBieSBTT1NMXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNvc2wgLSBTT1NMIHN0cmluZ1xuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKHNvc2wsIGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSB0aGlzLl9iYXNlVXJsKCkgKyBcIi9zZWFyY2g/cT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChzb3NsKTtcbiAgcmV0dXJuIHRoaXMucmVxdWVzdCh1cmwpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmVzdWx0IHJldHVybmVkIGJ5IGRlc2NyaWJlU09iamVjdCBjYWxsXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRGVzY3JpYmVTT2JqZWN0UmVzdWx0XG4gKi9cbi8qKlxuICogUGFyYW1ldGVyIGZvciBkZXNjcmliZVNPYmplY3QgY2FsbFxuICogXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZXNjcmliZVNPYmplY3RPcHRpb25zXG4gKi9cbi8qKlxuICogU3lub255bSBvZiBDb25uZWN0aW9uI2Rlc2NyaWJlKClcbiAqXG4gKiBAbWV0aG9kIENvbm5lY3Rpb24jZGVzY3JpYmVTT2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ3xEZXNjcmliZVNPYmplY3RPcHRpb25zfSB0eXBlIC0gU09iamVjdCBUeXBlIG9yIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZS50eXBlIC0gVGhlIG5hbWUgb2YgdGhlIFNPYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlLmlmTW9kaWZpZWRTaW5jZSAtIERhdGUgdmFsdWUgZm9yIElmLU1vZGlmaWVkLVNpbmNlIGhlYWRlcjsgdW5kZWZpbmVkIHJlc29sdmVkIGlmIG5vdCBtb2RpZmllZCBhZnRlciB0aGlzIGRhdGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPERlc2NyaWJlU09iamVjdFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPERlc2NyaWJlU09iamVjdFJlc3VsdD59XG4gKi9cbi8qKlxuICogRGVzY3JpYmUgU09iamVjdCBtZXRhZGF0YVxuICpcbiAqIEBtZXRob2QgQ29ubmVjdGlvbiNkZXNjcmliZVxuICogQHBhcmFtIHtTdHJpbmd8RGVzY3JpYmVTT2JqZWN0T3B0aW9uc30gdHlwZSAtIFNPYmplY3QgVHlwZSBvciBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUudHlwZSAtIFRoZSBuYW1lIG9mIHRoZSBTT2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZS5pZk1vZGlmaWVkU2luY2UgLSBEYXRlIHZhbHVlIGZvciBJZi1Nb2RpZmllZC1TaW5jZSBoZWFkZXI7IHVuZGVmaW5lZCByZXNvbHZlZCBpZiBub3QgbW9kaWZpZWQgYWZ0ZXIgdGhpcyBkYXRlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxEZXNjcmliZVNPYmplY3RSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxEZXNjcmliZVNPYmplY3RSZXN1bHQ+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5kZXNjcmliZSA9XG5Db25uZWN0aW9uLnByb3RvdHlwZS5kZXNjcmliZVNPYmplY3QgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaykge1xuICB2YXIgbmFtZSA9IHR5cGUudHlwZSA/IHR5cGUudHlwZSA6IHR5cGU7XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Jhc2VVcmwoKSwgXCJzb2JqZWN0c1wiLCBuYW1lLCBcImRlc2NyaWJlXCIgXS5qb2luKCcvJyk7XG4gIHZhciBoZWFkZXJzID0gdHlwZS5pZk1vZGlmaWVkU2luY2UgXG4gICAgPyB7ICdJZi1Nb2RpZmllZC1TaW5jZSc6IHR5cGUuaWZNb2RpZmllZFNpbmNlIH0gXG4gICAgOiB7fTtcbiAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICB1cmw6IHVybCxcbiAgICBoZWFkZXJzOiBoZWFkZXJzXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3ApIHtcbiAgICBpZiAocmVzcCA9PT0gJycpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwKTtcbiAgICB9XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmVzdWx0IHJldHVybmVkIGJ5IGJhdGNoRGVzY3JpYmVTT2JqZWN0cyBjYWxsXG4gKlxuICogQHR5cGVkZWYge09iamVjdFtdfSBEZXNjcmliZVNPYmplY3RSZXN1bHRcbiAqL1xuLyoqXG4gKiBQYXJhbWV0ZXIgZm9yIGRlc2NyaWJlU09iamVjdCBjYWxsXG4gKiBcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJhdGNoRGVzY3JpYmVTT2JqZWN0T3B0aW9uc1xuICovXG4vKipcbiAqIFN5bm9ueW0gb2YgQ29ubmVjdGlvbiNiYXRjaERlc2NyaWJlKClcbiAqXG4gKiBAbWV0aG9kIENvbm5lY3Rpb24jYmF0Y2hEZXNjcmliZVNPYmplY3RzXG4gKiBAcGFyYW0ge0JhdGNoRGVzY3JpYmVTT2JqZWN0T3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBvcHRpb25zLnR5cGVzIC0gbmFtZXMgb2Ygb2JqZWN0cyB0byBmZXRjaFxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmF1dG9mZXRjaCAtIHdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBmZXRjaCBtZXRhZGF0YSBmb3IgbGFyZ2UgbnVtYmVycyBvZiBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzIChvbmUgYmF0Y2ggcmVxdWVzdCByZXR1cm5zIGEgbWF4aW11bSBvZiAyNSByZXN1bHRzKTsgd2hlbiB0cnVlLCB3aWxsIG1ha2UgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzZXF1ZW50IHJlcXVlc3RzIHVudGlsIGFsbCBvYmplY3QgbWV0YWRhdGEgaXMgZmV0Y2hlZDsgd2hlbiBmYWxzZSAoZGVmYXVsdCksIFxuICogICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBtYWtlIG9uZSBiYXRjaCByZXF1ZXN0IGZvciBtYXhpbXVtIG9mIDI1IHJlc3VsdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1heENvbmN1cnJlbnRSZXF1ZXN0cyAtIG1heGltdW0gbnVtYmVyIG9mIGNvbmN1cnJlbnQgcmVxdWVzdHMgc2VudCB0byB0aGUgb3JnOyBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgYW5kIG1heGltdW0gaXMgMTVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPERlc2NyaWJlU09iamVjdFJlc3VsdFtdPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48RGVzY3JpYmVTT2JqZWN0UmVzdWx0W10+fVxuICovXG4vKipcbiAqIEJhdGNoIGRlc2NyaWJlIFNPYmplY3QgbWV0YWRhdGFcbiAqXG4gKiBAbWV0aG9kIENvbm5lY3Rpb24jYmF0Y2hEZXNjcmliZVxuICogQHBhcmFtIHtCYXRjaERlc2NyaWJlU09iamVjdE9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBmdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmdbXX0gb3B0aW9ucy50eXBlcyAtIG5hbWVzIG9mIG9iamVjdHMgdG8gZmV0Y2hcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5hdXRvZmV0Y2ggLSB3aGV0aGVyIHRvIGF1dG9tYXRpY2FsbHkgZmV0Y2ggbWV0YWRhdGEgZm9yIGxhcmdlIG51bWJlcnMgb2YgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlcyAob25lIGJhdGNoIHJlcXVlc3QgcmV0dXJucyBhIG1heGltdW0gb2YgMjUgcmVzdWx0cyk7IHdoZW4gdHJ1ZSwgd2lsbCBtYWtlIFxuICogICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2VxdWVudCByZXF1ZXN0cyB1bnRpbCBhbGwgb2JqZWN0IG1ldGFkYXRhIGlzIGZldGNoZWQ7IHdoZW4gZmFsc2UgKGRlZmF1bHQpLCBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgbWFrZSBvbmUgYmF0Y2ggcmVxdWVzdCBmb3IgbWF4aW11bSBvZiAyNSByZXN1bHRzXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tYXhDb25jdXJyZW50UmVxdWVzdHMgLSBtYXhpbXVtIG51bWJlciBvZiBjb25jdXJyZW50IHJlcXVlc3RzIHNlbnQgdG8gdGhlIG9yZzsgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IGFuZCBtYXhpbXVtIGlzIDE1XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxEZXNjcmliZVNPYmplY3RSZXN1bHRbXT59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPERlc2NyaWJlU09iamVjdFJlc3VsdFtdPn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuYmF0Y2hEZXNjcmliZSA9IENvbm5lY3Rpb24ucHJvdG90eXBlLmJhdGNoRGVzY3JpYmVTT2JqZWN0cyA9IGZ1bmN0aW9uIChcbiAgb3B0aW9ucyxcbiAgY2FsbGJhY2tcbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0eXBlcyA9IG9wdGlvbnMudHlwZXM7XG4gIHZhciBhdXRvZmV0Y2ggPSBvcHRpb25zLmF1dG9mZXRjaCB8fCBmYWxzZTtcbiAgdmFyIG1heENvbmN1cnJlbnRSZXF1ZXN0cyA9IE1hdGgubWluKChvcHRpb25zLm1heENvbmN1cnJlbnRSZXF1ZXN0cyB8fCAxNSksIDE1KTtcbiAgdmFyIGJhdGNoZXMgPSBbXTtcbiAgZG8ge1xuICAgIHZhciBiYXRjaCA9IHR5cGVzLmxlbmd0aCA+IE1BWF9CQVRDSF9SRVFVRVNUUyA/IHR5cGVzLnNsaWNlKDAsIE1BWF9CQVRDSF9SRVFVRVNUUykgOiB0eXBlcztcbiAgICBiYXRjaGVzLnB1c2goYmF0Y2gpO1xuICAgIHR5cGVzID0gdHlwZXMubGVuZ3RoID4gTUFYX0JBVENIX1JFUVVFU1RTID8gdHlwZXMuc2xpY2UoTUFYX0JBVENIX1JFUVVFU1RTKSA6IFtdO1xuICB9IHdoaWxlICh0eXBlcy5sZW5ndGggPiAwICYmIGF1dG9mZXRjaCk7XG4gIHZhciByZXF1ZXN0QmF0Y2hlcyA9IFtdO1xuICBkbyB7XG4gICAgdmFyIHJlcXVlc3RCYXRjaCA9IGJhdGNoZXMubGVuZ3RoID4gbWF4Q29uY3VycmVudFJlcXVlc3RzID8gYmF0Y2hlcy5zbGljZSgwLCBtYXhDb25jdXJyZW50UmVxdWVzdHMpIDogYmF0Y2hlcztcbiAgICByZXF1ZXN0QmF0Y2hlcy5wdXNoKHJlcXVlc3RCYXRjaCk7XG4gICAgYmF0Y2hlcyA9IGJhdGNoZXMubGVuZ3RoID4gbWF4Q29uY3VycmVudFJlcXVlc3RzID8gYmF0Y2hlcy5zbGljZShtYXhDb25jdXJyZW50UmVxdWVzdHMpIDogW107XG4gIH0gd2hpbGUgKGJhdGNoZXMubGVuZ3RoID4gMCk7XG4gIHJldHVybiBzZWxmLmRvQmF0Y2hEZXNjcmliZVJlcXVlc3RCYXRjaGVzKHJlcXVlc3RCYXRjaGVzKVxuICAgIC50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5kb0JhdGNoRGVzY3JpYmVSZXF1ZXN0QmF0Y2hlcyA9IGZ1bmN0aW9uKHJlcXVlc3RCYXRjaGVzKSB7XG4gIC8vIG1ha2UgZWFjaCBiYXRjaCBvZiByZXF1ZXN0cyBzZXF1ZW50aWFsbHkgdG8gYXZvaWQgb3JnIGxpbWl0cyBvZiBtYXggY29uY3VycmVudCByZXF1ZXN0c1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzb2JqZWN0cyA9IFtdO1xuICB2YXIgZmlyc3RCYXRjaCA9IHJlcXVlc3RCYXRjaGVzLnNoaWZ0KCk7XG4gIHJldHVybiBzZWxmLmRvQmF0Y2hPZkJhdGNoRGVzY3JpYmVSZXF1ZXN0cyhmaXJzdEJhdGNoKS50aGVuKFxuICAgIGZ1bmN0aW9uIChzb2JqZWN0QXJyYXkpIHtcbiAgICAgIHNvYmplY3RBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChzb2JqZWN0KSB7IHNvYmplY3RzLnB1c2goc29iamVjdCk7IH0pO1xuICAgICAgaWYgKHJlcXVlc3RCYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZG9CYXRjaERlc2NyaWJlUmVxdWVzdEJhdGNoZXMocmVxdWVzdEJhdGNoZXMpLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7IHNvYmplY3RzLnB1c2gocmVzdWx0KTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNvYmplY3RzKTtcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc29iamVjdHMpO1xuICAgICAgfVxuICAgIH1cbiAgKVxufVxuXG4vKiogcHJpdmF0ZSAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuZG9CYXRjaE9mQmF0Y2hEZXNjcmliZVJlcXVlc3RzID0gZnVuY3Rpb24ocmVxdWVzdEJhdGNoKSB7XG4gIC8vIG1ha2UgdXAgdG8gbWF4Q29uY3VycmVudFJlcXVlc3QgcmVxdWVzdHMgaW4gcGFyYWxsZWxcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgcmVxdWVzdEJhdGNoLm1hcChmdW5jdGlvbiAoYmF0Y2gpIHsgcmV0dXJuIHNlbGYuZG9CYXRjaERlc2NyaWJlUmVxdWVzdChiYXRjaCk7IH0gKVxuICApLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICB2YXIgc29iamVjdHMgPSBbXTtcbiAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24gKHNvYmplY3RBcnJheSkge1xuICAgICAgc29iamVjdEFycmF5LmZvckVhY2goZnVuY3Rpb24gKHNvYmplY3QpIHsgc29iamVjdHMucHVzaChzb2JqZWN0KTsgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNvYmplY3RzKTtcbn0pO1xufVxuXG4vKiogcHJpdmF0ZSAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuZG9CYXRjaERlc2NyaWJlUmVxdWVzdCA9IGZ1bmN0aW9uKHR5cGVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNvYmplY3RzID0gW107XG4gIHZhciB1cmwgPSBbc2VsZi5fYmFzZVVybCgpLCBcImNvbXBvc2l0ZS9iYXRjaFwiXS5qb2luKFwiL1wiKTtcbiAgdmFyIHZlcnNpb24gPSBcInZcIiArIHNlbGYudmVyc2lvbjtcbiAgdmFyIGJhdGNoUmVxdWVzdHMgPSBbXTtcbiAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGJhdGNoUmVxdWVzdHMucHVzaCh7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICB1cmw6IFt2ZXJzaW9uLCBcInNvYmplY3RzXCIsIHR5cGUsIFwiZGVzY3JpYmVcIl0uam9pbihcIi9cIilcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiB1cmwsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBiYXRjaFJlcXVlc3RzOiBiYXRjaFJlcXVlc3RzIH0pLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfVxuICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5yZXN1bHRzKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3BvbnNlLnJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN1YlJlc3AgPSByZXNwb25zZS5yZXN1bHRzW2ldO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJSZXNwLnJlc3VsdCkpIHtcbiAgICAgICAgICBpZiAoc3ViUmVzcC5yZXN1bHRbMF0uZXJyb3JDb2RlICYmIHN1YlJlc3AucmVzdWx0WzBdLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgJ0Vycm9yOiAnICsgc3ViUmVzcC5yZXN1bHRbMF0uZXJyb3JDb2RlICsgJyAnICsgIFxuICAgICAgICAgICAgICBzdWJSZXNwLnJlc3VsdFswXS5tZXNzYWdlICsgJyAtICcgKyB0eXBlc1RvRmV0Y2hbaV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvYmplY3RzLnB1c2goc3ViUmVzcC5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc29iamVjdHMpO1xuICB9KTsgXG59XG5cbi8qKlxuICogUmVzdWx0IHJldHVybmVkIGJ5IGRlc2NyaWJlR2xvYmFsIGNhbGxcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZXNjcmliZUdsb2JhbFJlc3VsdFxuICovXG4vKipcbiAqIERlc2NyaWJlIGdsb2JhbCBTT2JqZWN0c1xuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPERlc2NyaWJlR2xvYmFsUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48RGVzY3JpYmVHbG9iYWxSZXN1bHQ+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5kZXNjcmliZUdsb2JhbCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSB0aGlzLl9iYXNlVXJsKCkgKyBcIi9zb2JqZWN0c1wiO1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuXG4vKipcbiAqIEdldCBTT2JqZWN0IGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IFR5cGVcbiAqIEByZXR1cm5zIHtTT2JqZWN0fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zb2JqZWN0ID0gZnVuY3Rpb24odHlwZSkge1xuICB0aGlzLnNvYmplY3RzID0gdGhpcy5zb2JqZWN0cyB8fCB7fTtcbiAgdmFyIHNvYmplY3QgPSB0aGlzLnNvYmplY3RzW3R5cGVdID1cbiAgICB0aGlzLnNvYmplY3RzW3R5cGVdIHx8IG5ldyBTT2JqZWN0KHRoaXMsIHR5cGUpO1xuICByZXR1cm4gc29iamVjdDtcbn07XG5cbi8qKlxuICogR2V0IGlkZW50aXR5IGluZm9ybWF0aW9uIG9mIGN1cnJlbnQgdXNlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBJZGVudGl0eSBjYWxsIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgSFRUUCByZXF1ZXN0IGhlYWRlcnMgc2VudCBpbiBpZGVudGl0eSByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxJZGVudGl0eUluZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxJZGVudGl0eUluZm8+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5pZGVudGl0eSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGlkVXJsID0gdGhpcy51c2VySW5mbyAmJiB0aGlzLnVzZXJJbmZvLnVybDtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICBpZFVybCA/XG4gICAgeyBpZGVudGl0eTogaWRVcmwgfSA6XG4gICAgdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnR0VUJywgdXJsOiB0aGlzLl9iYXNlVXJsKCksIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyB9KVxuICApLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgdmFyIHVybCA9IHJlcy5pZGVudGl0eTtcbiAgICByZXR1cm4gc2VsZi5yZXF1ZXN0KHsgbWV0aG9kOiAnR0VUJywgdXJsOiB1cmwgfSk7XG4gIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgc2VsZi51c2VySW5mbyA9IHtcbiAgICAgIGlkOiByZXMudXNlcl9pZCxcbiAgICAgIG9yZ2FuaXphdGlvbklkOiByZXMub3JnYW5pemF0aW9uX2lkLFxuICAgICAgdXJsOiByZXMuaWRcbiAgICB9O1xuICAgIHJldHVybiByZXM7XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgVXNlckluZm9cbiAqIEBwcm9wIHtTdHJpbmd9IGlkIC0gVXNlciBJRFxuICogQHByb3Age1N0cmluZ30gb3JnYW5pemF0aW9uSWQgLSBPcmdhbml6YXRpb24gSURcbiAqIEBwcm9wIHtTdHJpbmd9IHVybCAtIElkZW50aXR5IFVSTCBvZiB0aGUgdXNlclxuICovXG5cbi8qKlxuICogQXV0aG9yaXplICh1c2luZyBvYXV0aDIgd2ViIHNlcnZlciBmbG93KVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlIC0gQXV0aG9yaXphdGlvbiBjb2RlXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzIHRvIHNlbmQgaW4gdG9rZW4gcmV0cmlldmFsXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5jb2RlX3ZlcmlmaWVyXSAtIENvZGUgdmVyaWZpZXIgdmFsdWUgKFJGQyA3NjM2IC0gUHJvb2YgS2V5IG9mIENvZGUgRXhjaGFuZ2UpXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxVc2VySW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFVzZXJJbmZvPn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuYXV0aG9yaXplID0gZnVuY3Rpb24oY29kZSwgcGFyYW1zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxvZ2dlciA9IHRoaXMuX2xvZ2dlcjtcblxuICByZXR1cm4gdGhpcy5vYXV0aDIucmVxdWVzdFRva2VuKGNvZGUsIHBhcmFtcykudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICB2YXIgdXNlckluZm8gPSBwYXJzZUlkVXJsKHJlcy5pZCk7XG4gICAgc2VsZi5pbml0aWFsaXplKHtcbiAgICAgIGluc3RhbmNlVXJsIDogcmVzLmluc3RhbmNlX3VybCxcbiAgICAgIGFjY2Vzc1Rva2VuIDogcmVzLmFjY2Vzc190b2tlbixcbiAgICAgIHJlZnJlc2hUb2tlbiA6IHJlcy5yZWZyZXNoX3Rva2VuLFxuICAgICAgdXNlckluZm86IHVzZXJJbmZvXG4gICAgfSk7XG4gICAgbG9nZ2VyLmRlYnVnKFwiPGxvZ2luPiBjb21wbGV0ZWQuIHVzZXIgaWQgPSBcIiArIHVzZXJJbmZvLmlkICsgXCIsIG9yZyBpZCA9IFwiICsgdXNlckluZm8ub3JnYW5pemF0aW9uSWQpO1xuICAgIHJldHVybiB1c2VySW5mbztcblxuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG5cbn07XG5cblxuLyoqXG4gKiBMb2dpbiB0byBTYWxlc2ZvcmNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lIC0gU2FsZXNmb3JjZSB1c2VybmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhc3N3b3JkIC0gU2FsZXNmb3JjZSBwYXNzd29yZCAoYW5kIHNlY3VyaXR5IHRva2VuLCBpZiByZXF1aXJlZClcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFVzZXJJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48VXNlckluZm8+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBwYXNzd29yZCwgY2FsbGJhY2spIHtcbiAgLy8gcmVnaXN0ZXIgcmVmcmVzaERlbGVnYXRlIGZvciBzZXNzaW9uIGV4cGlyYXRpb25cbiAgdGhpcy5fcmVmcmVzaERlbGVnYXRlID0gbmV3IEh0dHBBcGkuU2Vzc2lvblJlZnJlc2hEZWxlZ2F0ZSh0aGlzLCBjcmVhdGVVc2VybmFtZVBhc3N3b3JkUmVmcmVzaEZuKHVzZXJuYW1lLCBwYXNzd29yZCkpO1xuICBpZiAodGhpcy5vYXV0aDIgJiYgdGhpcy5vYXV0aDIuY2xpZW50SWQgJiYgdGhpcy5vYXV0aDIuY2xpZW50U2VjcmV0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9naW5CeU9BdXRoMih1c2VybmFtZSwgcGFzc3dvcmQsIGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5sb2dpbkJ5U29hcCh1c2VybmFtZSwgcGFzc3dvcmQsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqIEBwcml2YXRlICoqL1xuZnVuY3Rpb24gY3JlYXRlVXNlcm5hbWVQYXNzd29yZFJlZnJlc2hGbih1c2VybmFtZSwgcGFzc3dvcmQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbm4sIGNhbGxiYWNrKSB7XG4gICAgY29ubi5sb2dpbih1c2VybmFtZSwgcGFzc3dvcmQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgY29ubi5hY2Nlc3NUb2tlbik7XG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogTG9naW4gYnkgT0F1dGgyIHVzZXJuYW1lICYgcGFzc3dvcmQgZmxvd1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZSAtIFNhbGVzZm9yY2UgdXNlcm5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCAtIFNhbGVzZm9yY2UgcGFzc3dvcmQgKGFuZCBzZWN1cml0eSB0b2tlbiwgaWYgcmVxdWlyZWQpXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxVc2VySW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFVzZXJJbmZvPn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUubG9naW5CeU9BdXRoMiA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBwYXNzd29yZCwgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbG9nZ2VyID0gdGhpcy5fbG9nZ2VyO1xuICByZXR1cm4gdGhpcy5vYXV0aDIuYXV0aGVudGljYXRlKHVzZXJuYW1lLCBwYXNzd29yZCkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICB2YXIgdXNlckluZm8gPSBwYXJzZUlkVXJsKHJlcy5pZCk7XG4gICAgc2VsZi5pbml0aWFsaXplKHtcbiAgICAgIGluc3RhbmNlVXJsIDogcmVzLmluc3RhbmNlX3VybCxcbiAgICAgIGFjY2Vzc1Rva2VuIDogcmVzLmFjY2Vzc190b2tlbixcbiAgICAgIHVzZXJJbmZvOiB1c2VySW5mb1xuICAgIH0pO1xuICAgIGxvZ2dlci5kZWJ1ZyhcIjxsb2dpbj4gY29tcGxldGVkLiB1c2VyIGlkID0gXCIgKyB1c2VySW5mby5pZCArIFwiLCBvcmcgaWQgPSBcIiArIHVzZXJJbmZvLm9yZ2FuaXphdGlvbklkKTtcbiAgICByZXR1cm4gdXNlckluZm87XG5cbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xuXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVzYyhzdHIpIHtcbiAgcmV0dXJuIHN0ciAmJiBTdHJpbmcoc3RyKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59XG5cbi8qKlxuICogTG9naW4gYnkgU09BUCB3ZWIgc2VydmljZSBBUElcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUgLSBTYWxlc2ZvcmNlIHVzZXJuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQgLSBTYWxlc2ZvcmNlIHBhc3N3b3JkIChhbmQgc2VjdXJpdHkgdG9rZW4sIGlmIHJlcXVpcmVkKVxuICogQHBhcmFtIHtDYWxsYmFjay48VXNlckluZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxVc2VySW5mbz59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmxvZ2luQnlTb2FwID0gZnVuY3Rpb24odXNlcm5hbWUsIHBhc3N3b3JkLCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsb2dnZXIgPSB0aGlzLl9sb2dnZXI7XG4gIHZhciBib2R5ID0gW1xuICAgICc8c2U6RW52ZWxvcGUgeG1sbnM6c2U9XCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy9zb2FwL2VudmVsb3BlL1wiPicsXG4gICAgICAnPHNlOkhlYWRlci8+JyxcbiAgICAgICc8c2U6Qm9keT4nLFxuICAgICAgICAnPGxvZ2luIHhtbG5zPVwidXJuOnBhcnRuZXIuc29hcC5zZm9yY2UuY29tXCI+JyxcbiAgICAgICAgICAnPHVzZXJuYW1lPicgKyBlc2ModXNlcm5hbWUpICsgJzwvdXNlcm5hbWU+JyxcbiAgICAgICAgICAnPHBhc3N3b3JkPicgKyBlc2MocGFzc3dvcmQpICsgJzwvcGFzc3dvcmQ+JyxcbiAgICAgICAgJzwvbG9naW4+JyxcbiAgICAgICc8L3NlOkJvZHk+JyxcbiAgICAnPC9zZTpFbnZlbG9wZT4nXG4gIF0uam9pbignJyk7XG5cbiAgdmFyIHNvYXBMb2dpbkVuZHBvaW50ID0gWyB0aGlzLmxvZ2luVXJsLCBcInNlcnZpY2VzL1NvYXAvdVwiLCB0aGlzLnZlcnNpb24gXS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5odHRwUmVxdWVzdCh7XG4gICAgbWV0aG9kIDogJ1BPU1QnLFxuICAgIHVybCA6IHNvYXBMb2dpbkVuZHBvaW50LFxuICAgIGJvZHkgOiBib2R5LFxuICAgIGhlYWRlcnMgOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiIDogXCJ0ZXh0L3htbFwiLFxuICAgICAgXCJTT0FQQWN0aW9uXCIgOiAnXCJcIidcbiAgICB9XG4gIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgIG0gPSByZXNwb25zZS5ib2R5Lm1hdGNoKC88ZmF1bHRzdHJpbmc+KFtePF0rKTxcXC9mYXVsdHN0cmluZz4vKTtcbiAgICAgIHZhciBmYXVsdHN0cmluZyA9IG0gJiYgbVsxXTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmYXVsdHN0cmluZyB8fCByZXNwb25zZS5ib2R5KTtcbiAgICB9XG4gICAgbG9nZ2VyLmRlYnVnKFwiU09BUCByZXNwb25zZSA9IFwiICsgcmVzcG9uc2UuYm9keSk7XG4gICAgbSA9IHJlc3BvbnNlLmJvZHkubWF0Y2goLzxzZXJ2ZXJVcmw+KFtePF0rKTxcXC9zZXJ2ZXJVcmw+Lyk7XG4gICAgdmFyIHNlcnZlclVybCA9IG0gJiYgbVsxXTtcbiAgICBtID0gcmVzcG9uc2UuYm9keS5tYXRjaCgvPHNlc3Npb25JZD4oW148XSspPFxcL3Nlc3Npb25JZD4vKTtcbiAgICB2YXIgc2Vzc2lvbklkID0gbSAmJiBtWzFdO1xuICAgIG0gPSByZXNwb25zZS5ib2R5Lm1hdGNoKC88dXNlcklkPihbXjxdKyk8XFwvdXNlcklkPi8pO1xuICAgIHZhciB1c2VySWQgPSBtICYmIG1bMV07XG4gICAgbSA9IHJlc3BvbnNlLmJvZHkubWF0Y2goLzxvcmdhbml6YXRpb25JZD4oW148XSspPFxcL29yZ2FuaXphdGlvbklkPi8pO1xuICAgIHZhciBvcmdJZCA9IG0gJiYgbVsxXTtcbiAgICB2YXIgaWRVcmwgPSBzb2FwTG9naW5FbmRwb2ludC5zcGxpdCgnLycpLnNsaWNlKDAsIDMpLmpvaW4oJy8nKTtcbiAgICBpZFVybCArPSBcIi9pZC9cIiArIG9yZ0lkICsgXCIvXCIgKyB1c2VySWQ7XG4gICAgdmFyIHVzZXJJbmZvID0ge1xuICAgICAgaWQ6IHVzZXJJZCxcbiAgICAgIG9yZ2FuaXphdGlvbklkOiBvcmdJZCxcbiAgICAgIHVybDogaWRVcmxcbiAgICB9O1xuICAgIHNlbGYuaW5pdGlhbGl6ZSh7XG4gICAgICBzZXJ2ZXJVcmw6IHNlcnZlclVybC5zcGxpdCgnLycpLnNsaWNlKDAsIDMpLmpvaW4oJy8nKSxcbiAgICAgIHNlc3Npb25JZDogc2Vzc2lvbklkLFxuICAgICAgdXNlckluZm86IHVzZXJJbmZvXG4gICAgfSk7XG4gICAgbG9nZ2VyLmRlYnVnKFwiPGxvZ2luPiBjb21wbGV0ZWQuIHVzZXIgaWQgPSBcIiArIHVzZXJJZCArIFwiLCBvcmcgaWQgPSBcIiArIG9yZ0lkKTtcbiAgICByZXR1cm4gdXNlckluZm87XG5cbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xuXG59O1xuXG4vKipcbiAqIExvZ291dCB0aGUgY3VycmVudCBzZXNzaW9uIFxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Jldm9rZV0gLSBSZXZva2VzIEFQSSBBY2Nlc3MgaWYgc2V0IHRvIHRydWVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPHVuZGVmaW5lZD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPHVuZGVmaW5lZD59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmxvZ291dCA9IGZ1bmN0aW9uKHJldm9rZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiByZXZva2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHJldm9rZTtcbiAgICByZXZva2UgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl9zZXNzaW9uVHlwZSA9PT0gXCJvYXV0aDJcIikge1xuICAgIHJldHVybiB0aGlzLmxvZ291dEJ5T0F1dGgyKHJldm9rZSwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmxvZ291dEJ5U29hcChyZXZva2UsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMb2dvdXQgdGhlIGN1cnJlbnQgc2Vzc2lvbiBieSByZXZva2luZyBhY2Nlc3MgdG9rZW4gdmlhIE9BdXRoMiBzZXNzaW9uIHJldm9rZVxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Jldm9rZV0gLSBSZXZva2VzIEFQSSBBY2Nlc3MgaWYgc2V0IHRvIHRydWVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPHVuZGVmaW5lZD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPHVuZGVmaW5lZD59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmxvZ291dEJ5T0F1dGgyID0gZnVuY3Rpb24ocmV2b2tlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHJldm9rZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcmV2b2tlO1xuICAgIHJldm9rZSA9IGZhbHNlO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxvZ2dlciA9IHRoaXMuX2xvZ2dlcjtcblxuICByZXR1cm4gdGhpcy5vYXV0aDIucmV2b2tlVG9rZW4ocmV2b2tlID8gdGhpcy5yZWZyZXNoVG9rZW4gOiB0aGlzLmFjY2Vzc1Rva2VuKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIC8vIERlc3Ryb3kgdGhlIHNlc3Npb24gYm91bmQgdG8gdGhpcyBjb25uZWN0aW9uXG4gICAgc2VsZi5hY2Nlc3NUb2tlbiA9IG51bGw7XG4gICAgc2VsZi51c2VySW5mbyA9IG51bGw7XG4gICAgc2VsZi5yZWZyZXNoVG9rZW4gPSBudWxsO1xuICAgIHNlbGYuaW5zdGFuY2VVcmwgPSBudWxsO1xuICAgIHNlbGYuY2FjaGUuY2xlYXIoKTtcblxuICAgIC8vIG5vdGhpbmcgdXNlZnVsIHJldHVybmVkIGJ5IGxvZ291dCBBUEksIGp1c3QgcmV0dXJuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuXG4vKipcbiAqIExvZ291dCB0aGUgc2Vzc2lvbiBieSB1c2luZyBTT0FQIHdlYiBzZXJ2aWNlIEFQSVxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Jldm9rZV0gLSBSZXZva2VzIEFQSSBBY2Nlc3MgaWYgc2V0IHRvIHRydWVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPHVuZGVmaW5lZD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPHVuZGVmaW5lZD59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmxvZ291dEJ5U29hcCA9IGZ1bmN0aW9uKHJldm9rZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiByZXZva2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHJldm9rZTtcbiAgICByZXZva2UgPSBmYWxzZTtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsb2dnZXIgPSB0aGlzLl9sb2dnZXI7XG5cbiAgdmFyIGJvZHkgPSBbXG4gICAgJzxzZTpFbnZlbG9wZSB4bWxuczpzZT1cImh0dHA6Ly9zY2hlbWFzLnhtbHNvYXAub3JnL3NvYXAvZW52ZWxvcGUvXCI+JyxcbiAgICAgICc8c2U6SGVhZGVyPicsXG4gICAgICAgICc8U2Vzc2lvbkhlYWRlciB4bWxucz1cInVybjpwYXJ0bmVyLnNvYXAuc2ZvcmNlLmNvbVwiPicsXG4gICAgICAgICAgJzxzZXNzaW9uSWQ+JyArIGVzYyhyZXZva2UgPyB0aGlzLnJlZnJlc2hUb2tlbiA6IHRoaXMuYWNjZXNzVG9rZW4pICsgJzwvc2Vzc2lvbklkPicsXG4gICAgICAgICc8L1Nlc3Npb25IZWFkZXI+JyxcbiAgICAgICc8L3NlOkhlYWRlcj4nLFxuICAgICAgJzxzZTpCb2R5PicsXG4gICAgICAgICc8bG9nb3V0IHhtbG5zPVwidXJuOnBhcnRuZXIuc29hcC5zZm9yY2UuY29tXCIvPicsXG4gICAgICAnPC9zZTpCb2R5PicsXG4gICAgJzwvc2U6RW52ZWxvcGU+J1xuICBdLmpvaW4oJycpO1xuXG4gIHJldHVybiB0aGlzLl90cmFuc3BvcnQuaHR0cFJlcXVlc3Qoe1xuICAgIG1ldGhvZCA6ICdQT1NUJyxcbiAgICB1cmwgOiBbIHRoaXMuaW5zdGFuY2VVcmwsIFwic2VydmljZXMvU29hcC91XCIsIHRoaXMudmVyc2lvbiBdLmpvaW4oJy8nKSxcbiAgICBib2R5IDogYm9keSxcbiAgICBoZWFkZXJzIDoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIiA6IFwidGV4dC94bWxcIixcbiAgICAgIFwiU09BUEFjdGlvblwiIDogJ1wiXCInXG4gICAgfVxuICB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgbG9nZ2VyLmRlYnVnKFwiU09BUCBzdGF0dXNDb2RlID0gXCIgKyByZXNwb25zZS5zdGF0dXNDb2RlICsgXCIsIHJlc3BvbnNlID0gXCIgKyByZXNwb25zZS5ib2R5KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgIHZhciBtID0gcmVzcG9uc2UuYm9keS5tYXRjaCgvPGZhdWx0c3RyaW5nPihbXjxdKyk8XFwvZmF1bHRzdHJpbmc+Lyk7XG4gICAgICB2YXIgZmF1bHRzdHJpbmcgPSBtICYmIG1bMV07XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZmF1bHRzdHJpbmcgfHwgcmVzcG9uc2UuYm9keSk7XG4gICAgfVxuXG4gICAgLy8gRGVzdHJveSB0aGUgc2Vzc2lvbiBib3VuZCB0byB0aGlzIGNvbm5lY3Rpb25cbiAgICBzZWxmLmFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICBzZWxmLnVzZXJJbmZvID0gbnVsbDtcbiAgICBzZWxmLnJlZnJlc2hUb2tlbiA9IG51bGw7XG4gICAgc2VsZi5pbnN0YW5jZVVybCA9IG51bGw7XG4gICAgc2VsZi5jYWNoZS5jbGVhcigpO1xuXG4gICAgLy8gbm90aGluZyB1c2VmdWwgcmV0dXJuZWQgYnkgbG9nb3V0IEFQSSwganVzdCByZXR1cm5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogTGlzdCByZWNlbnRseSB2aWV3ZWQgcmVjb3Jkc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gLSBTT2JqZWN0IHR5cGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGltaXRdIC0gTGltaXQgbnVtIHRvIGZldGNoXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUucmVjZW50ID0gZnVuY3Rpb24odHlwZSwgbGltaXQsIGNhbGxiYWNrKSB7XG4gIGlmICghXy5pc1N0cmluZyh0eXBlKSkge1xuICAgIGNhbGxiYWNrID0gbGltaXQ7XG4gICAgbGltaXQgPSB0eXBlO1xuICAgIHR5cGUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKCFfLmlzTnVtYmVyKGxpbWl0KSkge1xuICAgIGNhbGxiYWNrID0gbGltaXQ7XG4gICAgbGltaXQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHVybDtcbiAgaWYgKHR5cGUpIHtcbiAgICB1cmwgPSBbIHRoaXMuX2Jhc2VVcmwoKSwgXCJzb2JqZWN0c1wiLCB0eXBlIF0uam9pbignLycpO1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXJsKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgcmV0dXJuIGxpbWl0ID8gcmVzLnJlY2VudEl0ZW1zLnNsaWNlKDAsIGxpbWl0KSA6IHJlcy5yZWNlbnRJdGVtcztcbiAgICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgdXJsID0gdGhpcy5fYmFzZVVybCgpICsgXCIvcmVjZW50XCI7XG4gICAgaWYgKGxpbWl0KSB7XG4gICAgICB1cmwgKz0gXCI/bGltaXQ9XCIgKyBsaW1pdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1cmwpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFVwZGF0ZWRSZWNvcmRzSW5mb1xuICogQHByb3Age1N0cmluZ30gbGF0ZXN0RGF0ZUNvdmVyZWQgLSBUaGUgdGltZXN0YW1wIG9mIHRoZSBsYXN0IGRhdGUgY292ZXJlZC5cbiAqIEBwcm9wIHtBcnJheS48U3RyaW5nPn0gaWRzIC0gVXBkYXRlZCByZWNvcmQgSURzLlxuICovXG5cbi8qKlxuICogUmV0cmlldmUgdXBkYXRlZCByZWNvcmRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBTT2JqZWN0IFR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfERhdGV9IHN0YXJ0IC0gc3RhcnQgZGF0ZSBvciBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzdGFydCBvZiB0aGUgaW50ZXJ2YWxcbiAqIEBwYXJhbSB7U3RyaW5nfERhdGV9IGVuZCAtIHN0YXJ0IGRhdGUgb3Igc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZW5kIG9mIHRoZSBpbnRlcnZhbCBtdXN0IGJlID4gc3RhcnRcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFVwZGF0ZWRSZWNvcmRzSW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFVwZGF0ZWRSZWNvcmRzSW5mbz59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnVwZGF0ZWQgPSBmdW5jdGlvbiAodHlwZSwgc3RhcnQsIGVuZCwgY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fYmFzZVVybCgpLCBcInNvYmplY3RzXCIsIHR5cGUsIFwidXBkYXRlZFwiIF0uam9pbignLycpO1xuXG4gIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgc3RhcnQgPSBuZXcgRGF0ZShzdGFydCk7XG4gIH1cblxuICBpZiAoc3RhcnQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgc3RhcnQgPSBmb3JtYXREYXRlKHN0YXJ0KTtcbiAgfVxuXG4gIGlmIChzdGFydCkge1xuICAgIHVybCArPSBcIj9zdGFydD1cIiArIGVuY29kZVVSSUNvbXBvbmVudChzdGFydCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmQgPSBuZXcgRGF0ZShlbmQpO1xuICB9XG5cbiAgaWYgKGVuZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICBlbmQgPSBmb3JtYXREYXRlKGVuZCk7XG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgdXJsICs9IFwiJmVuZD1cIiArIGVuY29kZVVSSUNvbXBvbmVudChlbmQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucmVxdWVzdCh1cmwpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRGVsZXRlZFJlY29yZHNJbmZvXG4gKiBAcHJvcCB7U3RyaW5nfSBlYXJsaWVzdERhdGVBdmFpbGFibGUgLSBUaGUgdGltZXN0YW1wIG9mIHRoZSBlYXJsaWVzdCBkYXRlIGF2YWlsYWJsZVxuICogQHByb3Age1N0cmluZ30gbGF0ZXN0RGF0ZUNvdmVyZWQgLSBUaGUgdGltZXN0YW1wIG9mIHRoZSBsYXN0IGRhdGUgY292ZXJlZFxuICogQHByb3Age0FycmF5LjxPYmplY3Q+fSBkZWxldGVkUmVjb3JkcyAtIFVwZGF0ZWQgcmVjb3Jkc1xuICogQHByb3Age1N0cmluZ30gZGVsZXRlZFJlY29yZHMuaWQgLSBSZWNvcmQgSURcbiAqIEBwcm9wIHtTdHJpbmd9IGRlbGV0ZWRSZWNvcmRzLmRlbGV0ZWREYXRlIC0gVGhlIHRpbWVzdGFtcCB3aGVuIHRoaXMgcmVjb3JkIHdhcyBkZWxldGVkXG4gKi9cblxuLyoqXG4gKiBSZXRyaWV2ZSBkZWxldGVkIHJlY29yZHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgVHlwZVxuICogQHBhcmFtIHtTdHJpbmd8RGF0ZX0gc3RhcnQgLSBzdGFydCBkYXRlIG9yIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IG9mIHRoZSBpbnRlcnZhbFxuICogQHBhcmFtIHtTdHJpbmd8RGF0ZX0gZW5kIC0gc3RhcnQgZGF0ZSBvciBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBlbmQgb2YgdGhlIGludGVydmFsXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxEZWxldGVkUmVjb3Jkc0luZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxEZWxldGVkUmVjb3Jkc0luZm8+fVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5kZWxldGVkID0gZnVuY3Rpb24gKHR5cGUsIHN0YXJ0LCBlbmQsIGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Jhc2VVcmwoKSwgXCJzb2JqZWN0c1wiLCB0eXBlLCBcImRlbGV0ZWRcIiBdLmpvaW4oJy8nKTtcblxuICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgIHN0YXJ0ID0gbmV3IERhdGUoc3RhcnQpO1xuICB9XG5cbiAgaWYgKHN0YXJ0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHN0YXJ0ID0gZm9ybWF0RGF0ZShzdGFydCk7XG4gIH1cblxuICBpZiAoc3RhcnQpIHtcbiAgICB1cmwgKz0gXCI/c3RhcnQ9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoc3RhcnQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5kID0gbmV3IERhdGUoZW5kKTtcbiAgfVxuXG4gIGlmIChlbmQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgZW5kID0gZm9ybWF0RGF0ZShlbmQpO1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHVybCArPSBcIiZlbmQ9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoZW5kKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGFic0luZm8gLSBTZWUgdGhlIEFQSSBkb2N1bWVudCBmb3IgZGV0YWlsIHN0cnVjdHVyZVxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRhYnNcbiAqXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxUYWJzSW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFRhYnNJbmZvPn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUudGFicyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Jhc2VVcmwoKSwgXCJ0YWJzXCIgXS5qb2luKCcvJyk7XG4gIHJldHVybiB0aGlzLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTGltaXRzSW5mbyAtIFNlZSB0aGUgQVBJIGRvY3VtZW50IGZvciBkZXRhaWwgc3RydWN0dXJlXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGN1cnJlbiBzeXN0ZW0gbGltaXQgaW4gdGhlIG9yZ2FuaXphdGlvblxuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPExpbWl0c0luZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxMaW1pdHNJbmZvPn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUubGltaXRzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fYmFzZVVybCgpLCBcImxpbWl0c1wiIF0uam9pbignLycpO1xuICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRoZW1lSW5mbyAtIFNlZSB0aGUgQVBJIGRvY3VtZW50IGZvciBkZXRhaWwgc3RydWN0dXJlXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgdGhlbWUgaW5mb1xuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFRoZW1lSW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFRoZW1lSW5mbz59XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnRoZW1lID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fYmFzZVVybCgpLCBcInRoZW1lXCIgXS5qb2luKCcvJyk7XG4gIHJldHVybiB0aGlzLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgZ2xvYmFsIHF1aWNrIGFjdGlvbnNcbiAqXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UXVpY2tBY3Rpb25+UXVpY2tBY3Rpb25JbmZvPj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxRdWlja0FjdGlvbn5RdWlja0FjdGlvbkluZm8+Pn1cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUucXVpY2tBY3Rpb25zID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9xdWlja0FjdGlvbnNcIikudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXQgcmVmZXJlbmNlIGZvciBzcGVjaWZpZWQgZ2xvYmFsIHF1aWNrIGFjaXRvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25OYW1lIC0gTmFtZSBvZiB0aGUgZ2xvYmFsIHF1aWNrIGFjdGlvblxuICogQHJldHVybnMge1F1aWNrQWN0aW9ufVxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5xdWlja0FjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbk5hbWUpIHtcbiAgcmV0dXJuIG5ldyBRdWlja0FjdGlvbih0aGlzLCBcIi9xdWlja0FjdGlvbnMvXCIgKyBhY3Rpb25OYW1lKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/connection.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/core.js":
/*!******************************************!*\
  !*** ./node_modules/jsforce/lib/core.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file JSforce Core\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\nvar jsforce = module.exports = new EventEmitter();\njsforce.VERSION = __webpack_require__(/*! ./VERSION */ \"(action-browser)/./node_modules/jsforce/lib/VERSION.js\");\njsforce.Connection = __webpack_require__(/*! ./connection */ \"(action-browser)/./node_modules/jsforce/lib/connection.js\");\njsforce.OAuth2 = __webpack_require__(/*! ./oauth2 */ \"(action-browser)/./node_modules/jsforce/lib/oauth2.js\");\njsforce.Date = jsforce.SfDate = __webpack_require__(/*! ./date */ \"(action-browser)/./node_modules/jsforce/lib/date.js\");\njsforce.RecordStream = __webpack_require__(/*! ./record-stream */ \"(action-browser)/./node_modules/jsforce/lib/record-stream.js\");\njsforce.Promise = __webpack_require__(/*! ./promise */ \"(action-browser)/./node_modules/jsforce/lib/promise.js\");\njsforce.require = __webpack_require__(/*! ./require */ \"(action-browser)/./node_modules/jsforce/lib/require.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsbUJBQW1CLDBEQUE4Qjs7QUFFakQ7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBVztBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQywrRUFBYztBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyx1RUFBVTtBQUNuQyxnQ0FBZ0MsbUJBQU8sQ0FBQyxtRUFBUTtBQUNoRCx1QkFBdUIsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDaEQsa0JBQWtCLG1CQUFPLENBQUMseUVBQVc7QUFDckMsa0JBQWtCLG1CQUFPLENBQUMseUVBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2NvcmUuanM/OGFlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIEpTZm9yY2UgQ29yZVxuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIGpzZm9yY2UgPSBtb2R1bGUuZXhwb3J0cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbmpzZm9yY2UuVkVSU0lPTiA9IHJlcXVpcmUoJy4vVkVSU0lPTicpO1xuanNmb3JjZS5Db25uZWN0aW9uID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJyk7XG5qc2ZvcmNlLk9BdXRoMiA9IHJlcXVpcmUoJy4vb2F1dGgyJyk7XG5qc2ZvcmNlLkRhdGUgPSBqc2ZvcmNlLlNmRGF0ZSA9IHJlcXVpcmUoXCIuL2RhdGVcIik7XG5qc2ZvcmNlLlJlY29yZFN0cmVhbSA9IHJlcXVpcmUoJy4vcmVjb3JkLXN0cmVhbScpO1xuanNmb3JjZS5Qcm9taXNlID0gcmVxdWlyZSgnLi9wcm9taXNlJyk7XG5qc2ZvcmNlLnJlcXVpcmUgPSByZXF1aXJlKCcuL3JlcXVpcmUnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/core.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/core.js":
/*!******************************************!*\
  !*** ./node_modules/jsforce/lib/core.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file JSforce Core\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\nvar jsforce = module.exports = new EventEmitter();\njsforce.VERSION = __webpack_require__(/*! ./VERSION */ \"(rsc)/./node_modules/jsforce/lib/VERSION.js\");\njsforce.Connection = __webpack_require__(/*! ./connection */ \"(rsc)/./node_modules/jsforce/lib/connection.js\");\njsforce.OAuth2 = __webpack_require__(/*! ./oauth2 */ \"(rsc)/./node_modules/jsforce/lib/oauth2.js\");\njsforce.Date = jsforce.SfDate = __webpack_require__(/*! ./date */ \"(rsc)/./node_modules/jsforce/lib/date.js\");\njsforce.RecordStream = __webpack_require__(/*! ./record-stream */ \"(rsc)/./node_modules/jsforce/lib/record-stream.js\");\njsforce.Promise = __webpack_require__(/*! ./promise */ \"(rsc)/./node_modules/jsforce/lib/promise.js\");\njsforce.require = __webpack_require__(/*! ./require */ \"(rsc)/./node_modules/jsforce/lib/require.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvY29yZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLG1CQUFtQiwwREFBOEI7O0FBRWpEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsOERBQVc7QUFDckMscUJBQXFCLG1CQUFPLENBQUMsb0VBQWM7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsNERBQVU7QUFDbkMsZ0NBQWdDLG1CQUFPLENBQUMsd0RBQVE7QUFDaEQsdUJBQXVCLG1CQUFPLENBQUMsMEVBQWlCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLDhEQUFXO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLDhEQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9jb3JlLmpzP2VjNWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBKU2ZvcmNlIENvcmVcbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBqc2ZvcmNlID0gbW9kdWxlLmV4cG9ydHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5qc2ZvcmNlLlZFUlNJT04gPSByZXF1aXJlKCcuL1ZFUlNJT04nKTtcbmpzZm9yY2UuQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbicpO1xuanNmb3JjZS5PQXV0aDIgPSByZXF1aXJlKCcuL29hdXRoMicpO1xuanNmb3JjZS5EYXRlID0ganNmb3JjZS5TZkRhdGUgPSByZXF1aXJlKFwiLi9kYXRlXCIpO1xuanNmb3JjZS5SZWNvcmRTdHJlYW0gPSByZXF1aXJlKCcuL3JlY29yZC1zdHJlYW0nKTtcbmpzZm9yY2UuUHJvbWlzZSA9IHJlcXVpcmUoJy4vcHJvbWlzZScpO1xuanNmb3JjZS5yZXF1aXJlID0gcmVxdWlyZSgnLi9yZXF1aXJlJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/core.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/csv.js":
/*!*****************************************!*\
  !*** ./node_modules/jsforce/lib/csv.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    csvParse = __webpack_require__(/*! csv-parse/lib/es5 */ \"(action-browser)/./node_modules/csv-parse/lib/es5/index.js\"),\n    csvParseSync = __webpack_require__(/*! csv-parse/lib/es5/sync */ \"(action-browser)/./node_modules/csv-parse/lib/es5/sync.js\"),\n    csvStringify = __webpack_require__(/*! csv-stringify */ \"(action-browser)/./node_modules/csv-stringify/lib/index.js\"),\n    csvStringifySync = __webpack_require__(/*! csv-stringify/lib/sync */ \"(action-browser)/./node_modules/csv-stringify/lib/sync.js\");\n\n/**\n * @private\n */\nfunction parseCSV(str, options) {\n  options = _.extend({}, options, { columns: true });\n  return csvParseSync(str, options);\n}\n\n/**\n * @private\n */\nfunction toCSV(records, options) {\n  options = _.extend({}, options, { header: true });\n  return csvStringifySync(records, options);\n}\n\n/**\n * @private\n */\nfunction parseCSVStream(options) {\n  options = _.extend({}, options, { columns: true });\n  return csvParse(options);\n}\n\n/**\n * @private\n */\nfunction serializeCSVStream(options) {\n  options = _.extend({}, options, { header: true });\n  return csvStringify(options);\n}\n\n\n/**\n * @protected\n */\nmodule.exports = {\n  parseCSV: parseCSV,\n  toCSV: toCSV,\n  parseCSVStream: parseCSVStream,\n  serializeCSVStream: serializeCSVStream\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9jc3YuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLG1FQUFhO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyxxRkFBbUI7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMseUZBQXdCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLGlGQUFlO0FBQzFDLHVCQUF1QixtQkFBTyxDQUFDLHlGQUF3Qjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYSxlQUFlO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYSxjQUFjO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYSxlQUFlO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYSxjQUFjO0FBQ2xEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvY3N2LmpzPzU2NzMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyksXG4gICAgY3N2UGFyc2UgPSByZXF1aXJlKCdjc3YtcGFyc2UvbGliL2VzNScpLFxuICAgIGNzdlBhcnNlU3luYyA9IHJlcXVpcmUoJ2Nzdi1wYXJzZS9saWIvZXM1L3N5bmMnKSxcbiAgICBjc3ZTdHJpbmdpZnkgPSByZXF1aXJlKCdjc3Ytc3RyaW5naWZ5JyksXG4gICAgY3N2U3RyaW5naWZ5U3luYyA9IHJlcXVpcmUoJ2Nzdi1zdHJpbmdpZnkvbGliL3N5bmMnKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUNTVihzdHIsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGNvbHVtbnM6IHRydWUgfSk7XG4gIHJldHVybiBjc3ZQYXJzZVN5bmMoc3RyLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0b0NTVihyZWNvcmRzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgb3B0aW9ucywgeyBoZWFkZXI6IHRydWUgfSk7XG4gIHJldHVybiBjc3ZTdHJpbmdpZnlTeW5jKHJlY29yZHMsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ1NWU3RyZWFtKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGNvbHVtbnM6IHRydWUgfSk7XG4gIHJldHVybiBjc3ZQYXJzZShvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVDU1ZTdHJlYW0ob3B0aW9ucykge1xuICBvcHRpb25zID0gXy5leHRlbmQoe30sIG9wdGlvbnMsIHsgaGVhZGVyOiB0cnVlIH0pO1xuICByZXR1cm4gY3N2U3RyaW5naWZ5KG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogQHByb3RlY3RlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2VDU1Y6IHBhcnNlQ1NWLFxuICB0b0NTVjogdG9DU1YsXG4gIHBhcnNlQ1NWU3RyZWFtOiBwYXJzZUNTVlN0cmVhbSxcbiAgc2VyaWFsaXplQ1NWU3RyZWFtOiBzZXJpYWxpemVDU1ZTdHJlYW1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/csv.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/csv.js":
/*!*****************************************!*\
  !*** ./node_modules/jsforce/lib/csv.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    csvParse = __webpack_require__(/*! csv-parse/lib/es5 */ \"(rsc)/./node_modules/csv-parse/lib/es5/index.js\"),\n    csvParseSync = __webpack_require__(/*! csv-parse/lib/es5/sync */ \"(rsc)/./node_modules/csv-parse/lib/es5/sync.js\"),\n    csvStringify = __webpack_require__(/*! csv-stringify */ \"(rsc)/./node_modules/csv-stringify/lib/index.js\"),\n    csvStringifySync = __webpack_require__(/*! csv-stringify/lib/sync */ \"(rsc)/./node_modules/csv-stringify/lib/sync.js\");\n\n/**\n * @private\n */\nfunction parseCSV(str, options) {\n  options = _.extend({}, options, { columns: true });\n  return csvParseSync(str, options);\n}\n\n/**\n * @private\n */\nfunction toCSV(records, options) {\n  options = _.extend({}, options, { header: true });\n  return csvStringifySync(records, options);\n}\n\n/**\n * @private\n */\nfunction parseCSVStream(options) {\n  options = _.extend({}, options, { columns: true });\n  return csvParse(options);\n}\n\n/**\n * @private\n */\nfunction serializeCSVStream(options) {\n  options = _.extend({}, options, { header: true });\n  return csvStringify(options);\n}\n\n\n/**\n * @protected\n */\nmodule.exports = {\n  parseCSV: parseCSV,\n  toCSV: toCSV,\n  parseCSVStream: parseCSVStream,\n  serializeCSVStream: serializeCSVStream\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvY3N2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyx3REFBYTtBQUM3QixlQUFlLG1CQUFPLENBQUMsMEVBQW1CO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLDhFQUF3QjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyxzRUFBZTtBQUMxQyx1QkFBdUIsbUJBQU8sQ0FBQyw4RUFBd0I7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWEsZUFBZTtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWEsY0FBYztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWEsZUFBZTtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWEsY0FBYztBQUNsRDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2Nzdi5qcz9hNTM5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpLFxuICAgIGNzdlBhcnNlID0gcmVxdWlyZSgnY3N2LXBhcnNlL2xpYi9lczUnKSxcbiAgICBjc3ZQYXJzZVN5bmMgPSByZXF1aXJlKCdjc3YtcGFyc2UvbGliL2VzNS9zeW5jJyksXG4gICAgY3N2U3RyaW5naWZ5ID0gcmVxdWlyZSgnY3N2LXN0cmluZ2lmeScpLFxuICAgIGNzdlN0cmluZ2lmeVN5bmMgPSByZXF1aXJlKCdjc3Ytc3RyaW5naWZ5L2xpYi9zeW5jJyk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VDU1Yoc3RyLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgb3B0aW9ucywgeyBjb2x1bW5zOiB0cnVlIH0pO1xuICByZXR1cm4gY3N2UGFyc2VTeW5jKHN0ciwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdG9DU1YocmVjb3Jkcywgb3B0aW9ucykge1xuICBvcHRpb25zID0gXy5leHRlbmQoe30sIG9wdGlvbnMsIHsgaGVhZGVyOiB0cnVlIH0pO1xuICByZXR1cm4gY3N2U3RyaW5naWZ5U3luYyhyZWNvcmRzLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUNTVlN0cmVhbShvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgb3B0aW9ucywgeyBjb2x1bW5zOiB0cnVlIH0pO1xuICByZXR1cm4gY3N2UGFyc2Uob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplQ1NWU3RyZWFtKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGhlYWRlcjogdHJ1ZSB9KTtcbiAgcmV0dXJuIGNzdlN0cmluZ2lmeShvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIEBwcm90ZWN0ZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlQ1NWOiBwYXJzZUNTVixcbiAgdG9DU1Y6IHRvQ1NWLFxuICBwYXJzZUNTVlN0cmVhbTogcGFyc2VDU1ZTdHJlYW0sXG4gIHNlcmlhbGl6ZUNTVlN0cmVhbTogc2VyaWFsaXplQ1NWU3RyZWFtXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/csv.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/date.js":
/*!******************************************!*\
  !*** ./node_modules/jsforce/lib/date.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\");\n\n/**\n * A date object to keep Salesforce date literal\n *\n * @class\n * @constructor\n * @see http://www.salesforce.com/us/developer/docs/soql_sosl/Content/sforce_api_calls_soql_select_dateformats.htm\n */\nvar SfDate = module.exports = function(literal) {\n  this._literal = literal;\n};\n\n/**\n * Returns literal when converted to string\n *\n * @override\n */\nSfDate.prototype.toString =\nSfDate.prototype.toJSON = function() { return this._literal; };\n\n\n/** @private **/\nfunction zeropad(n) { return (n<10 ? \"0\" : \"\") + n; }\n\n/**\n * Convert JavaScript date object to ISO8601 Date format (e.g. 2012-10-31)\n *\n * @param {String|Number|Date} date - Input date\n * @returns {SfDate} - Salesforce date literal with ISO8601 date format\n */\nSfDate.toDateLiteral = function(date) {\n  if (_.isNumber(date)) {\n    date = new Date(date);\n  } else if (_.isString(date)) {\n    date = SfDate.parseDate(date);\n  }\n  var yy = date.getFullYear();\n  var mm = date.getMonth()+1;\n  var dd = date.getDate();\n  var dstr = [ yy, zeropad(mm), zeropad(dd) ].join(\"-\");\n  return new SfDate(dstr);\n};\n\n/**\n * Convert JavaScript date object to ISO8601 DateTime format\n * (e.g. 2012-10-31T12:34:56Z)\n *\n * @param {String|Number|Date} date - Input date\n * @returns {SfDate} - Salesforce date literal with ISO8601 datetime format\n */\nSfDate.toDateTimeLiteral = function(date) {\n  if (_.isNumber(date)) {\n    date = new Date(date);\n  } else if (_.isString(date)) {\n    date = SfDate.parseDate(date);\n  }\n  var yy = date.getUTCFullYear();\n  var mm = date.getUTCMonth()+1;\n  var dd = date.getUTCDate();\n  var hh = date.getUTCHours();\n  var mi = date.getUTCMinutes();\n  var ss = date.getUTCSeconds();\n  var dtstr =\n    [ yy, zeropad(mm), zeropad(dd) ].join(\"-\") + \"T\" +\n    [ zeropad(hh), zeropad(mi), zeropad(ss) ].join(\":\") + \"Z\";\n  return new SfDate(dtstr);\n};\n\n/**\n * Parse IS08601 date(time) formatted string and return date instance\n *\n * @param {String} str\n * @returns {Date}\n */\nSfDate.parseDate = function(str) {\n  var d = new Date();\n  var regexp = /^([\\d]{4})-?([\\d]{2})-?([\\d]{2})(T([\\d]{2}):?([\\d]{2}):?([\\d]{2})(.([\\d]{3}))?(Z|([\\+\\-])([\\d]{2}):?([\\d]{2})))?$/;\n  var m = str.match(regexp);\n  if (m) {\n    d = new Date(0);\n    if (!m[4]) {\n      d.setFullYear(parseInt(m[1], 10));\n      d.setDate(parseInt(m[3], 10));\n      d.setMonth(parseInt(m[2], 10) - 1);\n      d.setHours(0);\n      d.setMinutes(0);\n      d.setSeconds(0);\n      d.setMilliseconds(0);\n    } else {\n      d.setUTCFullYear(parseInt(m[1], 10));\n      d.setUTCDate(parseInt(m[3], 10));\n      d.setUTCMonth(parseInt(m[2], 10) - 1);\n      d.setUTCHours(parseInt(m[5], 10));\n      d.setUTCMinutes(parseInt(m[6], 10));\n      d.setUTCSeconds(parseInt(m[7], 10));\n      d.setUTCMilliseconds(parseInt(m[9] || '0', 10));\n      if (m[10] && m[10] !== 'Z') {\n        var offset = parseInt(m[12],10) * 60 + parseInt(m[13], 10);\n        d.setTime((m[11] === '+' ? -1 : 1) * offset * 60 * 1000 +d.getTime());\n      }\n    }\n    return d;\n  } else {\n    throw new Error(\"Invalid date format is specified : \" + str);\n  }\n};\n\n/*\n * Pre-defined Salesforce Date Literals\n */\nvar SfDateLiterals = {\n  YESTERDAY: 1,\n  TODAY: 1,\n  TOMORROW: 1,\n  LAST_WEEK: 1,\n  THIS_WEEK: 1,\n  NEXT_WEEK: 1,\n  LAST_MONTH: 1,\n  THIS_MONTH: 1,\n  NEXT_MONTH: 1,\n  LAST_90_DAYS: 1,\n  NEXT_90_DAYS: 1,\n  LAST_N_DAYS: 2,\n  NEXT_N_DAYS: 2,\n  NEXT_N_WEEKS: 2,\n  LAST_N_WEEKS: 2,\n  NEXT_N_MONTHS: 2,\n  LAST_N_MONTHS: 2,\n  THIS_QUARTER: 1,\n  LAST_QUARTER: 1,\n  NEXT_QUARTER: 1,\n  NEXT_N_QUARTERS: 2,\n  LAST_N_QUARTERS: 2,\n  THIS_YEAR: 1,\n  LAST_YEAR: 1,\n  NEXT_YEAR: 1,\n  NEXT_N_YEARS: 2,\n  LAST_N_YEARS: 2,\n  THIS_FISCAL_QUARTER: 1,\n  LAST_FISCAL_QUARTER: 1,\n  NEXT_FISCAL_QUARTER: 1,\n  NEXT_N_FISCAL_QUARTERS:2,\n  LAST_N_FISCAL_QUARTERS:2,\n  THIS_FISCAL_YEAR:1,\n  LAST_FISCAL_YEAR:1,\n  NEXT_FISCAL_YEAR:1,\n  NEXT_N_FISCAL_YEARS: 2,\n  LAST_N_FISCAL_YEARS: 2\n};\n\nfor (var literal in SfDateLiterals) {\n  var type = SfDateLiterals[literal];\n  SfDate[literal] =\n   type === 1 ? new SfDate(literal) : createLiteralBuilder(literal);\n}\n\n/** @private **/\nfunction createLiteralBuilder(literal) {\n  return function(num) { return new SfDate(literal + \":\" + num); };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9kYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxtRUFBYTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOzs7QUFHdkM7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsb0JBQW9CLEVBQUUsU0FBUyxFQUFFO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2RhdGUuanM/Mzc4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKTtcblxuLyoqXG4gKiBBIGRhdGUgb2JqZWN0IHRvIGtlZXAgU2FsZXNmb3JjZSBkYXRlIGxpdGVyYWxcbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHNlZSBodHRwOi8vd3d3LnNhbGVzZm9yY2UuY29tL3VzL2RldmVsb3Blci9kb2NzL3NvcWxfc29zbC9Db250ZW50L3Nmb3JjZV9hcGlfY2FsbHNfc29xbF9zZWxlY3RfZGF0ZWZvcm1hdHMuaHRtXG4gKi9cbnZhciBTZkRhdGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpdGVyYWwpIHtcbiAgdGhpcy5fbGl0ZXJhbCA9IGxpdGVyYWw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgbGl0ZXJhbCB3aGVuIGNvbnZlcnRlZCB0byBzdHJpbmdcbiAqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU2ZEYXRlLnByb3RvdHlwZS50b1N0cmluZyA9XG5TZkRhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fbGl0ZXJhbDsgfTtcblxuXG4vKiogQHByaXZhdGUgKiovXG5mdW5jdGlvbiB6ZXJvcGFkKG4pIHsgcmV0dXJuIChuPDEwID8gXCIwXCIgOiBcIlwiKSArIG47IH1cblxuLyoqXG4gKiBDb252ZXJ0IEphdmFTY3JpcHQgZGF0ZSBvYmplY3QgdG8gSVNPODYwMSBEYXRlIGZvcm1hdCAoZS5nLiAyMDEyLTEwLTMxKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxEYXRlfSBkYXRlIC0gSW5wdXQgZGF0ZVxuICogQHJldHVybnMge1NmRGF0ZX0gLSBTYWxlc2ZvcmNlIGRhdGUgbGl0ZXJhbCB3aXRoIElTTzg2MDEgZGF0ZSBmb3JtYXRcbiAqL1xuU2ZEYXRlLnRvRGF0ZUxpdGVyYWwgPSBmdW5jdGlvbihkYXRlKSB7XG4gIGlmIChfLmlzTnVtYmVyKGRhdGUpKSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoZGF0ZSkpIHtcbiAgICBkYXRlID0gU2ZEYXRlLnBhcnNlRGF0ZShkYXRlKTtcbiAgfVxuICB2YXIgeXkgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gIHZhciBtbSA9IGRhdGUuZ2V0TW9udGgoKSsxO1xuICB2YXIgZGQgPSBkYXRlLmdldERhdGUoKTtcbiAgdmFyIGRzdHIgPSBbIHl5LCB6ZXJvcGFkKG1tKSwgemVyb3BhZChkZCkgXS5qb2luKFwiLVwiKTtcbiAgcmV0dXJuIG5ldyBTZkRhdGUoZHN0cik7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgSmF2YVNjcmlwdCBkYXRlIG9iamVjdCB0byBJU084NjAxIERhdGVUaW1lIGZvcm1hdFxuICogKGUuZy4gMjAxMi0xMC0zMVQxMjozNDo1NlopXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfERhdGV9IGRhdGUgLSBJbnB1dCBkYXRlXG4gKiBAcmV0dXJucyB7U2ZEYXRlfSAtIFNhbGVzZm9yY2UgZGF0ZSBsaXRlcmFsIHdpdGggSVNPODYwMSBkYXRldGltZSBmb3JtYXRcbiAqL1xuU2ZEYXRlLnRvRGF0ZVRpbWVMaXRlcmFsID0gZnVuY3Rpb24oZGF0ZSkge1xuICBpZiAoXy5pc051bWJlcihkYXRlKSkge1xuICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGRhdGUpKSB7XG4gICAgZGF0ZSA9IFNmRGF0ZS5wYXJzZURhdGUoZGF0ZSk7XG4gIH1cbiAgdmFyIHl5ID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICB2YXIgbW0gPSBkYXRlLmdldFVUQ01vbnRoKCkrMTtcbiAgdmFyIGRkID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gIHZhciBoaCA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgdmFyIG1pID0gZGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gIHZhciBzcyA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpO1xuICB2YXIgZHRzdHIgPVxuICAgIFsgeXksIHplcm9wYWQobW0pLCB6ZXJvcGFkKGRkKSBdLmpvaW4oXCItXCIpICsgXCJUXCIgK1xuICAgIFsgemVyb3BhZChoaCksIHplcm9wYWQobWkpLCB6ZXJvcGFkKHNzKSBdLmpvaW4oXCI6XCIpICsgXCJaXCI7XG4gIHJldHVybiBuZXcgU2ZEYXRlKGR0c3RyKTtcbn07XG5cbi8qKlxuICogUGFyc2UgSVMwODYwMSBkYXRlKHRpbWUpIGZvcm1hdHRlZCBzdHJpbmcgYW5kIHJldHVybiBkYXRlIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge0RhdGV9XG4gKi9cblNmRGF0ZS5wYXJzZURhdGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgcmVnZXhwID0gL14oW1xcZF17NH0pLT8oW1xcZF17Mn0pLT8oW1xcZF17Mn0pKFQoW1xcZF17Mn0pOj8oW1xcZF17Mn0pOj8oW1xcZF17Mn0pKC4oW1xcZF17M30pKT8oWnwoW1xcK1xcLV0pKFtcXGRdezJ9KTo/KFtcXGRdezJ9KSkpPyQvO1xuICB2YXIgbSA9IHN0ci5tYXRjaChyZWdleHApO1xuICBpZiAobSkge1xuICAgIGQgPSBuZXcgRGF0ZSgwKTtcbiAgICBpZiAoIW1bNF0pIHtcbiAgICAgIGQuc2V0RnVsbFllYXIocGFyc2VJbnQobVsxXSwgMTApKTtcbiAgICAgIGQuc2V0RGF0ZShwYXJzZUludChtWzNdLCAxMCkpO1xuICAgICAgZC5zZXRNb250aChwYXJzZUludChtWzJdLCAxMCkgLSAxKTtcbiAgICAgIGQuc2V0SG91cnMoMCk7XG4gICAgICBkLnNldE1pbnV0ZXMoMCk7XG4gICAgICBkLnNldFNlY29uZHMoMCk7XG4gICAgICBkLnNldE1pbGxpc2Vjb25kcygwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZC5zZXRVVENGdWxsWWVhcihwYXJzZUludChtWzFdLCAxMCkpO1xuICAgICAgZC5zZXRVVENEYXRlKHBhcnNlSW50KG1bM10sIDEwKSk7XG4gICAgICBkLnNldFVUQ01vbnRoKHBhcnNlSW50KG1bMl0sIDEwKSAtIDEpO1xuICAgICAgZC5zZXRVVENIb3VycyhwYXJzZUludChtWzVdLCAxMCkpO1xuICAgICAgZC5zZXRVVENNaW51dGVzKHBhcnNlSW50KG1bNl0sIDEwKSk7XG4gICAgICBkLnNldFVUQ1NlY29uZHMocGFyc2VJbnQobVs3XSwgMTApKTtcbiAgICAgIGQuc2V0VVRDTWlsbGlzZWNvbmRzKHBhcnNlSW50KG1bOV0gfHwgJzAnLCAxMCkpO1xuICAgICAgaWYgKG1bMTBdICYmIG1bMTBdICE9PSAnWicpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHBhcnNlSW50KG1bMTJdLDEwKSAqIDYwICsgcGFyc2VJbnQobVsxM10sIDEwKTtcbiAgICAgICAgZC5zZXRUaW1lKChtWzExXSA9PT0gJysnID8gLTEgOiAxKSAqIG9mZnNldCAqIDYwICogMTAwMCArZC5nZXRUaW1lKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgZm9ybWF0IGlzIHNwZWNpZmllZCA6IFwiICsgc3RyKTtcbiAgfVxufTtcblxuLypcbiAqIFByZS1kZWZpbmVkIFNhbGVzZm9yY2UgRGF0ZSBMaXRlcmFsc1xuICovXG52YXIgU2ZEYXRlTGl0ZXJhbHMgPSB7XG4gIFlFU1RFUkRBWTogMSxcbiAgVE9EQVk6IDEsXG4gIFRPTU9SUk9XOiAxLFxuICBMQVNUX1dFRUs6IDEsXG4gIFRISVNfV0VFSzogMSxcbiAgTkVYVF9XRUVLOiAxLFxuICBMQVNUX01PTlRIOiAxLFxuICBUSElTX01PTlRIOiAxLFxuICBORVhUX01PTlRIOiAxLFxuICBMQVNUXzkwX0RBWVM6IDEsXG4gIE5FWFRfOTBfREFZUzogMSxcbiAgTEFTVF9OX0RBWVM6IDIsXG4gIE5FWFRfTl9EQVlTOiAyLFxuICBORVhUX05fV0VFS1M6IDIsXG4gIExBU1RfTl9XRUVLUzogMixcbiAgTkVYVF9OX01PTlRIUzogMixcbiAgTEFTVF9OX01PTlRIUzogMixcbiAgVEhJU19RVUFSVEVSOiAxLFxuICBMQVNUX1FVQVJURVI6IDEsXG4gIE5FWFRfUVVBUlRFUjogMSxcbiAgTkVYVF9OX1FVQVJURVJTOiAyLFxuICBMQVNUX05fUVVBUlRFUlM6IDIsXG4gIFRISVNfWUVBUjogMSxcbiAgTEFTVF9ZRUFSOiAxLFxuICBORVhUX1lFQVI6IDEsXG4gIE5FWFRfTl9ZRUFSUzogMixcbiAgTEFTVF9OX1lFQVJTOiAyLFxuICBUSElTX0ZJU0NBTF9RVUFSVEVSOiAxLFxuICBMQVNUX0ZJU0NBTF9RVUFSVEVSOiAxLFxuICBORVhUX0ZJU0NBTF9RVUFSVEVSOiAxLFxuICBORVhUX05fRklTQ0FMX1FVQVJURVJTOjIsXG4gIExBU1RfTl9GSVNDQUxfUVVBUlRFUlM6MixcbiAgVEhJU19GSVNDQUxfWUVBUjoxLFxuICBMQVNUX0ZJU0NBTF9ZRUFSOjEsXG4gIE5FWFRfRklTQ0FMX1lFQVI6MSxcbiAgTkVYVF9OX0ZJU0NBTF9ZRUFSUzogMixcbiAgTEFTVF9OX0ZJU0NBTF9ZRUFSUzogMlxufTtcblxuZm9yICh2YXIgbGl0ZXJhbCBpbiBTZkRhdGVMaXRlcmFscykge1xuICB2YXIgdHlwZSA9IFNmRGF0ZUxpdGVyYWxzW2xpdGVyYWxdO1xuICBTZkRhdGVbbGl0ZXJhbF0gPVxuICAgdHlwZSA9PT0gMSA/IG5ldyBTZkRhdGUobGl0ZXJhbCkgOiBjcmVhdGVMaXRlcmFsQnVpbGRlcihsaXRlcmFsKTtcbn1cblxuLyoqIEBwcml2YXRlICoqL1xuZnVuY3Rpb24gY3JlYXRlTGl0ZXJhbEJ1aWxkZXIobGl0ZXJhbCkge1xuICByZXR1cm4gZnVuY3Rpb24obnVtKSB7IHJldHVybiBuZXcgU2ZEYXRlKGxpdGVyYWwgKyBcIjpcIiArIG51bSk7IH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/date.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/date.js":
/*!******************************************!*\
  !*** ./node_modules/jsforce/lib/date.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\");\n\n/**\n * A date object to keep Salesforce date literal\n *\n * @class\n * @constructor\n * @see http://www.salesforce.com/us/developer/docs/soql_sosl/Content/sforce_api_calls_soql_select_dateformats.htm\n */\nvar SfDate = module.exports = function(literal) {\n  this._literal = literal;\n};\n\n/**\n * Returns literal when converted to string\n *\n * @override\n */\nSfDate.prototype.toString =\nSfDate.prototype.toJSON = function() { return this._literal; };\n\n\n/** @private **/\nfunction zeropad(n) { return (n<10 ? \"0\" : \"\") + n; }\n\n/**\n * Convert JavaScript date object to ISO8601 Date format (e.g. 2012-10-31)\n *\n * @param {String|Number|Date} date - Input date\n * @returns {SfDate} - Salesforce date literal with ISO8601 date format\n */\nSfDate.toDateLiteral = function(date) {\n  if (_.isNumber(date)) {\n    date = new Date(date);\n  } else if (_.isString(date)) {\n    date = SfDate.parseDate(date);\n  }\n  var yy = date.getFullYear();\n  var mm = date.getMonth()+1;\n  var dd = date.getDate();\n  var dstr = [ yy, zeropad(mm), zeropad(dd) ].join(\"-\");\n  return new SfDate(dstr);\n};\n\n/**\n * Convert JavaScript date object to ISO8601 DateTime format\n * (e.g. 2012-10-31T12:34:56Z)\n *\n * @param {String|Number|Date} date - Input date\n * @returns {SfDate} - Salesforce date literal with ISO8601 datetime format\n */\nSfDate.toDateTimeLiteral = function(date) {\n  if (_.isNumber(date)) {\n    date = new Date(date);\n  } else if (_.isString(date)) {\n    date = SfDate.parseDate(date);\n  }\n  var yy = date.getUTCFullYear();\n  var mm = date.getUTCMonth()+1;\n  var dd = date.getUTCDate();\n  var hh = date.getUTCHours();\n  var mi = date.getUTCMinutes();\n  var ss = date.getUTCSeconds();\n  var dtstr =\n    [ yy, zeropad(mm), zeropad(dd) ].join(\"-\") + \"T\" +\n    [ zeropad(hh), zeropad(mi), zeropad(ss) ].join(\":\") + \"Z\";\n  return new SfDate(dtstr);\n};\n\n/**\n * Parse IS08601 date(time) formatted string and return date instance\n *\n * @param {String} str\n * @returns {Date}\n */\nSfDate.parseDate = function(str) {\n  var d = new Date();\n  var regexp = /^([\\d]{4})-?([\\d]{2})-?([\\d]{2})(T([\\d]{2}):?([\\d]{2}):?([\\d]{2})(.([\\d]{3}))?(Z|([\\+\\-])([\\d]{2}):?([\\d]{2})))?$/;\n  var m = str.match(regexp);\n  if (m) {\n    d = new Date(0);\n    if (!m[4]) {\n      d.setFullYear(parseInt(m[1], 10));\n      d.setDate(parseInt(m[3], 10));\n      d.setMonth(parseInt(m[2], 10) - 1);\n      d.setHours(0);\n      d.setMinutes(0);\n      d.setSeconds(0);\n      d.setMilliseconds(0);\n    } else {\n      d.setUTCFullYear(parseInt(m[1], 10));\n      d.setUTCDate(parseInt(m[3], 10));\n      d.setUTCMonth(parseInt(m[2], 10) - 1);\n      d.setUTCHours(parseInt(m[5], 10));\n      d.setUTCMinutes(parseInt(m[6], 10));\n      d.setUTCSeconds(parseInt(m[7], 10));\n      d.setUTCMilliseconds(parseInt(m[9] || '0', 10));\n      if (m[10] && m[10] !== 'Z') {\n        var offset = parseInt(m[12],10) * 60 + parseInt(m[13], 10);\n        d.setTime((m[11] === '+' ? -1 : 1) * offset * 60 * 1000 +d.getTime());\n      }\n    }\n    return d;\n  } else {\n    throw new Error(\"Invalid date format is specified : \" + str);\n  }\n};\n\n/*\n * Pre-defined Salesforce Date Literals\n */\nvar SfDateLiterals = {\n  YESTERDAY: 1,\n  TODAY: 1,\n  TOMORROW: 1,\n  LAST_WEEK: 1,\n  THIS_WEEK: 1,\n  NEXT_WEEK: 1,\n  LAST_MONTH: 1,\n  THIS_MONTH: 1,\n  NEXT_MONTH: 1,\n  LAST_90_DAYS: 1,\n  NEXT_90_DAYS: 1,\n  LAST_N_DAYS: 2,\n  NEXT_N_DAYS: 2,\n  NEXT_N_WEEKS: 2,\n  LAST_N_WEEKS: 2,\n  NEXT_N_MONTHS: 2,\n  LAST_N_MONTHS: 2,\n  THIS_QUARTER: 1,\n  LAST_QUARTER: 1,\n  NEXT_QUARTER: 1,\n  NEXT_N_QUARTERS: 2,\n  LAST_N_QUARTERS: 2,\n  THIS_YEAR: 1,\n  LAST_YEAR: 1,\n  NEXT_YEAR: 1,\n  NEXT_N_YEARS: 2,\n  LAST_N_YEARS: 2,\n  THIS_FISCAL_QUARTER: 1,\n  LAST_FISCAL_QUARTER: 1,\n  NEXT_FISCAL_QUARTER: 1,\n  NEXT_N_FISCAL_QUARTERS:2,\n  LAST_N_FISCAL_QUARTERS:2,\n  THIS_FISCAL_YEAR:1,\n  LAST_FISCAL_YEAR:1,\n  NEXT_FISCAL_YEAR:1,\n  NEXT_N_FISCAL_YEARS: 2,\n  LAST_N_FISCAL_YEARS: 2\n};\n\nfor (var literal in SfDateLiterals) {\n  var type = SfDateLiterals[literal];\n  SfDate[literal] =\n   type === 1 ? new SfDate(literal) : createLiteralBuilder(literal);\n}\n\n/** @private **/\nfunction createLiteralBuilder(literal) {\n  return function(num) { return new SfDate(literal + \":\" + num); };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvZGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMsd0RBQWE7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7O0FBR3ZDO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLG9CQUFvQixFQUFFLFNBQVMsRUFBRTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9kYXRlLmpzPzQ4MDkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyk7XG5cbi8qKlxuICogQSBkYXRlIG9iamVjdCB0byBrZWVwIFNhbGVzZm9yY2UgZGF0ZSBsaXRlcmFsXG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzZWUgaHR0cDovL3d3dy5zYWxlc2ZvcmNlLmNvbS91cy9kZXZlbG9wZXIvZG9jcy9zb3FsX3Nvc2wvQ29udGVudC9zZm9yY2VfYXBpX2NhbGxzX3NvcWxfc2VsZWN0X2RhdGVmb3JtYXRzLmh0bVxuICovXG52YXIgU2ZEYXRlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXRlcmFsKSB7XG4gIHRoaXMuX2xpdGVyYWwgPSBsaXRlcmFsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGxpdGVyYWwgd2hlbiBjb252ZXJ0ZWQgdG8gc3RyaW5nXG4gKlxuICogQG92ZXJyaWRlXG4gKi9cblNmRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPVxuU2ZEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2xpdGVyYWw7IH07XG5cblxuLyoqIEBwcml2YXRlICoqL1xuZnVuY3Rpb24gemVyb3BhZChuKSB7IHJldHVybiAobjwxMCA/IFwiMFwiIDogXCJcIikgKyBuOyB9XG5cbi8qKlxuICogQ29udmVydCBKYXZhU2NyaXB0IGRhdGUgb2JqZWN0IHRvIElTTzg2MDEgRGF0ZSBmb3JtYXQgKGUuZy4gMjAxMi0xMC0zMSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8RGF0ZX0gZGF0ZSAtIElucHV0IGRhdGVcbiAqIEByZXR1cm5zIHtTZkRhdGV9IC0gU2FsZXNmb3JjZSBkYXRlIGxpdGVyYWwgd2l0aCBJU084NjAxIGRhdGUgZm9ybWF0XG4gKi9cblNmRGF0ZS50b0RhdGVMaXRlcmFsID0gZnVuY3Rpb24oZGF0ZSkge1xuICBpZiAoXy5pc051bWJlcihkYXRlKSkge1xuICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGRhdGUpKSB7XG4gICAgZGF0ZSA9IFNmRGF0ZS5wYXJzZURhdGUoZGF0ZSk7XG4gIH1cbiAgdmFyIHl5ID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICB2YXIgbW0gPSBkYXRlLmdldE1vbnRoKCkrMTtcbiAgdmFyIGRkID0gZGF0ZS5nZXREYXRlKCk7XG4gIHZhciBkc3RyID0gWyB5eSwgemVyb3BhZChtbSksIHplcm9wYWQoZGQpIF0uam9pbihcIi1cIik7XG4gIHJldHVybiBuZXcgU2ZEYXRlKGRzdHIpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IEphdmFTY3JpcHQgZGF0ZSBvYmplY3QgdG8gSVNPODYwMSBEYXRlVGltZSBmb3JtYXRcbiAqIChlLmcuIDIwMTItMTAtMzFUMTI6MzQ6NTZaKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxEYXRlfSBkYXRlIC0gSW5wdXQgZGF0ZVxuICogQHJldHVybnMge1NmRGF0ZX0gLSBTYWxlc2ZvcmNlIGRhdGUgbGl0ZXJhbCB3aXRoIElTTzg2MDEgZGF0ZXRpbWUgZm9ybWF0XG4gKi9cblNmRGF0ZS50b0RhdGVUaW1lTGl0ZXJhbCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgaWYgKF8uaXNOdW1iZXIoZGF0ZSkpIHtcbiAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhkYXRlKSkge1xuICAgIGRhdGUgPSBTZkRhdGUucGFyc2VEYXRlKGRhdGUpO1xuICB9XG4gIHZhciB5eSA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgdmFyIG1tID0gZGF0ZS5nZXRVVENNb250aCgpKzE7XG4gIHZhciBkZCA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICB2YXIgaGggPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gIHZhciBtaSA9IGRhdGUuZ2V0VVRDTWludXRlcygpO1xuICB2YXIgc3MgPSBkYXRlLmdldFVUQ1NlY29uZHMoKTtcbiAgdmFyIGR0c3RyID1cbiAgICBbIHl5LCB6ZXJvcGFkKG1tKSwgemVyb3BhZChkZCkgXS5qb2luKFwiLVwiKSArIFwiVFwiICtcbiAgICBbIHplcm9wYWQoaGgpLCB6ZXJvcGFkKG1pKSwgemVyb3BhZChzcykgXS5qb2luKFwiOlwiKSArIFwiWlwiO1xuICByZXR1cm4gbmV3IFNmRGF0ZShkdHN0cik7XG59O1xuXG4vKipcbiAqIFBhcnNlIElTMDg2MDEgZGF0ZSh0aW1lKSBmb3JtYXR0ZWQgc3RyaW5nIGFuZCByZXR1cm4gZGF0ZSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtEYXRlfVxuICovXG5TZkRhdGUucGFyc2VEYXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHJlZ2V4cCA9IC9eKFtcXGRdezR9KS0/KFtcXGRdezJ9KS0/KFtcXGRdezJ9KShUKFtcXGRdezJ9KTo/KFtcXGRdezJ9KTo/KFtcXGRdezJ9KSguKFtcXGRdezN9KSk/KFp8KFtcXCtcXC1dKShbXFxkXXsyfSk6PyhbXFxkXXsyfSkpKT8kLztcbiAgdmFyIG0gPSBzdHIubWF0Y2gocmVnZXhwKTtcbiAgaWYgKG0pIHtcbiAgICBkID0gbmV3IERhdGUoMCk7XG4gICAgaWYgKCFtWzRdKSB7XG4gICAgICBkLnNldEZ1bGxZZWFyKHBhcnNlSW50KG1bMV0sIDEwKSk7XG4gICAgICBkLnNldERhdGUocGFyc2VJbnQobVszXSwgMTApKTtcbiAgICAgIGQuc2V0TW9udGgocGFyc2VJbnQobVsyXSwgMTApIC0gMSk7XG4gICAgICBkLnNldEhvdXJzKDApO1xuICAgICAgZC5zZXRNaW51dGVzKDApO1xuICAgICAgZC5zZXRTZWNvbmRzKDApO1xuICAgICAgZC5zZXRNaWxsaXNlY29uZHMoMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQuc2V0VVRDRnVsbFllYXIocGFyc2VJbnQobVsxXSwgMTApKTtcbiAgICAgIGQuc2V0VVRDRGF0ZShwYXJzZUludChtWzNdLCAxMCkpO1xuICAgICAgZC5zZXRVVENNb250aChwYXJzZUludChtWzJdLCAxMCkgLSAxKTtcbiAgICAgIGQuc2V0VVRDSG91cnMocGFyc2VJbnQobVs1XSwgMTApKTtcbiAgICAgIGQuc2V0VVRDTWludXRlcyhwYXJzZUludChtWzZdLCAxMCkpO1xuICAgICAgZC5zZXRVVENTZWNvbmRzKHBhcnNlSW50KG1bN10sIDEwKSk7XG4gICAgICBkLnNldFVUQ01pbGxpc2Vjb25kcyhwYXJzZUludChtWzldIHx8ICcwJywgMTApKTtcbiAgICAgIGlmIChtWzEwXSAmJiBtWzEwXSAhPT0gJ1onKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZUludChtWzEyXSwxMCkgKiA2MCArIHBhcnNlSW50KG1bMTNdLCAxMCk7XG4gICAgICAgIGQuc2V0VGltZSgobVsxMV0gPT09ICcrJyA/IC0xIDogMSkgKiBvZmZzZXQgKiA2MCAqIDEwMDAgK2QuZ2V0VGltZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRlIGZvcm1hdCBpcyBzcGVjaWZpZWQgOiBcIiArIHN0cik7XG4gIH1cbn07XG5cbi8qXG4gKiBQcmUtZGVmaW5lZCBTYWxlc2ZvcmNlIERhdGUgTGl0ZXJhbHNcbiAqL1xudmFyIFNmRGF0ZUxpdGVyYWxzID0ge1xuICBZRVNURVJEQVk6IDEsXG4gIFRPREFZOiAxLFxuICBUT01PUlJPVzogMSxcbiAgTEFTVF9XRUVLOiAxLFxuICBUSElTX1dFRUs6IDEsXG4gIE5FWFRfV0VFSzogMSxcbiAgTEFTVF9NT05USDogMSxcbiAgVEhJU19NT05USDogMSxcbiAgTkVYVF9NT05USDogMSxcbiAgTEFTVF85MF9EQVlTOiAxLFxuICBORVhUXzkwX0RBWVM6IDEsXG4gIExBU1RfTl9EQVlTOiAyLFxuICBORVhUX05fREFZUzogMixcbiAgTkVYVF9OX1dFRUtTOiAyLFxuICBMQVNUX05fV0VFS1M6IDIsXG4gIE5FWFRfTl9NT05USFM6IDIsXG4gIExBU1RfTl9NT05USFM6IDIsXG4gIFRISVNfUVVBUlRFUjogMSxcbiAgTEFTVF9RVUFSVEVSOiAxLFxuICBORVhUX1FVQVJURVI6IDEsXG4gIE5FWFRfTl9RVUFSVEVSUzogMixcbiAgTEFTVF9OX1FVQVJURVJTOiAyLFxuICBUSElTX1lFQVI6IDEsXG4gIExBU1RfWUVBUjogMSxcbiAgTkVYVF9ZRUFSOiAxLFxuICBORVhUX05fWUVBUlM6IDIsXG4gIExBU1RfTl9ZRUFSUzogMixcbiAgVEhJU19GSVNDQUxfUVVBUlRFUjogMSxcbiAgTEFTVF9GSVNDQUxfUVVBUlRFUjogMSxcbiAgTkVYVF9GSVNDQUxfUVVBUlRFUjogMSxcbiAgTkVYVF9OX0ZJU0NBTF9RVUFSVEVSUzoyLFxuICBMQVNUX05fRklTQ0FMX1FVQVJURVJTOjIsXG4gIFRISVNfRklTQ0FMX1lFQVI6MSxcbiAgTEFTVF9GSVNDQUxfWUVBUjoxLFxuICBORVhUX0ZJU0NBTF9ZRUFSOjEsXG4gIE5FWFRfTl9GSVNDQUxfWUVBUlM6IDIsXG4gIExBU1RfTl9GSVNDQUxfWUVBUlM6IDJcbn07XG5cbmZvciAodmFyIGxpdGVyYWwgaW4gU2ZEYXRlTGl0ZXJhbHMpIHtcbiAgdmFyIHR5cGUgPSBTZkRhdGVMaXRlcmFsc1tsaXRlcmFsXTtcbiAgU2ZEYXRlW2xpdGVyYWxdID1cbiAgIHR5cGUgPT09IDEgPyBuZXcgU2ZEYXRlKGxpdGVyYWwpIDogY3JlYXRlTGl0ZXJhbEJ1aWxkZXIobGl0ZXJhbCk7XG59XG5cbi8qKiBAcHJpdmF0ZSAqKi9cbmZ1bmN0aW9uIGNyZWF0ZUxpdGVyYWxCdWlsZGVyKGxpdGVyYWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbmV3IFNmRGF0ZShsaXRlcmFsICsgXCI6XCIgKyBudW0pOyB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/date.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/http-api.js":
/*!**********************************************!*\
  !*** ./node_modules/jsforce/lib/http-api.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\"),\n    events = __webpack_require__(/*! events */ \"events\"),\n    _ = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    Promise = __webpack_require__(/*! ./promise */ \"(action-browser)/./node_modules/jsforce/lib/promise.js\");\n\n/**\n * HTTP based API class with authorization hook\n *\n * @constructor\n * @extends events.EventEmitter\n * @param {Connection} conn - Connection object\n * @param {Object} [options] - Http API Options\n * @param {String} [options.responseType] - Overriding content mime-type in response\n * @param {Transport} [options.transport] - Transport for http api\n * @param {Object} [options.noContentResponse] - Alternative response when no content returned in response (= HTTP 204)\n */\nvar HttpApi = function(conn, options) {\n  options = options || {};\n  this._conn = conn;\n  this.on('resume', function(err) { conn.emit('resume', err); });\n  this._responseType = options.responseType;\n  this._transport = options.transport || conn._transport;\n  this._noContentResponse = options.noContentResponse;\n};\n\ninherits(HttpApi, events.EventEmitter);\n\n/**\n * Callout to API endpoint using http\n *\n * @param {Object} request - Http Request object\n * @param {String} request.url - Endpoint URL to request\n * @param {String} request.method - Http method for request\n * @param {Object} [request.headers] - Http request headers in hash object\n * @param {Callback.<Object>} callback - Callback function\n * @returns {Promise.<Object>} -\n */\nHttpApi.prototype.request = function(request, callback) {\n  var self = this;\n  var conn = this._conn;\n  var logger = conn._logger;\n  var refreshDelegate = this.getRefreshDelegate();\n  // remember previous instance url in case it changes after a refresh\n  var lastInstanceUrl = conn.instanceUrl;\n\n  var deferred = Promise.defer();\n\n  var onResume = function(err) {\n    if (err) {\n      deferred.reject(err);\n      return;\n    }\n    // check to see if the token refresh has changed the instance url\n    if(lastInstanceUrl !== conn.instanceUrl){\n      // if the instance url has changed\n      // then replace the current request urls instance url fragment\n      // with the updated instance url\n      request.url = request.url.replace(lastInstanceUrl,conn.instanceUrl);\n    }\n\n    self.request(request).then(function(response) {\n      deferred.resolve(response);\n    }, function(err) {\n      deferred.reject(err);\n    });\n  };\n\n  if (refreshDelegate && refreshDelegate._refreshing) {\n    refreshDelegate.once('resume', onResume);\n    return deferred.promise.thenCall(callback);\n  }\n\n  // hook before sending\n  self.beforeSend(request);\n\n  self.emit('request', request);\n  logger.debug(\"<request> method=\" + request.method + \", url=\" + request.url);\n  var requestTime = Date.now();\n\n  return this._transport.httpRequest(request).then(function(response) {\n    var responseTime = Date.now();\n    logger.debug(\"elapsed time : \" + (responseTime - requestTime) + \"msec\");\n    logger.debug(\"<response> status=\" + response.statusCode + \", url=\" + request.url);\n\n    self.emit('response', response);\n    // Refresh token if session has been expired and requires authentication\n    // when session refresh delegate is available\n    if (self.isSessionExpired(response) && refreshDelegate) {\n      refreshDelegate.refresh(requestTime, onResume);\n      return deferred.promise;\n    }\n    if (self.isErrorResponse(response)) {\n      var err = self.getError(response);\n      throw err;\n    }\n    return self.getResponseBody(response);\n  }, function(err) {\n    var responseTime = Date.now();\n    logger.debug(\"elapsed time : \" + (responseTime - requestTime) + \"msec\");\n    logger.error(err);\n    throw err;\n  })\n  .thenCall(callback);\n};\n\n/**\n * @protected\n */\nHttpApi.prototype.getRefreshDelegate = function() {\n  return this._conn._refreshDelegate;\n};\n\n/**\n *\n * @protected\n */\nHttpApi.prototype.beforeSend = function(request) {\n  request.headers = request.headers || {};\n  if (this._conn.accessToken) {\n    request.headers.Authorization = \"Bearer \" + this._conn.accessToken;\n  }\n  if (this._conn.callOptions) {\n    var callOptions = [];\n    for (var name in this._conn.callOptions) {\n      callOptions.push(name + \"=\" + this._conn.callOptions[name]);\n    }\n    request.headers[\"Sforce-Call-Options\"] = callOptions.join(', ');\n  }\n};\n\n/**\n * Detect response content mime-type\n * @protected\n */\nHttpApi.prototype.getResponseContentType = function(response) {\n  return this._responseType || response.headers && response.headers[\"content-type\"];\n};\n\n/**\n *\n */\nHttpApi.prototype.parseResponseBody = function(response) {\n  var contentType = this.getResponseContentType(response);\n  var parseBody = /^(text|application)\\/xml(;|$)/.test(contentType) ? parseXML :\n         /^application\\/json(;|$)/.test(contentType) ? parseJSON :\n         /^text\\/csv(;|$)/.test(contentType) ? parseCSV :\n         parseText;\n  try {\n    return parseBody(response.body);\n  } catch(e) {\n    return response.body;\n  }\n};\n\n/**\n * Get response body\n * @protected\n */\nHttpApi.prototype.getResponseBody = function(response) {\n  if (response.statusCode === 204) { // No Content\n    return this._noContentResponse;\n  }\n  var body = this.parseResponseBody(response);\n  var err;\n  if (this.hasErrorInResponseBody(body)) {\n    err = this.getError(response, body);\n    throw err;\n  }\n  if (response.statusCode === 300) { // Multiple Choices\n    err = new Error('Multiple records found');\n    err.name = \"MULTIPLE_CHOICES\";\n    err.content = body;\n    throw err;\n  }\n  return body;\n};\n\n/** @private */\nfunction parseJSON(str) {\n  return JSON.parse(str);\n}\n\n/** @private */\nfunction parseXML(str) {\n  var ret = {};\n  (__webpack_require__(/*! xml2js */ \"(action-browser)/./node_modules/xml2js/lib/xml2js.js\").parseString)(str, { explicitArray: false }, function(err, result) {\n    ret = { error: err, result : result };\n  });\n  if (ret.error) { throw ret.error; }\n  return ret.result;\n}\n\n/** @private */\nfunction parseCSV(str) {\n  return (__webpack_require__(/*! ./csv */ \"(action-browser)/./node_modules/jsforce/lib/csv.js\").parseCSV)(str);\n}\n\n/** @private */\nfunction parseText(str) { return str; }\n\n\n/**\n * Detect session expiry\n * @protected\n */\nHttpApi.prototype.isSessionExpired = function(response) {\n  return response.statusCode === 401;\n};\n\n/**\n * Detect error response\n * @protected\n */\nHttpApi.prototype.isErrorResponse = function(response) {\n  return response.statusCode >= 400;\n};\n\n/**\n * Detect error in response body\n * @protected\n */\nHttpApi.prototype.hasErrorInResponseBody = function(body) {\n  return false;\n};\n\n/**\n * Parsing error message in response\n * @protected\n */\nHttpApi.prototype.parseError = function(body) {\n  var errors = body;\n  return _.isArray(errors) ? errors[0] : errors;\n};\n\n/**\n * Get error message in response\n * @protected\n */\nHttpApi.prototype.getError = function(response, body) {\n  var error;\n  try {\n    error = this.parseError(body || this.parseResponseBody(response));\n  } catch(e) {}\n  error = _.isObject(error) && _.isString(error.message) ? error : {\n    errorCode: 'ERROR_HTTP_' + response.statusCode,\n    message : response.body\n  };\n  var err = new Error(error.message);\n  err.name = error.errorCode;\n  for (var key in error) { err[key] = error[key]; }\n  return err;\n};\n\n/*-------------------------------------------------------------------------*/\n\n/**\n * @protected\n */\nvar SessionRefreshDelegate = function(conn, refreshFn) {\n  this._conn = conn;\n  this._refreshFn = refreshFn;\n  this._refreshing = false;\n};\n\ninherits(SessionRefreshDelegate, events.EventEmitter);\n\n/**\n * Refresh access token\n * @private\n */\nSessionRefreshDelegate.prototype.refresh = function(since, callback) {\n  // Callback immediately When refreshed after designated time\n  if (this._lastRefreshedAt > since) { return callback(); }\n  var self = this;\n  var conn = this._conn;\n  var logger = conn._logger;\n  self.once('resume', callback);\n  if (self._refreshing) { return; }\n  logger.debug(\"<refresh token>\");\n  self._refreshing = true;\n  return self._refreshFn(conn, function(err, accessToken, res) {\n    if (!err) {\n      logger.debug(\"Connection refresh completed.\");\n      conn.accessToken = accessToken;\n      conn.emit(\"refresh\", accessToken, res);\n    }\n    self._lastRefreshedAt = Date.now();\n    self._refreshing = false;\n    self.emit('resume', err);\n  });\n};\n\n\n/**\n *\n */\nHttpApi.SessionRefreshDelegate = SessionRefreshDelegate;\nmodule.exports = HttpApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9odHRwLWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsc0VBQVU7QUFDakMsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLFFBQVEsbUJBQU8sQ0FBQyxtRUFBYTtBQUM3QixjQUFjLG1CQUFPLENBQUMseUVBQVc7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDhCQUE4QjtBQUM5QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRSx1R0FBNkIsUUFBUSxzQkFBc0I7QUFDN0QsWUFBWTtBQUNaLEdBQUc7QUFDSCxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxpR0FBeUI7QUFDbEM7O0FBRUE7QUFDQSwwQkFBMEI7OztBQUcxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvaHR0cC1hcGkuanM/NTc1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyksXG4gICAgXyA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vcHJvbWlzZScpO1xuXG4vKipcbiAqIEhUVFAgYmFzZWQgQVBJIGNsYXNzIHdpdGggYXV0aG9yaXphdGlvbiBob29rXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gLSBDb25uZWN0aW9uIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEh0dHAgQVBJIE9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXNwb25zZVR5cGVdIC0gT3ZlcnJpZGluZyBjb250ZW50IG1pbWUtdHlwZSBpbiByZXNwb25zZVxuICogQHBhcmFtIHtUcmFuc3BvcnR9IFtvcHRpb25zLnRyYW5zcG9ydF0gLSBUcmFuc3BvcnQgZm9yIGh0dHAgYXBpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubm9Db250ZW50UmVzcG9uc2VdIC0gQWx0ZXJuYXRpdmUgcmVzcG9uc2Ugd2hlbiBubyBjb250ZW50IHJldHVybmVkIGluIHJlc3BvbnNlICg9IEhUVFAgMjA0KVxuICovXG52YXIgSHR0cEFwaSA9IGZ1bmN0aW9uKGNvbm4sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX2Nvbm4gPSBjb25uO1xuICB0aGlzLm9uKCdyZXN1bWUnLCBmdW5jdGlvbihlcnIpIHsgY29ubi5lbWl0KCdyZXN1bWUnLCBlcnIpOyB9KTtcbiAgdGhpcy5fcmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGU7XG4gIHRoaXMuX3RyYW5zcG9ydCA9IG9wdGlvbnMudHJhbnNwb3J0IHx8IGNvbm4uX3RyYW5zcG9ydDtcbiAgdGhpcy5fbm9Db250ZW50UmVzcG9uc2UgPSBvcHRpb25zLm5vQ29udGVudFJlc3BvbnNlO1xufTtcblxuaW5oZXJpdHMoSHR0cEFwaSwgZXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogQ2FsbG91dCB0byBBUEkgZW5kcG9pbnQgdXNpbmcgaHR0cFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IC0gSHR0cCBSZXF1ZXN0IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3QudXJsIC0gRW5kcG9pbnQgVVJMIHRvIHJlcXVlc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0Lm1ldGhvZCAtIEh0dHAgbWV0aG9kIGZvciByZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3QuaGVhZGVyc10gLSBIdHRwIHJlcXVlc3QgaGVhZGVycyBpbiBoYXNoIG9iamVjdFxuICogQHBhcmFtIHtDYWxsYmFjay48T2JqZWN0Pn0gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59IC1cbiAqL1xuSHR0cEFwaS5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3QsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNvbm4gPSB0aGlzLl9jb25uO1xuICB2YXIgbG9nZ2VyID0gY29ubi5fbG9nZ2VyO1xuICB2YXIgcmVmcmVzaERlbGVnYXRlID0gdGhpcy5nZXRSZWZyZXNoRGVsZWdhdGUoKTtcbiAgLy8gcmVtZW1iZXIgcHJldmlvdXMgaW5zdGFuY2UgdXJsIGluIGNhc2UgaXQgY2hhbmdlcyBhZnRlciBhIHJlZnJlc2hcbiAgdmFyIGxhc3RJbnN0YW5jZVVybCA9IGNvbm4uaW5zdGFuY2VVcmw7XG5cbiAgdmFyIGRlZmVycmVkID0gUHJvbWlzZS5kZWZlcigpO1xuXG4gIHZhciBvblJlc3VtZSA9IGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHRva2VuIHJlZnJlc2ggaGFzIGNoYW5nZWQgdGhlIGluc3RhbmNlIHVybFxuICAgIGlmKGxhc3RJbnN0YW5jZVVybCAhPT0gY29ubi5pbnN0YW5jZVVybCl7XG4gICAgICAvLyBpZiB0aGUgaW5zdGFuY2UgdXJsIGhhcyBjaGFuZ2VkXG4gICAgICAvLyB0aGVuIHJlcGxhY2UgdGhlIGN1cnJlbnQgcmVxdWVzdCB1cmxzIGluc3RhbmNlIHVybCBmcmFnbWVudFxuICAgICAgLy8gd2l0aCB0aGUgdXBkYXRlZCBpbnN0YW5jZSB1cmxcbiAgICAgIHJlcXVlc3QudXJsID0gcmVxdWVzdC51cmwucmVwbGFjZShsYXN0SW5zdGFuY2VVcmwsY29ubi5pbnN0YW5jZVVybCk7XG4gICAgfVxuXG4gICAgc2VsZi5yZXF1ZXN0KHJlcXVlc3QpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzcG9uc2UpO1xuICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKHJlZnJlc2hEZWxlZ2F0ZSAmJiByZWZyZXNoRGVsZWdhdGUuX3JlZnJlc2hpbmcpIHtcbiAgICByZWZyZXNoRGVsZWdhdGUub25jZSgncmVzdW1lJywgb25SZXN1bWUpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlLnRoZW5DYWxsKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIGhvb2sgYmVmb3JlIHNlbmRpbmdcbiAgc2VsZi5iZWZvcmVTZW5kKHJlcXVlc3QpO1xuXG4gIHNlbGYuZW1pdCgncmVxdWVzdCcsIHJlcXVlc3QpO1xuICBsb2dnZXIuZGVidWcoXCI8cmVxdWVzdD4gbWV0aG9kPVwiICsgcmVxdWVzdC5tZXRob2QgKyBcIiwgdXJsPVwiICsgcmVxdWVzdC51cmwpO1xuICB2YXIgcmVxdWVzdFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIHJldHVybiB0aGlzLl90cmFuc3BvcnQuaHR0cFJlcXVlc3QocmVxdWVzdCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIHZhciByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxvZ2dlci5kZWJ1ZyhcImVsYXBzZWQgdGltZSA6IFwiICsgKHJlc3BvbnNlVGltZSAtIHJlcXVlc3RUaW1lKSArIFwibXNlY1wiKTtcbiAgICBsb2dnZXIuZGVidWcoXCI8cmVzcG9uc2U+IHN0YXR1cz1cIiArIHJlc3BvbnNlLnN0YXR1c0NvZGUgKyBcIiwgdXJsPVwiICsgcmVxdWVzdC51cmwpO1xuXG4gICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlc3BvbnNlKTtcbiAgICAvLyBSZWZyZXNoIHRva2VuIGlmIHNlc3Npb24gaGFzIGJlZW4gZXhwaXJlZCBhbmQgcmVxdWlyZXMgYXV0aGVudGljYXRpb25cbiAgICAvLyB3aGVuIHNlc3Npb24gcmVmcmVzaCBkZWxlZ2F0ZSBpcyBhdmFpbGFibGVcbiAgICBpZiAoc2VsZi5pc1Nlc3Npb25FeHBpcmVkKHJlc3BvbnNlKSAmJiByZWZyZXNoRGVsZWdhdGUpIHtcbiAgICAgIHJlZnJlc2hEZWxlZ2F0ZS5yZWZyZXNoKHJlcXVlc3RUaW1lLCBvblJlc3VtZSk7XG4gICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG4gICAgaWYgKHNlbGYuaXNFcnJvclJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgdmFyIGVyciA9IHNlbGYuZ2V0RXJyb3IocmVzcG9uc2UpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZi5nZXRSZXNwb25zZUJvZHkocmVzcG9uc2UpO1xuICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICB2YXIgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsb2dnZXIuZGVidWcoXCJlbGFwc2VkIHRpbWUgOiBcIiArIChyZXNwb25zZVRpbWUgLSByZXF1ZXN0VGltZSkgKyBcIm1zZWNcIik7XG4gICAgbG9nZ2VyLmVycm9yKGVycik7XG4gICAgdGhyb3cgZXJyO1xuICB9KVxuICAudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkh0dHBBcGkucHJvdG90eXBlLmdldFJlZnJlc2hEZWxlZ2F0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY29ubi5fcmVmcmVzaERlbGVnYXRlO1xufTtcblxuLyoqXG4gKlxuICogQHByb3RlY3RlZFxuICovXG5IdHRwQXBpLnByb3RvdHlwZS5iZWZvcmVTZW5kID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICByZXF1ZXN0LmhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnMgfHwge307XG4gIGlmICh0aGlzLl9jb25uLmFjY2Vzc1Rva2VuKSB7XG4gICAgcmVxdWVzdC5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBcIkJlYXJlciBcIiArIHRoaXMuX2Nvbm4uYWNjZXNzVG9rZW47XG4gIH1cbiAgaWYgKHRoaXMuX2Nvbm4uY2FsbE9wdGlvbnMpIHtcbiAgICB2YXIgY2FsbE9wdGlvbnMgPSBbXTtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuX2Nvbm4uY2FsbE9wdGlvbnMpIHtcbiAgICAgIGNhbGxPcHRpb25zLnB1c2gobmFtZSArIFwiPVwiICsgdGhpcy5fY29ubi5jYWxsT3B0aW9uc1tuYW1lXSk7XG4gICAgfVxuICAgIHJlcXVlc3QuaGVhZGVyc1tcIlNmb3JjZS1DYWxsLU9wdGlvbnNcIl0gPSBjYWxsT3B0aW9ucy5qb2luKCcsICcpO1xuICB9XG59O1xuXG4vKipcbiAqIERldGVjdCByZXNwb25zZSBjb250ZW50IG1pbWUtdHlwZVxuICogQHByb3RlY3RlZFxuICovXG5IdHRwQXBpLnByb3RvdHlwZS5nZXRSZXNwb25zZUNvbnRlbnRUeXBlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlVHlwZSB8fCByZXNwb25zZS5oZWFkZXJzICYmIHJlc3BvbnNlLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl07XG59O1xuXG4vKipcbiAqXG4gKi9cbkh0dHBBcGkucHJvdG90eXBlLnBhcnNlUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgdmFyIGNvbnRlbnRUeXBlID0gdGhpcy5nZXRSZXNwb25zZUNvbnRlbnRUeXBlKHJlc3BvbnNlKTtcbiAgdmFyIHBhcnNlQm9keSA9IC9eKHRleHR8YXBwbGljYXRpb24pXFwveG1sKDt8JCkvLnRlc3QoY29udGVudFR5cGUpID8gcGFyc2VYTUwgOlxuICAgICAgICAgL15hcHBsaWNhdGlvblxcL2pzb24oO3wkKS8udGVzdChjb250ZW50VHlwZSkgPyBwYXJzZUpTT04gOlxuICAgICAgICAgL150ZXh0XFwvY3N2KDt8JCkvLnRlc3QoY29udGVudFR5cGUpID8gcGFyc2VDU1YgOlxuICAgICAgICAgcGFyc2VUZXh0O1xuICB0cnkge1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVzcG9uc2UuYm9keSk7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiByZXNwb25zZS5ib2R5O1xuICB9XG59O1xuXG4vKipcbiAqIEdldCByZXNwb25zZSBib2R5XG4gKiBAcHJvdGVjdGVkXG4gKi9cbkh0dHBBcGkucHJvdG90eXBlLmdldFJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDQpIHsgLy8gTm8gQ29udGVudFxuICAgIHJldHVybiB0aGlzLl9ub0NvbnRlbnRSZXNwb25zZTtcbiAgfVxuICB2YXIgYm9keSA9IHRoaXMucGFyc2VSZXNwb25zZUJvZHkocmVzcG9uc2UpO1xuICB2YXIgZXJyO1xuICBpZiAodGhpcy5oYXNFcnJvckluUmVzcG9uc2VCb2R5KGJvZHkpKSB7XG4gICAgZXJyID0gdGhpcy5nZXRFcnJvcihyZXNwb25zZSwgYm9keSk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDApIHsgLy8gTXVsdGlwbGUgQ2hvaWNlc1xuICAgIGVyciA9IG5ldyBFcnJvcignTXVsdGlwbGUgcmVjb3JkcyBmb3VuZCcpO1xuICAgIGVyci5uYW1lID0gXCJNVUxUSVBMRV9DSE9JQ0VTXCI7XG4gICAgZXJyLmNvbnRlbnQgPSBib2R5O1xuICAgIHRocm93IGVycjtcbiAgfVxuICByZXR1cm4gYm9keTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gcGFyc2VKU09OKHN0cikge1xuICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xufVxuXG4vKiogQHByaXZhdGUgKi9cbmZ1bmN0aW9uIHBhcnNlWE1MKHN0cikge1xuICB2YXIgcmV0ID0ge307XG4gIHJlcXVpcmUoJ3htbDJqcycpLnBhcnNlU3RyaW5nKHN0ciwgeyBleHBsaWNpdEFycmF5OiBmYWxzZSB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgIHJldCA9IHsgZXJyb3I6IGVyciwgcmVzdWx0IDogcmVzdWx0IH07XG4gIH0pO1xuICBpZiAocmV0LmVycm9yKSB7IHRocm93IHJldC5lcnJvcjsgfVxuICByZXR1cm4gcmV0LnJlc3VsdDtcbn1cblxuLyoqIEBwcml2YXRlICovXG5mdW5jdGlvbiBwYXJzZUNTVihzdHIpIHtcbiAgcmV0dXJuIHJlcXVpcmUoJy4vY3N2JykucGFyc2VDU1Yoc3RyKTtcbn1cblxuLyoqIEBwcml2YXRlICovXG5mdW5jdGlvbiBwYXJzZVRleHQoc3RyKSB7IHJldHVybiBzdHI7IH1cblxuXG4vKipcbiAqIERldGVjdCBzZXNzaW9uIGV4cGlyeVxuICogQHByb3RlY3RlZFxuICovXG5IdHRwQXBpLnByb3RvdHlwZS5pc1Nlc3Npb25FeHBpcmVkID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwMTtcbn07XG5cbi8qKlxuICogRGV0ZWN0IGVycm9yIHJlc3BvbnNlXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkh0dHBBcGkucHJvdG90eXBlLmlzRXJyb3JSZXNwb25zZSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMDtcbn07XG5cbi8qKlxuICogRGV0ZWN0IGVycm9yIGluIHJlc3BvbnNlIGJvZHlcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuSHR0cEFwaS5wcm90b3R5cGUuaGFzRXJyb3JJblJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBQYXJzaW5nIGVycm9yIG1lc3NhZ2UgaW4gcmVzcG9uc2VcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuSHR0cEFwaS5wcm90b3R5cGUucGFyc2VFcnJvciA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgdmFyIGVycm9ycyA9IGJvZHk7XG4gIHJldHVybiBfLmlzQXJyYXkoZXJyb3JzKSA/IGVycm9yc1swXSA6IGVycm9ycztcbn07XG5cbi8qKlxuICogR2V0IGVycm9yIG1lc3NhZ2UgaW4gcmVzcG9uc2VcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuSHR0cEFwaS5wcm90b3R5cGUuZ2V0RXJyb3IgPSBmdW5jdGlvbihyZXNwb25zZSwgYm9keSkge1xuICB2YXIgZXJyb3I7XG4gIHRyeSB7XG4gICAgZXJyb3IgPSB0aGlzLnBhcnNlRXJyb3IoYm9keSB8fCB0aGlzLnBhcnNlUmVzcG9uc2VCb2R5KHJlc3BvbnNlKSk7XG4gIH0gY2F0Y2goZSkge31cbiAgZXJyb3IgPSBfLmlzT2JqZWN0KGVycm9yKSAmJiBfLmlzU3RyaW5nKGVycm9yLm1lc3NhZ2UpID8gZXJyb3IgOiB7XG4gICAgZXJyb3JDb2RlOiAnRVJST1JfSFRUUF8nICsgcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICBtZXNzYWdlIDogcmVzcG9uc2UuYm9keVxuICB9O1xuICB2YXIgZXJyID0gbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICBlcnIubmFtZSA9IGVycm9yLmVycm9yQ29kZTtcbiAgZm9yICh2YXIga2V5IGluIGVycm9yKSB7IGVycltrZXldID0gZXJyb3Jba2V5XTsgfVxuICByZXR1cm4gZXJyO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBAcHJvdGVjdGVkXG4gKi9cbnZhciBTZXNzaW9uUmVmcmVzaERlbGVnYXRlID0gZnVuY3Rpb24oY29ubiwgcmVmcmVzaEZuKSB7XG4gIHRoaXMuX2Nvbm4gPSBjb25uO1xuICB0aGlzLl9yZWZyZXNoRm4gPSByZWZyZXNoRm47XG4gIHRoaXMuX3JlZnJlc2hpbmcgPSBmYWxzZTtcbn07XG5cbmluaGVyaXRzKFNlc3Npb25SZWZyZXNoRGVsZWdhdGUsIGV2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIFJlZnJlc2ggYWNjZXNzIHRva2VuXG4gKiBAcHJpdmF0ZVxuICovXG5TZXNzaW9uUmVmcmVzaERlbGVnYXRlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oc2luY2UsIGNhbGxiYWNrKSB7XG4gIC8vIENhbGxiYWNrIGltbWVkaWF0ZWx5IFdoZW4gcmVmcmVzaGVkIGFmdGVyIGRlc2lnbmF0ZWQgdGltZVxuICBpZiAodGhpcy5fbGFzdFJlZnJlc2hlZEF0ID4gc2luY2UpIHsgcmV0dXJuIGNhbGxiYWNrKCk7IH1cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY29ubiA9IHRoaXMuX2Nvbm47XG4gIHZhciBsb2dnZXIgPSBjb25uLl9sb2dnZXI7XG4gIHNlbGYub25jZSgncmVzdW1lJywgY2FsbGJhY2spO1xuICBpZiAoc2VsZi5fcmVmcmVzaGluZykgeyByZXR1cm47IH1cbiAgbG9nZ2VyLmRlYnVnKFwiPHJlZnJlc2ggdG9rZW4+XCIpO1xuICBzZWxmLl9yZWZyZXNoaW5nID0gdHJ1ZTtcbiAgcmV0dXJuIHNlbGYuX3JlZnJlc2hGbihjb25uLCBmdW5jdGlvbihlcnIsIGFjY2Vzc1Rva2VuLCByZXMpIHtcbiAgICBpZiAoIWVycikge1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiQ29ubmVjdGlvbiByZWZyZXNoIGNvbXBsZXRlZC5cIik7XG4gICAgICBjb25uLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gICAgICBjb25uLmVtaXQoXCJyZWZyZXNoXCIsIGFjY2Vzc1Rva2VuLCByZXMpO1xuICAgIH1cbiAgICBzZWxmLl9sYXN0UmVmcmVzaGVkQXQgPSBEYXRlLm5vdygpO1xuICAgIHNlbGYuX3JlZnJlc2hpbmcgPSBmYWxzZTtcbiAgICBzZWxmLmVtaXQoJ3Jlc3VtZScsIGVycik7XG4gIH0pO1xufTtcblxuXG4vKipcbiAqXG4gKi9cbkh0dHBBcGkuU2Vzc2lvblJlZnJlc2hEZWxlZ2F0ZSA9IFNlc3Npb25SZWZyZXNoRGVsZWdhdGU7XG5tb2R1bGUuZXhwb3J0cyA9IEh0dHBBcGk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/http-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/http-api.js":
/*!**********************************************!*\
  !*** ./node_modules/jsforce/lib/http-api.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\"),\n    events = __webpack_require__(/*! events */ \"events\"),\n    _ = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    Promise = __webpack_require__(/*! ./promise */ \"(rsc)/./node_modules/jsforce/lib/promise.js\");\n\n/**\n * HTTP based API class with authorization hook\n *\n * @constructor\n * @extends events.EventEmitter\n * @param {Connection} conn - Connection object\n * @param {Object} [options] - Http API Options\n * @param {String} [options.responseType] - Overriding content mime-type in response\n * @param {Transport} [options.transport] - Transport for http api\n * @param {Object} [options.noContentResponse] - Alternative response when no content returned in response (= HTTP 204)\n */\nvar HttpApi = function(conn, options) {\n  options = options || {};\n  this._conn = conn;\n  this.on('resume', function(err) { conn.emit('resume', err); });\n  this._responseType = options.responseType;\n  this._transport = options.transport || conn._transport;\n  this._noContentResponse = options.noContentResponse;\n};\n\ninherits(HttpApi, events.EventEmitter);\n\n/**\n * Callout to API endpoint using http\n *\n * @param {Object} request - Http Request object\n * @param {String} request.url - Endpoint URL to request\n * @param {String} request.method - Http method for request\n * @param {Object} [request.headers] - Http request headers in hash object\n * @param {Callback.<Object>} callback - Callback function\n * @returns {Promise.<Object>} -\n */\nHttpApi.prototype.request = function(request, callback) {\n  var self = this;\n  var conn = this._conn;\n  var logger = conn._logger;\n  var refreshDelegate = this.getRefreshDelegate();\n  // remember previous instance url in case it changes after a refresh\n  var lastInstanceUrl = conn.instanceUrl;\n\n  var deferred = Promise.defer();\n\n  var onResume = function(err) {\n    if (err) {\n      deferred.reject(err);\n      return;\n    }\n    // check to see if the token refresh has changed the instance url\n    if(lastInstanceUrl !== conn.instanceUrl){\n      // if the instance url has changed\n      // then replace the current request urls instance url fragment\n      // with the updated instance url\n      request.url = request.url.replace(lastInstanceUrl,conn.instanceUrl);\n    }\n\n    self.request(request).then(function(response) {\n      deferred.resolve(response);\n    }, function(err) {\n      deferred.reject(err);\n    });\n  };\n\n  if (refreshDelegate && refreshDelegate._refreshing) {\n    refreshDelegate.once('resume', onResume);\n    return deferred.promise.thenCall(callback);\n  }\n\n  // hook before sending\n  self.beforeSend(request);\n\n  self.emit('request', request);\n  logger.debug(\"<request> method=\" + request.method + \", url=\" + request.url);\n  var requestTime = Date.now();\n\n  return this._transport.httpRequest(request).then(function(response) {\n    var responseTime = Date.now();\n    logger.debug(\"elapsed time : \" + (responseTime - requestTime) + \"msec\");\n    logger.debug(\"<response> status=\" + response.statusCode + \", url=\" + request.url);\n\n    self.emit('response', response);\n    // Refresh token if session has been expired and requires authentication\n    // when session refresh delegate is available\n    if (self.isSessionExpired(response) && refreshDelegate) {\n      refreshDelegate.refresh(requestTime, onResume);\n      return deferred.promise;\n    }\n    if (self.isErrorResponse(response)) {\n      var err = self.getError(response);\n      throw err;\n    }\n    return self.getResponseBody(response);\n  }, function(err) {\n    var responseTime = Date.now();\n    logger.debug(\"elapsed time : \" + (responseTime - requestTime) + \"msec\");\n    logger.error(err);\n    throw err;\n  })\n  .thenCall(callback);\n};\n\n/**\n * @protected\n */\nHttpApi.prototype.getRefreshDelegate = function() {\n  return this._conn._refreshDelegate;\n};\n\n/**\n *\n * @protected\n */\nHttpApi.prototype.beforeSend = function(request) {\n  request.headers = request.headers || {};\n  if (this._conn.accessToken) {\n    request.headers.Authorization = \"Bearer \" + this._conn.accessToken;\n  }\n  if (this._conn.callOptions) {\n    var callOptions = [];\n    for (var name in this._conn.callOptions) {\n      callOptions.push(name + \"=\" + this._conn.callOptions[name]);\n    }\n    request.headers[\"Sforce-Call-Options\"] = callOptions.join(', ');\n  }\n};\n\n/**\n * Detect response content mime-type\n * @protected\n */\nHttpApi.prototype.getResponseContentType = function(response) {\n  return this._responseType || response.headers && response.headers[\"content-type\"];\n};\n\n/**\n *\n */\nHttpApi.prototype.parseResponseBody = function(response) {\n  var contentType = this.getResponseContentType(response);\n  var parseBody = /^(text|application)\\/xml(;|$)/.test(contentType) ? parseXML :\n         /^application\\/json(;|$)/.test(contentType) ? parseJSON :\n         /^text\\/csv(;|$)/.test(contentType) ? parseCSV :\n         parseText;\n  try {\n    return parseBody(response.body);\n  } catch(e) {\n    return response.body;\n  }\n};\n\n/**\n * Get response body\n * @protected\n */\nHttpApi.prototype.getResponseBody = function(response) {\n  if (response.statusCode === 204) { // No Content\n    return this._noContentResponse;\n  }\n  var body = this.parseResponseBody(response);\n  var err;\n  if (this.hasErrorInResponseBody(body)) {\n    err = this.getError(response, body);\n    throw err;\n  }\n  if (response.statusCode === 300) { // Multiple Choices\n    err = new Error('Multiple records found');\n    err.name = \"MULTIPLE_CHOICES\";\n    err.content = body;\n    throw err;\n  }\n  return body;\n};\n\n/** @private */\nfunction parseJSON(str) {\n  return JSON.parse(str);\n}\n\n/** @private */\nfunction parseXML(str) {\n  var ret = {};\n  (__webpack_require__(/*! xml2js */ \"(rsc)/./node_modules/xml2js/lib/xml2js.js\").parseString)(str, { explicitArray: false }, function(err, result) {\n    ret = { error: err, result : result };\n  });\n  if (ret.error) { throw ret.error; }\n  return ret.result;\n}\n\n/** @private */\nfunction parseCSV(str) {\n  return (__webpack_require__(/*! ./csv */ \"(rsc)/./node_modules/jsforce/lib/csv.js\").parseCSV)(str);\n}\n\n/** @private */\nfunction parseText(str) { return str; }\n\n\n/**\n * Detect session expiry\n * @protected\n */\nHttpApi.prototype.isSessionExpired = function(response) {\n  return response.statusCode === 401;\n};\n\n/**\n * Detect error response\n * @protected\n */\nHttpApi.prototype.isErrorResponse = function(response) {\n  return response.statusCode >= 400;\n};\n\n/**\n * Detect error in response body\n * @protected\n */\nHttpApi.prototype.hasErrorInResponseBody = function(body) {\n  return false;\n};\n\n/**\n * Parsing error message in response\n * @protected\n */\nHttpApi.prototype.parseError = function(body) {\n  var errors = body;\n  return _.isArray(errors) ? errors[0] : errors;\n};\n\n/**\n * Get error message in response\n * @protected\n */\nHttpApi.prototype.getError = function(response, body) {\n  var error;\n  try {\n    error = this.parseError(body || this.parseResponseBody(response));\n  } catch(e) {}\n  error = _.isObject(error) && _.isString(error.message) ? error : {\n    errorCode: 'ERROR_HTTP_' + response.statusCode,\n    message : response.body\n  };\n  var err = new Error(error.message);\n  err.name = error.errorCode;\n  for (var key in error) { err[key] = error[key]; }\n  return err;\n};\n\n/*-------------------------------------------------------------------------*/\n\n/**\n * @protected\n */\nvar SessionRefreshDelegate = function(conn, refreshFn) {\n  this._conn = conn;\n  this._refreshFn = refreshFn;\n  this._refreshing = false;\n};\n\ninherits(SessionRefreshDelegate, events.EventEmitter);\n\n/**\n * Refresh access token\n * @private\n */\nSessionRefreshDelegate.prototype.refresh = function(since, callback) {\n  // Callback immediately When refreshed after designated time\n  if (this._lastRefreshedAt > since) { return callback(); }\n  var self = this;\n  var conn = this._conn;\n  var logger = conn._logger;\n  self.once('resume', callback);\n  if (self._refreshing) { return; }\n  logger.debug(\"<refresh token>\");\n  self._refreshing = true;\n  return self._refreshFn(conn, function(err, accessToken, res) {\n    if (!err) {\n      logger.debug(\"Connection refresh completed.\");\n      conn.accessToken = accessToken;\n      conn.emit(\"refresh\", accessToken, res);\n    }\n    self._lastRefreshedAt = Date.now();\n    self._refreshing = false;\n    self.emit('resume', err);\n  });\n};\n\n\n/**\n *\n */\nHttpApi.SessionRefreshDelegate = SessionRefreshDelegate;\nmodule.exports = HttpApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvaHR0cC1hcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDJEQUFVO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixRQUFRLG1CQUFPLENBQUMsd0RBQWE7QUFDN0IsY0FBYyxtQkFBTyxDQUFDLDhEQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyQkFBMkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qyw4QkFBOEI7QUFDOUIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNEZBQTZCLFFBQVEsc0JBQXNCO0FBQzdELFlBQVk7QUFDWixHQUFHO0FBQ0gsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsc0ZBQXlCO0FBQ2xDOztBQUVBO0FBQ0EsMEJBQTBCOzs7QUFHMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2h0dHAtYXBpLmpzPzQ0ZjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpLFxuICAgIF8gPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL3Byb21pc2UnKTtcblxuLyoqXG4gKiBIVFRQIGJhc2VkIEFQSSBjbGFzcyB3aXRoIGF1dGhvcml6YXRpb24gaG9va1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlclxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIC0gQ29ubmVjdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBIdHRwIEFQSSBPcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVzcG9uc2VUeXBlXSAtIE92ZXJyaWRpbmcgY29udGVudCBtaW1lLXR5cGUgaW4gcmVzcG9uc2VcbiAqIEBwYXJhbSB7VHJhbnNwb3J0fSBbb3B0aW9ucy50cmFuc3BvcnRdIC0gVHJhbnNwb3J0IGZvciBodHRwIGFwaVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm5vQ29udGVudFJlc3BvbnNlXSAtIEFsdGVybmF0aXZlIHJlc3BvbnNlIHdoZW4gbm8gY29udGVudCByZXR1cm5lZCBpbiByZXNwb25zZSAoPSBIVFRQIDIwNClcbiAqL1xudmFyIEh0dHBBcGkgPSBmdW5jdGlvbihjb25uLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9jb25uID0gY29ubjtcbiAgdGhpcy5vbigncmVzdW1lJywgZnVuY3Rpb24oZXJyKSB7IGNvbm4uZW1pdCgncmVzdW1lJywgZXJyKTsgfSk7XG4gIHRoaXMuX3Jlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlO1xuICB0aGlzLl90cmFuc3BvcnQgPSBvcHRpb25zLnRyYW5zcG9ydCB8fCBjb25uLl90cmFuc3BvcnQ7XG4gIHRoaXMuX25vQ29udGVudFJlc3BvbnNlID0gb3B0aW9ucy5ub0NvbnRlbnRSZXNwb25zZTtcbn07XG5cbmluaGVyaXRzKEh0dHBBcGksIGV2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIENhbGxvdXQgdG8gQVBJIGVuZHBvaW50IHVzaW5nIGh0dHBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCAtIEh0dHAgUmVxdWVzdCBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0LnVybCAtIEVuZHBvaW50IFVSTCB0byByZXF1ZXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdC5tZXRob2QgLSBIdHRwIG1ldGhvZCBmb3IgcmVxdWVzdFxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0LmhlYWRlcnNdIC0gSHR0cCByZXF1ZXN0IGhlYWRlcnMgaW4gaGFzaCBvYmplY3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE9iamVjdD59IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxPYmplY3Q+fSAtXG4gKi9cbkh0dHBBcGkucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0LCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjb25uID0gdGhpcy5fY29ubjtcbiAgdmFyIGxvZ2dlciA9IGNvbm4uX2xvZ2dlcjtcbiAgdmFyIHJlZnJlc2hEZWxlZ2F0ZSA9IHRoaXMuZ2V0UmVmcmVzaERlbGVnYXRlKCk7XG4gIC8vIHJlbWVtYmVyIHByZXZpb3VzIGluc3RhbmNlIHVybCBpbiBjYXNlIGl0IGNoYW5nZXMgYWZ0ZXIgYSByZWZyZXNoXG4gIHZhciBsYXN0SW5zdGFuY2VVcmwgPSBjb25uLmluc3RhbmNlVXJsO1xuXG4gIHZhciBkZWZlcnJlZCA9IFByb21pc2UuZGVmZXIoKTtcblxuICB2YXIgb25SZXN1bWUgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSB0b2tlbiByZWZyZXNoIGhhcyBjaGFuZ2VkIHRoZSBpbnN0YW5jZSB1cmxcbiAgICBpZihsYXN0SW5zdGFuY2VVcmwgIT09IGNvbm4uaW5zdGFuY2VVcmwpe1xuICAgICAgLy8gaWYgdGhlIGluc3RhbmNlIHVybCBoYXMgY2hhbmdlZFxuICAgICAgLy8gdGhlbiByZXBsYWNlIHRoZSBjdXJyZW50IHJlcXVlc3QgdXJscyBpbnN0YW5jZSB1cmwgZnJhZ21lbnRcbiAgICAgIC8vIHdpdGggdGhlIHVwZGF0ZWQgaW5zdGFuY2UgdXJsXG4gICAgICByZXF1ZXN0LnVybCA9IHJlcXVlc3QudXJsLnJlcGxhY2UobGFzdEluc3RhbmNlVXJsLGNvbm4uaW5zdGFuY2VVcmwpO1xuICAgIH1cblxuICAgIHNlbGYucmVxdWVzdChyZXF1ZXN0KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgIH0pO1xuICB9O1xuXG4gIGlmIChyZWZyZXNoRGVsZWdhdGUgJiYgcmVmcmVzaERlbGVnYXRlLl9yZWZyZXNoaW5nKSB7XG4gICAgcmVmcmVzaERlbGVnYXRlLm9uY2UoJ3Jlc3VtZScsIG9uUmVzdW1lKTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZS50aGVuQ2FsbChjYWxsYmFjayk7XG4gIH1cblxuICAvLyBob29rIGJlZm9yZSBzZW5kaW5nXG4gIHNlbGYuYmVmb3JlU2VuZChyZXF1ZXN0KTtcblxuICBzZWxmLmVtaXQoJ3JlcXVlc3QnLCByZXF1ZXN0KTtcbiAgbG9nZ2VyLmRlYnVnKFwiPHJlcXVlc3Q+IG1ldGhvZD1cIiArIHJlcXVlc3QubWV0aG9kICsgXCIsIHVybD1cIiArIHJlcXVlc3QudXJsKTtcbiAgdmFyIHJlcXVlc3RUaW1lID0gRGF0ZS5ub3coKTtcblxuICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lmh0dHBSZXF1ZXN0KHJlcXVlc3QpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICB2YXIgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsb2dnZXIuZGVidWcoXCJlbGFwc2VkIHRpbWUgOiBcIiArIChyZXNwb25zZVRpbWUgLSByZXF1ZXN0VGltZSkgKyBcIm1zZWNcIik7XG4gICAgbG9nZ2VyLmRlYnVnKFwiPHJlc3BvbnNlPiBzdGF0dXM9XCIgKyByZXNwb25zZS5zdGF0dXNDb2RlICsgXCIsIHVybD1cIiArIHJlcXVlc3QudXJsKTtcblxuICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXNwb25zZSk7XG4gICAgLy8gUmVmcmVzaCB0b2tlbiBpZiBzZXNzaW9uIGhhcyBiZWVuIGV4cGlyZWQgYW5kIHJlcXVpcmVzIGF1dGhlbnRpY2F0aW9uXG4gICAgLy8gd2hlbiBzZXNzaW9uIHJlZnJlc2ggZGVsZWdhdGUgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHNlbGYuaXNTZXNzaW9uRXhwaXJlZChyZXNwb25zZSkgJiYgcmVmcmVzaERlbGVnYXRlKSB7XG4gICAgICByZWZyZXNoRGVsZWdhdGUucmVmcmVzaChyZXF1ZXN0VGltZSwgb25SZXN1bWUpO1xuICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxuICAgIGlmIChzZWxmLmlzRXJyb3JSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgIHZhciBlcnIgPSBzZWxmLmdldEVycm9yKHJlc3BvbnNlKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGYuZ2V0UmVzcG9uc2VCb2R5KHJlc3BvbnNlKTtcbiAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgdmFyIHJlc3BvbnNlVGltZSA9IERhdGUubm93KCk7XG4gICAgbG9nZ2VyLmRlYnVnKFwiZWxhcHNlZCB0aW1lIDogXCIgKyAocmVzcG9uc2VUaW1lIC0gcmVxdWVzdFRpbWUpICsgXCJtc2VjXCIpO1xuICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgIHRocm93IGVycjtcbiAgfSlcbiAgLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQHByb3RlY3RlZFxuICovXG5IdHRwQXBpLnByb3RvdHlwZS5nZXRSZWZyZXNoRGVsZWdhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4uX3JlZnJlc2hEZWxlZ2F0ZTtcbn07XG5cbi8qKlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuSHR0cEFwaS5wcm90b3R5cGUuYmVmb3JlU2VuZCA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgcmVxdWVzdC5oZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzIHx8IHt9O1xuICBpZiAodGhpcy5fY29ubi5hY2Nlc3NUb2tlbikge1xuICAgIHJlcXVlc3QuaGVhZGVycy5BdXRob3JpemF0aW9uID0gXCJCZWFyZXIgXCIgKyB0aGlzLl9jb25uLmFjY2Vzc1Rva2VuO1xuICB9XG4gIGlmICh0aGlzLl9jb25uLmNhbGxPcHRpb25zKSB7XG4gICAgdmFyIGNhbGxPcHRpb25zID0gW107XG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLl9jb25uLmNhbGxPcHRpb25zKSB7XG4gICAgICBjYWxsT3B0aW9ucy5wdXNoKG5hbWUgKyBcIj1cIiArIHRoaXMuX2Nvbm4uY2FsbE9wdGlvbnNbbmFtZV0pO1xuICAgIH1cbiAgICByZXF1ZXN0LmhlYWRlcnNbXCJTZm9yY2UtQ2FsbC1PcHRpb25zXCJdID0gY2FsbE9wdGlvbnMuam9pbignLCAnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXRlY3QgcmVzcG9uc2UgY29udGVudCBtaW1lLXR5cGVcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuSHR0cEFwaS5wcm90b3R5cGUuZ2V0UmVzcG9uc2VDb250ZW50VHlwZSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gIHJldHVybiB0aGlzLl9yZXNwb25zZVR5cGUgfHwgcmVzcG9uc2UuaGVhZGVycyAmJiByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdO1xufTtcblxuLyoqXG4gKlxuICovXG5IdHRwQXBpLnByb3RvdHlwZS5wYXJzZVJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gIHZhciBjb250ZW50VHlwZSA9IHRoaXMuZ2V0UmVzcG9uc2VDb250ZW50VHlwZShyZXNwb25zZSk7XG4gIHZhciBwYXJzZUJvZHkgPSAvXih0ZXh0fGFwcGxpY2F0aW9uKVxcL3htbCg7fCQpLy50ZXN0KGNvbnRlbnRUeXBlKSA/IHBhcnNlWE1MIDpcbiAgICAgICAgIC9eYXBwbGljYXRpb25cXC9qc29uKDt8JCkvLnRlc3QoY29udGVudFR5cGUpID8gcGFyc2VKU09OIDpcbiAgICAgICAgIC9edGV4dFxcL2Nzdig7fCQpLy50ZXN0KGNvbnRlbnRUeXBlKSA/IHBhcnNlQ1NWIDpcbiAgICAgICAgIHBhcnNlVGV4dDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlc3BvbnNlLmJvZHkpO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuYm9keTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgcmVzcG9uc2UgYm9keVxuICogQHByb3RlY3RlZFxuICovXG5IdHRwQXBpLnByb3RvdHlwZS5nZXRSZXNwb25zZUJvZHkgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjA0KSB7IC8vIE5vIENvbnRlbnRcbiAgICByZXR1cm4gdGhpcy5fbm9Db250ZW50UmVzcG9uc2U7XG4gIH1cbiAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlUmVzcG9uc2VCb2R5KHJlc3BvbnNlKTtcbiAgdmFyIGVycjtcbiAgaWYgKHRoaXMuaGFzRXJyb3JJblJlc3BvbnNlQm9keShib2R5KSkge1xuICAgIGVyciA9IHRoaXMuZ2V0RXJyb3IocmVzcG9uc2UsIGJvZHkpO1xuICAgIHRocm93IGVycjtcbiAgfVxuICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAwKSB7IC8vIE11bHRpcGxlIENob2ljZXNcbiAgICBlcnIgPSBuZXcgRXJyb3IoJ011bHRpcGxlIHJlY29yZHMgZm91bmQnKTtcbiAgICBlcnIubmFtZSA9IFwiTVVMVElQTEVfQ0hPSUNFU1wiO1xuICAgIGVyci5jb250ZW50ID0gYm9keTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgcmV0dXJuIGJvZHk7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cbmZ1bmN0aW9uIHBhcnNlSlNPTihzdHIpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcbn1cblxuLyoqIEBwcml2YXRlICovXG5mdW5jdGlvbiBwYXJzZVhNTChzdHIpIHtcbiAgdmFyIHJldCA9IHt9O1xuICByZXF1aXJlKCd4bWwyanMnKS5wYXJzZVN0cmluZyhzdHIsIHsgZXhwbGljaXRBcnJheTogZmFsc2UgfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICByZXQgPSB7IGVycm9yOiBlcnIsIHJlc3VsdCA6IHJlc3VsdCB9O1xuICB9KTtcbiAgaWYgKHJldC5lcnJvcikgeyB0aHJvdyByZXQuZXJyb3I7IH1cbiAgcmV0dXJuIHJldC5yZXN1bHQ7XG59XG5cbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gcGFyc2VDU1Yoc3RyKSB7XG4gIHJldHVybiByZXF1aXJlKCcuL2NzdicpLnBhcnNlQ1NWKHN0cik7XG59XG5cbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gcGFyc2VUZXh0KHN0cikgeyByZXR1cm4gc3RyOyB9XG5cblxuLyoqXG4gKiBEZXRlY3Qgc2Vzc2lvbiBleHBpcnlcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuSHR0cEFwaS5wcm90b3R5cGUuaXNTZXNzaW9uRXhwaXJlZCA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDE7XG59O1xuXG4vKipcbiAqIERldGVjdCBlcnJvciByZXNwb25zZVxuICogQHByb3RlY3RlZFxuICovXG5IdHRwQXBpLnByb3RvdHlwZS5pc0Vycm9yUmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICByZXR1cm4gcmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDA7XG59O1xuXG4vKipcbiAqIERldGVjdCBlcnJvciBpbiByZXNwb25zZSBib2R5XG4gKiBAcHJvdGVjdGVkXG4gKi9cbkh0dHBBcGkucHJvdG90eXBlLmhhc0Vycm9ySW5SZXNwb25zZUJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUGFyc2luZyBlcnJvciBtZXNzYWdlIGluIHJlc3BvbnNlXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkh0dHBBcGkucHJvdG90eXBlLnBhcnNlRXJyb3IgPSBmdW5jdGlvbihib2R5KSB7XG4gIHZhciBlcnJvcnMgPSBib2R5O1xuICByZXR1cm4gXy5pc0FycmF5KGVycm9ycykgPyBlcnJvcnNbMF0gOiBlcnJvcnM7XG59O1xuXG4vKipcbiAqIEdldCBlcnJvciBtZXNzYWdlIGluIHJlc3BvbnNlXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkh0dHBBcGkucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24ocmVzcG9uc2UsIGJvZHkpIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIGVycm9yID0gdGhpcy5wYXJzZUVycm9yKGJvZHkgfHwgdGhpcy5wYXJzZVJlc3BvbnNlQm9keShyZXNwb25zZSkpO1xuICB9IGNhdGNoKGUpIHt9XG4gIGVycm9yID0gXy5pc09iamVjdChlcnJvcikgJiYgXy5pc1N0cmluZyhlcnJvci5tZXNzYWdlKSA/IGVycm9yIDoge1xuICAgIGVycm9yQ29kZTogJ0VSUk9SX0hUVFBfJyArIHJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgbWVzc2FnZSA6IHJlc3BvbnNlLmJvZHlcbiAgfTtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgZXJyLm5hbWUgPSBlcnJvci5lcnJvckNvZGU7XG4gIGZvciAodmFyIGtleSBpbiBlcnJvcikgeyBlcnJba2V5XSA9IGVycm9yW2tleV07IH1cbiAgcmV0dXJuIGVycjtcbn07XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKlxuICogQHByb3RlY3RlZFxuICovXG52YXIgU2Vzc2lvblJlZnJlc2hEZWxlZ2F0ZSA9IGZ1bmN0aW9uKGNvbm4sIHJlZnJlc2hGbikge1xuICB0aGlzLl9jb25uID0gY29ubjtcbiAgdGhpcy5fcmVmcmVzaEZuID0gcmVmcmVzaEZuO1xuICB0aGlzLl9yZWZyZXNoaW5nID0gZmFsc2U7XG59O1xuXG5pbmhlcml0cyhTZXNzaW9uUmVmcmVzaERlbGVnYXRlLCBldmVudHMuRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBSZWZyZXNoIGFjY2VzcyB0b2tlblxuICogQHByaXZhdGVcbiAqL1xuU2Vzc2lvblJlZnJlc2hEZWxlZ2F0ZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKHNpbmNlLCBjYWxsYmFjaykge1xuICAvLyBDYWxsYmFjayBpbW1lZGlhdGVseSBXaGVuIHJlZnJlc2hlZCBhZnRlciBkZXNpZ25hdGVkIHRpbWVcbiAgaWYgKHRoaXMuX2xhc3RSZWZyZXNoZWRBdCA+IHNpbmNlKSB7IHJldHVybiBjYWxsYmFjaygpOyB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNvbm4gPSB0aGlzLl9jb25uO1xuICB2YXIgbG9nZ2VyID0gY29ubi5fbG9nZ2VyO1xuICBzZWxmLm9uY2UoJ3Jlc3VtZScsIGNhbGxiYWNrKTtcbiAgaWYgKHNlbGYuX3JlZnJlc2hpbmcpIHsgcmV0dXJuOyB9XG4gIGxvZ2dlci5kZWJ1ZyhcIjxyZWZyZXNoIHRva2VuPlwiKTtcbiAgc2VsZi5fcmVmcmVzaGluZyA9IHRydWU7XG4gIHJldHVybiBzZWxmLl9yZWZyZXNoRm4oY29ubiwgZnVuY3Rpb24oZXJyLCBhY2Nlc3NUb2tlbiwgcmVzKSB7XG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcIkNvbm5lY3Rpb24gcmVmcmVzaCBjb21wbGV0ZWQuXCIpO1xuICAgICAgY29ubi5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICAgICAgY29ubi5lbWl0KFwicmVmcmVzaFwiLCBhY2Nlc3NUb2tlbiwgcmVzKTtcbiAgICB9XG4gICAgc2VsZi5fbGFzdFJlZnJlc2hlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICBzZWxmLl9yZWZyZXNoaW5nID0gZmFsc2U7XG4gICAgc2VsZi5lbWl0KCdyZXN1bWUnLCBlcnIpO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKlxuICovXG5IdHRwQXBpLlNlc3Npb25SZWZyZXNoRGVsZWdhdGUgPSBTZXNzaW9uUmVmcmVzaERlbGVnYXRlO1xubW9kdWxlLmV4cG9ydHMgPSBIdHRwQXBpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/http-api.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/jsforce.js":
/*!*********************************************!*\
  !*** ./node_modules/jsforce/lib/jsforce.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file JSforce API root object\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\n__webpack_require__(/*! ./api */ \"(action-browser)/./node_modules/jsforce/lib/api/index.js\");\n__webpack_require__(/*! ./registry */ \"(action-browser)/./node_modules/jsforce/lib/registry/index.js\");\nmodule.exports = __webpack_require__(/*! ./core */ \"(action-browser)/./node_modules/jsforce/lib/core.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9qc2ZvcmNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLG1CQUFPLENBQUMsdUVBQU87QUFDZixtQkFBTyxDQUFDLGlGQUFZO0FBQ3BCLHlHQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvanNmb3JjZS5qcz81NjVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgSlNmb3JjZSBBUEkgcm9vdCBvYmplY3RcbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9hcGknKTtcbnJlcXVpcmUoJy4vcmVnaXN0cnknKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb3JlJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/jsforce.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/jsforce.js":
/*!*********************************************!*\
  !*** ./node_modules/jsforce/lib/jsforce.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file JSforce API root object\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\n__webpack_require__(/*! ./api */ \"(rsc)/./node_modules/jsforce/lib/api/index.js\");\n__webpack_require__(/*! ./registry */ \"(rsc)/./node_modules/jsforce/lib/registry/index.js\");\nmodule.exports = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/jsforce/lib/core.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvanNmb3JjZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixtQkFBTyxDQUFDLDREQUFPO0FBQ2YsbUJBQU8sQ0FBQyxzRUFBWTtBQUNwQiw4RkFBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2pzZm9yY2UuanM/MmJjMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIEpTZm9yY2UgQVBJIHJvb3Qgb2JqZWN0XG4gKiBAYXV0aG9yIFNoaW5pY2hpIFRvbWl0YSA8c2hpbmljaGkudG9taXRhQGdtYWlsLmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vYXBpJyk7XG5yZXF1aXJlKCcuL3JlZ2lzdHJ5Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29yZScpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/jsforce.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/logger.js":
/*!********************************************!*\
  !*** ./node_modules/jsforce/lib/logger.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * @protected\n * @class\n * @constructor\n * @param {String|Number} logLevel - Log level\n */\nvar Logger = module.exports = function(logLevel) {\n  if (typeof logLevel === 'string') {\n    logLevel = LogLevels[logLevel];\n  }\n  if (!logLevel) {\n    logLevel = LogLevels.INFO;\n  }\n  this._logLevel = logLevel;\n};\n\n/**\n * @memberof Logger\n */\nvar LogLevels = Logger.LogLevels = {\n  \"DEBUG\" : 1,\n  \"INFO\" : 2,\n  \"WARN\" : 3,\n  \"ERROR\" : 4,\n  \"FATAL\" : 5\n};\n\n/**\n * Output log\n *\n * @param {String} level - Logging target level\n * @param {String} message - Message to log\n */\nLogger.prototype.log = function(level, message) {\n  if (this._logLevel <= level) {\n    if (level < LogLevels.ERROR) {\n      console.log(message);\n    } else {\n      console.error(message);\n    }\n  }\n};\n\nfor (var level in LogLevels) {\n  Logger.prototype[level.toLowerCase()] = createLoggerFunction(LogLevels[level]);\n}\n\nfunction createLoggerFunction(level) {\n  return function(message) { this.log(level, message); };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9sb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvbG9nZ2VyLmpzPzZiYTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwcm90ZWN0ZWRcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGxvZ0xldmVsIC0gTG9nIGxldmVsXG4gKi9cbnZhciBMb2dnZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxvZ0xldmVsKSB7XG4gIGlmICh0eXBlb2YgbG9nTGV2ZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgbG9nTGV2ZWwgPSBMb2dMZXZlbHNbbG9nTGV2ZWxdO1xuICB9XG4gIGlmICghbG9nTGV2ZWwpIHtcbiAgICBsb2dMZXZlbCA9IExvZ0xldmVscy5JTkZPO1xuICB9XG4gIHRoaXMuX2xvZ0xldmVsID0gbG9nTGV2ZWw7XG59O1xuXG4vKipcbiAqIEBtZW1iZXJvZiBMb2dnZXJcbiAqL1xudmFyIExvZ0xldmVscyA9IExvZ2dlci5Mb2dMZXZlbHMgPSB7XG4gIFwiREVCVUdcIiA6IDEsXG4gIFwiSU5GT1wiIDogMixcbiAgXCJXQVJOXCIgOiAzLFxuICBcIkVSUk9SXCIgOiA0LFxuICBcIkZBVEFMXCIgOiA1XG59O1xuXG4vKipcbiAqIE91dHB1dCBsb2dcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbGV2ZWwgLSBMb2dnaW5nIHRhcmdldCBsZXZlbFxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGxvZ1xuICovXG5Mb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uKGxldmVsLCBtZXNzYWdlKSB7XG4gIGlmICh0aGlzLl9sb2dMZXZlbCA8PSBsZXZlbCkge1xuICAgIGlmIChsZXZlbCA8IExvZ0xldmVscy5FUlJPUikge1xuICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICB9XG59O1xuXG5mb3IgKHZhciBsZXZlbCBpbiBMb2dMZXZlbHMpIHtcbiAgTG9nZ2VyLnByb3RvdHlwZVtsZXZlbC50b0xvd2VyQ2FzZSgpXSA9IGNyZWF0ZUxvZ2dlckZ1bmN0aW9uKExvZ0xldmVsc1tsZXZlbF0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2dnZXJGdW5jdGlvbihsZXZlbCkge1xuICByZXR1cm4gZnVuY3Rpb24obWVzc2FnZSkgeyB0aGlzLmxvZyhsZXZlbCwgbWVzc2FnZSk7IH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/logger.js":
/*!********************************************!*\
  !*** ./node_modules/jsforce/lib/logger.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * @protected\n * @class\n * @constructor\n * @param {String|Number} logLevel - Log level\n */\nvar Logger = module.exports = function(logLevel) {\n  if (typeof logLevel === 'string') {\n    logLevel = LogLevels[logLevel];\n  }\n  if (!logLevel) {\n    logLevel = LogLevels.INFO;\n  }\n  this._logLevel = logLevel;\n};\n\n/**\n * @memberof Logger\n */\nvar LogLevels = Logger.LogLevels = {\n  \"DEBUG\" : 1,\n  \"INFO\" : 2,\n  \"WARN\" : 3,\n  \"ERROR\" : 4,\n  \"FATAL\" : 5\n};\n\n/**\n * Output log\n *\n * @param {String} level - Logging target level\n * @param {String} message - Message to log\n */\nLogger.prototype.log = function(level, message) {\n  if (this._logLevel <= level) {\n    if (level < LogLevels.ERROR) {\n      console.log(message);\n    } else {\n      console.error(message);\n    }\n  }\n};\n\nfor (var level in LogLevels) {\n  Logger.prototype[level.toLowerCase()] = createLoggerFunction(LogLevels[level]);\n}\n\nfunction createLoggerFunction(level) {\n  return function(message) { this.log(level, message); };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvbG9nZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL2xvZ2dlci5qcz8wZDc2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcHJvdGVjdGVkXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBsb2dMZXZlbCAtIExvZyBsZXZlbFxuICovXG52YXIgTG9nZ2VyID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsb2dMZXZlbCkge1xuICBpZiAodHlwZW9mIGxvZ0xldmVsID09PSAnc3RyaW5nJykge1xuICAgIGxvZ0xldmVsID0gTG9nTGV2ZWxzW2xvZ0xldmVsXTtcbiAgfVxuICBpZiAoIWxvZ0xldmVsKSB7XG4gICAgbG9nTGV2ZWwgPSBMb2dMZXZlbHMuSU5GTztcbiAgfVxuICB0aGlzLl9sb2dMZXZlbCA9IGxvZ0xldmVsO1xufTtcblxuLyoqXG4gKiBAbWVtYmVyb2YgTG9nZ2VyXG4gKi9cbnZhciBMb2dMZXZlbHMgPSBMb2dnZXIuTG9nTGV2ZWxzID0ge1xuICBcIkRFQlVHXCIgOiAxLFxuICBcIklORk9cIiA6IDIsXG4gIFwiV0FSTlwiIDogMyxcbiAgXCJFUlJPUlwiIDogNCxcbiAgXCJGQVRBTFwiIDogNVxufTtcblxuLyoqXG4gKiBPdXRwdXQgbG9nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxldmVsIC0gTG9nZ2luZyB0YXJnZXQgbGV2ZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIC0gTWVzc2FnZSB0byBsb2dcbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbihsZXZlbCwgbWVzc2FnZSkge1xuICBpZiAodGhpcy5fbG9nTGV2ZWwgPD0gbGV2ZWwpIHtcbiAgICBpZiAobGV2ZWwgPCBMb2dMZXZlbHMuRVJST1IpIHtcbiAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufTtcblxuZm9yICh2YXIgbGV2ZWwgaW4gTG9nTGV2ZWxzKSB7XG4gIExvZ2dlci5wcm90b3R5cGVbbGV2ZWwudG9Mb3dlckNhc2UoKV0gPSBjcmVhdGVMb2dnZXJGdW5jdGlvbihMb2dMZXZlbHNbbGV2ZWxdKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyRnVuY3Rpb24obGV2ZWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG1lc3NhZ2UpIHsgdGhpcy5sb2cobGV2ZWwsIG1lc3NhZ2UpOyB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/logger.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/oauth2.js":
/*!********************************************!*\
  !*** ./node_modules/jsforce/lib/oauth2.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages Salesforce OAuth2 operations\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar querystring = __webpack_require__(/*! querystring */ \"querystring\"),\n    _ = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    Transport = __webpack_require__(/*! ./transport */ \"(action-browser)/./node_modules/jsforce/lib/transport.js\");\n\nvar defaults = {\n  loginUrl : \"https://login.salesforce.com\"\n};\n\n/**\n * OAuth2 class\n *\n * @class\n * @constructor\n * @param {Object} options - OAuth2 config options\n * @param {String} [options.loginUrl] - Salesforce login server URL\n * @param {String} [options.authzServiceUrl] - OAuth2 authorization service URL. If not specified, it generates from default by adding to login server URL.\n * @param {String} [options.tokenServiceUrl] - OAuth2 token service URL. If not specified it generates from default by adding to login server URL.\n * @param {String} options.clientId - OAuth2 client ID.\n * @param {String} [options.clientSecret] - OAuth2 client secret (This is optional for public client).\n * @param {String} options.redirectUri - URI to be callbacked from Salesforce OAuth2 authorization service.\n */\nvar OAuth2 = module.exports = function(options) {\n  if (options.authzServiceUrl && options.tokenServiceUrl) {\n    this.loginUrl = options.authzServiceUrl.split('/').slice(0, 3).join('/');\n    this.authzServiceUrl = options.authzServiceUrl;\n    this.tokenServiceUrl = options.tokenServiceUrl;\n    this.revokeServiceUrl = options.revokeServiceUrl;\n  } else {\n    this.loginUrl = options.loginUrl || defaults.loginUrl;\n    this.authzServiceUrl = this.loginUrl + \"/services/oauth2/authorize\";\n    this.tokenServiceUrl = this.loginUrl + \"/services/oauth2/token\";\n    this.revokeServiceUrl = this.loginUrl + \"/services/oauth2/revoke\";\n  }\n  this.clientId = options.clientId;\n  this.clientSecret = options.clientSecret;\n  this.redirectUri = options.redirectUri;\n  if (options.proxyUrl) {\n    this._transport = new Transport.ProxyTransport(options.proxyUrl);\n  } else if (options.httpProxy) {\n    this._transport = new Transport.HttpProxyTransport(options.httpProxy);\n  } else {\n    this._transport = new Transport();\n  }\n};\n\n\n\n/**\n *\n */\n_.extend(OAuth2.prototype, /** @lends OAuth2.prototype **/ {\n\n  /**\n   * Get Salesforce OAuth2 authorization page URL to redirect user agent.\n   *\n   * @param {Object} params - Parameters\n   * @param {String} [params.scope] - Scope values in space-separated string\n   * @param {String} [params.state] - State parameter\n   * @param {String} [params.code_challenge] - Code challenge value (RFC 7636 - Proof Key of Code Exchange)\n   * @returns {String} Authorization page URL\n   */\n  getAuthorizationUrl : function(params) {\n    params = _.extend({\n      response_type : \"code\",\n      client_id : this.clientId,\n      redirect_uri : this.redirectUri\n    }, params || {});\n    return this.authzServiceUrl +\n      (this.authzServiceUrl.indexOf('?') >= 0 ? \"&\" : \"?\") +\n      querystring.stringify(params);\n  },\n\n  /**\n   * @typedef TokenResponse\n   * @type {Object}\n   * @property {String} access_token\n   * @property {String} refresh_token\n   */\n\n  /**\n   * OAuth2 Refresh Token Flow\n   *\n   * @param {String} refreshToken - Refresh token\n   * @param {Callback.<TokenResponse>} [callback] - Callback function\n   * @returns {Promise.<TokenResponse>}\n   */\n  refreshToken : function(refreshToken, callback) {\n    var params = {\n      grant_type : \"refresh_token\",\n      refresh_token : refreshToken,\n      client_id : this.clientId\n    };\n    if (this.clientSecret) {\n      params.client_secret = this.clientSecret;\n    }\n    return this._postParams(params, callback);\n  },\n\n  /**\n   * OAuth2 Web Server Authentication Flow (Authorization Code)\n   * Access Token Request\n   *\n   * @param {String} code - Authorization code\n   * @param {Object} [params] - Optional parameters to send in token retrieval\n   * @param {String} [params.code_verifier] - Code verifier value (RFC 7636 - Proof Key of Code Exchange)\n   * @param {Callback.<TokenResponse>} [callback] - Callback function\n   * @returns {Promise.<TokenResponse>}\n   */\n  requestToken : function(code, params, callback) {\n    if (typeof params === 'function') {\n      callback = params;\n      params = {};\n    }\n    params = _.extend({\n      grant_type : \"authorization_code\",\n      code : code,\n      client_id : this.clientId,\n      redirect_uri : this.redirectUri\n    }, params || {});\n    if (this.clientSecret) {\n      params.client_secret = this.clientSecret;\n    }\n    return this._postParams(params, callback);\n  },\n\n  /**\n   * OAuth2 Username-Password Flow (Resource Owner Password Credentials)\n   *\n   * @param {String} username - Salesforce username\n   * @param {String} password - Salesforce password\n   * @param {Callback.<TokenResponse>} [callback] - Callback function\n   * @returns {Promise.<TokenResponse>}\n   */\n  authenticate : function(username, password, callback) {\n    return this._postParams({\n      grant_type : \"password\",\n      username : username,\n      password : password,\n      client_id : this.clientId,\n      client_secret : this.clientSecret,\n      redirect_uri : this.redirectUri\n    }, callback);\n  },\n\n  /**\n   * OAuth2 Revoke Session or API Token\n   *\n   * @param {String} token - Access or Refresh token to revoke. Passing in the Access token revokes the session. Passing in the Refresh token revokes API Access.\n   * @param {Callback.<undefined>} [callback] - Callback function\n   * @returns {Promise.<undefined>}\n   */\n  revokeToken : function(token, callback) {\n    return this._transport.httpRequest({\n      method : 'POST',\n      url : this.revokeServiceUrl,\n      body: querystring.stringify({ token: token }),\n      headers: {\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n      }\n    }).then(function(response) {\n      if (response.statusCode >= 400) {\n        var res = querystring.parse(response.body);\n        if (!res || !res.error) {\n          res = { error: \"ERROR_HTTP_\"+response.statusCode, error_description: response.body };\n        }\n        var err = new Error(res.error_description);\n        err.name = res.error;\n        throw err;\n      }\n    }).thenCall(callback);\n  },\n\n  /**\n   * @private\n   */\n  _postParams : function(params, callback) {\n    return this._transport.httpRequest({\n      method : 'POST',\n      url : this.tokenServiceUrl,\n      body : querystring.stringify(params),\n      headers : {\n        \"content-type\" : \"application/x-www-form-urlencoded\"\n      }\n    }).then(function(response) {\n      var res;\n      try {\n        res = JSON.parse(response.body);\n      } catch(e) {}\n      if (response.statusCode >= 400) {\n        res = res || { error: \"ERROR_HTTP_\"+response.statusCode, error_description: response.body };\n        var err = new Error(res.error_description);\n        err.name = res.error;\n        throw err;\n      }\n      return res;\n    }).thenCall(callback);\n  }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9vYXV0aDIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsZ0NBQWE7QUFDdkMsUUFBUSxtQkFBTyxDQUFDLG1FQUFhO0FBQzdCLGdCQUFnQixtQkFBTyxDQUFDLDZFQUFhOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssY0FBYztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxZQUFZO0FBQ1osZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsMEJBQTBCO0FBQ3ZDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsMEJBQTBCO0FBQ3ZDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxjQUFjO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsMEJBQTBCO0FBQ3ZDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxzQkFBc0I7QUFDbkMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL29hdXRoMi5qcz83NjY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgTWFuYWdlcyBTYWxlc2ZvcmNlIE9BdXRoMiBvcGVyYXRpb25zXG4gKiBAYXV0aG9yIFNoaW5pY2hpIFRvbWl0YSA8c2hpbmljaGkudG9taXRhQGdtYWlsLmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyksXG4gICAgXyA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyksXG4gICAgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBsb2dpblVybCA6IFwiaHR0cHM6Ly9sb2dpbi5zYWxlc2ZvcmNlLmNvbVwiXG59O1xuXG4vKipcbiAqIE9BdXRoMiBjbGFzc1xuICpcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9BdXRoMiBjb25maWcgb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmxvZ2luVXJsXSAtIFNhbGVzZm9yY2UgbG9naW4gc2VydmVyIFVSTFxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmF1dGh6U2VydmljZVVybF0gLSBPQXV0aDIgYXV0aG9yaXphdGlvbiBzZXJ2aWNlIFVSTC4gSWYgbm90IHNwZWNpZmllZCwgaXQgZ2VuZXJhdGVzIGZyb20gZGVmYXVsdCBieSBhZGRpbmcgdG8gbG9naW4gc2VydmVyIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50b2tlblNlcnZpY2VVcmxdIC0gT0F1dGgyIHRva2VuIHNlcnZpY2UgVVJMLiBJZiBub3Qgc3BlY2lmaWVkIGl0IGdlbmVyYXRlcyBmcm9tIGRlZmF1bHQgYnkgYWRkaW5nIHRvIGxvZ2luIHNlcnZlciBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5jbGllbnRJZCAtIE9BdXRoMiBjbGllbnQgSUQuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY2xpZW50U2VjcmV0XSAtIE9BdXRoMiBjbGllbnQgc2VjcmV0IChUaGlzIGlzIG9wdGlvbmFsIGZvciBwdWJsaWMgY2xpZW50KS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnJlZGlyZWN0VXJpIC0gVVJJIHRvIGJlIGNhbGxiYWNrZWQgZnJvbSBTYWxlc2ZvcmNlIE9BdXRoMiBhdXRob3JpemF0aW9uIHNlcnZpY2UuXG4gKi9cbnZhciBPQXV0aDIgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuYXV0aHpTZXJ2aWNlVXJsICYmIG9wdGlvbnMudG9rZW5TZXJ2aWNlVXJsKSB7XG4gICAgdGhpcy5sb2dpblVybCA9IG9wdGlvbnMuYXV0aHpTZXJ2aWNlVXJsLnNwbGl0KCcvJykuc2xpY2UoMCwgMykuam9pbignLycpO1xuICAgIHRoaXMuYXV0aHpTZXJ2aWNlVXJsID0gb3B0aW9ucy5hdXRoelNlcnZpY2VVcmw7XG4gICAgdGhpcy50b2tlblNlcnZpY2VVcmwgPSBvcHRpb25zLnRva2VuU2VydmljZVVybDtcbiAgICB0aGlzLnJldm9rZVNlcnZpY2VVcmwgPSBvcHRpb25zLnJldm9rZVNlcnZpY2VVcmw7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sb2dpblVybCA9IG9wdGlvbnMubG9naW5VcmwgfHwgZGVmYXVsdHMubG9naW5Vcmw7XG4gICAgdGhpcy5hdXRoelNlcnZpY2VVcmwgPSB0aGlzLmxvZ2luVXJsICsgXCIvc2VydmljZXMvb2F1dGgyL2F1dGhvcml6ZVwiO1xuICAgIHRoaXMudG9rZW5TZXJ2aWNlVXJsID0gdGhpcy5sb2dpblVybCArIFwiL3NlcnZpY2VzL29hdXRoMi90b2tlblwiO1xuICAgIHRoaXMucmV2b2tlU2VydmljZVVybCA9IHRoaXMubG9naW5VcmwgKyBcIi9zZXJ2aWNlcy9vYXV0aDIvcmV2b2tlXCI7XG4gIH1cbiAgdGhpcy5jbGllbnRJZCA9IG9wdGlvbnMuY2xpZW50SWQ7XG4gIHRoaXMuY2xpZW50U2VjcmV0ID0gb3B0aW9ucy5jbGllbnRTZWNyZXQ7XG4gIHRoaXMucmVkaXJlY3RVcmkgPSBvcHRpb25zLnJlZGlyZWN0VXJpO1xuICBpZiAob3B0aW9ucy5wcm94eVVybCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG5ldyBUcmFuc3BvcnQuUHJveHlUcmFuc3BvcnQob3B0aW9ucy5wcm94eVVybCk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5odHRwUHJveHkpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0Lkh0dHBQcm94eVRyYW5zcG9ydChvcHRpb25zLmh0dHBQcm94eSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydCgpO1xuICB9XG59O1xuXG5cblxuLyoqXG4gKlxuICovXG5fLmV4dGVuZChPQXV0aDIucHJvdG90eXBlLCAvKiogQGxlbmRzIE9BdXRoMi5wcm90b3R5cGUgKiovIHtcblxuICAvKipcbiAgICogR2V0IFNhbGVzZm9yY2UgT0F1dGgyIGF1dGhvcml6YXRpb24gcGFnZSBVUkwgdG8gcmVkaXJlY3QgdXNlciBhZ2VudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuc2NvcGVdIC0gU2NvcGUgdmFsdWVzIGluIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuc3RhdGVdIC0gU3RhdGUgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLmNvZGVfY2hhbGxlbmdlXSAtIENvZGUgY2hhbGxlbmdlIHZhbHVlIChSRkMgNzYzNiAtIFByb29mIEtleSBvZiBDb2RlIEV4Y2hhbmdlKVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBdXRob3JpemF0aW9uIHBhZ2UgVVJMXG4gICAqL1xuICBnZXRBdXRob3JpemF0aW9uVXJsIDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgcGFyYW1zID0gXy5leHRlbmQoe1xuICAgICAgcmVzcG9uc2VfdHlwZSA6IFwiY29kZVwiLFxuICAgICAgY2xpZW50X2lkIDogdGhpcy5jbGllbnRJZCxcbiAgICAgIHJlZGlyZWN0X3VyaSA6IHRoaXMucmVkaXJlY3RVcmlcbiAgICB9LCBwYXJhbXMgfHwge30pO1xuICAgIHJldHVybiB0aGlzLmF1dGh6U2VydmljZVVybCArXG4gICAgICAodGhpcy5hdXRoelNlcnZpY2VVcmwuaW5kZXhPZignPycpID49IDAgPyBcIiZcIiA6IFwiP1wiKSArXG4gICAgICBxdWVyeXN0cmluZy5zdHJpbmdpZnkocGFyYW1zKTtcbiAgfSxcblxuICAvKipcbiAgICogQHR5cGVkZWYgVG9rZW5SZXNwb25zZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gYWNjZXNzX3Rva2VuXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZWZyZXNoX3Rva2VuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBPQXV0aDIgUmVmcmVzaCBUb2tlbiBGbG93XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZWZyZXNoVG9rZW4gLSBSZWZyZXNoIHRva2VuXG4gICAqIEBwYXJhbSB7Q2FsbGJhY2suPFRva2VuUmVzcG9uc2U+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHJldHVybnMge1Byb21pc2UuPFRva2VuUmVzcG9uc2U+fVxuICAgKi9cbiAgcmVmcmVzaFRva2VuIDogZnVuY3Rpb24ocmVmcmVzaFRva2VuLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICBncmFudF90eXBlIDogXCJyZWZyZXNoX3Rva2VuXCIsXG4gICAgICByZWZyZXNoX3Rva2VuIDogcmVmcmVzaFRva2VuLFxuICAgICAgY2xpZW50X2lkIDogdGhpcy5jbGllbnRJZFxuICAgIH07XG4gICAgaWYgKHRoaXMuY2xpZW50U2VjcmV0KSB7XG4gICAgICBwYXJhbXMuY2xpZW50X3NlY3JldCA9IHRoaXMuY2xpZW50U2VjcmV0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcG9zdFBhcmFtcyhwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogT0F1dGgyIFdlYiBTZXJ2ZXIgQXV0aGVudGljYXRpb24gRmxvdyAoQXV0aG9yaXphdGlvbiBDb2RlKVxuICAgKiBBY2Nlc3MgVG9rZW4gUmVxdWVzdFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29kZSAtIEF1dGhvcml6YXRpb24gY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzIHRvIHNlbmQgaW4gdG9rZW4gcmV0cmlldmFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLmNvZGVfdmVyaWZpZXJdIC0gQ29kZSB2ZXJpZmllciB2YWx1ZSAoUkZDIDc2MzYgLSBQcm9vZiBLZXkgb2YgQ29kZSBFeGNoYW5nZSlcbiAgICogQHBhcmFtIHtDYWxsYmFjay48VG9rZW5SZXNwb25zZT59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48VG9rZW5SZXNwb25zZT59XG4gICAqL1xuICByZXF1ZXN0VG9rZW4gOiBmdW5jdGlvbihjb2RlLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgcGFyYW1zID0ge307XG4gICAgfVxuICAgIHBhcmFtcyA9IF8uZXh0ZW5kKHtcbiAgICAgIGdyYW50X3R5cGUgOiBcImF1dGhvcml6YXRpb25fY29kZVwiLFxuICAgICAgY29kZSA6IGNvZGUsXG4gICAgICBjbGllbnRfaWQgOiB0aGlzLmNsaWVudElkLFxuICAgICAgcmVkaXJlY3RfdXJpIDogdGhpcy5yZWRpcmVjdFVyaVxuICAgIH0sIHBhcmFtcyB8fCB7fSk7XG4gICAgaWYgKHRoaXMuY2xpZW50U2VjcmV0KSB7XG4gICAgICBwYXJhbXMuY2xpZW50X3NlY3JldCA9IHRoaXMuY2xpZW50U2VjcmV0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcG9zdFBhcmFtcyhwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogT0F1dGgyIFVzZXJuYW1lLVBhc3N3b3JkIEZsb3cgKFJlc291cmNlIE93bmVyIFBhc3N3b3JkIENyZWRlbnRpYWxzKVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUgLSBTYWxlc2ZvcmNlIHVzZXJuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCAtIFNhbGVzZm9yY2UgcGFzc3dvcmRcbiAgICogQHBhcmFtIHtDYWxsYmFjay48VG9rZW5SZXNwb25zZT59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48VG9rZW5SZXNwb25zZT59XG4gICAqL1xuICBhdXRoZW50aWNhdGUgOiBmdW5jdGlvbih1c2VybmFtZSwgcGFzc3dvcmQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3RQYXJhbXMoe1xuICAgICAgZ3JhbnRfdHlwZSA6IFwicGFzc3dvcmRcIixcbiAgICAgIHVzZXJuYW1lIDogdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCA6IHBhc3N3b3JkLFxuICAgICAgY2xpZW50X2lkIDogdGhpcy5jbGllbnRJZCxcbiAgICAgIGNsaWVudF9zZWNyZXQgOiB0aGlzLmNsaWVudFNlY3JldCxcbiAgICAgIHJlZGlyZWN0X3VyaSA6IHRoaXMucmVkaXJlY3RVcmlcbiAgICB9LCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE9BdXRoMiBSZXZva2UgU2Vzc2lvbiBvciBBUEkgVG9rZW5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIC0gQWNjZXNzIG9yIFJlZnJlc2ggdG9rZW4gdG8gcmV2b2tlLiBQYXNzaW5nIGluIHRoZSBBY2Nlc3MgdG9rZW4gcmV2b2tlcyB0aGUgc2Vzc2lvbi4gUGFzc2luZyBpbiB0aGUgUmVmcmVzaCB0b2tlbiByZXZva2VzIEFQSSBBY2Nlc3MuXG4gICAqIEBwYXJhbSB7Q2FsbGJhY2suPHVuZGVmaW5lZD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48dW5kZWZpbmVkPn1cbiAgICovXG4gIHJldm9rZVRva2VuIDogZnVuY3Rpb24odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5odHRwUmVxdWVzdCh7XG4gICAgICBtZXRob2QgOiAnUE9TVCcsXG4gICAgICB1cmwgOiB0aGlzLnJldm9rZVNlcnZpY2VVcmwsXG4gICAgICBib2R5OiBxdWVyeXN0cmluZy5zdHJpbmdpZnkoeyB0b2tlbjogdG9rZW4gfSksXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgICAgIH1cbiAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgdmFyIHJlcyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHJlc3BvbnNlLmJvZHkpO1xuICAgICAgICBpZiAoIXJlcyB8fCAhcmVzLmVycm9yKSB7XG4gICAgICAgICAgcmVzID0geyBlcnJvcjogXCJFUlJPUl9IVFRQX1wiK3Jlc3BvbnNlLnN0YXR1c0NvZGUsIGVycm9yX2Rlc2NyaXB0aW9uOiByZXNwb25zZS5ib2R5IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihyZXMuZXJyb3JfZGVzY3JpcHRpb24pO1xuICAgICAgICBlcnIubmFtZSA9IHJlcy5lcnJvcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wb3N0UGFyYW1zIDogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuaHR0cFJlcXVlc3Qoe1xuICAgICAgbWV0aG9kIDogJ1BPU1QnLFxuICAgICAgdXJsIDogdGhpcy50b2tlblNlcnZpY2VVcmwsXG4gICAgICBib2R5IDogcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHBhcmFtcyksXG4gICAgICBoZWFkZXJzIDoge1xuICAgICAgICBcImNvbnRlbnQtdHlwZVwiIDogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICAgICAgfVxuICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHZhciByZXM7XG4gICAgICB0cnkge1xuICAgICAgICByZXMgPSBKU09OLnBhcnNlKHJlc3BvbnNlLmJvZHkpO1xuICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgIHJlcyA9IHJlcyB8fCB7IGVycm9yOiBcIkVSUk9SX0hUVFBfXCIrcmVzcG9uc2Uuc3RhdHVzQ29kZSwgZXJyb3JfZGVzY3JpcHRpb246IHJlc3BvbnNlLmJvZHkgfTtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihyZXMuZXJyb3JfZGVzY3JpcHRpb24pO1xuICAgICAgICBlcnIubmFtZSA9IHJlcy5lcnJvcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG4gIH1cblxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/oauth2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/oauth2.js":
/*!********************************************!*\
  !*** ./node_modules/jsforce/lib/oauth2.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages Salesforce OAuth2 operations\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar querystring = __webpack_require__(/*! querystring */ \"querystring\"),\n    _ = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    Transport = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/jsforce/lib/transport.js\");\n\nvar defaults = {\n  loginUrl : \"https://login.salesforce.com\"\n};\n\n/**\n * OAuth2 class\n *\n * @class\n * @constructor\n * @param {Object} options - OAuth2 config options\n * @param {String} [options.loginUrl] - Salesforce login server URL\n * @param {String} [options.authzServiceUrl] - OAuth2 authorization service URL. If not specified, it generates from default by adding to login server URL.\n * @param {String} [options.tokenServiceUrl] - OAuth2 token service URL. If not specified it generates from default by adding to login server URL.\n * @param {String} options.clientId - OAuth2 client ID.\n * @param {String} [options.clientSecret] - OAuth2 client secret (This is optional for public client).\n * @param {String} options.redirectUri - URI to be callbacked from Salesforce OAuth2 authorization service.\n */\nvar OAuth2 = module.exports = function(options) {\n  if (options.authzServiceUrl && options.tokenServiceUrl) {\n    this.loginUrl = options.authzServiceUrl.split('/').slice(0, 3).join('/');\n    this.authzServiceUrl = options.authzServiceUrl;\n    this.tokenServiceUrl = options.tokenServiceUrl;\n    this.revokeServiceUrl = options.revokeServiceUrl;\n  } else {\n    this.loginUrl = options.loginUrl || defaults.loginUrl;\n    this.authzServiceUrl = this.loginUrl + \"/services/oauth2/authorize\";\n    this.tokenServiceUrl = this.loginUrl + \"/services/oauth2/token\";\n    this.revokeServiceUrl = this.loginUrl + \"/services/oauth2/revoke\";\n  }\n  this.clientId = options.clientId;\n  this.clientSecret = options.clientSecret;\n  this.redirectUri = options.redirectUri;\n  if (options.proxyUrl) {\n    this._transport = new Transport.ProxyTransport(options.proxyUrl);\n  } else if (options.httpProxy) {\n    this._transport = new Transport.HttpProxyTransport(options.httpProxy);\n  } else {\n    this._transport = new Transport();\n  }\n};\n\n\n\n/**\n *\n */\n_.extend(OAuth2.prototype, /** @lends OAuth2.prototype **/ {\n\n  /**\n   * Get Salesforce OAuth2 authorization page URL to redirect user agent.\n   *\n   * @param {Object} params - Parameters\n   * @param {String} [params.scope] - Scope values in space-separated string\n   * @param {String} [params.state] - State parameter\n   * @param {String} [params.code_challenge] - Code challenge value (RFC 7636 - Proof Key of Code Exchange)\n   * @returns {String} Authorization page URL\n   */\n  getAuthorizationUrl : function(params) {\n    params = _.extend({\n      response_type : \"code\",\n      client_id : this.clientId,\n      redirect_uri : this.redirectUri\n    }, params || {});\n    return this.authzServiceUrl +\n      (this.authzServiceUrl.indexOf('?') >= 0 ? \"&\" : \"?\") +\n      querystring.stringify(params);\n  },\n\n  /**\n   * @typedef TokenResponse\n   * @type {Object}\n   * @property {String} access_token\n   * @property {String} refresh_token\n   */\n\n  /**\n   * OAuth2 Refresh Token Flow\n   *\n   * @param {String} refreshToken - Refresh token\n   * @param {Callback.<TokenResponse>} [callback] - Callback function\n   * @returns {Promise.<TokenResponse>}\n   */\n  refreshToken : function(refreshToken, callback) {\n    var params = {\n      grant_type : \"refresh_token\",\n      refresh_token : refreshToken,\n      client_id : this.clientId\n    };\n    if (this.clientSecret) {\n      params.client_secret = this.clientSecret;\n    }\n    return this._postParams(params, callback);\n  },\n\n  /**\n   * OAuth2 Web Server Authentication Flow (Authorization Code)\n   * Access Token Request\n   *\n   * @param {String} code - Authorization code\n   * @param {Object} [params] - Optional parameters to send in token retrieval\n   * @param {String} [params.code_verifier] - Code verifier value (RFC 7636 - Proof Key of Code Exchange)\n   * @param {Callback.<TokenResponse>} [callback] - Callback function\n   * @returns {Promise.<TokenResponse>}\n   */\n  requestToken : function(code, params, callback) {\n    if (typeof params === 'function') {\n      callback = params;\n      params = {};\n    }\n    params = _.extend({\n      grant_type : \"authorization_code\",\n      code : code,\n      client_id : this.clientId,\n      redirect_uri : this.redirectUri\n    }, params || {});\n    if (this.clientSecret) {\n      params.client_secret = this.clientSecret;\n    }\n    return this._postParams(params, callback);\n  },\n\n  /**\n   * OAuth2 Username-Password Flow (Resource Owner Password Credentials)\n   *\n   * @param {String} username - Salesforce username\n   * @param {String} password - Salesforce password\n   * @param {Callback.<TokenResponse>} [callback] - Callback function\n   * @returns {Promise.<TokenResponse>}\n   */\n  authenticate : function(username, password, callback) {\n    return this._postParams({\n      grant_type : \"password\",\n      username : username,\n      password : password,\n      client_id : this.clientId,\n      client_secret : this.clientSecret,\n      redirect_uri : this.redirectUri\n    }, callback);\n  },\n\n  /**\n   * OAuth2 Revoke Session or API Token\n   *\n   * @param {String} token - Access or Refresh token to revoke. Passing in the Access token revokes the session. Passing in the Refresh token revokes API Access.\n   * @param {Callback.<undefined>} [callback] - Callback function\n   * @returns {Promise.<undefined>}\n   */\n  revokeToken : function(token, callback) {\n    return this._transport.httpRequest({\n      method : 'POST',\n      url : this.revokeServiceUrl,\n      body: querystring.stringify({ token: token }),\n      headers: {\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n      }\n    }).then(function(response) {\n      if (response.statusCode >= 400) {\n        var res = querystring.parse(response.body);\n        if (!res || !res.error) {\n          res = { error: \"ERROR_HTTP_\"+response.statusCode, error_description: response.body };\n        }\n        var err = new Error(res.error_description);\n        err.name = res.error;\n        throw err;\n      }\n    }).thenCall(callback);\n  },\n\n  /**\n   * @private\n   */\n  _postParams : function(params, callback) {\n    return this._transport.httpRequest({\n      method : 'POST',\n      url : this.tokenServiceUrl,\n      body : querystring.stringify(params),\n      headers : {\n        \"content-type\" : \"application/x-www-form-urlencoded\"\n      }\n    }).then(function(response) {\n      var res;\n      try {\n        res = JSON.parse(response.body);\n      } catch(e) {}\n      if (response.statusCode >= 400) {\n        res = res || { error: \"ERROR_HTTP_\"+response.statusCode, error_description: response.body };\n        var err = new Error(res.error_description);\n        err.name = res.error;\n        throw err;\n      }\n      return res;\n    }).thenCall(callback);\n  }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvb2F1dGgyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLGdDQUFhO0FBQ3ZDLFFBQVEsbUJBQU8sQ0FBQyx3REFBYTtBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBYTs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGNBQWM7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsWUFBWTtBQUNaLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLDBCQUEwQjtBQUN2QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLDBCQUEwQjtBQUN2QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssY0FBYztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLDBCQUEwQjtBQUN2QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsc0JBQXNCO0FBQ25DLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9vYXV0aDIuanM/OGIyMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIE1hbmFnZXMgU2FsZXNmb3JjZSBPQXV0aDIgb3BlcmF0aW9uc1xuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpLFxuICAgIF8gPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpLFxuICAgIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0Jyk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgbG9naW5VcmwgOiBcImh0dHBzOi8vbG9naW4uc2FsZXNmb3JjZS5jb21cIlxufTtcblxuLyoqXG4gKiBPQXV0aDIgY2xhc3NcbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPQXV0aDIgY29uZmlnIG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5sb2dpblVybF0gLSBTYWxlc2ZvcmNlIGxvZ2luIHNlcnZlciBVUkxcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hdXRoelNlcnZpY2VVcmxdIC0gT0F1dGgyIGF1dGhvcml6YXRpb24gc2VydmljZSBVUkwuIElmIG5vdCBzcGVjaWZpZWQsIGl0IGdlbmVyYXRlcyBmcm9tIGRlZmF1bHQgYnkgYWRkaW5nIHRvIGxvZ2luIHNlcnZlciBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudG9rZW5TZXJ2aWNlVXJsXSAtIE9BdXRoMiB0b2tlbiBzZXJ2aWNlIFVSTC4gSWYgbm90IHNwZWNpZmllZCBpdCBnZW5lcmF0ZXMgZnJvbSBkZWZhdWx0IGJ5IGFkZGluZyB0byBsb2dpbiBzZXJ2ZXIgVVJMLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuY2xpZW50SWQgLSBPQXV0aDIgY2xpZW50IElELlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNsaWVudFNlY3JldF0gLSBPQXV0aDIgY2xpZW50IHNlY3JldCAoVGhpcyBpcyBvcHRpb25hbCBmb3IgcHVibGljIGNsaWVudCkuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5yZWRpcmVjdFVyaSAtIFVSSSB0byBiZSBjYWxsYmFja2VkIGZyb20gU2FsZXNmb3JjZSBPQXV0aDIgYXV0aG9yaXphdGlvbiBzZXJ2aWNlLlxuICovXG52YXIgT0F1dGgyID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmF1dGh6U2VydmljZVVybCAmJiBvcHRpb25zLnRva2VuU2VydmljZVVybCkge1xuICAgIHRoaXMubG9naW5VcmwgPSBvcHRpb25zLmF1dGh6U2VydmljZVVybC5zcGxpdCgnLycpLnNsaWNlKDAsIDMpLmpvaW4oJy8nKTtcbiAgICB0aGlzLmF1dGh6U2VydmljZVVybCA9IG9wdGlvbnMuYXV0aHpTZXJ2aWNlVXJsO1xuICAgIHRoaXMudG9rZW5TZXJ2aWNlVXJsID0gb3B0aW9ucy50b2tlblNlcnZpY2VVcmw7XG4gICAgdGhpcy5yZXZva2VTZXJ2aWNlVXJsID0gb3B0aW9ucy5yZXZva2VTZXJ2aWNlVXJsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubG9naW5VcmwgPSBvcHRpb25zLmxvZ2luVXJsIHx8IGRlZmF1bHRzLmxvZ2luVXJsO1xuICAgIHRoaXMuYXV0aHpTZXJ2aWNlVXJsID0gdGhpcy5sb2dpblVybCArIFwiL3NlcnZpY2VzL29hdXRoMi9hdXRob3JpemVcIjtcbiAgICB0aGlzLnRva2VuU2VydmljZVVybCA9IHRoaXMubG9naW5VcmwgKyBcIi9zZXJ2aWNlcy9vYXV0aDIvdG9rZW5cIjtcbiAgICB0aGlzLnJldm9rZVNlcnZpY2VVcmwgPSB0aGlzLmxvZ2luVXJsICsgXCIvc2VydmljZXMvb2F1dGgyL3Jldm9rZVwiO1xuICB9XG4gIHRoaXMuY2xpZW50SWQgPSBvcHRpb25zLmNsaWVudElkO1xuICB0aGlzLmNsaWVudFNlY3JldCA9IG9wdGlvbnMuY2xpZW50U2VjcmV0O1xuICB0aGlzLnJlZGlyZWN0VXJpID0gb3B0aW9ucy5yZWRpcmVjdFVyaTtcbiAgaWYgKG9wdGlvbnMucHJveHlVcmwpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0LlByb3h5VHJhbnNwb3J0KG9wdGlvbnMucHJveHlVcmwpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuaHR0cFByb3h5KSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydC5IdHRwUHJveHlUcmFuc3BvcnQob3B0aW9ucy5odHRwUHJveHkpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG5ldyBUcmFuc3BvcnQoKTtcbiAgfVxufTtcblxuXG5cbi8qKlxuICpcbiAqL1xuXy5leHRlbmQoT0F1dGgyLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBPQXV0aDIucHJvdG90eXBlICoqLyB7XG5cbiAgLyoqXG4gICAqIEdldCBTYWxlc2ZvcmNlIE9BdXRoMiBhdXRob3JpemF0aW9uIHBhZ2UgVVJMIHRvIHJlZGlyZWN0IHVzZXIgYWdlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBQYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLnNjb3BlXSAtIFNjb3BlIHZhbHVlcyBpbiBzcGFjZS1zZXBhcmF0ZWQgc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLnN0YXRlXSAtIFN0YXRlIHBhcmFtZXRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5jb2RlX2NoYWxsZW5nZV0gLSBDb2RlIGNoYWxsZW5nZSB2YWx1ZSAoUkZDIDc2MzYgLSBQcm9vZiBLZXkgb2YgQ29kZSBFeGNoYW5nZSlcbiAgICogQHJldHVybnMge1N0cmluZ30gQXV0aG9yaXphdGlvbiBwYWdlIFVSTFxuICAgKi9cbiAgZ2V0QXV0aG9yaXphdGlvblVybCA6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIHBhcmFtcyA9IF8uZXh0ZW5kKHtcbiAgICAgIHJlc3BvbnNlX3R5cGUgOiBcImNvZGVcIixcbiAgICAgIGNsaWVudF9pZCA6IHRoaXMuY2xpZW50SWQsXG4gICAgICByZWRpcmVjdF91cmkgOiB0aGlzLnJlZGlyZWN0VXJpXG4gICAgfSwgcGFyYW1zIHx8IHt9KTtcbiAgICByZXR1cm4gdGhpcy5hdXRoelNlcnZpY2VVcmwgK1xuICAgICAgKHRoaXMuYXV0aHpTZXJ2aWNlVXJsLmluZGV4T2YoJz8nKSA+PSAwID8gXCImXCIgOiBcIj9cIikgK1xuICAgICAgcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHBhcmFtcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIFRva2VuUmVzcG9uc2VcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGFjY2Vzc190b2tlblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gcmVmcmVzaF90b2tlblxuICAgKi9cblxuICAvKipcbiAgICogT0F1dGgyIFJlZnJlc2ggVG9rZW4gRmxvd1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVmcmVzaFRva2VuIC0gUmVmcmVzaCB0b2tlblxuICAgKiBAcGFyYW0ge0NhbGxiYWNrLjxUb2tlblJlc3BvbnNlPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxUb2tlblJlc3BvbnNlPn1cbiAgICovXG4gIHJlZnJlc2hUb2tlbiA6IGZ1bmN0aW9uKHJlZnJlc2hUb2tlbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgZ3JhbnRfdHlwZSA6IFwicmVmcmVzaF90b2tlblwiLFxuICAgICAgcmVmcmVzaF90b2tlbiA6IHJlZnJlc2hUb2tlbixcbiAgICAgIGNsaWVudF9pZCA6IHRoaXMuY2xpZW50SWRcbiAgICB9O1xuICAgIGlmICh0aGlzLmNsaWVudFNlY3JldCkge1xuICAgICAgcGFyYW1zLmNsaWVudF9zZWNyZXQgPSB0aGlzLmNsaWVudFNlY3JldDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3RQYXJhbXMocGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE9BdXRoMiBXZWIgU2VydmVyIEF1dGhlbnRpY2F0aW9uIEZsb3cgKEF1dGhvcml6YXRpb24gQ29kZSlcbiAgICogQWNjZXNzIFRva2VuIFJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvZGUgLSBBdXRob3JpemF0aW9uIGNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gT3B0aW9uYWwgcGFyYW1ldGVycyB0byBzZW5kIGluIHRva2VuIHJldHJpZXZhbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5jb2RlX3ZlcmlmaWVyXSAtIENvZGUgdmVyaWZpZXIgdmFsdWUgKFJGQyA3NjM2IC0gUHJvb2YgS2V5IG9mIENvZGUgRXhjaGFuZ2UpXG4gICAqIEBwYXJhbSB7Q2FsbGJhY2suPFRva2VuUmVzcG9uc2U+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHJldHVybnMge1Byb21pc2UuPFRva2VuUmVzcG9uc2U+fVxuICAgKi9cbiAgcmVxdWVzdFRva2VuIDogZnVuY3Rpb24oY29kZSwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgIHBhcmFtcyA9IHt9O1xuICAgIH1cbiAgICBwYXJhbXMgPSBfLmV4dGVuZCh7XG4gICAgICBncmFudF90eXBlIDogXCJhdXRob3JpemF0aW9uX2NvZGVcIixcbiAgICAgIGNvZGUgOiBjb2RlLFxuICAgICAgY2xpZW50X2lkIDogdGhpcy5jbGllbnRJZCxcbiAgICAgIHJlZGlyZWN0X3VyaSA6IHRoaXMucmVkaXJlY3RVcmlcbiAgICB9LCBwYXJhbXMgfHwge30pO1xuICAgIGlmICh0aGlzLmNsaWVudFNlY3JldCkge1xuICAgICAgcGFyYW1zLmNsaWVudF9zZWNyZXQgPSB0aGlzLmNsaWVudFNlY3JldDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3RQYXJhbXMocGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE9BdXRoMiBVc2VybmFtZS1QYXNzd29yZCBGbG93IChSZXNvdXJjZSBPd25lciBQYXNzd29yZCBDcmVkZW50aWFscylcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lIC0gU2FsZXNmb3JjZSB1c2VybmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQgLSBTYWxlc2ZvcmNlIHBhc3N3b3JkXG4gICAqIEBwYXJhbSB7Q2FsbGJhY2suPFRva2VuUmVzcG9uc2U+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHJldHVybnMge1Byb21pc2UuPFRva2VuUmVzcG9uc2U+fVxuICAgKi9cbiAgYXV0aGVudGljYXRlIDogZnVuY3Rpb24odXNlcm5hbWUsIHBhc3N3b3JkLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9wb3N0UGFyYW1zKHtcbiAgICAgIGdyYW50X3R5cGUgOiBcInBhc3N3b3JkXCIsXG4gICAgICB1c2VybmFtZSA6IHVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQgOiBwYXNzd29yZCxcbiAgICAgIGNsaWVudF9pZCA6IHRoaXMuY2xpZW50SWQsXG4gICAgICBjbGllbnRfc2VjcmV0IDogdGhpcy5jbGllbnRTZWNyZXQsXG4gICAgICByZWRpcmVjdF91cmkgOiB0aGlzLnJlZGlyZWN0VXJpXG4gICAgfSwgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBPQXV0aDIgUmV2b2tlIFNlc3Npb24gb3IgQVBJIFRva2VuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiAtIEFjY2VzcyBvciBSZWZyZXNoIHRva2VuIHRvIHJldm9rZS4gUGFzc2luZyBpbiB0aGUgQWNjZXNzIHRva2VuIHJldm9rZXMgdGhlIHNlc3Npb24uIFBhc3NpbmcgaW4gdGhlIFJlZnJlc2ggdG9rZW4gcmV2b2tlcyBBUEkgQWNjZXNzLlxuICAgKiBAcGFyYW0ge0NhbGxiYWNrLjx1bmRlZmluZWQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHJldHVybnMge1Byb21pc2UuPHVuZGVmaW5lZD59XG4gICAqL1xuICByZXZva2VUb2tlbiA6IGZ1bmN0aW9uKHRva2VuLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuaHR0cFJlcXVlc3Qoe1xuICAgICAgbWV0aG9kIDogJ1BPU1QnLFxuICAgICAgdXJsIDogdGhpcy5yZXZva2VTZXJ2aWNlVXJsLFxuICAgICAgYm9keTogcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHsgdG9rZW46IHRva2VuIH0pLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiXG4gICAgICB9XG4gICAgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgIHZhciByZXMgPSBxdWVyeXN0cmluZy5wYXJzZShyZXNwb25zZS5ib2R5KTtcbiAgICAgICAgaWYgKCFyZXMgfHwgIXJlcy5lcnJvcikge1xuICAgICAgICAgIHJlcyA9IHsgZXJyb3I6IFwiRVJST1JfSFRUUF9cIityZXNwb25zZS5zdGF0dXNDb2RlLCBlcnJvcl9kZXNjcmlwdGlvbjogcmVzcG9uc2UuYm9keSB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IocmVzLmVycm9yX2Rlc2NyaXB0aW9uKTtcbiAgICAgICAgZXJyLm5hbWUgPSByZXMuZXJyb3I7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcG9zdFBhcmFtcyA6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lmh0dHBSZXF1ZXN0KHtcbiAgICAgIG1ldGhvZCA6ICdQT1NUJyxcbiAgICAgIHVybCA6IHRoaXMudG9rZW5TZXJ2aWNlVXJsLFxuICAgICAgYm9keSA6IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShwYXJhbXMpLFxuICAgICAgaGVhZGVycyA6IHtcbiAgICAgICAgXCJjb250ZW50LXR5cGVcIiA6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgICAgIH1cbiAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB2YXIgcmVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzID0gSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5KTtcbiAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICByZXMgPSByZXMgfHwgeyBlcnJvcjogXCJFUlJPUl9IVFRQX1wiK3Jlc3BvbnNlLnN0YXR1c0NvZGUsIGVycm9yX2Rlc2NyaXB0aW9uOiByZXNwb25zZS5ib2R5IH07XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IocmVzLmVycm9yX2Rlc2NyaXB0aW9uKTtcbiAgICAgICAgZXJyLm5hbWUgPSByZXMuZXJyb3I7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xuICB9XG5cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/oauth2.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/process.js":
/*!*********************************************!*\
  !*** ./node_modules/jsforce/lib/process.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Process class to manage/run workflow rule and approval process\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar _ = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    Promise = __webpack_require__(/*! ./promise */ \"(action-browser)/./node_modules/jsforce/lib/promise.js\"),\n    Conneciton = __webpack_require__(/*! ./connection */ \"(action-browser)/./node_modules/jsforce/lib/connection.js\");\n\n/**\n * A class which manages process rules and approval processes\n *\n * @class\n * @param {Connection} conn - Connection object\n */\nvar Process = module.exports = function(conn) {\n  /**\n   * Object which mangages process rules\n   * @member {Process~ProcessRule} Process#rule\n   */\n  this.rule = new ProcessRule(conn);\n  /**\n   * Object which mangages approval process\n   * @member {Process~ApprovalProcess} Process#approval\n   */\n  this.approval = new ApprovalProcess(conn);\n};\n\n/**\n * A class which manages process (workflow) rules\n *\n * @class Process~ProcessRule\n * @param {Connection} conn - Connection object\n */\nvar ProcessRule = function(conn) {\n  this._conn = conn;\n};\n\n/**\n * @typedef {Object} Process~ProcessRuleDefinition\n * @prop {String} id - Id of approval process definition\n * @prop {String} name - Name of process rule definition\n * @prop {String} object - SObject name which process rule is defined\n */\n\n/**\n * Get all process rule definitions registered to sobjects\n *\n * @method Process~ProcessRule#list\n * @param {Callback.<Map.<String, Array.<Process~ProcessRuleDefinition>>>} [callback] - Callback function\n * @returns {Promise.<Map.<String, Array.<Process~ProcessRuleDefinition>>>}\n */\nProcessRule.prototype.list = function(callback) {\n  return this._conn.request(\"/process/rules\").then(function(res) {\n    return res.rules;\n  }).thenCall(callback);\n};\n\n\n/**\n * @typedef {Object} Process~ProcessRuleTriggerResult\n * @prop {Boolean} success - Is process rule trigger succeeded or not\n * @prop {Array.<Object>} errors - Array of errors returned if the request failed\n */\n\n/**\n * Trigger process rule for given entities\n *\n * @method Process~ProcessRule#trigger\n * @param {String|Array.<String>} contextIds - Entity ID(s) to trigger workflow process\n * @param {Callback.<Process~ProcessRuleTriggerResult>} [callback] - Callback function\n * @returns {Promise.<Process~ProcessRuleTriggerResult>}\n */\nProcessRule.prototype.trigger = function(contextIds, callback) {\n  contextIds = _.isArray(contextIds) ? contextIds : [ contextIds ];\n  return this._conn.request({\n    method: \"POST\",\n    url: \"/process/rules/\",\n    body: JSON.stringify({\n      contextIds: contextIds\n    }),\n    headers: {\n      \"content-type\": \"application/json\"\n    }\n  }).thenCall(callback);\n};\n\n/**\n * A class which manages approval processes\n *\n * @class Process~ApprovalProcess\n * @param {Connection} conn - Connection object\n */\nvar ApprovalProcess = function(conn) {\n  this._conn = conn;\n};\n\n/**\n * @typedef {Object} Process~ApprovalProcessDefinition\n * @prop {String} id - Id of approval process definition\n * @prop {String} name - Name of approval process definition\n * @prop {String} object - SObject name which approval process is defined\n * @prop {Number} sortOrder - Processing order of approval in SObject\n */\n/**\n * Get all approval process definitions registered to sobjects\n *\n * @method Process~ApprovalProcess#list\n * @param {Callback.<Map.<String, Array.<ApprovalProcessDefinition>>>} [callback] - Callback function\n * @returns {Promise.<Map.<String, Array.<ApprovalProcessDefinition>>>}\n */\nApprovalProcess.prototype.list = function(callback) {\n  return this._conn.request(\"/process/approvals\").then(function(res) {\n    return res.approvals;\n  }).thenCall(callback);\n};\n\n/**\n * @typedef {Object} Process~ApprovalProcessRequestResult\n * @prop {Boolean} success - True if processing or approval completed successfully\n * @prop {Array.<Object>} errors - The set of errors returned if the request failed\n * @prop {Array.<String>} actorIds - IDs of the users who are currently assigned to this approval step\n * @prop {String} entityId - Object being processed\n * @prop {String} instanceId - ID of the ProcessInstance associated with the object submitted for processing\n * @prop {String} instanceStatus - Status of the current process instance (not an individual object but the entire process instance)\n * @prop {Array.<String>} newWorkItemIds - Case-insensitive IDs that point to ProcessInstanceWorkitem items (the set of pending approval requests)\n */\n\n/**\n * Send bulk requests for approval process\n *\n * @method Process~ApprovalProcess#request\n * @param {Array.<ApprovalProcessRequest>} requests - Array of approval process request to send\n * @param {Callback.<Array.<ApprovalProcessRequestResult>>} - Callback function\n * @param {Promise.<Array.<ApprovalProcessRequestResult>>}\n */\nApprovalProcess.prototype.request = function(requests, callback) {\n  requests = requests.map(function(req) {\n    return req._request ? req._request : req;\n  });\n  return this._conn.request({\n    method: 'POST',\n    url: '/process/approvals',\n    headers: { \"content-type\": \"application/json\" },\n    body: JSON.stringify({ requests: requests })\n  }).thenCall(callback);\n};\n\n/**\n * Create approval process request\n *\n * @private\n */\nApprovalProcess.prototype._createRequest = function(actionType, contextId, comments, options, callback) {\n  if (typeof comments === \"function\") {\n    callback = comments;\n    options = null;\n    comments = null;\n  }\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  options = options || {};\n  var request = {\n    actionType: actionType,\n    contextId: contextId,\n    comments: comments\n  };\n  _.extend(request, options);\n  return new ApprovalProcessRequest(this, request).thenCall(callback);\n};\n\n/**\n * Submit approval request for an item\n *\n * @method Process~ApprovalProcess#submit\n * @param {String} contextId - ID of the item that is being acted upon\n * @param {String} [comments] - Comment to add to the history step associated with this request\n * @param {Object} [options] - Request parameters\n * @param {Array.<String>} [options.nextApproverIds] - If the process requires specification of the next approval, the ID of the user to be assigned the next request\n * @param {String} [options.processDefinitionNameOrId] - Developer name or ID of the process definition\n * @param {Boolean} [options.skipEntryCriteria] - Determines whether to evaluate the entry criteria for the process (true) or not (false) if the process definition name or ID isnt null\n * @param {Callback.<ApprovalProcessRequestResult>} [callback] - Callback function\n * @returns {ApprovalProcessRequest}\n */\nApprovalProcess.prototype.submit = function(contextId, comments, options, callback) {\n  return this._createRequest(\"Submit\", contextId, comments, options, callback);\n};\n\n/**\n * Approve approval request for an item\n *\n * @method Process~ApprovalProcess#approve\n * @param {String} workitemId - ID of the item that is being acted upon\n * @param {String} [comments] - Comment to add to the history step associated with this request\n * @param {Object} [options] - Request parameters\n * @param {Array.<String>} [options.nextApproverIds] - If the process requires specification of the next approval, the ID of the user to be assigned the next request\n * @param {String} [options.processDefinitionNameOrId] - Developer name or ID of the process definition\n * @param {Boolean} [options.skipEntryCriteria] - Determines whether to evaluate the entry criteria for the process (true) or not (false) if the process definition name or ID isnt null\n * @param {Callback.<ApprovalProcessRequestResult>} [callback] - Callback function\n * @returns {ApprovalProcessRequest}\n */\nApprovalProcess.prototype.approve = function(workitemId, comments, options, callback) {\n  return this._createRequest(\"Approve\", workitemId, comments, options, callback);\n};\n\n/**\n * Reject approval request for an item\n *\n * @method Process~ApprovalProcess#reject\n * @param {String} workitemId - ID of the item that is being acted upon\n * @param {String} [comments] - Comment to add to the history step associated with this request\n * @param {Object} [options] - Request parameters\n * @param {Array.<String>} [options.nextApproverIds] - If the process requires specification of the next approval, the ID of the user to be assigned the next request\n * @param {String} [options.processDefinitionNameOrId] - Developer name or ID of the process definition\n * @param {Boolean} [options.skipEntryCriteria] - Determines whether to evaluate the entry criteria for the process (true) or not (false) if the process definition name or ID isnt null\n * @param {Callback.<ApprovalProcessRequestResult>} [callback] - Callback function\n * @returns {ApprovalProcessRequest}\n */\nApprovalProcess.prototype.reject = function(workitemId, comments, options, callback) {\n  return this._createRequest(\"Reject\", workitemId, comments, options, callback);\n};\n\n/**\n * A class representing approval process request\n *\n * @protected\n * @class Process~ApprovalProcessRequest\n * @implements {Promise.<Process~ApprovalProcessRequestResult>}\n * @param {Process~ApprovalProcess} process - ApprovalProcess\n * @param {Object} request - Request parameters\n * @param {String} request.actionType - Represents the kind of action to take: Submit, Approve, or Reject\n * @param {String} request.contextId - ID of the item that is being acted upon\n * @param {String} request.comments - Comment to add to the history step associated with this request\n * @param {Array.<String>} [request.nextApproverIds] - If the process requires specification of the next approval, the ID of the user to be assigned the next request\n * @param {String} [request.processDefinitionNameOrId] - Developer name or ID of the process definition\n * @param {Boolean} [request.skipEntryCriteria] - Determines whether to evaluate the entry criteria for the process (true) or not (false) if the process definition name or ID isnt null\n */\nvar ApprovalProcessRequest = function(process, request) {\n  this._process = process;\n  this._request = request;\n};\n\n/**\n * Promise/A+ interface\n * http://promises-aplus.github.io/promises-spec/\n *\n * @method Process~ApprovalProcessRequest#then\n */\nApprovalProcessRequest.prototype.then = function(onResolve, onReject) {\n  if (!this._promise) {\n    this._promise = this._process.request([ this ]).then(function(rets) {\n      return rets[0];\n    });\n  }\n  this._promise.then(onResolve, onReject);\n};\n\n/**\n * Promise/A+ extension\n * Call \"then\" using given node-style callback function\n *\n * @method Process~ApprovalProcessRequest#thenCall\n */\nApprovalProcessRequest.prototype.thenCall = function(callback) {\n  return callback ? this.then(function(res) {\n    callback(null, res);\n  }, function(err) {\n    callback(err);\n  }) :\n  this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9wcm9jZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxtRUFBYTtBQUM3QixjQUFjLG1CQUFPLENBQUMseUVBQVc7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsK0VBQWM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdFQUFnRTtBQUMzRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsU0FBUztBQUNuQixVQUFVLGdCQUFnQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsNkNBQTZDO0FBQ3hELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNERBQTREO0FBQ3ZFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxnQkFBZ0I7QUFDMUIsVUFBVSxnQkFBZ0I7QUFDMUIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxnQkFBZ0I7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdDQUFnQztBQUMzQyxXQUFXLGlEQUFpRDtBQUM1RCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQsMkJBQTJCLG9CQUFvQjtBQUMvQyxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLHlDQUF5QztBQUNwRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcseUNBQXlDO0FBQ3BELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyx5Q0FBeUM7QUFDcEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsV0FBVyx5QkFBeUI7QUFDcEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL3Byb2Nlc3MuanM/ZDc4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIFByb2Nlc3MgY2xhc3MgdG8gbWFuYWdlL3J1biB3b3JrZmxvdyBydWxlIGFuZCBhcHByb3ZhbCBwcm9jZXNzXG4gKiBAYXV0aG9yIFNoaW5pY2hpIFRvbWl0YSA8c2hpbmljaGkudG9taXRhQGdtYWlsLmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9wcm9taXNlJyksXG4gICAgQ29ubmVjaXRvbiA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbicpO1xuXG4vKipcbiAqIEEgY2xhc3Mgd2hpY2ggbWFuYWdlcyBwcm9jZXNzIHJ1bGVzIGFuZCBhcHByb3ZhbCBwcm9jZXNzZXNcbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiAtIENvbm5lY3Rpb24gb2JqZWN0XG4gKi9cbnZhciBQcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb25uKSB7XG4gIC8qKlxuICAgKiBPYmplY3Qgd2hpY2ggbWFuZ2FnZXMgcHJvY2VzcyBydWxlc1xuICAgKiBAbWVtYmVyIHtQcm9jZXNzflByb2Nlc3NSdWxlfSBQcm9jZXNzI3J1bGVcbiAgICovXG4gIHRoaXMucnVsZSA9IG5ldyBQcm9jZXNzUnVsZShjb25uKTtcbiAgLyoqXG4gICAqIE9iamVjdCB3aGljaCBtYW5nYWdlcyBhcHByb3ZhbCBwcm9jZXNzXG4gICAqIEBtZW1iZXIge1Byb2Nlc3N+QXBwcm92YWxQcm9jZXNzfSBQcm9jZXNzI2FwcHJvdmFsXG4gICAqL1xuICB0aGlzLmFwcHJvdmFsID0gbmV3IEFwcHJvdmFsUHJvY2Vzcyhjb25uKTtcbn07XG5cbi8qKlxuICogQSBjbGFzcyB3aGljaCBtYW5hZ2VzIHByb2Nlc3MgKHdvcmtmbG93KSBydWxlc1xuICpcbiAqIEBjbGFzcyBQcm9jZXNzflByb2Nlc3NSdWxlXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gLSBDb25uZWN0aW9uIG9iamVjdFxuICovXG52YXIgUHJvY2Vzc1J1bGUgPSBmdW5jdGlvbihjb25uKSB7XG4gIHRoaXMuX2Nvbm4gPSBjb25uO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9jZXNzflByb2Nlc3NSdWxlRGVmaW5pdGlvblxuICogQHByb3Age1N0cmluZ30gaWQgLSBJZCBvZiBhcHByb3ZhbCBwcm9jZXNzIGRlZmluaXRpb25cbiAqIEBwcm9wIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHByb2Nlc3MgcnVsZSBkZWZpbml0aW9uXG4gKiBAcHJvcCB7U3RyaW5nfSBvYmplY3QgLSBTT2JqZWN0IG5hbWUgd2hpY2ggcHJvY2VzcyBydWxlIGlzIGRlZmluZWRcbiAqL1xuXG4vKipcbiAqIEdldCBhbGwgcHJvY2VzcyBydWxlIGRlZmluaXRpb25zIHJlZ2lzdGVyZWQgdG8gc29iamVjdHNcbiAqXG4gKiBAbWV0aG9kIFByb2Nlc3N+UHJvY2Vzc1J1bGUjbGlzdFxuICogQHBhcmFtIHtDYWxsYmFjay48TWFwLjxTdHJpbmcsIEFycmF5LjxQcm9jZXNzflByb2Nlc3NSdWxlRGVmaW5pdGlvbj4+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TWFwLjxTdHJpbmcsIEFycmF5LjxQcm9jZXNzflByb2Nlc3NSdWxlRGVmaW5pdGlvbj4+Pn1cbiAqL1xuUHJvY2Vzc1J1bGUucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KFwiL3Byb2Nlc3MvcnVsZXNcIikudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICByZXR1cm4gcmVzLnJ1bGVzO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUHJvY2Vzc35Qcm9jZXNzUnVsZVRyaWdnZXJSZXN1bHRcbiAqIEBwcm9wIHtCb29sZWFufSBzdWNjZXNzIC0gSXMgcHJvY2VzcyBydWxlIHRyaWdnZXIgc3VjY2VlZGVkIG9yIG5vdFxuICogQHByb3Age0FycmF5LjxPYmplY3Q+fSBlcnJvcnMgLSBBcnJheSBvZiBlcnJvcnMgcmV0dXJuZWQgaWYgdGhlIHJlcXVlc3QgZmFpbGVkXG4gKi9cblxuLyoqXG4gKiBUcmlnZ2VyIHByb2Nlc3MgcnVsZSBmb3IgZ2l2ZW4gZW50aXRpZXNcbiAqXG4gKiBAbWV0aG9kIFByb2Nlc3N+UHJvY2Vzc1J1bGUjdHJpZ2dlclxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnRleHRJZHMgLSBFbnRpdHkgSUQocykgdG8gdHJpZ2dlciB3b3JrZmxvdyBwcm9jZXNzXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxQcm9jZXNzflByb2Nlc3NSdWxlVHJpZ2dlclJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFByb2Nlc3N+UHJvY2Vzc1J1bGVUcmlnZ2VyUmVzdWx0Pn1cbiAqL1xuUHJvY2Vzc1J1bGUucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihjb250ZXh0SWRzLCBjYWxsYmFjaykge1xuICBjb250ZXh0SWRzID0gXy5pc0FycmF5KGNvbnRleHRJZHMpID8gY29udGV4dElkcyA6IFsgY29udGV4dElkcyBdO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogXCIvcHJvY2Vzcy9ydWxlcy9cIixcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBjb250ZXh0SWRzOiBjb250ZXh0SWRzXG4gICAgfSksXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQSBjbGFzcyB3aGljaCBtYW5hZ2VzIGFwcHJvdmFsIHByb2Nlc3Nlc1xuICpcbiAqIEBjbGFzcyBQcm9jZXNzfkFwcHJvdmFsUHJvY2Vzc1xuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIC0gQ29ubmVjdGlvbiBvYmplY3RcbiAqL1xudmFyIEFwcHJvdmFsUHJvY2VzcyA9IGZ1bmN0aW9uKGNvbm4pIHtcbiAgdGhpcy5fY29ubiA9IGNvbm47XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb2Nlc3N+QXBwcm92YWxQcm9jZXNzRGVmaW5pdGlvblxuICogQHByb3Age1N0cmluZ30gaWQgLSBJZCBvZiBhcHByb3ZhbCBwcm9jZXNzIGRlZmluaXRpb25cbiAqIEBwcm9wIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIGFwcHJvdmFsIHByb2Nlc3MgZGVmaW5pdGlvblxuICogQHByb3Age1N0cmluZ30gb2JqZWN0IC0gU09iamVjdCBuYW1lIHdoaWNoIGFwcHJvdmFsIHByb2Nlc3MgaXMgZGVmaW5lZFxuICogQHByb3Age051bWJlcn0gc29ydE9yZGVyIC0gUHJvY2Vzc2luZyBvcmRlciBvZiBhcHByb3ZhbCBpbiBTT2JqZWN0XG4gKi9cbi8qKlxuICogR2V0IGFsbCBhcHByb3ZhbCBwcm9jZXNzIGRlZmluaXRpb25zIHJlZ2lzdGVyZWQgdG8gc29iamVjdHNcbiAqXG4gKiBAbWV0aG9kIFByb2Nlc3N+QXBwcm92YWxQcm9jZXNzI2xpc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1hcC48U3RyaW5nLCBBcnJheS48QXBwcm92YWxQcm9jZXNzRGVmaW5pdGlvbj4+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TWFwLjxTdHJpbmcsIEFycmF5LjxBcHByb3ZhbFByb2Nlc3NEZWZpbml0aW9uPj4+fVxuICovXG5BcHByb3ZhbFByb2Nlc3MucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KFwiL3Byb2Nlc3MvYXBwcm92YWxzXCIpLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgcmV0dXJuIHJlcy5hcHByb3ZhbHM7XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUHJvY2Vzc35BcHByb3ZhbFByb2Nlc3NSZXF1ZXN0UmVzdWx0XG4gKiBAcHJvcCB7Qm9vbGVhbn0gc3VjY2VzcyAtIFRydWUgaWYgcHJvY2Vzc2luZyBvciBhcHByb3ZhbCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5XG4gKiBAcHJvcCB7QXJyYXkuPE9iamVjdD59IGVycm9ycyAtIFRoZSBzZXQgb2YgZXJyb3JzIHJldHVybmVkIGlmIHRoZSByZXF1ZXN0IGZhaWxlZFxuICogQHByb3Age0FycmF5LjxTdHJpbmc+fSBhY3RvcklkcyAtIElEcyBvZiB0aGUgdXNlcnMgd2hvIGFyZSBjdXJyZW50bHkgYXNzaWduZWQgdG8gdGhpcyBhcHByb3ZhbCBzdGVwXG4gKiBAcHJvcCB7U3RyaW5nfSBlbnRpdHlJZCAtIE9iamVjdCBiZWluZyBwcm9jZXNzZWRcbiAqIEBwcm9wIHtTdHJpbmd9IGluc3RhbmNlSWQgLSBJRCBvZiB0aGUgUHJvY2Vzc0luc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgb2JqZWN0IHN1Ym1pdHRlZCBmb3IgcHJvY2Vzc2luZ1xuICogQHByb3Age1N0cmluZ30gaW5zdGFuY2VTdGF0dXMgLSBTdGF0dXMgb2YgdGhlIGN1cnJlbnQgcHJvY2VzcyBpbnN0YW5jZSAobm90IGFuIGluZGl2aWR1YWwgb2JqZWN0IGJ1dCB0aGUgZW50aXJlIHByb2Nlc3MgaW5zdGFuY2UpXG4gKiBAcHJvcCB7QXJyYXkuPFN0cmluZz59IG5ld1dvcmtJdGVtSWRzIC0gQ2FzZS1pbnNlbnNpdGl2ZSBJRHMgdGhhdCBwb2ludCB0byBQcm9jZXNzSW5zdGFuY2VXb3JraXRlbSBpdGVtcyAodGhlIHNldCBvZiBwZW5kaW5nIGFwcHJvdmFsIHJlcXVlc3RzKVxuICovXG5cbi8qKlxuICogU2VuZCBidWxrIHJlcXVlc3RzIGZvciBhcHByb3ZhbCBwcm9jZXNzXG4gKlxuICogQG1ldGhvZCBQcm9jZXNzfkFwcHJvdmFsUHJvY2VzcyNyZXF1ZXN0XG4gKiBAcGFyYW0ge0FycmF5LjxBcHByb3ZhbFByb2Nlc3NSZXF1ZXN0Pn0gcmVxdWVzdHMgLSBBcnJheSBvZiBhcHByb3ZhbCBwcm9jZXNzIHJlcXVlc3QgdG8gc2VuZFxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPEFwcHJvdmFsUHJvY2Vzc1JlcXVlc3RSZXN1bHQ+Pn0gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHBhcmFtIHtQcm9taXNlLjxBcnJheS48QXBwcm92YWxQcm9jZXNzUmVxdWVzdFJlc3VsdD4+fVxuICovXG5BcHByb3ZhbFByb2Nlc3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0cywgY2FsbGJhY2spIHtcbiAgcmVxdWVzdHMgPSByZXF1ZXN0cy5tYXAoZnVuY3Rpb24ocmVxKSB7XG4gICAgcmV0dXJuIHJlcS5fcmVxdWVzdCA/IHJlcS5fcmVxdWVzdCA6IHJlcTtcbiAgfSk7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogJy9wcm9jZXNzL2FwcHJvdmFscycsXG4gICAgaGVhZGVyczogeyBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcmVxdWVzdHM6IHJlcXVlc3RzIH0pXG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFwcHJvdmFsIHByb2Nlc3MgcmVxdWVzdFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkFwcHJvdmFsUHJvY2Vzcy5wcm90b3R5cGUuX2NyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbihhY3Rpb25UeXBlLCBjb250ZXh0SWQsIGNvbW1lbnRzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNvbW1lbnRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjYWxsYmFjayA9IGNvbW1lbnRzO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIGNvbW1lbnRzID0gbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJlcXVlc3QgPSB7XG4gICAgYWN0aW9uVHlwZTogYWN0aW9uVHlwZSxcbiAgICBjb250ZXh0SWQ6IGNvbnRleHRJZCxcbiAgICBjb21tZW50czogY29tbWVudHNcbiAgfTtcbiAgXy5leHRlbmQocmVxdWVzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBuZXcgQXBwcm92YWxQcm9jZXNzUmVxdWVzdCh0aGlzLCByZXF1ZXN0KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFN1Ym1pdCBhcHByb3ZhbCByZXF1ZXN0IGZvciBhbiBpdGVtXG4gKlxuICogQG1ldGhvZCBQcm9jZXNzfkFwcHJvdmFsUHJvY2VzcyNzdWJtaXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZXh0SWQgLSBJRCBvZiB0aGUgaXRlbSB0aGF0IGlzIGJlaW5nIGFjdGVkIHVwb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBbY29tbWVudHNdIC0gQ29tbWVudCB0byBhZGQgdG8gdGhlIGhpc3Rvcnkgc3RlcCBhc3NvY2lhdGVkIHdpdGggdGhpcyByZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gUmVxdWVzdCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBbb3B0aW9ucy5uZXh0QXBwcm92ZXJJZHNdIC0gSWYgdGhlIHByb2Nlc3MgcmVxdWlyZXMgc3BlY2lmaWNhdGlvbiBvZiB0aGUgbmV4dCBhcHByb3ZhbCwgdGhlIElEIG9mIHRoZSB1c2VyIHRvIGJlIGFzc2lnbmVkIHRoZSBuZXh0IHJlcXVlc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm9jZXNzRGVmaW5pdGlvbk5hbWVPcklkXSAtIERldmVsb3BlciBuYW1lIG9yIElEIG9mIHRoZSBwcm9jZXNzIGRlZmluaXRpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcEVudHJ5Q3JpdGVyaWFdIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV2YWx1YXRlIHRoZSBlbnRyeSBjcml0ZXJpYSBmb3IgdGhlIHByb2Nlc3MgKHRydWUpIG9yIG5vdCAoZmFsc2UpIGlmIHRoZSBwcm9jZXNzIGRlZmluaXRpb24gbmFtZSBvciBJRCBpc27igJl0IG51bGxcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFwcHJvdmFsUHJvY2Vzc1JlcXVlc3RSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtBcHByb3ZhbFByb2Nlc3NSZXF1ZXN0fVxuICovXG5BcHByb3ZhbFByb2Nlc3MucHJvdG90eXBlLnN1Ym1pdCA9IGZ1bmN0aW9uKGNvbnRleHRJZCwgY29tbWVudHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVSZXF1ZXN0KFwiU3VibWl0XCIsIGNvbnRleHRJZCwgY29tbWVudHMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQXBwcm92ZSBhcHByb3ZhbCByZXF1ZXN0IGZvciBhbiBpdGVtXG4gKlxuICogQG1ldGhvZCBQcm9jZXNzfkFwcHJvdmFsUHJvY2VzcyNhcHByb3ZlXG4gKiBAcGFyYW0ge1N0cmluZ30gd29ya2l0ZW1JZCAtIElEIG9mIHRoZSBpdGVtIHRoYXQgaXMgYmVpbmcgYWN0ZWQgdXBvblxuICogQHBhcmFtIHtTdHJpbmd9IFtjb21tZW50c10gLSBDb21tZW50IHRvIGFkZCB0byB0aGUgaGlzdG9yeSBzdGVwIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBSZXF1ZXN0IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IFtvcHRpb25zLm5leHRBcHByb3Zlcklkc10gLSBJZiB0aGUgcHJvY2VzcyByZXF1aXJlcyBzcGVjaWZpY2F0aW9uIG9mIHRoZSBuZXh0IGFwcHJvdmFsLCB0aGUgSUQgb2YgdGhlIHVzZXIgdG8gYmUgYXNzaWduZWQgdGhlIG5leHQgcmVxdWVzdFxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnByb2Nlc3NEZWZpbml0aW9uTmFtZU9ySWRdIC0gRGV2ZWxvcGVyIG5hbWUgb3IgSUQgb2YgdGhlIHByb2Nlc3MgZGVmaW5pdGlvblxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwRW50cnlDcml0ZXJpYV0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXZhbHVhdGUgdGhlIGVudHJ5IGNyaXRlcmlhIGZvciB0aGUgcHJvY2VzcyAodHJ1ZSkgb3Igbm90IChmYWxzZSkgaWYgdGhlIHByb2Nlc3MgZGVmaW5pdGlvbiBuYW1lIG9yIElEIGlzbuKAmXQgbnVsbFxuICogQHBhcmFtIHtDYWxsYmFjay48QXBwcm92YWxQcm9jZXNzUmVxdWVzdFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0FwcHJvdmFsUHJvY2Vzc1JlcXVlc3R9XG4gKi9cbkFwcHJvdmFsUHJvY2Vzcy5wcm90b3R5cGUuYXBwcm92ZSA9IGZ1bmN0aW9uKHdvcmtpdGVtSWQsIGNvbW1lbnRzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fY3JlYXRlUmVxdWVzdChcIkFwcHJvdmVcIiwgd29ya2l0ZW1JZCwgY29tbWVudHMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmVqZWN0IGFwcHJvdmFsIHJlcXVlc3QgZm9yIGFuIGl0ZW1cbiAqXG4gKiBAbWV0aG9kIFByb2Nlc3N+QXBwcm92YWxQcm9jZXNzI3JlamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHdvcmtpdGVtSWQgLSBJRCBvZiB0aGUgaXRlbSB0aGF0IGlzIGJlaW5nIGFjdGVkIHVwb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBbY29tbWVudHNdIC0gQ29tbWVudCB0byBhZGQgdG8gdGhlIGhpc3Rvcnkgc3RlcCBhc3NvY2lhdGVkIHdpdGggdGhpcyByZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gUmVxdWVzdCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBbb3B0aW9ucy5uZXh0QXBwcm92ZXJJZHNdIC0gSWYgdGhlIHByb2Nlc3MgcmVxdWlyZXMgc3BlY2lmaWNhdGlvbiBvZiB0aGUgbmV4dCBhcHByb3ZhbCwgdGhlIElEIG9mIHRoZSB1c2VyIHRvIGJlIGFzc2lnbmVkIHRoZSBuZXh0IHJlcXVlc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm9jZXNzRGVmaW5pdGlvbk5hbWVPcklkXSAtIERldmVsb3BlciBuYW1lIG9yIElEIG9mIHRoZSBwcm9jZXNzIGRlZmluaXRpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcEVudHJ5Q3JpdGVyaWFdIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV2YWx1YXRlIHRoZSBlbnRyeSBjcml0ZXJpYSBmb3IgdGhlIHByb2Nlc3MgKHRydWUpIG9yIG5vdCAoZmFsc2UpIGlmIHRoZSBwcm9jZXNzIGRlZmluaXRpb24gbmFtZSBvciBJRCBpc27igJl0IG51bGxcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFwcHJvdmFsUHJvY2Vzc1JlcXVlc3RSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtBcHByb3ZhbFByb2Nlc3NSZXF1ZXN0fVxuICovXG5BcHByb3ZhbFByb2Nlc3MucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHdvcmtpdGVtSWQsIGNvbW1lbnRzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fY3JlYXRlUmVxdWVzdChcIlJlamVjdFwiLCB3b3JraXRlbUlkLCBjb21tZW50cywgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhcHByb3ZhbCBwcm9jZXNzIHJlcXVlc3RcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAY2xhc3MgUHJvY2Vzc35BcHByb3ZhbFByb2Nlc3NSZXF1ZXN0XG4gKiBAaW1wbGVtZW50cyB7UHJvbWlzZS48UHJvY2Vzc35BcHByb3ZhbFByb2Nlc3NSZXF1ZXN0UmVzdWx0Pn1cbiAqIEBwYXJhbSB7UHJvY2Vzc35BcHByb3ZhbFByb2Nlc3N9IHByb2Nlc3MgLSBBcHByb3ZhbFByb2Nlc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IC0gUmVxdWVzdCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdC5hY3Rpb25UeXBlIC0gUmVwcmVzZW50cyB0aGUga2luZCBvZiBhY3Rpb24gdG8gdGFrZTogU3VibWl0LCBBcHByb3ZlLCBvciBSZWplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0LmNvbnRleHRJZCAtIElEIG9mIHRoZSBpdGVtIHRoYXQgaXMgYmVpbmcgYWN0ZWQgdXBvblxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3QuY29tbWVudHMgLSBDb21tZW50IHRvIGFkZCB0byB0aGUgaGlzdG9yeSBzdGVwIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJlcXVlc3RcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IFtyZXF1ZXN0Lm5leHRBcHByb3Zlcklkc10gLSBJZiB0aGUgcHJvY2VzcyByZXF1aXJlcyBzcGVjaWZpY2F0aW9uIG9mIHRoZSBuZXh0IGFwcHJvdmFsLCB0aGUgSUQgb2YgdGhlIHVzZXIgdG8gYmUgYXNzaWduZWQgdGhlIG5leHQgcmVxdWVzdFxuICogQHBhcmFtIHtTdHJpbmd9IFtyZXF1ZXN0LnByb2Nlc3NEZWZpbml0aW9uTmFtZU9ySWRdIC0gRGV2ZWxvcGVyIG5hbWUgb3IgSUQgb2YgdGhlIHByb2Nlc3MgZGVmaW5pdGlvblxuICogQHBhcmFtIHtCb29sZWFufSBbcmVxdWVzdC5za2lwRW50cnlDcml0ZXJpYV0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXZhbHVhdGUgdGhlIGVudHJ5IGNyaXRlcmlhIGZvciB0aGUgcHJvY2VzcyAodHJ1ZSkgb3Igbm90IChmYWxzZSkgaWYgdGhlIHByb2Nlc3MgZGVmaW5pdGlvbiBuYW1lIG9yIElEIGlzbuKAmXQgbnVsbFxuICovXG52YXIgQXBwcm92YWxQcm9jZXNzUmVxdWVzdCA9IGZ1bmN0aW9uKHByb2Nlc3MsIHJlcXVlc3QpIHtcbiAgdGhpcy5fcHJvY2VzcyA9IHByb2Nlc3M7XG4gIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0O1xufTtcblxuLyoqXG4gKiBQcm9taXNlL0ErIGludGVyZmFjZVxuICogaHR0cDovL3Byb21pc2VzLWFwbHVzLmdpdGh1Yi5pby9wcm9taXNlcy1zcGVjL1xuICpcbiAqIEBtZXRob2QgUHJvY2Vzc35BcHByb3ZhbFByb2Nlc3NSZXF1ZXN0I3RoZW5cbiAqL1xuQXBwcm92YWxQcm9jZXNzUmVxdWVzdC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uUmVzb2x2ZSwgb25SZWplY3QpIHtcbiAgaWYgKCF0aGlzLl9wcm9taXNlKSB7XG4gICAgdGhpcy5fcHJvbWlzZSA9IHRoaXMuX3Byb2Nlc3MucmVxdWVzdChbIHRoaXMgXSkudGhlbihmdW5jdGlvbihyZXRzKSB7XG4gICAgICByZXR1cm4gcmV0c1swXTtcbiAgICB9KTtcbiAgfVxuICB0aGlzLl9wcm9taXNlLnRoZW4ob25SZXNvbHZlLCBvblJlamVjdCk7XG59O1xuXG4vKipcbiAqIFByb21pc2UvQSsgZXh0ZW5zaW9uXG4gKiBDYWxsIFwidGhlblwiIHVzaW5nIGdpdmVuIG5vZGUtc3R5bGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqXG4gKiBAbWV0aG9kIFByb2Nlc3N+QXBwcm92YWxQcm9jZXNzUmVxdWVzdCN0aGVuQ2FsbFxuICovXG5BcHByb3ZhbFByb2Nlc3NSZXF1ZXN0LnByb3RvdHlwZS50aGVuQ2FsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiBjYWxsYmFjayA/IHRoaXMudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICBjYWxsYmFjayhudWxsLCByZXMpO1xuICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9KSA6XG4gIHRoaXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/process.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/process.js":
/*!*********************************************!*\
  !*** ./node_modules/jsforce/lib/process.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Process class to manage/run workflow rule and approval process\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar _ = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    Promise = __webpack_require__(/*! ./promise */ \"(rsc)/./node_modules/jsforce/lib/promise.js\"),\n    Conneciton = __webpack_require__(/*! ./connection */ \"(rsc)/./node_modules/jsforce/lib/connection.js\");\n\n/**\n * A class which manages process rules and approval processes\n *\n * @class\n * @param {Connection} conn - Connection object\n */\nvar Process = module.exports = function(conn) {\n  /**\n   * Object which mangages process rules\n   * @member {Process~ProcessRule} Process#rule\n   */\n  this.rule = new ProcessRule(conn);\n  /**\n   * Object which mangages approval process\n   * @member {Process~ApprovalProcess} Process#approval\n   */\n  this.approval = new ApprovalProcess(conn);\n};\n\n/**\n * A class which manages process (workflow) rules\n *\n * @class Process~ProcessRule\n * @param {Connection} conn - Connection object\n */\nvar ProcessRule = function(conn) {\n  this._conn = conn;\n};\n\n/**\n * @typedef {Object} Process~ProcessRuleDefinition\n * @prop {String} id - Id of approval process definition\n * @prop {String} name - Name of process rule definition\n * @prop {String} object - SObject name which process rule is defined\n */\n\n/**\n * Get all process rule definitions registered to sobjects\n *\n * @method Process~ProcessRule#list\n * @param {Callback.<Map.<String, Array.<Process~ProcessRuleDefinition>>>} [callback] - Callback function\n * @returns {Promise.<Map.<String, Array.<Process~ProcessRuleDefinition>>>}\n */\nProcessRule.prototype.list = function(callback) {\n  return this._conn.request(\"/process/rules\").then(function(res) {\n    return res.rules;\n  }).thenCall(callback);\n};\n\n\n/**\n * @typedef {Object} Process~ProcessRuleTriggerResult\n * @prop {Boolean} success - Is process rule trigger succeeded or not\n * @prop {Array.<Object>} errors - Array of errors returned if the request failed\n */\n\n/**\n * Trigger process rule for given entities\n *\n * @method Process~ProcessRule#trigger\n * @param {String|Array.<String>} contextIds - Entity ID(s) to trigger workflow process\n * @param {Callback.<Process~ProcessRuleTriggerResult>} [callback] - Callback function\n * @returns {Promise.<Process~ProcessRuleTriggerResult>}\n */\nProcessRule.prototype.trigger = function(contextIds, callback) {\n  contextIds = _.isArray(contextIds) ? contextIds : [ contextIds ];\n  return this._conn.request({\n    method: \"POST\",\n    url: \"/process/rules/\",\n    body: JSON.stringify({\n      contextIds: contextIds\n    }),\n    headers: {\n      \"content-type\": \"application/json\"\n    }\n  }).thenCall(callback);\n};\n\n/**\n * A class which manages approval processes\n *\n * @class Process~ApprovalProcess\n * @param {Connection} conn - Connection object\n */\nvar ApprovalProcess = function(conn) {\n  this._conn = conn;\n};\n\n/**\n * @typedef {Object} Process~ApprovalProcessDefinition\n * @prop {String} id - Id of approval process definition\n * @prop {String} name - Name of approval process definition\n * @prop {String} object - SObject name which approval process is defined\n * @prop {Number} sortOrder - Processing order of approval in SObject\n */\n/**\n * Get all approval process definitions registered to sobjects\n *\n * @method Process~ApprovalProcess#list\n * @param {Callback.<Map.<String, Array.<ApprovalProcessDefinition>>>} [callback] - Callback function\n * @returns {Promise.<Map.<String, Array.<ApprovalProcessDefinition>>>}\n */\nApprovalProcess.prototype.list = function(callback) {\n  return this._conn.request(\"/process/approvals\").then(function(res) {\n    return res.approvals;\n  }).thenCall(callback);\n};\n\n/**\n * @typedef {Object} Process~ApprovalProcessRequestResult\n * @prop {Boolean} success - True if processing or approval completed successfully\n * @prop {Array.<Object>} errors - The set of errors returned if the request failed\n * @prop {Array.<String>} actorIds - IDs of the users who are currently assigned to this approval step\n * @prop {String} entityId - Object being processed\n * @prop {String} instanceId - ID of the ProcessInstance associated with the object submitted for processing\n * @prop {String} instanceStatus - Status of the current process instance (not an individual object but the entire process instance)\n * @prop {Array.<String>} newWorkItemIds - Case-insensitive IDs that point to ProcessInstanceWorkitem items (the set of pending approval requests)\n */\n\n/**\n * Send bulk requests for approval process\n *\n * @method Process~ApprovalProcess#request\n * @param {Array.<ApprovalProcessRequest>} requests - Array of approval process request to send\n * @param {Callback.<Array.<ApprovalProcessRequestResult>>} - Callback function\n * @param {Promise.<Array.<ApprovalProcessRequestResult>>}\n */\nApprovalProcess.prototype.request = function(requests, callback) {\n  requests = requests.map(function(req) {\n    return req._request ? req._request : req;\n  });\n  return this._conn.request({\n    method: 'POST',\n    url: '/process/approvals',\n    headers: { \"content-type\": \"application/json\" },\n    body: JSON.stringify({ requests: requests })\n  }).thenCall(callback);\n};\n\n/**\n * Create approval process request\n *\n * @private\n */\nApprovalProcess.prototype._createRequest = function(actionType, contextId, comments, options, callback) {\n  if (typeof comments === \"function\") {\n    callback = comments;\n    options = null;\n    comments = null;\n  }\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  options = options || {};\n  var request = {\n    actionType: actionType,\n    contextId: contextId,\n    comments: comments\n  };\n  _.extend(request, options);\n  return new ApprovalProcessRequest(this, request).thenCall(callback);\n};\n\n/**\n * Submit approval request for an item\n *\n * @method Process~ApprovalProcess#submit\n * @param {String} contextId - ID of the item that is being acted upon\n * @param {String} [comments] - Comment to add to the history step associated with this request\n * @param {Object} [options] - Request parameters\n * @param {Array.<String>} [options.nextApproverIds] - If the process requires specification of the next approval, the ID of the user to be assigned the next request\n * @param {String} [options.processDefinitionNameOrId] - Developer name or ID of the process definition\n * @param {Boolean} [options.skipEntryCriteria] - Determines whether to evaluate the entry criteria for the process (true) or not (false) if the process definition name or ID isnt null\n * @param {Callback.<ApprovalProcessRequestResult>} [callback] - Callback function\n * @returns {ApprovalProcessRequest}\n */\nApprovalProcess.prototype.submit = function(contextId, comments, options, callback) {\n  return this._createRequest(\"Submit\", contextId, comments, options, callback);\n};\n\n/**\n * Approve approval request for an item\n *\n * @method Process~ApprovalProcess#approve\n * @param {String} workitemId - ID of the item that is being acted upon\n * @param {String} [comments] - Comment to add to the history step associated with this request\n * @param {Object} [options] - Request parameters\n * @param {Array.<String>} [options.nextApproverIds] - If the process requires specification of the next approval, the ID of the user to be assigned the next request\n * @param {String} [options.processDefinitionNameOrId] - Developer name or ID of the process definition\n * @param {Boolean} [options.skipEntryCriteria] - Determines whether to evaluate the entry criteria for the process (true) or not (false) if the process definition name or ID isnt null\n * @param {Callback.<ApprovalProcessRequestResult>} [callback] - Callback function\n * @returns {ApprovalProcessRequest}\n */\nApprovalProcess.prototype.approve = function(workitemId, comments, options, callback) {\n  return this._createRequest(\"Approve\", workitemId, comments, options, callback);\n};\n\n/**\n * Reject approval request for an item\n *\n * @method Process~ApprovalProcess#reject\n * @param {String} workitemId - ID of the item that is being acted upon\n * @param {String} [comments] - Comment to add to the history step associated with this request\n * @param {Object} [options] - Request parameters\n * @param {Array.<String>} [options.nextApproverIds] - If the process requires specification of the next approval, the ID of the user to be assigned the next request\n * @param {String} [options.processDefinitionNameOrId] - Developer name or ID of the process definition\n * @param {Boolean} [options.skipEntryCriteria] - Determines whether to evaluate the entry criteria for the process (true) or not (false) if the process definition name or ID isnt null\n * @param {Callback.<ApprovalProcessRequestResult>} [callback] - Callback function\n * @returns {ApprovalProcessRequest}\n */\nApprovalProcess.prototype.reject = function(workitemId, comments, options, callback) {\n  return this._createRequest(\"Reject\", workitemId, comments, options, callback);\n};\n\n/**\n * A class representing approval process request\n *\n * @protected\n * @class Process~ApprovalProcessRequest\n * @implements {Promise.<Process~ApprovalProcessRequestResult>}\n * @param {Process~ApprovalProcess} process - ApprovalProcess\n * @param {Object} request - Request parameters\n * @param {String} request.actionType - Represents the kind of action to take: Submit, Approve, or Reject\n * @param {String} request.contextId - ID of the item that is being acted upon\n * @param {String} request.comments - Comment to add to the history step associated with this request\n * @param {Array.<String>} [request.nextApproverIds] - If the process requires specification of the next approval, the ID of the user to be assigned the next request\n * @param {String} [request.processDefinitionNameOrId] - Developer name or ID of the process definition\n * @param {Boolean} [request.skipEntryCriteria] - Determines whether to evaluate the entry criteria for the process (true) or not (false) if the process definition name or ID isnt null\n */\nvar ApprovalProcessRequest = function(process, request) {\n  this._process = process;\n  this._request = request;\n};\n\n/**\n * Promise/A+ interface\n * http://promises-aplus.github.io/promises-spec/\n *\n * @method Process~ApprovalProcessRequest#then\n */\nApprovalProcessRequest.prototype.then = function(onResolve, onReject) {\n  if (!this._promise) {\n    this._promise = this._process.request([ this ]).then(function(rets) {\n      return rets[0];\n    });\n  }\n  this._promise.then(onResolve, onReject);\n};\n\n/**\n * Promise/A+ extension\n * Call \"then\" using given node-style callback function\n *\n * @method Process~ApprovalProcessRequest#thenCall\n */\nApprovalProcessRequest.prototype.thenCall = function(callback) {\n  return callback ? this.then(function(res) {\n    callback(null, res);\n  }, function(err) {\n    callback(err);\n  }) :\n  this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcHJvY2Vzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixRQUFRLG1CQUFPLENBQUMsd0RBQWE7QUFDN0IsY0FBYyxtQkFBTyxDQUFDLDhEQUFXO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLG9FQUFjOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnRUFBZ0U7QUFDM0UsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxnQkFBZ0I7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLDZDQUE2QztBQUN4RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUE0RDtBQUN2RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsZ0JBQWdCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0MsV0FBVyxpREFBaUQ7QUFDNUQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25ELDJCQUEyQixvQkFBb0I7QUFDL0MsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyx5Q0FBeUM7QUFDcEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLHlDQUF5QztBQUNwRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcseUNBQXlDO0FBQ3BELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLFdBQVcseUJBQXlCO0FBQ3BDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9wcm9jZXNzLmpzPzUwYjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBQcm9jZXNzIGNsYXNzIHRvIG1hbmFnZS9ydW4gd29ya2Zsb3cgcnVsZSBhbmQgYXBwcm92YWwgcHJvY2Vzc1xuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vcHJvbWlzZScpLFxuICAgIENvbm5lY2l0b24gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKTtcblxuLyoqXG4gKiBBIGNsYXNzIHdoaWNoIG1hbmFnZXMgcHJvY2VzcyBydWxlcyBhbmQgYXBwcm92YWwgcHJvY2Vzc2VzXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gLSBDb25uZWN0aW9uIG9iamVjdFxuICovXG52YXIgUHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29ubikge1xuICAvKipcbiAgICogT2JqZWN0IHdoaWNoIG1hbmdhZ2VzIHByb2Nlc3MgcnVsZXNcbiAgICogQG1lbWJlciB7UHJvY2Vzc35Qcm9jZXNzUnVsZX0gUHJvY2VzcyNydWxlXG4gICAqL1xuICB0aGlzLnJ1bGUgPSBuZXcgUHJvY2Vzc1J1bGUoY29ubik7XG4gIC8qKlxuICAgKiBPYmplY3Qgd2hpY2ggbWFuZ2FnZXMgYXBwcm92YWwgcHJvY2Vzc1xuICAgKiBAbWVtYmVyIHtQcm9jZXNzfkFwcHJvdmFsUHJvY2Vzc30gUHJvY2VzcyNhcHByb3ZhbFxuICAgKi9cbiAgdGhpcy5hcHByb3ZhbCA9IG5ldyBBcHByb3ZhbFByb2Nlc3MoY29ubik7XG59O1xuXG4vKipcbiAqIEEgY2xhc3Mgd2hpY2ggbWFuYWdlcyBwcm9jZXNzICh3b3JrZmxvdykgcnVsZXNcbiAqXG4gKiBAY2xhc3MgUHJvY2Vzc35Qcm9jZXNzUnVsZVxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIC0gQ29ubmVjdGlvbiBvYmplY3RcbiAqL1xudmFyIFByb2Nlc3NSdWxlID0gZnVuY3Rpb24oY29ubikge1xuICB0aGlzLl9jb25uID0gY29ubjtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUHJvY2Vzc35Qcm9jZXNzUnVsZURlZmluaXRpb25cbiAqIEBwcm9wIHtTdHJpbmd9IGlkIC0gSWQgb2YgYXBwcm92YWwgcHJvY2VzcyBkZWZpbml0aW9uXG4gKiBAcHJvcCB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiBwcm9jZXNzIHJ1bGUgZGVmaW5pdGlvblxuICogQHByb3Age1N0cmluZ30gb2JqZWN0IC0gU09iamVjdCBuYW1lIHdoaWNoIHByb2Nlc3MgcnVsZSBpcyBkZWZpbmVkXG4gKi9cblxuLyoqXG4gKiBHZXQgYWxsIHByb2Nlc3MgcnVsZSBkZWZpbml0aW9ucyByZWdpc3RlcmVkIHRvIHNvYmplY3RzXG4gKlxuICogQG1ldGhvZCBQcm9jZXNzflByb2Nlc3NSdWxlI2xpc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE1hcC48U3RyaW5nLCBBcnJheS48UHJvY2Vzc35Qcm9jZXNzUnVsZURlZmluaXRpb24+Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE1hcC48U3RyaW5nLCBBcnJheS48UHJvY2Vzc35Qcm9jZXNzUnVsZURlZmluaXRpb24+Pj59XG4gKi9cblByb2Nlc3NSdWxlLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdChcIi9wcm9jZXNzL3J1bGVzXCIpLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgcmV0dXJuIHJlcy5ydWxlcztcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb2Nlc3N+UHJvY2Vzc1J1bGVUcmlnZ2VyUmVzdWx0XG4gKiBAcHJvcCB7Qm9vbGVhbn0gc3VjY2VzcyAtIElzIHByb2Nlc3MgcnVsZSB0cmlnZ2VyIHN1Y2NlZWRlZCBvciBub3RcbiAqIEBwcm9wIHtBcnJheS48T2JqZWN0Pn0gZXJyb3JzIC0gQXJyYXkgb2YgZXJyb3JzIHJldHVybmVkIGlmIHRoZSByZXF1ZXN0IGZhaWxlZFxuICovXG5cbi8qKlxuICogVHJpZ2dlciBwcm9jZXNzIHJ1bGUgZm9yIGdpdmVuIGVudGl0aWVzXG4gKlxuICogQG1ldGhvZCBQcm9jZXNzflByb2Nlc3NSdWxlI3RyaWdnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb250ZXh0SWRzIC0gRW50aXR5IElEKHMpIHRvIHRyaWdnZXIgd29ya2Zsb3cgcHJvY2Vzc1xuICogQHBhcmFtIHtDYWxsYmFjay48UHJvY2Vzc35Qcm9jZXNzUnVsZVRyaWdnZXJSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxQcm9jZXNzflByb2Nlc3NSdWxlVHJpZ2dlclJlc3VsdD59XG4gKi9cblByb2Nlc3NSdWxlLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24oY29udGV4dElkcywgY2FsbGJhY2spIHtcbiAgY29udGV4dElkcyA9IF8uaXNBcnJheShjb250ZXh0SWRzKSA/IGNvbnRleHRJZHMgOiBbIGNvbnRleHRJZHMgXTtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdCh7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IFwiL3Byb2Nlc3MvcnVsZXMvXCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgY29udGV4dElkczogY29udGV4dElkc1xuICAgIH0pLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfVxuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEEgY2xhc3Mgd2hpY2ggbWFuYWdlcyBhcHByb3ZhbCBwcm9jZXNzZXNcbiAqXG4gKiBAY2xhc3MgUHJvY2Vzc35BcHByb3ZhbFByb2Nlc3NcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiAtIENvbm5lY3Rpb24gb2JqZWN0XG4gKi9cbnZhciBBcHByb3ZhbFByb2Nlc3MgPSBmdW5jdGlvbihjb25uKSB7XG4gIHRoaXMuX2Nvbm4gPSBjb25uO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9jZXNzfkFwcHJvdmFsUHJvY2Vzc0RlZmluaXRpb25cbiAqIEBwcm9wIHtTdHJpbmd9IGlkIC0gSWQgb2YgYXBwcm92YWwgcHJvY2VzcyBkZWZpbml0aW9uXG4gKiBAcHJvcCB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiBhcHByb3ZhbCBwcm9jZXNzIGRlZmluaXRpb25cbiAqIEBwcm9wIHtTdHJpbmd9IG9iamVjdCAtIFNPYmplY3QgbmFtZSB3aGljaCBhcHByb3ZhbCBwcm9jZXNzIGlzIGRlZmluZWRcbiAqIEBwcm9wIHtOdW1iZXJ9IHNvcnRPcmRlciAtIFByb2Nlc3Npbmcgb3JkZXIgb2YgYXBwcm92YWwgaW4gU09iamVjdFxuICovXG4vKipcbiAqIEdldCBhbGwgYXBwcm92YWwgcHJvY2VzcyBkZWZpbml0aW9ucyByZWdpc3RlcmVkIHRvIHNvYmplY3RzXG4gKlxuICogQG1ldGhvZCBQcm9jZXNzfkFwcHJvdmFsUHJvY2VzcyNsaXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxNYXAuPFN0cmluZywgQXJyYXkuPEFwcHJvdmFsUHJvY2Vzc0RlZmluaXRpb24+Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE1hcC48U3RyaW5nLCBBcnJheS48QXBwcm92YWxQcm9jZXNzRGVmaW5pdGlvbj4+Pn1cbiAqL1xuQXBwcm92YWxQcm9jZXNzLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdChcIi9wcm9jZXNzL2FwcHJvdmFsc1wiKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgIHJldHVybiByZXMuYXBwcm92YWxzO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb2Nlc3N+QXBwcm92YWxQcm9jZXNzUmVxdWVzdFJlc3VsdFxuICogQHByb3Age0Jvb2xlYW59IHN1Y2Nlc3MgLSBUcnVlIGlmIHByb2Nlc3Npbmcgb3IgYXBwcm92YWwgY29tcGxldGVkIHN1Y2Nlc3NmdWxseVxuICogQHByb3Age0FycmF5LjxPYmplY3Q+fSBlcnJvcnMgLSBUaGUgc2V0IG9mIGVycm9ycyByZXR1cm5lZCBpZiB0aGUgcmVxdWVzdCBmYWlsZWRcbiAqIEBwcm9wIHtBcnJheS48U3RyaW5nPn0gYWN0b3JJZHMgLSBJRHMgb2YgdGhlIHVzZXJzIHdobyBhcmUgY3VycmVudGx5IGFzc2lnbmVkIHRvIHRoaXMgYXBwcm92YWwgc3RlcFxuICogQHByb3Age1N0cmluZ30gZW50aXR5SWQgLSBPYmplY3QgYmVpbmcgcHJvY2Vzc2VkXG4gKiBAcHJvcCB7U3RyaW5nfSBpbnN0YW5jZUlkIC0gSUQgb2YgdGhlIFByb2Nlc3NJbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggdGhlIG9iamVjdCBzdWJtaXR0ZWQgZm9yIHByb2Nlc3NpbmdcbiAqIEBwcm9wIHtTdHJpbmd9IGluc3RhbmNlU3RhdHVzIC0gU3RhdHVzIG9mIHRoZSBjdXJyZW50IHByb2Nlc3MgaW5zdGFuY2UgKG5vdCBhbiBpbmRpdmlkdWFsIG9iamVjdCBidXQgdGhlIGVudGlyZSBwcm9jZXNzIGluc3RhbmNlKVxuICogQHByb3Age0FycmF5LjxTdHJpbmc+fSBuZXdXb3JrSXRlbUlkcyAtIENhc2UtaW5zZW5zaXRpdmUgSURzIHRoYXQgcG9pbnQgdG8gUHJvY2Vzc0luc3RhbmNlV29ya2l0ZW0gaXRlbXMgKHRoZSBzZXQgb2YgcGVuZGluZyBhcHByb3ZhbCByZXF1ZXN0cylcbiAqL1xuXG4vKipcbiAqIFNlbmQgYnVsayByZXF1ZXN0cyBmb3IgYXBwcm92YWwgcHJvY2Vzc1xuICpcbiAqIEBtZXRob2QgUHJvY2Vzc35BcHByb3ZhbFByb2Nlc3MjcmVxdWVzdFxuICogQHBhcmFtIHtBcnJheS48QXBwcm92YWxQcm9jZXNzUmVxdWVzdD59IHJlcXVlc3RzIC0gQXJyYXkgb2YgYXBwcm92YWwgcHJvY2VzcyByZXF1ZXN0IHRvIHNlbmRcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxBcHByb3ZhbFByb2Nlc3NSZXF1ZXN0UmVzdWx0Pj59IC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7UHJvbWlzZS48QXJyYXkuPEFwcHJvdmFsUHJvY2Vzc1JlcXVlc3RSZXN1bHQ+Pn1cbiAqL1xuQXBwcm92YWxQcm9jZXNzLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdHMsIGNhbGxiYWNrKSB7XG4gIHJlcXVlc3RzID0gcmVxdWVzdHMubWFwKGZ1bmN0aW9uKHJlcSkge1xuICAgIHJldHVybiByZXEuX3JlcXVlc3QgPyByZXEuX3JlcXVlc3QgOiByZXE7XG4gIH0pO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6ICcvcHJvY2Vzcy9hcHByb3ZhbHMnLFxuICAgIGhlYWRlcnM6IHsgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHJlcXVlc3RzOiByZXF1ZXN0cyB9KVxuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhcHByb3ZhbCBwcm9jZXNzIHJlcXVlc3RcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5BcHByb3ZhbFByb2Nlc3MucHJvdG90eXBlLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oYWN0aW9uVHlwZSwgY29udGV4dElkLCBjb21tZW50cywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjb21tZW50cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2FsbGJhY2sgPSBjb21tZW50cztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgICBjb21tZW50cyA9IG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciByZXF1ZXN0ID0ge1xuICAgIGFjdGlvblR5cGU6IGFjdGlvblR5cGUsXG4gICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgY29tbWVudHM6IGNvbW1lbnRzXG4gIH07XG4gIF8uZXh0ZW5kKHJlcXVlc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IEFwcHJvdmFsUHJvY2Vzc1JlcXVlc3QodGhpcywgcmVxdWVzdCkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTdWJtaXQgYXBwcm92YWwgcmVxdWVzdCBmb3IgYW4gaXRlbVxuICpcbiAqIEBtZXRob2QgUHJvY2Vzc35BcHByb3ZhbFByb2Nlc3Mjc3VibWl0XG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGV4dElkIC0gSUQgb2YgdGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBhY3RlZCB1cG9uXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NvbW1lbnRzXSAtIENvbW1lbnQgdG8gYWRkIHRvIHRoZSBoaXN0b3J5IHN0ZXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmVxdWVzdFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFJlcXVlc3QgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gW29wdGlvbnMubmV4dEFwcHJvdmVySWRzXSAtIElmIHRoZSBwcm9jZXNzIHJlcXVpcmVzIHNwZWNpZmljYXRpb24gb2YgdGhlIG5leHQgYXBwcm92YWwsIHRoZSBJRCBvZiB0aGUgdXNlciB0byBiZSBhc3NpZ25lZCB0aGUgbmV4dCByZXF1ZXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvY2Vzc0RlZmluaXRpb25OYW1lT3JJZF0gLSBEZXZlbG9wZXIgbmFtZSBvciBJRCBvZiB0aGUgcHJvY2VzcyBkZWZpbml0aW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBFbnRyeUNyaXRlcmlhXSAtIERldGVybWluZXMgd2hldGhlciB0byBldmFsdWF0ZSB0aGUgZW50cnkgY3JpdGVyaWEgZm9yIHRoZSBwcm9jZXNzICh0cnVlKSBvciBub3QgKGZhbHNlKSBpZiB0aGUgcHJvY2VzcyBkZWZpbml0aW9uIG5hbWUgb3IgSUQgaXNu4oCZdCBudWxsXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcHByb3ZhbFByb2Nlc3NSZXF1ZXN0UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QXBwcm92YWxQcm9jZXNzUmVxdWVzdH1cbiAqL1xuQXBwcm92YWxQcm9jZXNzLnByb3RvdHlwZS5zdWJtaXQgPSBmdW5jdGlvbihjb250ZXh0SWQsIGNvbW1lbnRzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fY3JlYXRlUmVxdWVzdChcIlN1Ym1pdFwiLCBjb250ZXh0SWQsIGNvbW1lbnRzLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEFwcHJvdmUgYXBwcm92YWwgcmVxdWVzdCBmb3IgYW4gaXRlbVxuICpcbiAqIEBtZXRob2QgUHJvY2Vzc35BcHByb3ZhbFByb2Nlc3MjYXBwcm92ZVxuICogQHBhcmFtIHtTdHJpbmd9IHdvcmtpdGVtSWQgLSBJRCBvZiB0aGUgaXRlbSB0aGF0IGlzIGJlaW5nIGFjdGVkIHVwb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBbY29tbWVudHNdIC0gQ29tbWVudCB0byBhZGQgdG8gdGhlIGhpc3Rvcnkgc3RlcCBhc3NvY2lhdGVkIHdpdGggdGhpcyByZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gUmVxdWVzdCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBbb3B0aW9ucy5uZXh0QXBwcm92ZXJJZHNdIC0gSWYgdGhlIHByb2Nlc3MgcmVxdWlyZXMgc3BlY2lmaWNhdGlvbiBvZiB0aGUgbmV4dCBhcHByb3ZhbCwgdGhlIElEIG9mIHRoZSB1c2VyIHRvIGJlIGFzc2lnbmVkIHRoZSBuZXh0IHJlcXVlc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm9jZXNzRGVmaW5pdGlvbk5hbWVPcklkXSAtIERldmVsb3BlciBuYW1lIG9yIElEIG9mIHRoZSBwcm9jZXNzIGRlZmluaXRpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcEVudHJ5Q3JpdGVyaWFdIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV2YWx1YXRlIHRoZSBlbnRyeSBjcml0ZXJpYSBmb3IgdGhlIHByb2Nlc3MgKHRydWUpIG9yIG5vdCAoZmFsc2UpIGlmIHRoZSBwcm9jZXNzIGRlZmluaXRpb24gbmFtZSBvciBJRCBpc27igJl0IG51bGxcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFwcHJvdmFsUHJvY2Vzc1JlcXVlc3RSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtBcHByb3ZhbFByb2Nlc3NSZXF1ZXN0fVxuICovXG5BcHByb3ZhbFByb2Nlc3MucHJvdG90eXBlLmFwcHJvdmUgPSBmdW5jdGlvbih3b3JraXRlbUlkLCBjb21tZW50cywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZVJlcXVlc3QoXCJBcHByb3ZlXCIsIHdvcmtpdGVtSWQsIGNvbW1lbnRzLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJlamVjdCBhcHByb3ZhbCByZXF1ZXN0IGZvciBhbiBpdGVtXG4gKlxuICogQG1ldGhvZCBQcm9jZXNzfkFwcHJvdmFsUHJvY2VzcyNyZWplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSB3b3JraXRlbUlkIC0gSUQgb2YgdGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBhY3RlZCB1cG9uXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NvbW1lbnRzXSAtIENvbW1lbnQgdG8gYWRkIHRvIHRoZSBoaXN0b3J5IHN0ZXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmVxdWVzdFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFJlcXVlc3QgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gW29wdGlvbnMubmV4dEFwcHJvdmVySWRzXSAtIElmIHRoZSBwcm9jZXNzIHJlcXVpcmVzIHNwZWNpZmljYXRpb24gb2YgdGhlIG5leHQgYXBwcm92YWwsIHRoZSBJRCBvZiB0aGUgdXNlciB0byBiZSBhc3NpZ25lZCB0aGUgbmV4dCByZXF1ZXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvY2Vzc0RlZmluaXRpb25OYW1lT3JJZF0gLSBEZXZlbG9wZXIgbmFtZSBvciBJRCBvZiB0aGUgcHJvY2VzcyBkZWZpbml0aW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBFbnRyeUNyaXRlcmlhXSAtIERldGVybWluZXMgd2hldGhlciB0byBldmFsdWF0ZSB0aGUgZW50cnkgY3JpdGVyaWEgZm9yIHRoZSBwcm9jZXNzICh0cnVlKSBvciBub3QgKGZhbHNlKSBpZiB0aGUgcHJvY2VzcyBkZWZpbml0aW9uIG5hbWUgb3IgSUQgaXNu4oCZdCBudWxsXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcHByb3ZhbFByb2Nlc3NSZXF1ZXN0UmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QXBwcm92YWxQcm9jZXNzUmVxdWVzdH1cbiAqL1xuQXBwcm92YWxQcm9jZXNzLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbih3b3JraXRlbUlkLCBjb21tZW50cywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZVJlcXVlc3QoXCJSZWplY3RcIiwgd29ya2l0ZW1JZCwgY29tbWVudHMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQSBjbGFzcyByZXByZXNlbnRpbmcgYXBwcm92YWwgcHJvY2VzcyByZXF1ZXN0XG4gKlxuICogQHByb3RlY3RlZFxuICogQGNsYXNzIFByb2Nlc3N+QXBwcm92YWxQcm9jZXNzUmVxdWVzdFxuICogQGltcGxlbWVudHMge1Byb21pc2UuPFByb2Nlc3N+QXBwcm92YWxQcm9jZXNzUmVxdWVzdFJlc3VsdD59XG4gKiBAcGFyYW0ge1Byb2Nlc3N+QXBwcm92YWxQcm9jZXNzfSBwcm9jZXNzIC0gQXBwcm92YWxQcm9jZXNzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCAtIFJlcXVlc3QgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3QuYWN0aW9uVHlwZSAtIFJlcHJlc2VudHMgdGhlIGtpbmQgb2YgYWN0aW9uIHRvIHRha2U6IFN1Ym1pdCwgQXBwcm92ZSwgb3IgUmVqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdC5jb250ZXh0SWQgLSBJRCBvZiB0aGUgaXRlbSB0aGF0IGlzIGJlaW5nIGFjdGVkIHVwb25cbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0LmNvbW1lbnRzIC0gQ29tbWVudCB0byBhZGQgdG8gdGhlIGhpc3Rvcnkgc3RlcCBhc3NvY2lhdGVkIHdpdGggdGhpcyByZXF1ZXN0XG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBbcmVxdWVzdC5uZXh0QXBwcm92ZXJJZHNdIC0gSWYgdGhlIHByb2Nlc3MgcmVxdWlyZXMgc3BlY2lmaWNhdGlvbiBvZiB0aGUgbmV4dCBhcHByb3ZhbCwgdGhlIElEIG9mIHRoZSB1c2VyIHRvIGJlIGFzc2lnbmVkIHRoZSBuZXh0IHJlcXVlc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcmVxdWVzdC5wcm9jZXNzRGVmaW5pdGlvbk5hbWVPcklkXSAtIERldmVsb3BlciBuYW1lIG9yIElEIG9mIHRoZSBwcm9jZXNzIGRlZmluaXRpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlcXVlc3Quc2tpcEVudHJ5Q3JpdGVyaWFdIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV2YWx1YXRlIHRoZSBlbnRyeSBjcml0ZXJpYSBmb3IgdGhlIHByb2Nlc3MgKHRydWUpIG9yIG5vdCAoZmFsc2UpIGlmIHRoZSBwcm9jZXNzIGRlZmluaXRpb24gbmFtZSBvciBJRCBpc27igJl0IG51bGxcbiAqL1xudmFyIEFwcHJvdmFsUHJvY2Vzc1JlcXVlc3QgPSBmdW5jdGlvbihwcm9jZXNzLCByZXF1ZXN0KSB7XG4gIHRoaXMuX3Byb2Nlc3MgPSBwcm9jZXNzO1xuICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdDtcbn07XG5cbi8qKlxuICogUHJvbWlzZS9BKyBpbnRlcmZhY2VcbiAqIGh0dHA6Ly9wcm9taXNlcy1hcGx1cy5naXRodWIuaW8vcHJvbWlzZXMtc3BlYy9cbiAqXG4gKiBAbWV0aG9kIFByb2Nlc3N+QXBwcm92YWxQcm9jZXNzUmVxdWVzdCN0aGVuXG4gKi9cbkFwcHJvdmFsUHJvY2Vzc1JlcXVlc3QucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvblJlc29sdmUsIG9uUmVqZWN0KSB7XG4gIGlmICghdGhpcy5fcHJvbWlzZSkge1xuICAgIHRoaXMuX3Byb21pc2UgPSB0aGlzLl9wcm9jZXNzLnJlcXVlc3QoWyB0aGlzIF0pLnRoZW4oZnVuY3Rpb24ocmV0cykge1xuICAgICAgcmV0dXJuIHJldHNbMF07XG4gICAgfSk7XG4gIH1cbiAgdGhpcy5fcHJvbWlzZS50aGVuKG9uUmVzb2x2ZSwgb25SZWplY3QpO1xufTtcblxuLyoqXG4gKiBQcm9taXNlL0ErIGV4dGVuc2lvblxuICogQ2FsbCBcInRoZW5cIiB1c2luZyBnaXZlbiBub2RlLXN0eWxlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCBQcm9jZXNzfkFwcHJvdmFsUHJvY2Vzc1JlcXVlc3QjdGhlbkNhbGxcbiAqL1xuQXBwcm92YWxQcm9jZXNzUmVxdWVzdC5wcm90b3R5cGUudGhlbkNhbGwgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gY2FsbGJhY2sgPyB0aGlzLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfSkgOlxuICB0aGlzO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/process.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/promise.js":
/*!*********************************************!*\
  !*** ./node_modules/jsforce/lib/promise.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global process*/\n\n\n\nvar _ = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\");\n\n/**\n * @callback ResolvedCallback\n * @param {T} result - Resolved value\n * @returns {S}\n * @template T,S\n */\n\n/**\n * @callback RejectedCallback\n * @param {Error} reason - Rejected reason\n * @returns {S}\n * @template S\n */\n\n/**\n * @callback ResolveCallback\n * @param {T} result\n * @template T\n */\n\n/**\n * @callback RejectedCallback\n * @param {Error} reason - Rejected reason\n * @returns {S}\n * @template S\n */\n\n/**\n * @callback PromiseCallback\n * @param {ResolveCallback.<T>} resolve\n * @param {RejectCallback} reject\n * @template T\n */\n\n/**\n * Promise class with a little extension\n *\n * @class Promise\n * @constructor\n * @param {PromiseCallback.<T>}\n * @template T\n */\nvar Promise = __webpack_require__(/*! promise/lib/es6-extensions */ \"(action-browser)/./node_modules/promise/lib/es6-extensions.js\");\n\n/**\n * The \"then\" method from the Promises/A+ specification\n *\n * @method Promise#then\n * @param {FulfilledCallback.<T, S1>} [onFulfilled]\n * @param {RejectedCallback.<S2>} [onRejected]\n * @returns {Promise.<S1|S2>}\n */\n\n/**\n * Call \"then\" using given node-style callback function.\n * This is basically same as \"nodeify\" except that it always return the original promise\n *\n * @method Promise#thenCall\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Promise}\n */\nPromise.prototype.thenCall = function(callback) {\n  if (_.isFunction(callback)) {\n    this.then(function(res) {\n      process.nextTick(function() {\n        callback(null, res);\n      });\n    }, function(err) {\n      process.nextTick(function() {\n        callback(err);\n      });\n    });\n  }\n  return this;\n};\n\n/**\n * A sugar method, equivalent to promise.then(undefined, onRejected).\n *\n * @method Promise#catch\n * @param {RejectedCallback.<S>} onRejected\n * @returns {Promise.<S>}\n */\n\n/**\n * Synonym of Promise#catch\n *\n * @method Promise#fail\n * @param {RejectedCallback.<S>} onRejected\n * @returns {Promise.<S>}\n */\nPromise.prototype.fail = Promise.prototype['catch'];\n\n/**\n * Returns resolving promise with given reason\n *\n * @method Promise.resolve\n * @param {*} result - Resolved value\n * @returns {Promise}\n */\n\n/**\n * Returns rejecting promise with given reason\n *\n * @method Promise.reject\n * @param {Error} reason - Rejecting reason\n * @returns {Promise}\n */\n\n/**\n * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise,\n * or is rejected with the same rejection reason as the first promise to be rejected.\n *\n * @method Promise.all\n * @param {Array.<Promise.<*>|*>} promises\n * @returns {Promise.<Array.<*>>}\n */\n\n/**\n * Returns a deferred object\n *\n * @method Promise.defer\n * @returns {Deferred}\n */\nPromise.defer = function() {\n  return new Deferred();\n};\n\n/**\n * Deferred object\n *\n * @protected\n * @constructor\n */\nvar Deferred = function() {\n  var self = this;\n  this.promise = new Promise(function(resolve, reject) {\n    self.resolve = resolve;\n    self.reject = reject;\n  });\n};\n\n/**\n * Resolve promise\n * @method Deferred#resolve\n * @param {*} result - Resolving result\n */\n\n/**\n * Reject promise\n * @method Deferred#reject\n * @param {Error} error - Rejecting reason\n */\n\n/**\n *\n */\nmodule.exports = Promise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9wcm9taXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxtRUFBYTs7QUFFN0I7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsaUdBQTRCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDLFdBQVcsdUJBQXVCO0FBQ2xDLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9wcm9taXNlLmpzP2E0MTkiXSwic291cmNlc0NvbnRlbnQiOlsiLypnbG9iYWwgcHJvY2VzcyovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpO1xuXG4vKipcbiAqIEBjYWxsYmFjayBSZXNvbHZlZENhbGxiYWNrXG4gKiBAcGFyYW0ge1R9IHJlc3VsdCAtIFJlc29sdmVkIHZhbHVlXG4gKiBAcmV0dXJucyB7U31cbiAqIEB0ZW1wbGF0ZSBULFNcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBSZWplY3RlZENhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSByZWFzb24gLSBSZWplY3RlZCByZWFzb25cbiAqIEByZXR1cm5zIHtTfVxuICogQHRlbXBsYXRlIFNcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBSZXNvbHZlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7VH0gcmVzdWx0XG4gKiBAdGVtcGxhdGUgVFxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFJlamVjdGVkQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IHJlYXNvbiAtIFJlamVjdGVkIHJlYXNvblxuICogQHJldHVybnMge1N9XG4gKiBAdGVtcGxhdGUgU1xuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFByb21pc2VDYWxsYmFja1xuICogQHBhcmFtIHtSZXNvbHZlQ2FsbGJhY2suPFQ+fSByZXNvbHZlXG4gKiBAcGFyYW0ge1JlamVjdENhbGxiYWNrfSByZWplY3RcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cblxuLyoqXG4gKiBQcm9taXNlIGNsYXNzIHdpdGggYSBsaXR0bGUgZXh0ZW5zaW9uXG4gKlxuICogQGNsYXNzIFByb21pc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtQcm9taXNlQ2FsbGJhY2suPFQ+fVxuICogQHRlbXBsYXRlIFRcbiAqL1xudmFyIFByb21pc2UgPSByZXF1aXJlKCdwcm9taXNlL2xpYi9lczYtZXh0ZW5zaW9ucycpO1xuXG4vKipcbiAqIFRoZSBcInRoZW5cIiBtZXRob2QgZnJvbSB0aGUgUHJvbWlzZXMvQSsgc3BlY2lmaWNhdGlvblxuICpcbiAqIEBtZXRob2QgUHJvbWlzZSN0aGVuXG4gKiBAcGFyYW0ge0Z1bGZpbGxlZENhbGxiYWNrLjxULCBTMT59IFtvbkZ1bGZpbGxlZF1cbiAqIEBwYXJhbSB7UmVqZWN0ZWRDYWxsYmFjay48UzI+fSBbb25SZWplY3RlZF1cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxTMXxTMj59XG4gKi9cblxuLyoqXG4gKiBDYWxsIFwidGhlblwiIHVzaW5nIGdpdmVuIG5vZGUtc3R5bGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBzYW1lIGFzIFwibm9kZWlmeVwiIGV4Y2VwdCB0aGF0IGl0IGFsd2F5cyByZXR1cm4gdGhlIG9yaWdpbmFsIHByb21pc2VcbiAqXG4gKiBAbWV0aG9kIFByb21pc2UjdGhlbkNhbGxcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuQ2FsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIGlmIChfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgdGhpcy50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBIHN1Z2FyIG1ldGhvZCwgZXF1aXZhbGVudCB0byBwcm9taXNlLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKS5cbiAqXG4gKiBAbWV0aG9kIFByb21pc2UjY2F0Y2hcbiAqIEBwYXJhbSB7UmVqZWN0ZWRDYWxsYmFjay48Uz59IG9uUmVqZWN0ZWRcbiAqIEByZXR1cm5zIHtQcm9taXNlLjxTPn1cbiAqL1xuXG4vKipcbiAqIFN5bm9ueW0gb2YgUHJvbWlzZSNjYXRjaFxuICpcbiAqIEBtZXRob2QgUHJvbWlzZSNmYWlsXG4gKiBAcGFyYW0ge1JlamVjdGVkQ2FsbGJhY2suPFM+fSBvblJlamVjdGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48Uz59XG4gKi9cblByb21pc2UucHJvdG90eXBlLmZhaWwgPSBQcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXTtcblxuLyoqXG4gKiBSZXR1cm5zIHJlc29sdmluZyBwcm9taXNlIHdpdGggZ2l2ZW4gcmVhc29uXG4gKlxuICogQG1ldGhvZCBQcm9taXNlLnJlc29sdmVcbiAqIEBwYXJhbSB7Kn0gcmVzdWx0IC0gUmVzb2x2ZWQgdmFsdWVcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5cbi8qKlxuICogUmV0dXJucyByZWplY3RpbmcgcHJvbWlzZSB3aXRoIGdpdmVuIHJlYXNvblxuICpcbiAqIEBtZXRob2QgUHJvbWlzZS5yZWplY3RcbiAqIEBwYXJhbSB7RXJyb3J9IHJlYXNvbiAtIFJlamVjdGluZyByZWFzb25cbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBjb250YWluaW5nIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBvZiBlYWNoIHByb21pc2UsXG4gKiBvciBpcyByZWplY3RlZCB3aXRoIHRoZSBzYW1lIHJlamVjdGlvbiByZWFzb24gYXMgdGhlIGZpcnN0IHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuXG4gKlxuICogQG1ldGhvZCBQcm9taXNlLmFsbFxuICogQHBhcmFtIHtBcnJheS48UHJvbWlzZS48Kj58Kj59IHByb21pc2VzXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXkuPCo+Pn1cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBkZWZlcnJlZCBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIFByb21pc2UuZGVmZXJcbiAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAqL1xuUHJvbWlzZS5kZWZlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IERlZmVycmVkKCk7XG59O1xuXG4vKipcbiAqIERlZmVycmVkIG9iamVjdFxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRGVmZXJyZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBzZWxmLnJlc29sdmUgPSByZXNvbHZlO1xuICAgIHNlbGYucmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZSBwcm9taXNlXG4gKiBAbWV0aG9kIERlZmVycmVkI3Jlc29sdmVcbiAqIEBwYXJhbSB7Kn0gcmVzdWx0IC0gUmVzb2x2aW5nIHJlc3VsdFxuICovXG5cbi8qKlxuICogUmVqZWN0IHByb21pc2VcbiAqIEBtZXRob2QgRGVmZXJyZWQjcmVqZWN0XG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciAtIFJlamVjdGluZyByZWFzb25cbiAqL1xuXG4vKipcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/promise.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/promise.js":
/*!*********************************************!*\
  !*** ./node_modules/jsforce/lib/promise.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global process*/\n\n\n\nvar _ = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\");\n\n/**\n * @callback ResolvedCallback\n * @param {T} result - Resolved value\n * @returns {S}\n * @template T,S\n */\n\n/**\n * @callback RejectedCallback\n * @param {Error} reason - Rejected reason\n * @returns {S}\n * @template S\n */\n\n/**\n * @callback ResolveCallback\n * @param {T} result\n * @template T\n */\n\n/**\n * @callback RejectedCallback\n * @param {Error} reason - Rejected reason\n * @returns {S}\n * @template S\n */\n\n/**\n * @callback PromiseCallback\n * @param {ResolveCallback.<T>} resolve\n * @param {RejectCallback} reject\n * @template T\n */\n\n/**\n * Promise class with a little extension\n *\n * @class Promise\n * @constructor\n * @param {PromiseCallback.<T>}\n * @template T\n */\nvar Promise = __webpack_require__(/*! promise/lib/es6-extensions */ \"(rsc)/./node_modules/promise/lib/es6-extensions.js\");\n\n/**\n * The \"then\" method from the Promises/A+ specification\n *\n * @method Promise#then\n * @param {FulfilledCallback.<T, S1>} [onFulfilled]\n * @param {RejectedCallback.<S2>} [onRejected]\n * @returns {Promise.<S1|S2>}\n */\n\n/**\n * Call \"then\" using given node-style callback function.\n * This is basically same as \"nodeify\" except that it always return the original promise\n *\n * @method Promise#thenCall\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Promise}\n */\nPromise.prototype.thenCall = function(callback) {\n  if (_.isFunction(callback)) {\n    this.then(function(res) {\n      process.nextTick(function() {\n        callback(null, res);\n      });\n    }, function(err) {\n      process.nextTick(function() {\n        callback(err);\n      });\n    });\n  }\n  return this;\n};\n\n/**\n * A sugar method, equivalent to promise.then(undefined, onRejected).\n *\n * @method Promise#catch\n * @param {RejectedCallback.<S>} onRejected\n * @returns {Promise.<S>}\n */\n\n/**\n * Synonym of Promise#catch\n *\n * @method Promise#fail\n * @param {RejectedCallback.<S>} onRejected\n * @returns {Promise.<S>}\n */\nPromise.prototype.fail = Promise.prototype['catch'];\n\n/**\n * Returns resolving promise with given reason\n *\n * @method Promise.resolve\n * @param {*} result - Resolved value\n * @returns {Promise}\n */\n\n/**\n * Returns rejecting promise with given reason\n *\n * @method Promise.reject\n * @param {Error} reason - Rejecting reason\n * @returns {Promise}\n */\n\n/**\n * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise,\n * or is rejected with the same rejection reason as the first promise to be rejected.\n *\n * @method Promise.all\n * @param {Array.<Promise.<*>|*>} promises\n * @returns {Promise.<Array.<*>>}\n */\n\n/**\n * Returns a deferred object\n *\n * @method Promise.defer\n * @returns {Deferred}\n */\nPromise.defer = function() {\n  return new Deferred();\n};\n\n/**\n * Deferred object\n *\n * @protected\n * @constructor\n */\nvar Deferred = function() {\n  var self = this;\n  this.promise = new Promise(function(resolve, reject) {\n    self.resolve = resolve;\n    self.reject = reject;\n  });\n};\n\n/**\n * Resolve promise\n * @method Deferred#resolve\n * @param {*} result - Resolving result\n */\n\n/**\n * Reject promise\n * @method Deferred#reject\n * @param {Error} error - Rejecting reason\n */\n\n/**\n *\n */\nmodule.exports = Promise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcHJvbWlzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFYTs7QUFFYixRQUFRLG1CQUFPLENBQUMsd0RBQWE7O0FBRTdCO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHNGQUE0Qjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QyxXQUFXLHVCQUF1QjtBQUNsQyxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcHJvbWlzZS5qcz83ODQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIHByb2Nlc3MqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgUmVzb2x2ZWRDYWxsYmFja1xuICogQHBhcmFtIHtUfSByZXN1bHQgLSBSZXNvbHZlZCB2YWx1ZVxuICogQHJldHVybnMge1N9XG4gKiBAdGVtcGxhdGUgVCxTXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgUmVqZWN0ZWRDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gcmVhc29uIC0gUmVqZWN0ZWQgcmVhc29uXG4gKiBAcmV0dXJucyB7U31cbiAqIEB0ZW1wbGF0ZSBTXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgUmVzb2x2ZUNhbGxiYWNrXG4gKiBAcGFyYW0ge1R9IHJlc3VsdFxuICogQHRlbXBsYXRlIFRcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBSZWplY3RlZENhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSByZWFzb24gLSBSZWplY3RlZCByZWFzb25cbiAqIEByZXR1cm5zIHtTfVxuICogQHRlbXBsYXRlIFNcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBQcm9taXNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7UmVzb2x2ZUNhbGxiYWNrLjxUPn0gcmVzb2x2ZVxuICogQHBhcmFtIHtSZWplY3RDYWxsYmFja30gcmVqZWN0XG4gKiBAdGVtcGxhdGUgVFxuICovXG5cbi8qKlxuICogUHJvbWlzZSBjbGFzcyB3aXRoIGEgbGl0dGxlIGV4dGVuc2lvblxuICpcbiAqIEBjbGFzcyBQcm9taXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UHJvbWlzZUNhbGxiYWNrLjxUPn1cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbnZhciBQcm9taXNlID0gcmVxdWlyZSgncHJvbWlzZS9saWIvZXM2LWV4dGVuc2lvbnMnKTtcblxuLyoqXG4gKiBUaGUgXCJ0aGVuXCIgbWV0aG9kIGZyb20gdGhlIFByb21pc2VzL0ErIHNwZWNpZmljYXRpb25cbiAqXG4gKiBAbWV0aG9kIFByb21pc2UjdGhlblxuICogQHBhcmFtIHtGdWxmaWxsZWRDYWxsYmFjay48VCwgUzE+fSBbb25GdWxmaWxsZWRdXG4gKiBAcGFyYW0ge1JlamVjdGVkQ2FsbGJhY2suPFMyPn0gW29uUmVqZWN0ZWRdXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UzF8UzI+fVxuICovXG5cbi8qKlxuICogQ2FsbCBcInRoZW5cIiB1c2luZyBnaXZlbiBub2RlLXN0eWxlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogVGhpcyBpcyBiYXNpY2FsbHkgc2FtZSBhcyBcIm5vZGVpZnlcIiBleGNlcHQgdGhhdCBpdCBhbHdheXMgcmV0dXJuIHRoZSBvcmlnaW5hbCBwcm9taXNlXG4gKlxuICogQG1ldGhvZCBQcm9taXNlI3RoZW5DYWxsXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxUPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUudGhlbkNhbGwgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICBpZiAoXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgIHRoaXMudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQSBzdWdhciBtZXRob2QsIGVxdWl2YWxlbnQgdG8gcHJvbWlzZS50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCkuXG4gKlxuICogQG1ldGhvZCBQcm9taXNlI2NhdGNoXG4gKiBAcGFyYW0ge1JlamVjdGVkQ2FsbGJhY2suPFM+fSBvblJlamVjdGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48Uz59XG4gKi9cblxuLyoqXG4gKiBTeW5vbnltIG9mIFByb21pc2UjY2F0Y2hcbiAqXG4gKiBAbWV0aG9kIFByb21pc2UjZmFpbFxuICogQHBhcmFtIHtSZWplY3RlZENhbGxiYWNrLjxTPn0gb25SZWplY3RlZFxuICogQHJldHVybnMge1Byb21pc2UuPFM+fVxuICovXG5Qcm9taXNlLnByb3RvdHlwZS5mYWlsID0gUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ107XG5cbi8qKlxuICogUmV0dXJucyByZXNvbHZpbmcgcHJvbWlzZSB3aXRoIGdpdmVuIHJlYXNvblxuICpcbiAqIEBtZXRob2QgUHJvbWlzZS5yZXNvbHZlXG4gKiBAcGFyYW0geyp9IHJlc3VsdCAtIFJlc29sdmVkIHZhbHVlXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgcmVqZWN0aW5nIHByb21pc2Ugd2l0aCBnaXZlbiByZWFzb25cbiAqXG4gKiBAbWV0aG9kIFByb21pc2UucmVqZWN0XG4gKiBAcGFyYW0ge0Vycm9yfSByZWFzb24gLSBSZWplY3RpbmcgcmVhc29uXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggYW4gYXJyYXkgY29udGFpbmluZyB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgb2YgZWFjaCBwcm9taXNlLFxuICogb3IgaXMgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZSByZWplY3Rpb24gcmVhc29uIGFzIHRoZSBmaXJzdCBwcm9taXNlIHRvIGJlIHJlamVjdGVkLlxuICpcbiAqIEBtZXRob2QgUHJvbWlzZS5hbGxcbiAqIEBwYXJhbSB7QXJyYXkuPFByb21pc2UuPCo+fCo+fSBwcm9taXNlc1xuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjwqPj59XG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVmZXJyZWQgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBQcm9taXNlLmRlZmVyXG4gKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gKi9cblByb21pc2UuZGVmZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBEZWZlcnJlZCgpO1xufTtcblxuLyoqXG4gKiBEZWZlcnJlZCBvYmplY3RcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERlZmVycmVkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgc2VsZi5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICBzZWxmLnJlamVjdCA9IHJlamVjdDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlc29sdmUgcHJvbWlzZVxuICogQG1ldGhvZCBEZWZlcnJlZCNyZXNvbHZlXG4gKiBAcGFyYW0geyp9IHJlc3VsdCAtIFJlc29sdmluZyByZXN1bHRcbiAqL1xuXG4vKipcbiAqIFJlamVjdCBwcm9taXNlXG4gKiBAbWV0aG9kIERlZmVycmVkI3JlamVjdFxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgLSBSZWplY3RpbmcgcmVhc29uXG4gKi9cblxuLyoqXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/promise.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/query.js":
/*!*******************************************!*\
  !*** ./node_modules/jsforce/lib/query.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global process*/\n/**\n * @file Manages query for records in Salesforce\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\"),\n    events = __webpack_require__(/*! events */ \"events\"),\n    stream = __webpack_require__(/*! readable-stream */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/readable.js\"),\n    _      = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    Promise = __webpack_require__(/*! ./promise */ \"(action-browser)/./node_modules/jsforce/lib/promise.js\"),\n    SfDate = __webpack_require__(/*! ./date */ \"(action-browser)/./node_modules/jsforce/lib/date.js\"),\n    SOQLBuilder = __webpack_require__(/*! ./soql-builder */ \"(action-browser)/./node_modules/jsforce/lib/soql-builder.js\"),\n    RecordStream = __webpack_require__(/*! ./record-stream */ \"(action-browser)/./node_modules/jsforce/lib/record-stream.js\");\n\n/**\n * Query\n *\n * @protected\n * @class\n * @extends {stream.Readable}\n * @implements Promise.<T>\n * @template T\n * @param {Connection} conn - Connection object\n * @param {Object|String} config - Query config object or SOQL string\n * @param {Object} [options] - Default query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n */\nvar Query = module.exports = function(conn, config, options) {\n  Query.super_.call(this, { objectMode: true });\n\n  this._conn = conn;\n  if (_.isString(config)) { // if query config is string, it is given in SOQL.\n    this._soql = config;\n  } else if (config.locator && config.locator.indexOf(\"/\") >= 0) { // if locator given in url for next records\n    this._locator = config.locator.split(\"/\").pop();\n  } else {\n    this._config = config;\n    this.select(config.fields);\n    if (config.includes) {\n      this.include(config.includes);\n    }\n    if (config.sort) {\n      this.sort(config.sort);\n    }\n  }\n  this._options = _.defaults(options || {}, {\n    maxFetch: 10000,\n    autoFetch: false,\n    scanAll: false,\n    responseTarget: ResponseTargets.QueryResult\n  });\n  this._executed = false;\n  this._finished = false;\n  this._chaining = false;\n\n  this._deferred = Promise.defer();\n\n  var self = this;\n};\n\ninherits(Query, stream.Readable);\n\n/**\n * Select fields to include in the returning result\n *\n * @param {Object|Array.<String>|String} fields - Fields to fetch. Format can be in JSON object (MongoDB-like), array of field names, or comma-separated field names.\n * @returns {Query.<T>}\n */\nQuery.prototype.select = function(fields) {\n  if (this._soql) {\n    throw Error(\"Cannot set select fields for the query which has already built SOQL.\");\n  }\n  fields = fields || '*';\n  if (_.isString(fields)) {\n    fields = fields.split(/\\s*,\\s*/);\n  } else if (_.isObject(fields) && !_.isArray(fields)) {\n    var _fields =  [];\n    for (var k in fields) {\n      if (fields[k]) { _fields.push(k); }\n    }\n    fields = _fields;\n  }\n  this._config.fields = fields;\n  return this;\n};\n\n/**\n * Set query conditions to filter the result records\n *\n * @param {Object|String} conditions - Conditions in JSON object (MongoDB-like), or raw SOQL WHERE clause string.\n * @returns {Query.<T>}\n */\nQuery.prototype.where = function(conditions) {\n  if (this._soql) {\n    throw Error(\"Cannot set where conditions for the query which has already built SOQL.\");\n  }\n  this._config.conditions = conditions;\n  return this;\n};\n\n/**\n * Limit the returning result\n *\n * @param {Number} limit - Maximum number of records the query will return.\n * @returns {Query.<T>}\n */\nQuery.prototype.limit = function(limit) {\n  if (this._soql) {\n    throw Error(\"Cannot set limit for the query which has already built SOQL.\");\n  }\n  this._config.limit = limit;\n  return this;\n};\n\n/**\n * Synonym of Query#offset()\n *\n * @method Query#skip\n * @param {Number} offset - Offset number where begins returning results.\n * @returns {Query.<T>}\n */\n/**\n * Skip records\n *\n * @method Query#offset\n * @param {Number} offset - Offset number where begins returning results.\n * @returns {Query.<T>}\n */\nQuery.prototype.skip =\nQuery.prototype.offset = function(offset) {\n  if (this._soql) {\n    throw Error(\"Cannot set skip/offset for the query which has already built SOQL.\");\n  }\n  this._config.offset = offset;\n  return this;\n};\n\n/**\n * Synonym of Query#sort()\n *\n * @memthod Query#orderby\n * @param {String|Object} sort - Sorting field or hash object with field name and sord direction\n * @param {String|Number} [dir] - Sorting direction (ASC|DESC|1|-1)\n * @returns {Query.<T>}\n */\n/**\n * Set query sort with direction\n *\n * @method Query#sort\n * @param {String|Object} sort - Sorting field or hash object with field name and sord direction\n * @param {String|Number} [dir] - Sorting direction (ASC|DESC|1|-1)\n * @returns {Query.<T>}\n */\nQuery.prototype.sort =\nQuery.prototype.orderby = function(sort, dir) {\n  if (this._soql) {\n    throw Error(\"Cannot set sort for the query which has already built SOQL.\");\n  }\n  if (_.isString(sort) && _.isString(dir)) {\n    sort = [ [ sort, dir ] ];\n  }\n  this._config.sort = sort;\n  return this;\n};\n\n/**\n * Include child relationship query\n *\n * @param {String} childRelName - Child relationship name to include in query result\n * @param {Object|String} [conditions] - Conditions in JSON object (MongoDB-like), or raw SOQL WHERE clause string.\n * @param {Object|Array.<String>|String} [fields] - Fields to fetch. Format can be in JSON object (MongoDB-like), array of field names, or comma-separated field names.\n * @param {Object} [options] - Optional query configulations.\n * @param {Number} [options.limit] - Maximum number of records the query will return.\n * @param {Number} [options.offset] - Offset number where begins returning results.\n * @param {Number} [options.skip] - Synonym of options.offset.\n * @returns {Query~SubQuery}\n */\nQuery.prototype.include = function(childRelName, conditions, fields, options) {\n  if (this._soql) {\n    throw Error(\"Cannot include child relationship into the query which has already built SOQL.\");\n  }\n  if (_.isObject(childRelName)) {\n    var includes = childRelName;\n    for (var crname in includes) {\n      var config = includes[crname];\n      this.include(crname, config.conditions, config.fields, config);\n    }\n    return;\n  }\n  var childConfig = {\n    table: childRelName,\n    conditions: conditions,\n    fields: fields,\n    limit: options && options.limit,\n    offset: options && (options.offset || options.skip),\n    sort: options && options.sort\n  };\n  if (!_.isArray(this._config.includes)) this._config.includes = [];\n  this._config.includes.push(childConfig);\n  var childQuery = new SubQuery(this._conn, this, childConfig);\n  this._children = this._children || [];\n  this._children.push(childQuery);\n  return childQuery;\n};\n\n\n/**\n * Setting maxFetch query option\n *\n * @param {Number} maxFetch - Max fetching records in auto fetch mode\n * @returns {Query.<T>}\n */\nQuery.prototype.maxFetch = function(maxFetch) {\n  this._options.maxFetch = maxFetch;\n  return this;\n};\n\n/**\n * Switching auto fetch mode\n *\n * @param {Boolean} autoFetch - Using auto fetch mode or not\n * @returns {Query.<T>}\n */\nQuery.prototype.autoFetch = function(autoFetch) {\n  this._options.autoFetch = autoFetch;\n  return this;\n};\n\n/**\n * Set flag to scan all records including deleted and archived.\n *\n * @param {Boolean} scanAll - Flag whether include deleted/archived record or not. Default is false.\n * @returns {Query.<T>}\n */\nQuery.prototype.scanAll = function(scanAll) {\n  this._options.scanAll = scanAll;\n  return this;\n};\n\n/**\n * @private\n */\nvar ResponseTargets = Query.ResponseTargets = {};\n[ \"QueryResult\", \"Records\", \"SingleRecord\", \"Count\" ].forEach(function(f) {\n  ResponseTargets[f] = f;\n});\n\n/**\n * @protected\n * @param {String} responseTarget - Query response target\n * @returns {Query.<S>}\n */\nQuery.prototype.setResponseTarget = function(responseTarget) {\n  if (responseTarget in ResponseTargets) {\n    this._options.responseTarget = responseTarget;\n  }\n  return this;\n};\n\n\n/**\n * Synonym of Query#execute()\n *\n * @method Query#run\n * @param {Object} [options] - Query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query.<T>}\n */\nQuery.prototype.run =\n/**\n * Synonym of Query#execute()\n *\n * @method Query#exec\n * @param {Object} [options] - Query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query.<T>}\n */\nQuery.prototype.exec =\n/**\n * Execute query and fetch records from server.\n *\n * @method Query#execute\n * @param {Object} [options] - Query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query.<T>}\n */\nQuery.prototype.execute = function(options, callback) {\n  var self = this;\n  var logger = this._conn._logger;\n  var deferred = this._deferred;\n\n  if (this._executed) {\n    deferred.reject(new Error(\"re-executing already executed query\"));\n    return this;\n  }\n\n  if (this._finished) {\n    deferred.reject(new Error(\"executing already closed query\"));\n    return this;\n  }\n\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  options = {\n    headers: options.headers || self._options.headers,\n    responseTarget: options.responseTarget || self._options.responseTarget,\n    autoFetch: options.autoFetch || self._options.autoFetch,\n    maxFetch: options.maxFetch || self._options.maxFetch,\n    scanAll: options.scanAll || self._options.scanAll\n  };\n\n  // callback and promise resolution;\n  var promiseCallback = function(err, res) {\n    if (_.isFunction(callback)) {\n      try {\n        res = callback(err, res);\n        err = null;\n      } catch(e) {\n        err = e;\n      }\n    }\n    if (err) {\n      deferred.reject(err);\n    } else {\n      deferred.resolve(res);\n    }\n  };\n  this.once('response', function(res) {\n    promiseCallback(null, res);\n  });\n  this.once('error', function(err) {\n    promiseCallback(err);\n  });\n\n  // collect fetched records in array\n  // only when response target is Records and\n  // either callback or chaining promises are available to this query.\n  this.once('fetch', function() {\n    if (options.responseTarget === ResponseTargets.Records && (self._chaining || callback)) {\n      logger.debug('--- collecting all fetched records ---');\n      var records = [];\n      var onRecord = function(record) {\n        records.push(record);\n      };\n      self.on('record', onRecord);\n      self.once('end', function() {\n        self.removeListener('record', onRecord);\n        self.emit('response', records, self);\n      });\n    }\n  });\n\n  // flag to prevent re-execution\n  this._executed = true;\n\n  // start actual query\n  logger.debug('>>> Query start >>>');\n  this._execute(options).then(function() {\n    logger.debug('*** Query finished ***');\n  }).fail(function(err) {\n    logger.debug('--- Query error ---');\n    self.emit('error', err);\n  });\n\n  // return Query instance for chaining\n  return this;\n};\n\n/**\n * @private\n */\nQuery.prototype._execute = function(options) {\n  var self = this;\n  var logger = this._conn._logger;\n  var responseTarget = options.responseTarget;\n  var autoFetch = options.autoFetch;\n  var maxFetch = options.maxFetch;\n  var scanAll = options.scanAll;\n\n  return Promise.resolve(\n    self._locator ?\n    self._conn._baseUrl() + \"/query/\" + self._locator :\n    self.toSOQL().then(function(soql) {\n      self.totalFetched = 0;\n      logger.debug(\"SOQL = \" + soql);\n      return self._conn._baseUrl() + \"/\" + (scanAll ? \"queryAll\" : \"query\") + \"?q=\" + encodeURIComponent(soql);\n    })\n  ).then(function(url) {\n    return self._conn.request({\n      method: 'GET',\n      url: url,\n      headers: options.headers\n    });\n  }).then(function(data) {\n    self.emit(\"fetch\");\n    self.totalSize = data.totalSize;\n    var res;\n    switch(responseTarget) {\n      case ResponseTargets.SingleRecord:\n        res = data.records && data.records.length > 0 ? data.records[0] : null;\n        break;\n      case ResponseTargets.Records:\n        res = data.records;\n        break;\n      case ResponseTargets.Count:\n        res = data.totalSize;\n        break;\n      default:\n        res = data;\n    }\n    // only fire response event when it should be notified per fetch\n    if (responseTarget !== ResponseTargets.Records) {\n      self.emit(\"response\", res, self);\n    }\n\n    // streaming record instances\n    var numRecords = (data.records && data.records.length) || 0;\n    for (var i=0; i<numRecords; i++) {\n      if (self.totalFetched >= maxFetch) {\n        self._finished = true;\n        break;\n      }\n      var record = data.records[i];\n      self.push(record);\n      self.emit('record', record, self.totalFetched++, self);\n    }\n    if (data.nextRecordsUrl) {\n      self._locator = data.nextRecordsUrl.split('/').pop();\n    }\n    self._finished = self._finished || data.done || !autoFetch;\n    if (self._finished) {\n      self.push(null);\n    } else {\n      self._execute(options);\n    }\n    return res;\n  });\n};\n\n/**\n * Readable stream implementation\n *\n * @override\n * @private\n */\nQuery.prototype._read = function(size) {\n  if (!this._finished && !this._executed) {\n    this.execute({ autoFetch: true });\n  }\n};\n\n/** @override **/\nQuery.prototype.on = function(e, fn) {\n  if (e === 'record') {\n    var self = this;\n    this.on('readable', function() {\n      while(self.read() !== null) {} // discard buffered records\n    });\n  }\n  return Query.super_.prototype.on.call(this, e, fn);\n};\n\n/** @override **/\nQuery.prototype.addListener = Query.prototype.on;\n\n\n/**\n * @private\n */\nQuery.prototype._expandFields = function() {\n  if (this._soql) {\n    return Promise.reject(new Error(\"Cannot expand fields for the query which has already built SOQL.\"));\n  }\n  var self = this;\n  var logger = self._conn._logger;\n  var conn = this._conn;\n  var table = this._config.table;\n  var fields = this._config.fields || [];\n\n  logger.debug('_expandFields: table = ' + table + ', fields = ' + fields.join(', '));\n\n  return Promise.all([\n    Promise.resolve(self._parent ? findRelationTable(table) : table)\n      .then(function(table) {\n        return Promise.all(\n          _.map(fields, function(field) { return expandAsteriskField(table, field); })\n        ).then(function(expandedFields) {\n          self._config.fields = _.flatten(expandedFields);\n        });\n      }),\n    Promise.all(\n      _.map(self._children || [], function(childQuery) {\n        return childQuery._expandFields();\n      })\n    )\n  ]);\n\n  function findRelationTable(rname) {\n    var ptable = self._parent._config.table;\n    logger.debug('finding table for relation \"' + rname + '\" in \"' + ptable + '\"...');\n    return describeCache(ptable).then(function(sobject) {\n      var upperRname = rname.toUpperCase();\n      var childRelation = _.find(sobject.childRelationships, function(cr) {\n        return (cr.relationshipName || '').toUpperCase() === upperRname;\n      });\n      return childRelation ? childRelation.childSObject :\n        Promise.reject(new Error(\"No child relationship found: \" + rname ));\n    });\n  }\n\n  function describeCache(table) {\n    logger.debug('describe cache: '+table);\n    var deferred = Promise.defer();\n    conn.describe$(table, function(err, sobject) {\n      logger.debug('... done.');\n      if (err) { deferred.reject(err); }\n      else { deferred.resolve(sobject); }\n    });\n    return deferred.promise;\n  }\n\n  function expandAsteriskField(table, field) {\n    logger.debug('expanding field \"'+ field + '\" in \"' + table + '\"...');\n    var fpath = field.split('.');\n    return fpath[fpath.length - 1] === '*' ?\n      describeCache(table).then(function(sobject) {\n        logger.debug('table '+table+'has been described');\n        if (fpath.length > 1) {\n          var rname = fpath.shift();\n          var rfield = _.find(sobject.fields, function(f) {\n            return f.relationshipName &&\n                   f.relationshipName.toUpperCase() === rname.toUpperCase();\n          });\n          if (rfield) {\n            var rtable = rfield.referenceTo.length === 1 ? rfield.referenceTo[0] : 'Name';\n            return expandAsteriskField(rtable, fpath.join('.')).then(function(fpaths) {\n              return _.map(fpaths, function(fpath) { return rname + '.' + fpath; });\n            });\n          } else {\n            return [];\n          }\n        } else {\n          return _.map(sobject.fields, function(f) { return f.name; });\n        }\n      }) :\n      Promise.resolve([ field ]);\n  }\n};\n\n/**\n * Explain plan for executing query\n *\n * @param {Callback.<ExplainInfo>} [callback] - Callback function\n * @returns {Promise.<ExplainInfo>}\n */\nQuery.prototype.explain = function(callback) {\n  var self = this;\n  var logger = this._conn._logger;\n  return self.toSOQL().then(function(soql) {\n    logger.debug(\"SOQL = \" + soql);\n    var url = \"/query/?explain=\" + encodeURIComponent(soql);\n    return self._conn.request(url);\n  }).thenCall(callback);\n};\n\n/**\n * Return SOQL expression for the query\n *\n * @param {Callback.<String>} [callback] - Callback function\n * @returns {Promise.<String>}\n */\nQuery.prototype.toSOQL = function(callback) {\n  var self = this;\n  return Promise.resolve(self._soql ||\n    self._expandFields().then(function() { return SOQLBuilder.createSOQL(self._config); })\n  ).thenCall(callback);\n};\n\n/**\n * Create data stream of queried records.\n * Automatically resume query if paused.\n *\n * @param {String} [type] - Type of outgoing data format. Currently 'csv' is default value and the only supported.\n * @param {Object} [options] - Options passed to converter\n * @returns {stream.Readable}\n */\nQuery.prototype.stream = RecordStream.Serializable.prototype.stream;\n\n/**\n * Get record stream of queried records applying the given mapping function\n *\n * @param {RecordMapFunction} fn - Record mapping function\n * @returns {RecordStream.Serializable}\n */\nQuery.prototype.map = RecordStream.prototype.map;\n\n/**\n * Get record stream of queried records, applying the given filter function\n *\n * @param {RecordFilterFunction} fn - Record filtering function\n * @returns {RecordStream.Serializable}\n */\nQuery.prototype.filter = RecordStream.prototype.map;\n\n/*\n * Default threshold num of bulk API switching\n */\nvar DEFAULT_BULK_THRESHOLD = 200;\n\n/**\n * Synonym of Query#destroy()\n *\n * @method Query#delete\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\n/**\n * Synonym of Query#destroy()\n *\n * @method Query#del\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\n/**\n * Delete queried records\n *\n * @method Query#destroy\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Object} [options] - Mass delete operation options\n * @param {Boolean} [options.allowBulk] - Allow switching to Bulk API when the num of queried records reached to certain threshold. Default is true.\n * @param {Number} [options.bulkThreshold] - Threshold num to switch to use Bulk API instead of usual `SObject#delete()` call. Default value is 200 after API ver 42.0, and 0.5 * `maxRequest` before API ver 42.0.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\nQuery.prototype[\"delete\"] =\nQuery.prototype.del =\nQuery.prototype.destroy = function(type, options, callback) {\n  if (typeof type === 'function') {\n    callback = type;\n    options = {};\n    type = null;\n  } else if (typeof type === 'object' && type !== null) {\n    callback = options;\n    options = type;\n    type = null;\n  }\n  options = options || {};\n  type = type || (this._config && this._config.table);\n  if (!type) {\n    throw new Error(\"SOQL based query needs SObject type information to bulk delete.\");\n  }\n  // Set the threshold number to pass to bulk API\n  var thresholdNum =\n    options.allowBulk === false ?\n      -1 :\n    typeof options.bulkThreshold === 'number' ?\n      options.bulkThreshold :\n      // determine threshold if the connection version supports SObject collection API or not\n      (this._conn._ensureVersion(42) ? DEFAULT_BULK_THRESHOLD : this._conn.maxRequest / 2);\n  var self = this;\n  return new Promise(function(resolve, reject) {\n    var records = [];\n    var batch = null;\n    var handleRecord = function(rec) {\n      if (!rec.Id) {\n        self.emit('error', new Error('Queried record does not include Salesforce record ID.'))\n        return;\n      }\n      var record = { Id: rec.Id };\n      if (batch) {\n        batch.write(record);\n      } else {\n        records.push(record);\n        if (thresholdNum < 0 || records.length > thresholdNum) {\n          // Use bulk delete instead of SObject REST API\n          batch =\n            self._conn.sobject(type).deleteBulk()\n              .on('response', resolve)\n              .on('error', reject);\n          records.forEach(function(record) {\n            batch.write(record);\n          });\n          records = [];\n        }\n      }\n    };\n    var handleEnd = function() {\n      if (batch) {\n        batch.end();\n      } else {\n        var ids = records.map(function (record) { return record.Id; });\n        self._conn.sobject(type).destroy(ids, { allowRecursive: true }).then(resolve, reject);\n      }\n    };\n    self.on('data', handleRecord)\n      .on('end', handleEnd)\n      .on('error', reject);\n  }).thenCall(callback);\n};\n\n/**\n * Update queried records, using given mapping function/object\n *\n * @param {Record|RecordMapFunction} mapping - Mapping record or record mapping function\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Object} [options] - Mass update operation options\n * @param {Boolean} [options.allowBulk] - Allow switching to Bulk API when the num of queried records reached to certain threshold. Default is true.\n * @param {Number} [options.bulkThreshold] - Threshold num to switch to use Bulk API instead of usual `SObject#delete()` call. Default value is 200 after API ver 42.0, and 0.5 * `maxRequest` before API ver 42.0.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\nQuery.prototype.update = function(mapping, type, options, callback) {\n  if (typeof type === 'function') {\n    callback = type;\n    options = {};\n    type = null;\n  } else if (typeof type === 'object' && type !== null) {\n    callback = options;\n    options = type;\n    type = null;\n  }\n  options = options || {};\n  type = type || (this._config && this._config.table);\n  if (!type) {\n    throw new Error(\"SOQL based query needs SObject type information to bulk update.\");\n  }\n  var updateStream = _.isFunction(mapping) ? RecordStream.map(mapping) : RecordStream.recordMapStream(mapping);\n  // Set the threshold number to pass to bulk API\n  var thresholdNum =\n    options.allowBulk === false ?\n      -1 :\n    typeof options.bulkThreshold === 'number' ?\n      options.bulkThreshold :\n      // determine threshold if the connection version supports SObject collection API or not\n      (this._conn._ensureVersion(42) ? DEFAULT_BULK_THRESHOLD : this._conn.maxRequest / 2);\n  var self = this;\n  return new Promise(function(resolve, reject) {\n    var records = [];\n    var batch = null;\n    var handleRecord = function(record) {\n      if (batch) {\n        batch.write(record);\n      } else {\n        records.push(record);\n        if (thresholdNum < 0 || records.length > thresholdNum) {\n          // Use bulk update instead of SObject REST API\n          batch =\n            self._conn.sobject(type).updateBulk()\n              .on('response', resolve)\n              .on('error', reject);\n          records.forEach(function(record) {\n            batch.write(record);\n          });\n          records = [];\n        }\n      }\n    };\n    var handleEnd = function() {\n      if (batch) {\n        batch.end();\n      } else {\n        self._conn.sobject(type).update(records, { allowRecursive: true }).then(resolve, reject);\n      }\n    };\n    self.on('error', reject)\n      .pipe(updateStream)\n      .on('data', handleRecord)\n      .on('end', handleEnd)\n      .on('error', reject);\n  }).thenCall(callback);\n};\n\n/**\n * Promise/A+ interface\n * http://promises-aplus.github.io/promises-spec/\n *\n * Delegate to deferred promise, return promise instance for query result\n *\n * @param {FulfilledCallback.<T, S1>} [onFulfilled]\n * @param {RejectedCallback.<S2>} [onRejected]\n * @returns {Promise.<S1|S2>}\n */\nQuery.prototype.then = function(onResolved, onReject) {\n  this._chaining = true;\n  if (!this._finished && !this._executed) { this.execute(); }\n  return this._deferred.promise.then.apply(this._deferred.promise, arguments);\n};\n\n/**\n * Promise/A+ extension\n * Call \"then\" using given node-style callback function\n *\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query}\n */\nQuery.prototype.thenCall = function(callback) {\n  if (_.isFunction(callback)) {\n    this.then(function(res) {\n      process.nextTick(function() {\n        callback(null, res);\n      });\n    }, function(err) {\n      process.nextTick(function() {\n        callback(err);\n      });\n    });\n  }\n  return this;\n};\n\n/*--------------------------------------------*/\n\n/**\n * SubQuery object for representing child relationship query\n *\n * @protected\n * @class Query~SubQuery\n * @extends Query\n * @param {Connection} conn - Connection object\n * @param {Query} parent - Parent query object\n * @param {Object} config - Sub query configuration\n */\nvar SubQuery = function(conn, parent, config) {\n  SubQuery.super_.call(this, conn, config);\n  this._parent = parent;\n};\n\ninherits(SubQuery, Query);\n\n/**\n * @method Query~SubQuery#include\n * @override\n */\nSubQuery.prototype.include = function() {\n  throw new Error(\"Not allowed to include another subquery in subquery.\");\n};\n\n/**\n * Back the context to parent query object\n *\n * @method Query~SubQuery#end\n * @returns {Query}\n */\nSubQuery.prototype.end = function() {\n  return this._parent;\n};\n\n/**\n * If execute is called in subquery context, delegate it to parent query object\n *\n * @method Query~SubQuery#execute\n * @override\n */\nSubQuery.prototype.run =\nSubQuery.prototype.exec =\nSubQuery.prototype.execute = function() {\n  return this._parent.execute.apply(this._parent, arguments);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxzRUFBVTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLHlHQUFpQjtBQUN0QyxhQUFhLG1CQUFPLENBQUMsbUVBQWE7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLHlFQUFXO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxtRUFBUTtBQUM3QixrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBZ0I7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMscUZBQWlCOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7O0FBRTlDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsSUFBSSwrREFBK0Q7QUFDbkU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxjQUFjO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsY0FBYztBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGNBQWM7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJDQUEyQztBQUNyRjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EscURBQXFELDZCQUE2QjtBQUNsRixhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1YscURBQXFELGdCQUFnQjtBQUNyRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDhDQUE4QztBQUN6RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtEQUFrRCxtQkFBbUI7QUFDckUsZ0RBQWdELHNCQUFzQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixtREFBbUQsc0JBQXNCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDLFdBQVcsdUJBQXVCO0FBQ2xDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9xdWVyeS5qcz84NGIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIHByb2Nlc3MqL1xuLyoqXG4gKiBAZmlsZSBNYW5hZ2VzIHF1ZXJ5IGZvciByZWNvcmRzIGluIFNhbGVzZm9yY2VcbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKSxcbiAgICBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKSxcbiAgICBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKSxcbiAgICBfICAgICAgPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL3Byb21pc2UnKSxcbiAgICBTZkRhdGUgPSByZXF1aXJlKFwiLi9kYXRlXCIpLFxuICAgIFNPUUxCdWlsZGVyID0gcmVxdWlyZShcIi4vc29xbC1idWlsZGVyXCIpLFxuICAgIFJlY29yZFN0cmVhbSA9IHJlcXVpcmUoXCIuL3JlY29yZC1zdHJlYW1cIik7XG5cbi8qKlxuICogUXVlcnlcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIHtzdHJlYW0uUmVhZGFibGV9XG4gKiBAaW1wbGVtZW50cyBQcm9taXNlLjxUPlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiAtIENvbm5lY3Rpb24gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGNvbmZpZyAtIFF1ZXJ5IGNvbmZpZyBvYmplY3Qgb3IgU09RTCBzdHJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBEZWZhdWx0IHF1ZXJ5IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b0ZldGNoXSAtIFVzaW5nIGF1dG8gZmV0Y2ggbW9kZSBvciBub3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhGZXRjaF0gLSBNYXggZmV0Y2hpbmcgcmVjb3JkcyBpbiBhdXRvIGZldGNoIG1vZGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2NhbkFsbF0gLSBJbmNsdWRpbmcgZGVsZXRlZCByZWNvcmRzIGZvciBxdWVyeSB0YXJnZXQgb3Igbm90XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gLSBBZGRpdGlvbmFsIEhUVFAgcmVxdWVzdCBoZWFkZXJzIHNlbnQgaW4gcXVlcnkgcmVxdWVzdFxuICovXG52YXIgUXVlcnkgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbm4sIGNvbmZpZywgb3B0aW9ucykge1xuICBRdWVyeS5zdXBlcl8uY2FsbCh0aGlzLCB7IG9iamVjdE1vZGU6IHRydWUgfSk7XG5cbiAgdGhpcy5fY29ubiA9IGNvbm47XG4gIGlmIChfLmlzU3RyaW5nKGNvbmZpZykpIHsgLy8gaWYgcXVlcnkgY29uZmlnIGlzIHN0cmluZywgaXQgaXMgZ2l2ZW4gaW4gU09RTC5cbiAgICB0aGlzLl9zb3FsID0gY29uZmlnO1xuICB9IGVsc2UgaWYgKGNvbmZpZy5sb2NhdG9yICYmIGNvbmZpZy5sb2NhdG9yLmluZGV4T2YoXCIvXCIpID49IDApIHsgLy8gaWYgbG9jYXRvciBnaXZlbiBpbiB1cmwgZm9yIG5leHQgcmVjb3Jkc1xuICAgIHRoaXMuX2xvY2F0b3IgPSBjb25maWcubG9jYXRvci5zcGxpdChcIi9cIikucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuc2VsZWN0KGNvbmZpZy5maWVsZHMpO1xuICAgIGlmIChjb25maWcuaW5jbHVkZXMpIHtcbiAgICAgIHRoaXMuaW5jbHVkZShjb25maWcuaW5jbHVkZXMpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnNvcnQpIHtcbiAgICAgIHRoaXMuc29ydChjb25maWcuc29ydCk7XG4gICAgfVxuICB9XG4gIHRoaXMuX29wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMgfHwge30sIHtcbiAgICBtYXhGZXRjaDogMTAwMDAsXG4gICAgYXV0b0ZldGNoOiBmYWxzZSxcbiAgICBzY2FuQWxsOiBmYWxzZSxcbiAgICByZXNwb25zZVRhcmdldDogUmVzcG9uc2VUYXJnZXRzLlF1ZXJ5UmVzdWx0XG4gIH0pO1xuICB0aGlzLl9leGVjdXRlZCA9IGZhbHNlO1xuICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICB0aGlzLl9jaGFpbmluZyA9IGZhbHNlO1xuXG4gIHRoaXMuX2RlZmVycmVkID0gUHJvbWlzZS5kZWZlcigpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbn07XG5cbmluaGVyaXRzKFF1ZXJ5LCBzdHJlYW0uUmVhZGFibGUpO1xuXG4vKipcbiAqIFNlbGVjdCBmaWVsZHMgdG8gaW5jbHVkZSBpbiB0aGUgcmV0dXJuaW5nIHJlc3VsdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5LjxTdHJpbmc+fFN0cmluZ30gZmllbGRzIC0gRmllbGRzIHRvIGZldGNoLiBGb3JtYXQgY2FuIGJlIGluIEpTT04gb2JqZWN0IChNb25nb0RCLWxpa2UpLCBhcnJheSBvZiBmaWVsZCBuYW1lcywgb3IgY29tbWEtc2VwYXJhdGVkIGZpZWxkIG5hbWVzLlxuICogQHJldHVybnMge1F1ZXJ5LjxUPn1cbiAqL1xuUXVlcnkucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKGZpZWxkcykge1xuICBpZiAodGhpcy5fc29xbCkge1xuICAgIHRocm93IEVycm9yKFwiQ2Fubm90IHNldCBzZWxlY3QgZmllbGRzIGZvciB0aGUgcXVlcnkgd2hpY2ggaGFzIGFscmVhZHkgYnVpbHQgU09RTC5cIik7XG4gIH1cbiAgZmllbGRzID0gZmllbGRzIHx8ICcqJztcbiAgaWYgKF8uaXNTdHJpbmcoZmllbGRzKSkge1xuICAgIGZpZWxkcyA9IGZpZWxkcy5zcGxpdCgvXFxzKixcXHMqLyk7XG4gIH0gZWxzZSBpZiAoXy5pc09iamVjdChmaWVsZHMpICYmICFfLmlzQXJyYXkoZmllbGRzKSkge1xuICAgIHZhciBfZmllbGRzID0gIFtdO1xuICAgIGZvciAodmFyIGsgaW4gZmllbGRzKSB7XG4gICAgICBpZiAoZmllbGRzW2tdKSB7IF9maWVsZHMucHVzaChrKTsgfVxuICAgIH1cbiAgICBmaWVsZHMgPSBfZmllbGRzO1xuICB9XG4gIHRoaXMuX2NvbmZpZy5maWVsZHMgPSBmaWVsZHM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgcXVlcnkgY29uZGl0aW9ucyB0byBmaWx0ZXIgdGhlIHJlc3VsdCByZWNvcmRzXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBjb25kaXRpb25zIC0gQ29uZGl0aW9ucyBpbiBKU09OIG9iamVjdCAoTW9uZ29EQi1saWtlKSwgb3IgcmF3IFNPUUwgV0hFUkUgY2xhdXNlIHN0cmluZy5cbiAqIEByZXR1cm5zIHtRdWVyeS48VD59XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS53aGVyZSA9IGZ1bmN0aW9uKGNvbmRpdGlvbnMpIHtcbiAgaWYgKHRoaXMuX3NvcWwpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCBzZXQgd2hlcmUgY29uZGl0aW9ucyBmb3IgdGhlIHF1ZXJ5IHdoaWNoIGhhcyBhbHJlYWR5IGJ1aWx0IFNPUUwuXCIpO1xuICB9XG4gIHRoaXMuX2NvbmZpZy5jb25kaXRpb25zID0gY29uZGl0aW9ucztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExpbWl0IHRoZSByZXR1cm5pbmcgcmVzdWx0XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxpbWl0IC0gTWF4aW11bSBudW1iZXIgb2YgcmVjb3JkcyB0aGUgcXVlcnkgd2lsbCByZXR1cm4uXG4gKiBAcmV0dXJucyB7UXVlcnkuPFQ+fVxuICovXG5RdWVyeS5wcm90b3R5cGUubGltaXQgPSBmdW5jdGlvbihsaW1pdCkge1xuICBpZiAodGhpcy5fc29xbCkge1xuICAgIHRocm93IEVycm9yKFwiQ2Fubm90IHNldCBsaW1pdCBmb3IgdGhlIHF1ZXJ5IHdoaWNoIGhhcyBhbHJlYWR5IGJ1aWx0IFNPUUwuXCIpO1xuICB9XG4gIHRoaXMuX2NvbmZpZy5saW1pdCA9IGxpbWl0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3lub255bSBvZiBRdWVyeSNvZmZzZXQoKVxuICpcbiAqIEBtZXRob2QgUXVlcnkjc2tpcFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIE9mZnNldCBudW1iZXIgd2hlcmUgYmVnaW5zIHJldHVybmluZyByZXN1bHRzLlxuICogQHJldHVybnMge1F1ZXJ5LjxUPn1cbiAqL1xuLyoqXG4gKiBTa2lwIHJlY29yZHNcbiAqXG4gKiBAbWV0aG9kIFF1ZXJ5I29mZnNldFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIE9mZnNldCBudW1iZXIgd2hlcmUgYmVnaW5zIHJldHVybmluZyByZXN1bHRzLlxuICogQHJldHVybnMge1F1ZXJ5LjxUPn1cbiAqL1xuUXVlcnkucHJvdG90eXBlLnNraXAgPVxuUXVlcnkucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICBpZiAodGhpcy5fc29xbCkge1xuICAgIHRocm93IEVycm9yKFwiQ2Fubm90IHNldCBza2lwL29mZnNldCBmb3IgdGhlIHF1ZXJ5IHdoaWNoIGhhcyBhbHJlYWR5IGJ1aWx0IFNPUUwuXCIpO1xuICB9XG4gIHRoaXMuX2NvbmZpZy5vZmZzZXQgPSBvZmZzZXQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTeW5vbnltIG9mIFF1ZXJ5I3NvcnQoKVxuICpcbiAqIEBtZW10aG9kIFF1ZXJ5I29yZGVyYnlcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gc29ydCAtIFNvcnRpbmcgZmllbGQgb3IgaGFzaCBvYmplY3Qgd2l0aCBmaWVsZCBuYW1lIGFuZCBzb3JkIGRpcmVjdGlvblxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbZGlyXSAtIFNvcnRpbmcgZGlyZWN0aW9uIChBU0N8REVTQ3wxfC0xKVxuICogQHJldHVybnMge1F1ZXJ5LjxUPn1cbiAqL1xuLyoqXG4gKiBTZXQgcXVlcnkgc29ydCB3aXRoIGRpcmVjdGlvblxuICpcbiAqIEBtZXRob2QgUXVlcnkjc29ydFxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBzb3J0IC0gU29ydGluZyBmaWVsZCBvciBoYXNoIG9iamVjdCB3aXRoIGZpZWxkIG5hbWUgYW5kIHNvcmQgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFtkaXJdIC0gU29ydGluZyBkaXJlY3Rpb24gKEFTQ3xERVNDfDF8LTEpXG4gKiBAcmV0dXJucyB7UXVlcnkuPFQ+fVxuICovXG5RdWVyeS5wcm90b3R5cGUuc29ydCA9XG5RdWVyeS5wcm90b3R5cGUub3JkZXJieSA9IGZ1bmN0aW9uKHNvcnQsIGRpcikge1xuICBpZiAodGhpcy5fc29xbCkge1xuICAgIHRocm93IEVycm9yKFwiQ2Fubm90IHNldCBzb3J0IGZvciB0aGUgcXVlcnkgd2hpY2ggaGFzIGFscmVhZHkgYnVpbHQgU09RTC5cIik7XG4gIH1cbiAgaWYgKF8uaXNTdHJpbmcoc29ydCkgJiYgXy5pc1N0cmluZyhkaXIpKSB7XG4gICAgc29ydCA9IFsgWyBzb3J0LCBkaXIgXSBdO1xuICB9XG4gIHRoaXMuX2NvbmZpZy5zb3J0ID0gc29ydDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEluY2x1ZGUgY2hpbGQgcmVsYXRpb25zaGlwIHF1ZXJ5XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNoaWxkUmVsTmFtZSAtIENoaWxkIHJlbGF0aW9uc2hpcCBuYW1lIHRvIGluY2x1ZGUgaW4gcXVlcnkgcmVzdWx0XG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtjb25kaXRpb25zXSAtIENvbmRpdGlvbnMgaW4gSlNPTiBvYmplY3QgKE1vbmdvREItbGlrZSksIG9yIHJhdyBTT1FMIFdIRVJFIGNsYXVzZSBzdHJpbmcuXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheS48U3RyaW5nPnxTdHJpbmd9IFtmaWVsZHNdIC0gRmllbGRzIHRvIGZldGNoLiBGb3JtYXQgY2FuIGJlIGluIEpTT04gb2JqZWN0IChNb25nb0RCLWxpa2UpLCBhcnJheSBvZiBmaWVsZCBuYW1lcywgb3IgY29tbWEtc2VwYXJhdGVkIGZpZWxkIG5hbWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHF1ZXJ5IGNvbmZpZ3VsYXRpb25zLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxpbWl0XSAtIE1heGltdW0gbnVtYmVyIG9mIHJlY29yZHMgdGhlIHF1ZXJ5IHdpbGwgcmV0dXJuLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldF0gLSBPZmZzZXQgbnVtYmVyIHdoZXJlIGJlZ2lucyByZXR1cm5pbmcgcmVzdWx0cy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5za2lwXSAtIFN5bm9ueW0gb2Ygb3B0aW9ucy5vZmZzZXQuXG4gKiBAcmV0dXJucyB7UXVlcnl+U3ViUXVlcnl9XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5pbmNsdWRlID0gZnVuY3Rpb24oY2hpbGRSZWxOYW1lLCBjb25kaXRpb25zLCBmaWVsZHMsIG9wdGlvbnMpIHtcbiAgaWYgKHRoaXMuX3NvcWwpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCBpbmNsdWRlIGNoaWxkIHJlbGF0aW9uc2hpcCBpbnRvIHRoZSBxdWVyeSB3aGljaCBoYXMgYWxyZWFkeSBidWlsdCBTT1FMLlwiKTtcbiAgfVxuICBpZiAoXy5pc09iamVjdChjaGlsZFJlbE5hbWUpKSB7XG4gICAgdmFyIGluY2x1ZGVzID0gY2hpbGRSZWxOYW1lO1xuICAgIGZvciAodmFyIGNybmFtZSBpbiBpbmNsdWRlcykge1xuICAgICAgdmFyIGNvbmZpZyA9IGluY2x1ZGVzW2NybmFtZV07XG4gICAgICB0aGlzLmluY2x1ZGUoY3JuYW1lLCBjb25maWcuY29uZGl0aW9ucywgY29uZmlnLmZpZWxkcywgY29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjaGlsZENvbmZpZyA9IHtcbiAgICB0YWJsZTogY2hpbGRSZWxOYW1lLFxuICAgIGNvbmRpdGlvbnM6IGNvbmRpdGlvbnMsXG4gICAgZmllbGRzOiBmaWVsZHMsXG4gICAgbGltaXQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5saW1pdCxcbiAgICBvZmZzZXQ6IG9wdGlvbnMgJiYgKG9wdGlvbnMub2Zmc2V0IHx8IG9wdGlvbnMuc2tpcCksXG4gICAgc29ydDogb3B0aW9ucyAmJiBvcHRpb25zLnNvcnRcbiAgfTtcbiAgaWYgKCFfLmlzQXJyYXkodGhpcy5fY29uZmlnLmluY2x1ZGVzKSkgdGhpcy5fY29uZmlnLmluY2x1ZGVzID0gW107XG4gIHRoaXMuX2NvbmZpZy5pbmNsdWRlcy5wdXNoKGNoaWxkQ29uZmlnKTtcbiAgdmFyIGNoaWxkUXVlcnkgPSBuZXcgU3ViUXVlcnkodGhpcy5fY29ubiwgdGhpcywgY2hpbGRDb25maWcpO1xuICB0aGlzLl9jaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuIHx8IFtdO1xuICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkUXVlcnkpO1xuICByZXR1cm4gY2hpbGRRdWVyeTtcbn07XG5cblxuLyoqXG4gKiBTZXR0aW5nIG1heEZldGNoIHF1ZXJ5IG9wdGlvblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhGZXRjaCAtIE1heCBmZXRjaGluZyByZWNvcmRzIGluIGF1dG8gZmV0Y2ggbW9kZVxuICogQHJldHVybnMge1F1ZXJ5LjxUPn1cbiAqL1xuUXVlcnkucHJvdG90eXBlLm1heEZldGNoID0gZnVuY3Rpb24obWF4RmV0Y2gpIHtcbiAgdGhpcy5fb3B0aW9ucy5tYXhGZXRjaCA9IG1heEZldGNoO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3dpdGNoaW5nIGF1dG8gZmV0Y2ggbW9kZVxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYXV0b0ZldGNoIC0gVXNpbmcgYXV0byBmZXRjaCBtb2RlIG9yIG5vdFxuICogQHJldHVybnMge1F1ZXJ5LjxUPn1cbiAqL1xuUXVlcnkucHJvdG90eXBlLmF1dG9GZXRjaCA9IGZ1bmN0aW9uKGF1dG9GZXRjaCkge1xuICB0aGlzLl9vcHRpb25zLmF1dG9GZXRjaCA9IGF1dG9GZXRjaDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBmbGFnIHRvIHNjYW4gYWxsIHJlY29yZHMgaW5jbHVkaW5nIGRlbGV0ZWQgYW5kIGFyY2hpdmVkLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2NhbkFsbCAtIEZsYWcgd2hldGhlciBpbmNsdWRlIGRlbGV0ZWQvYXJjaGl2ZWQgcmVjb3JkIG9yIG5vdC4gRGVmYXVsdCBpcyBmYWxzZS5cbiAqIEByZXR1cm5zIHtRdWVyeS48VD59XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5zY2FuQWxsID0gZnVuY3Rpb24oc2NhbkFsbCkge1xuICB0aGlzLl9vcHRpb25zLnNjYW5BbGwgPSBzY2FuQWxsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIFJlc3BvbnNlVGFyZ2V0cyA9IFF1ZXJ5LlJlc3BvbnNlVGFyZ2V0cyA9IHt9O1xuWyBcIlF1ZXJ5UmVzdWx0XCIsIFwiUmVjb3Jkc1wiLCBcIlNpbmdsZVJlY29yZFwiLCBcIkNvdW50XCIgXS5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgUmVzcG9uc2VUYXJnZXRzW2ZdID0gZjtcbn0pO1xuXG4vKipcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXNwb25zZVRhcmdldCAtIFF1ZXJ5IHJlc3BvbnNlIHRhcmdldFxuICogQHJldHVybnMge1F1ZXJ5LjxTPn1cbiAqL1xuUXVlcnkucHJvdG90eXBlLnNldFJlc3BvbnNlVGFyZ2V0ID0gZnVuY3Rpb24ocmVzcG9uc2VUYXJnZXQpIHtcbiAgaWYgKHJlc3BvbnNlVGFyZ2V0IGluIFJlc3BvbnNlVGFyZ2V0cykge1xuICAgIHRoaXMuX29wdGlvbnMucmVzcG9uc2VUYXJnZXQgPSByZXNwb25zZVRhcmdldDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBTeW5vbnltIG9mIFF1ZXJ5I2V4ZWN1dGUoKVxuICpcbiAqIEBtZXRob2QgUXVlcnkjcnVuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gUXVlcnkgb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvRmV0Y2hdIC0gVXNpbmcgYXV0byBmZXRjaCBtb2RlIG9yIG5vdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEZldGNoXSAtIE1heCBmZXRjaGluZyByZWNvcmRzIGluIGF1dG8gZmV0Y2ggbW9kZVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zY2FuQWxsXSAtIEluY2x1ZGluZyBkZWxldGVkIHJlY29yZHMgZm9yIHF1ZXJ5IHRhcmdldCBvciBub3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgSFRUUCByZXF1ZXN0IGhlYWRlcnMgc2VudCBpbiBxdWVyeSByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxUPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UXVlcnkuPFQ+fVxuICovXG5RdWVyeS5wcm90b3R5cGUucnVuID1cbi8qKlxuICogU3lub255bSBvZiBRdWVyeSNleGVjdXRlKClcbiAqXG4gKiBAbWV0aG9kIFF1ZXJ5I2V4ZWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBRdWVyeSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9GZXRjaF0gLSBVc2luZyBhdXRvIGZldGNoIG1vZGUgb3Igbm90XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4RmV0Y2hdIC0gTWF4IGZldGNoaW5nIHJlY29yZHMgaW4gYXV0byBmZXRjaCBtb2RlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNjYW5BbGxdIC0gSW5jbHVkaW5nIGRlbGV0ZWQgcmVjb3JkcyBmb3IgcXVlcnkgdGFyZ2V0IG9yIG5vdFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBIVFRQIHJlcXVlc3QgaGVhZGVycyBzZW50IGluIHF1ZXJ5IHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtRdWVyeS48VD59XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5leGVjID1cbi8qKlxuICogRXhlY3V0ZSBxdWVyeSBhbmQgZmV0Y2ggcmVjb3JkcyBmcm9tIHNlcnZlci5cbiAqXG4gKiBAbWV0aG9kIFF1ZXJ5I2V4ZWN1dGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBRdWVyeSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9GZXRjaF0gLSBVc2luZyBhdXRvIGZldGNoIG1vZGUgb3Igbm90XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4RmV0Y2hdIC0gTWF4IGZldGNoaW5nIHJlY29yZHMgaW4gYXV0byBmZXRjaCBtb2RlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNjYW5BbGxdIC0gSW5jbHVkaW5nIGRlbGV0ZWQgcmVjb3JkcyBmb3IgcXVlcnkgdGFyZ2V0IG9yIG5vdFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBIVFRQIHJlcXVlc3QgaGVhZGVycyBzZW50IGluIHF1ZXJ5IHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtRdWVyeS48VD59XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbG9nZ2VyID0gdGhpcy5fY29ubi5fbG9nZ2VyO1xuICB2YXIgZGVmZXJyZWQgPSB0aGlzLl9kZWZlcnJlZDtcblxuICBpZiAodGhpcy5fZXhlY3V0ZWQpIHtcbiAgICBkZWZlcnJlZC5yZWplY3QobmV3IEVycm9yKFwicmUtZXhlY3V0aW5nIGFscmVhZHkgZXhlY3V0ZWQgcXVlcnlcIikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKHRoaXMuX2ZpbmlzaGVkKSB7XG4gICAgZGVmZXJyZWQucmVqZWN0KG5ldyBFcnJvcihcImV4ZWN1dGluZyBhbHJlYWR5IGNsb3NlZCBxdWVyeVwiKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMgPSB7XG4gICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzIHx8IHNlbGYuX29wdGlvbnMuaGVhZGVycyxcbiAgICByZXNwb25zZVRhcmdldDogb3B0aW9ucy5yZXNwb25zZVRhcmdldCB8fCBzZWxmLl9vcHRpb25zLnJlc3BvbnNlVGFyZ2V0LFxuICAgIGF1dG9GZXRjaDogb3B0aW9ucy5hdXRvRmV0Y2ggfHwgc2VsZi5fb3B0aW9ucy5hdXRvRmV0Y2gsXG4gICAgbWF4RmV0Y2g6IG9wdGlvbnMubWF4RmV0Y2ggfHwgc2VsZi5fb3B0aW9ucy5tYXhGZXRjaCxcbiAgICBzY2FuQWxsOiBvcHRpb25zLnNjYW5BbGwgfHwgc2VsZi5fb3B0aW9ucy5zY2FuQWxsXG4gIH07XG5cbiAgLy8gY2FsbGJhY2sgYW5kIHByb21pc2UgcmVzb2x1dGlvbjtcbiAgdmFyIHByb21pc2VDYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGNhbGxiYWNrKGVyciwgcmVzKTtcbiAgICAgICAgZXJyID0gbnVsbDtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBlcnIgPSBlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXJyKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXMpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5vbmNlKCdyZXNwb25zZScsIGZ1bmN0aW9uKHJlcykge1xuICAgIHByb21pc2VDYWxsYmFjayhudWxsLCByZXMpO1xuICB9KTtcbiAgdGhpcy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgIHByb21pc2VDYWxsYmFjayhlcnIpO1xuICB9KTtcblxuICAvLyBjb2xsZWN0IGZldGNoZWQgcmVjb3JkcyBpbiBhcnJheVxuICAvLyBvbmx5IHdoZW4gcmVzcG9uc2UgdGFyZ2V0IGlzIFJlY29yZHMgYW5kXG4gIC8vIGVpdGhlciBjYWxsYmFjayBvciBjaGFpbmluZyBwcm9taXNlcyBhcmUgYXZhaWxhYmxlIHRvIHRoaXMgcXVlcnkuXG4gIHRoaXMub25jZSgnZmV0Y2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAob3B0aW9ucy5yZXNwb25zZVRhcmdldCA9PT0gUmVzcG9uc2VUYXJnZXRzLlJlY29yZHMgJiYgKHNlbGYuX2NoYWluaW5nIHx8IGNhbGxiYWNrKSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCctLS0gY29sbGVjdGluZyBhbGwgZmV0Y2hlZCByZWNvcmRzIC0tLScpO1xuICAgICAgdmFyIHJlY29yZHMgPSBbXTtcbiAgICAgIHZhciBvblJlY29yZCA9IGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgICByZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgICAgIH07XG4gICAgICBzZWxmLm9uKCdyZWNvcmQnLCBvblJlY29yZCk7XG4gICAgICBzZWxmLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdyZWNvcmQnLCBvblJlY29yZCk7XG4gICAgICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZWNvcmRzLCBzZWxmKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZmxhZyB0byBwcmV2ZW50IHJlLWV4ZWN1dGlvblxuICB0aGlzLl9leGVjdXRlZCA9IHRydWU7XG5cbiAgLy8gc3RhcnQgYWN0dWFsIHF1ZXJ5XG4gIGxvZ2dlci5kZWJ1ZygnPj4+IFF1ZXJ5IHN0YXJ0ID4+PicpO1xuICB0aGlzLl9leGVjdXRlKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgbG9nZ2VyLmRlYnVnKCcqKiogUXVlcnkgZmluaXNoZWQgKioqJyk7XG4gIH0pLmZhaWwoZnVuY3Rpb24oZXJyKSB7XG4gICAgbG9nZ2VyLmRlYnVnKCctLS0gUXVlcnkgZXJyb3IgLS0tJyk7XG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gIH0pO1xuXG4gIC8vIHJldHVybiBRdWVyeSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZXhlY3V0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbG9nZ2VyID0gdGhpcy5fY29ubi5fbG9nZ2VyO1xuICB2YXIgcmVzcG9uc2VUYXJnZXQgPSBvcHRpb25zLnJlc3BvbnNlVGFyZ2V0O1xuICB2YXIgYXV0b0ZldGNoID0gb3B0aW9ucy5hdXRvRmV0Y2g7XG4gIHZhciBtYXhGZXRjaCA9IG9wdGlvbnMubWF4RmV0Y2g7XG4gIHZhciBzY2FuQWxsID0gb3B0aW9ucy5zY2FuQWxsO1xuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgc2VsZi5fbG9jYXRvciA/XG4gICAgc2VsZi5fY29ubi5fYmFzZVVybCgpICsgXCIvcXVlcnkvXCIgKyBzZWxmLl9sb2NhdG9yIDpcbiAgICBzZWxmLnRvU09RTCgpLnRoZW4oZnVuY3Rpb24oc29xbCkge1xuICAgICAgc2VsZi50b3RhbEZldGNoZWQgPSAwO1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiU09RTCA9IFwiICsgc29xbCk7XG4gICAgICByZXR1cm4gc2VsZi5fY29ubi5fYmFzZVVybCgpICsgXCIvXCIgKyAoc2NhbkFsbCA/IFwicXVlcnlBbGxcIiA6IFwicXVlcnlcIikgKyBcIj9xPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHNvcWwpO1xuICAgIH0pXG4gICkudGhlbihmdW5jdGlvbih1cmwpIHtcbiAgICByZXR1cm4gc2VsZi5fY29ubi5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH0pO1xuICB9KS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBzZWxmLmVtaXQoXCJmZXRjaFwiKTtcbiAgICBzZWxmLnRvdGFsU2l6ZSA9IGRhdGEudG90YWxTaXplO1xuICAgIHZhciByZXM7XG4gICAgc3dpdGNoKHJlc3BvbnNlVGFyZ2V0KSB7XG4gICAgICBjYXNlIFJlc3BvbnNlVGFyZ2V0cy5TaW5nbGVSZWNvcmQ6XG4gICAgICAgIHJlcyA9IGRhdGEucmVjb3JkcyAmJiBkYXRhLnJlY29yZHMubGVuZ3RoID4gMCA/IGRhdGEucmVjb3Jkc1swXSA6IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSZXNwb25zZVRhcmdldHMuUmVjb3JkczpcbiAgICAgICAgcmVzID0gZGF0YS5yZWNvcmRzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUmVzcG9uc2VUYXJnZXRzLkNvdW50OlxuICAgICAgICByZXMgPSBkYXRhLnRvdGFsU2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXMgPSBkYXRhO1xuICAgIH1cbiAgICAvLyBvbmx5IGZpcmUgcmVzcG9uc2UgZXZlbnQgd2hlbiBpdCBzaG91bGQgYmUgbm90aWZpZWQgcGVyIGZldGNoXG4gICAgaWYgKHJlc3BvbnNlVGFyZ2V0ICE9PSBSZXNwb25zZVRhcmdldHMuUmVjb3Jkcykge1xuICAgICAgc2VsZi5lbWl0KFwicmVzcG9uc2VcIiwgcmVzLCBzZWxmKTtcbiAgICB9XG5cbiAgICAvLyBzdHJlYW1pbmcgcmVjb3JkIGluc3RhbmNlc1xuICAgIHZhciBudW1SZWNvcmRzID0gKGRhdGEucmVjb3JkcyAmJiBkYXRhLnJlY29yZHMubGVuZ3RoKSB8fCAwO1xuICAgIGZvciAodmFyIGk9MDsgaTxudW1SZWNvcmRzOyBpKyspIHtcbiAgICAgIGlmIChzZWxmLnRvdGFsRmV0Y2hlZCA+PSBtYXhGZXRjaCkge1xuICAgICAgICBzZWxmLl9maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdmFyIHJlY29yZCA9IGRhdGEucmVjb3Jkc1tpXTtcbiAgICAgIHNlbGYucHVzaChyZWNvcmQpO1xuICAgICAgc2VsZi5lbWl0KCdyZWNvcmQnLCByZWNvcmQsIHNlbGYudG90YWxGZXRjaGVkKyssIHNlbGYpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5uZXh0UmVjb3Jkc1VybCkge1xuICAgICAgc2VsZi5fbG9jYXRvciA9IGRhdGEubmV4dFJlY29yZHNVcmwuc3BsaXQoJy8nKS5wb3AoKTtcbiAgICB9XG4gICAgc2VsZi5fZmluaXNoZWQgPSBzZWxmLl9maW5pc2hlZCB8fCBkYXRhLmRvbmUgfHwgIWF1dG9GZXRjaDtcbiAgICBpZiAoc2VsZi5fZmluaXNoZWQpIHtcbiAgICAgIHNlbGYucHVzaChudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fZXhlY3V0ZShvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlYWRhYmxlIHN0cmVhbSBpbXBsZW1lbnRhdGlvblxuICpcbiAqIEBvdmVycmlkZVxuICogQHByaXZhdGVcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24oc2l6ZSkge1xuICBpZiAoIXRoaXMuX2ZpbmlzaGVkICYmICF0aGlzLl9leGVjdXRlZCkge1xuICAgIHRoaXMuZXhlY3V0ZSh7IGF1dG9GZXRjaDogdHJ1ZSB9KTtcbiAgfVxufTtcblxuLyoqIEBvdmVycmlkZSAqKi9cblF1ZXJ5LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGUsIGZuKSB7XG4gIGlmIChlID09PSAncmVjb3JkJykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgd2hpbGUoc2VsZi5yZWFkKCkgIT09IG51bGwpIHt9IC8vIGRpc2NhcmQgYnVmZmVyZWQgcmVjb3Jkc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBRdWVyeS5zdXBlcl8ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZSwgZm4pO1xufTtcblxuLyoqIEBvdmVycmlkZSAqKi9cblF1ZXJ5LnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFF1ZXJ5LnByb3RvdHlwZS5vbjtcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZXhwYW5kRmllbGRzID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9zb3FsKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkNhbm5vdCBleHBhbmQgZmllbGRzIGZvciB0aGUgcXVlcnkgd2hpY2ggaGFzIGFscmVhZHkgYnVpbHQgU09RTC5cIikpO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxvZ2dlciA9IHNlbGYuX2Nvbm4uX2xvZ2dlcjtcbiAgdmFyIGNvbm4gPSB0aGlzLl9jb25uO1xuICB2YXIgdGFibGUgPSB0aGlzLl9jb25maWcudGFibGU7XG4gIHZhciBmaWVsZHMgPSB0aGlzLl9jb25maWcuZmllbGRzIHx8IFtdO1xuXG4gIGxvZ2dlci5kZWJ1ZygnX2V4cGFuZEZpZWxkczogdGFibGUgPSAnICsgdGFibGUgKyAnLCBmaWVsZHMgPSAnICsgZmllbGRzLmpvaW4oJywgJykpO1xuXG4gIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgUHJvbWlzZS5yZXNvbHZlKHNlbGYuX3BhcmVudCA/IGZpbmRSZWxhdGlvblRhYmxlKHRhYmxlKSA6IHRhYmxlKVxuICAgICAgLnRoZW4oZnVuY3Rpb24odGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgIF8ubWFwKGZpZWxkcywgZnVuY3Rpb24oZmllbGQpIHsgcmV0dXJuIGV4cGFuZEFzdGVyaXNrRmllbGQodGFibGUsIGZpZWxkKTsgfSlcbiAgICAgICAgKS50aGVuKGZ1bmN0aW9uKGV4cGFuZGVkRmllbGRzKSB7XG4gICAgICAgICAgc2VsZi5fY29uZmlnLmZpZWxkcyA9IF8uZmxhdHRlbihleHBhbmRlZEZpZWxkcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgUHJvbWlzZS5hbGwoXG4gICAgICBfLm1hcChzZWxmLl9jaGlsZHJlbiB8fCBbXSwgZnVuY3Rpb24oY2hpbGRRdWVyeSkge1xuICAgICAgICByZXR1cm4gY2hpbGRRdWVyeS5fZXhwYW5kRmllbGRzKCk7XG4gICAgICB9KVxuICAgIClcbiAgXSk7XG5cbiAgZnVuY3Rpb24gZmluZFJlbGF0aW9uVGFibGUocm5hbWUpIHtcbiAgICB2YXIgcHRhYmxlID0gc2VsZi5fcGFyZW50Ll9jb25maWcudGFibGU7XG4gICAgbG9nZ2VyLmRlYnVnKCdmaW5kaW5nIHRhYmxlIGZvciByZWxhdGlvbiBcIicgKyBybmFtZSArICdcIiBpbiBcIicgKyBwdGFibGUgKyAnXCIuLi4nKTtcbiAgICByZXR1cm4gZGVzY3JpYmVDYWNoZShwdGFibGUpLnRoZW4oZnVuY3Rpb24oc29iamVjdCkge1xuICAgICAgdmFyIHVwcGVyUm5hbWUgPSBybmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgdmFyIGNoaWxkUmVsYXRpb24gPSBfLmZpbmQoc29iamVjdC5jaGlsZFJlbGF0aW9uc2hpcHMsIGZ1bmN0aW9uKGNyKSB7XG4gICAgICAgIHJldHVybiAoY3IucmVsYXRpb25zaGlwTmFtZSB8fCAnJykudG9VcHBlckNhc2UoKSA9PT0gdXBwZXJSbmFtZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNoaWxkUmVsYXRpb24gPyBjaGlsZFJlbGF0aW9uLmNoaWxkU09iamVjdCA6XG4gICAgICAgIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIGNoaWxkIHJlbGF0aW9uc2hpcCBmb3VuZDogXCIgKyBybmFtZSApKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc2NyaWJlQ2FjaGUodGFibGUpIHtcbiAgICBsb2dnZXIuZGVidWcoJ2Rlc2NyaWJlIGNhY2hlOiAnK3RhYmxlKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBQcm9taXNlLmRlZmVyKCk7XG4gICAgY29ubi5kZXNjcmliZSQodGFibGUsIGZ1bmN0aW9uKGVyciwgc29iamVjdCkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCcuLi4gZG9uZS4nKTtcbiAgICAgIGlmIChlcnIpIHsgZGVmZXJyZWQucmVqZWN0KGVycik7IH1cbiAgICAgIGVsc2UgeyBkZWZlcnJlZC5yZXNvbHZlKHNvYmplY3QpOyB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBleHBhbmRBc3Rlcmlza0ZpZWxkKHRhYmxlLCBmaWVsZCkge1xuICAgIGxvZ2dlci5kZWJ1ZygnZXhwYW5kaW5nIGZpZWxkIFwiJysgZmllbGQgKyAnXCIgaW4gXCInICsgdGFibGUgKyAnXCIuLi4nKTtcbiAgICB2YXIgZnBhdGggPSBmaWVsZC5zcGxpdCgnLicpO1xuICAgIHJldHVybiBmcGF0aFtmcGF0aC5sZW5ndGggLSAxXSA9PT0gJyonID9cbiAgICAgIGRlc2NyaWJlQ2FjaGUodGFibGUpLnRoZW4oZnVuY3Rpb24oc29iamVjdCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3RhYmxlICcrdGFibGUrJ2hhcyBiZWVuIGRlc2NyaWJlZCcpO1xuICAgICAgICBpZiAoZnBhdGgubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHZhciBybmFtZSA9IGZwYXRoLnNoaWZ0KCk7XG4gICAgICAgICAgdmFyIHJmaWVsZCA9IF8uZmluZChzb2JqZWN0LmZpZWxkcywgZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgcmV0dXJuIGYucmVsYXRpb25zaGlwTmFtZSAmJlxuICAgICAgICAgICAgICAgICAgIGYucmVsYXRpb25zaGlwTmFtZS50b1VwcGVyQ2FzZSgpID09PSBybmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZmllbGQpIHtcbiAgICAgICAgICAgIHZhciBydGFibGUgPSByZmllbGQucmVmZXJlbmNlVG8ubGVuZ3RoID09PSAxID8gcmZpZWxkLnJlZmVyZW5jZVRvWzBdIDogJ05hbWUnO1xuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZEFzdGVyaXNrRmllbGQocnRhYmxlLCBmcGF0aC5qb2luKCcuJykpLnRoZW4oZnVuY3Rpb24oZnBhdGhzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfLm1hcChmcGF0aHMsIGZ1bmN0aW9uKGZwYXRoKSB7IHJldHVybiBybmFtZSArICcuJyArIGZwYXRoOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfLm1hcChzb2JqZWN0LmZpZWxkcywgZnVuY3Rpb24oZikgeyByZXR1cm4gZi5uYW1lOyB9KTtcbiAgICAgICAgfVxuICAgICAgfSkgOlxuICAgICAgUHJvbWlzZS5yZXNvbHZlKFsgZmllbGQgXSk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhwbGFpbiBwbGFuIGZvciBleGVjdXRpbmcgcXVlcnlcbiAqXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxFeHBsYWluSW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEV4cGxhaW5JbmZvPn1cbiAqL1xuUXVlcnkucHJvdG90eXBlLmV4cGxhaW4gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsb2dnZXIgPSB0aGlzLl9jb25uLl9sb2dnZXI7XG4gIHJldHVybiBzZWxmLnRvU09RTCgpLnRoZW4oZnVuY3Rpb24oc29xbCkge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIlNPUUwgPSBcIiArIHNvcWwpO1xuICAgIHZhciB1cmwgPSBcIi9xdWVyeS8/ZXhwbGFpbj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChzb3FsKTtcbiAgICByZXR1cm4gc2VsZi5fY29ubi5yZXF1ZXN0KHVybCk7XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIFNPUUwgZXhwcmVzc2lvbiBmb3IgdGhlIHF1ZXJ5XG4gKlxuICogQHBhcmFtIHtDYWxsYmFjay48U3RyaW5nPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48U3RyaW5nPn1cbiAqL1xuUXVlcnkucHJvdG90eXBlLnRvU09RTCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLl9zb3FsIHx8XG4gICAgc2VsZi5fZXhwYW5kRmllbGRzKCkudGhlbihmdW5jdGlvbigpIHsgcmV0dXJuIFNPUUxCdWlsZGVyLmNyZWF0ZVNPUUwoc2VsZi5fY29uZmlnKTsgfSlcbiAgKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBkYXRhIHN0cmVhbSBvZiBxdWVyaWVkIHJlY29yZHMuXG4gKiBBdXRvbWF0aWNhbGx5IHJlc3VtZSBxdWVyeSBpZiBwYXVzZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAtIFR5cGUgb2Ygb3V0Z29pbmcgZGF0YSBmb3JtYXQuIEN1cnJlbnRseSAnY3N2JyBpcyBkZWZhdWx0IHZhbHVlIGFuZCB0aGUgb25seSBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBwYXNzZWQgdG8gY29udmVydGVyXG4gKiBAcmV0dXJucyB7c3RyZWFtLlJlYWRhYmxlfVxuICovXG5RdWVyeS5wcm90b3R5cGUuc3RyZWFtID0gUmVjb3JkU3RyZWFtLlNlcmlhbGl6YWJsZS5wcm90b3R5cGUuc3RyZWFtO1xuXG4vKipcbiAqIEdldCByZWNvcmQgc3RyZWFtIG9mIHF1ZXJpZWQgcmVjb3JkcyBhcHBseWluZyB0aGUgZ2l2ZW4gbWFwcGluZyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7UmVjb3JkTWFwRnVuY3Rpb259IGZuIC0gUmVjb3JkIG1hcHBpbmcgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtSZWNvcmRTdHJlYW0uU2VyaWFsaXphYmxlfVxuICovXG5RdWVyeS5wcm90b3R5cGUubWFwID0gUmVjb3JkU3RyZWFtLnByb3RvdHlwZS5tYXA7XG5cbi8qKlxuICogR2V0IHJlY29yZCBzdHJlYW0gb2YgcXVlcmllZCByZWNvcmRzLCBhcHBseWluZyB0aGUgZ2l2ZW4gZmlsdGVyIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtSZWNvcmRGaWx0ZXJGdW5jdGlvbn0gZm4gLSBSZWNvcmQgZmlsdGVyaW5nIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UmVjb3JkU3RyZWFtLlNlcmlhbGl6YWJsZX1cbiAqL1xuUXVlcnkucHJvdG90eXBlLmZpbHRlciA9IFJlY29yZFN0cmVhbS5wcm90b3R5cGUubWFwO1xuXG4vKlxuICogRGVmYXVsdCB0aHJlc2hvbGQgbnVtIG9mIGJ1bGsgQVBJIHN3aXRjaGluZ1xuICovXG52YXIgREVGQVVMVF9CVUxLX1RIUkVTSE9MRCA9IDIwMDtcblxuLyoqXG4gKiBTeW5vbnltIG9mIFF1ZXJ5I2Rlc3Ryb3koKVxuICpcbiAqIEBtZXRob2QgUXVlcnkjZGVsZXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIC0gU09iamVjdCB0eXBlLiBSZXF1aXJlZCBmb3IgU09RTCBiYXNlZCBxdWVyeSBvYmplY3QuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuLyoqXG4gKiBTeW5vbnltIG9mIFF1ZXJ5I2Rlc3Ryb3koKVxuICpcbiAqIEBtZXRob2QgUXVlcnkjZGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIC0gU09iamVjdCB0eXBlLiBSZXF1aXJlZCBmb3IgU09RTCBiYXNlZCBxdWVyeSBvYmplY3QuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuLyoqXG4gKiBEZWxldGUgcXVlcmllZCByZWNvcmRzXG4gKlxuICogQG1ldGhvZCBRdWVyeSNkZXN0cm95XG4gKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIC0gU09iamVjdCB0eXBlLiBSZXF1aXJlZCBmb3IgU09RTCBiYXNlZCBxdWVyeSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gTWFzcyBkZWxldGUgb3BlcmF0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dCdWxrXSAtIEFsbG93IHN3aXRjaGluZyB0byBCdWxrIEFQSSB3aGVuIHRoZSBudW0gb2YgcXVlcmllZCByZWNvcmRzIHJlYWNoZWQgdG8gY2VydGFpbiB0aHJlc2hvbGQuIERlZmF1bHQgaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5idWxrVGhyZXNob2xkXSAtIFRocmVzaG9sZCBudW0gdG8gc3dpdGNoIHRvIHVzZSBCdWxrIEFQSSBpbnN0ZWFkIG9mIHVzdWFsIGBTT2JqZWN0I2RlbGV0ZSgpYCBjYWxsLiBEZWZhdWx0IHZhbHVlIGlzIDIwMCBhZnRlciBBUEkgdmVyIDQyLjAsIGFuZCAwLjUgKiBgbWF4UmVxdWVzdGAgYmVmb3JlIEFQSSB2ZXIgNDIuMC5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG5RdWVyeS5wcm90b3R5cGVbXCJkZWxldGVcIl0gPVxuUXVlcnkucHJvdG90eXBlLmRlbCA9XG5RdWVyeS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKHR5cGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gdHlwZTtcbiAgICBvcHRpb25zID0ge307XG4gICAgdHlwZSA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHR5cGU7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHR5cGUgPSB0eXBlIHx8ICh0aGlzLl9jb25maWcgJiYgdGhpcy5fY29uZmlnLnRhYmxlKTtcbiAgaWYgKCF0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU09RTCBiYXNlZCBxdWVyeSBuZWVkcyBTT2JqZWN0IHR5cGUgaW5mb3JtYXRpb24gdG8gYnVsayBkZWxldGUuXCIpO1xuICB9XG4gIC8vIFNldCB0aGUgdGhyZXNob2xkIG51bWJlciB0byBwYXNzIHRvIGJ1bGsgQVBJXG4gIHZhciB0aHJlc2hvbGROdW0gPVxuICAgIG9wdGlvbnMuYWxsb3dCdWxrID09PSBmYWxzZSA/XG4gICAgICAtMSA6XG4gICAgdHlwZW9mIG9wdGlvbnMuYnVsa1RocmVzaG9sZCA9PT0gJ251bWJlcicgP1xuICAgICAgb3B0aW9ucy5idWxrVGhyZXNob2xkIDpcbiAgICAgIC8vIGRldGVybWluZSB0aHJlc2hvbGQgaWYgdGhlIGNvbm5lY3Rpb24gdmVyc2lvbiBzdXBwb3J0cyBTT2JqZWN0IGNvbGxlY3Rpb24gQVBJIG9yIG5vdFxuICAgICAgKHRoaXMuX2Nvbm4uX2Vuc3VyZVZlcnNpb24oNDIpID8gREVGQVVMVF9CVUxLX1RIUkVTSE9MRCA6IHRoaXMuX2Nvbm4ubWF4UmVxdWVzdCAvIDIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVjb3JkcyA9IFtdO1xuICAgIHZhciBiYXRjaCA9IG51bGw7XG4gICAgdmFyIGhhbmRsZVJlY29yZCA9IGZ1bmN0aW9uKHJlYykge1xuICAgICAgaWYgKCFyZWMuSWQpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignUXVlcmllZCByZWNvcmQgZG9lcyBub3QgaW5jbHVkZSBTYWxlc2ZvcmNlIHJlY29yZCBJRC4nKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJlY29yZCA9IHsgSWQ6IHJlYy5JZCB9O1xuICAgICAgaWYgKGJhdGNoKSB7XG4gICAgICAgIGJhdGNoLndyaXRlKHJlY29yZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgICAgICAgaWYgKHRocmVzaG9sZE51bSA8IDAgfHwgcmVjb3Jkcy5sZW5ndGggPiB0aHJlc2hvbGROdW0pIHtcbiAgICAgICAgICAvLyBVc2UgYnVsayBkZWxldGUgaW5zdGVhZCBvZiBTT2JqZWN0IFJFU1QgQVBJXG4gICAgICAgICAgYmF0Y2ggPVxuICAgICAgICAgICAgc2VsZi5fY29ubi5zb2JqZWN0KHR5cGUpLmRlbGV0ZUJ1bGsoKVxuICAgICAgICAgICAgICAub24oJ3Jlc3BvbnNlJywgcmVzb2x2ZSlcbiAgICAgICAgICAgICAgLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgICAgICAgYmF0Y2gud3JpdGUocmVjb3JkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZWNvcmRzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBoYW5kbGVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChiYXRjaCkge1xuICAgICAgICBiYXRjaC5lbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZHMgPSByZWNvcmRzLm1hcChmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiByZWNvcmQuSWQ7IH0pO1xuICAgICAgICBzZWxmLl9jb25uLnNvYmplY3QodHlwZSkuZGVzdHJveShpZHMsIHsgYWxsb3dSZWN1cnNpdmU6IHRydWUgfSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2VsZi5vbignZGF0YScsIGhhbmRsZVJlY29yZClcbiAgICAgIC5vbignZW5kJywgaGFuZGxlRW5kKVxuICAgICAgLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHF1ZXJpZWQgcmVjb3JkcywgdXNpbmcgZ2l2ZW4gbWFwcGluZyBmdW5jdGlvbi9vYmplY3RcbiAqXG4gKiBAcGFyYW0ge1JlY29yZHxSZWNvcmRNYXBGdW5jdGlvbn0gbWFwcGluZyAtIE1hcHBpbmcgcmVjb3JkIG9yIHJlY29yZCBtYXBwaW5nIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIC0gU09iamVjdCB0eXBlLiBSZXF1aXJlZCBmb3IgU09RTCBiYXNlZCBxdWVyeSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gTWFzcyB1cGRhdGUgb3BlcmF0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dCdWxrXSAtIEFsbG93IHN3aXRjaGluZyB0byBCdWxrIEFQSSB3aGVuIHRoZSBudW0gb2YgcXVlcmllZCByZWNvcmRzIHJlYWNoZWQgdG8gY2VydGFpbiB0aHJlc2hvbGQuIERlZmF1bHQgaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5idWxrVGhyZXNob2xkXSAtIFRocmVzaG9sZCBudW0gdG8gc3dpdGNoIHRvIHVzZSBCdWxrIEFQSSBpbnN0ZWFkIG9mIHVzdWFsIGBTT2JqZWN0I2RlbGV0ZSgpYCBjYWxsLiBEZWZhdWx0IHZhbHVlIGlzIDIwMCBhZnRlciBBUEkgdmVyIDQyLjAsIGFuZCAwLjUgKiBgbWF4UmVxdWVzdGAgYmVmb3JlIEFQSSB2ZXIgNDIuMC5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG5RdWVyeS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24obWFwcGluZywgdHlwZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSB0eXBlO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgICB0eXBlID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gdHlwZTtcbiAgICB0eXBlID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdHlwZSA9IHR5cGUgfHwgKHRoaXMuX2NvbmZpZyAmJiB0aGlzLl9jb25maWcudGFibGUpO1xuICBpZiAoIXR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTT1FMIGJhc2VkIHF1ZXJ5IG5lZWRzIFNPYmplY3QgdHlwZSBpbmZvcm1hdGlvbiB0byBidWxrIHVwZGF0ZS5cIik7XG4gIH1cbiAgdmFyIHVwZGF0ZVN0cmVhbSA9IF8uaXNGdW5jdGlvbihtYXBwaW5nKSA/IFJlY29yZFN0cmVhbS5tYXAobWFwcGluZykgOiBSZWNvcmRTdHJlYW0ucmVjb3JkTWFwU3RyZWFtKG1hcHBpbmcpO1xuICAvLyBTZXQgdGhlIHRocmVzaG9sZCBudW1iZXIgdG8gcGFzcyB0byBidWxrIEFQSVxuICB2YXIgdGhyZXNob2xkTnVtID1cbiAgICBvcHRpb25zLmFsbG93QnVsayA9PT0gZmFsc2UgP1xuICAgICAgLTEgOlxuICAgIHR5cGVvZiBvcHRpb25zLmJ1bGtUaHJlc2hvbGQgPT09ICdudW1iZXInID9cbiAgICAgIG9wdGlvbnMuYnVsa1RocmVzaG9sZCA6XG4gICAgICAvLyBkZXRlcm1pbmUgdGhyZXNob2xkIGlmIHRoZSBjb25uZWN0aW9uIHZlcnNpb24gc3VwcG9ydHMgU09iamVjdCBjb2xsZWN0aW9uIEFQSSBvciBub3RcbiAgICAgICh0aGlzLl9jb25uLl9lbnN1cmVWZXJzaW9uKDQyKSA/IERFRkFVTFRfQlVMS19USFJFU0hPTEQgOiB0aGlzLl9jb25uLm1heFJlcXVlc3QgLyAyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlY29yZHMgPSBbXTtcbiAgICB2YXIgYmF0Y2ggPSBudWxsO1xuICAgIHZhciBoYW5kbGVSZWNvcmQgPSBmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgIGlmIChiYXRjaCkge1xuICAgICAgICBiYXRjaC53cml0ZShyZWNvcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gICAgICAgIGlmICh0aHJlc2hvbGROdW0gPCAwIHx8IHJlY29yZHMubGVuZ3RoID4gdGhyZXNob2xkTnVtKSB7XG4gICAgICAgICAgLy8gVXNlIGJ1bGsgdXBkYXRlIGluc3RlYWQgb2YgU09iamVjdCBSRVNUIEFQSVxuICAgICAgICAgIGJhdGNoID1cbiAgICAgICAgICAgIHNlbGYuX2Nvbm4uc29iamVjdCh0eXBlKS51cGRhdGVCdWxrKClcbiAgICAgICAgICAgICAgLm9uKCdyZXNwb25zZScsIHJlc29sdmUpXG4gICAgICAgICAgICAgIC5vbignZXJyb3InLCByZWplY3QpO1xuICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgICAgICAgIGJhdGNoLndyaXRlKHJlY29yZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVjb3JkcyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoYmF0Y2gpIHtcbiAgICAgICAgYmF0Y2guZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl9jb25uLnNvYmplY3QodHlwZSkudXBkYXRlKHJlY29yZHMsIHsgYWxsb3dSZWN1cnNpdmU6IHRydWUgfSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2VsZi5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAucGlwZSh1cGRhdGVTdHJlYW0pXG4gICAgICAub24oJ2RhdGEnLCBoYW5kbGVSZWNvcmQpXG4gICAgICAub24oJ2VuZCcsIGhhbmRsZUVuZClcbiAgICAgIC5vbignZXJyb3InLCByZWplY3QpO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFByb21pc2UvQSsgaW50ZXJmYWNlXG4gKiBodHRwOi8vcHJvbWlzZXMtYXBsdXMuZ2l0aHViLmlvL3Byb21pc2VzLXNwZWMvXG4gKlxuICogRGVsZWdhdGUgdG8gZGVmZXJyZWQgcHJvbWlzZSwgcmV0dXJuIHByb21pc2UgaW5zdGFuY2UgZm9yIHF1ZXJ5IHJlc3VsdFxuICpcbiAqIEBwYXJhbSB7RnVsZmlsbGVkQ2FsbGJhY2suPFQsIFMxPn0gW29uRnVsZmlsbGVkXVxuICogQHBhcmFtIHtSZWplY3RlZENhbGxiYWNrLjxTMj59IFtvblJlamVjdGVkXVxuICogQHJldHVybnMge1Byb21pc2UuPFMxfFMyPn1cbiAqL1xuUXVlcnkucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvblJlc29sdmVkLCBvblJlamVjdCkge1xuICB0aGlzLl9jaGFpbmluZyA9IHRydWU7XG4gIGlmICghdGhpcy5fZmluaXNoZWQgJiYgIXRoaXMuX2V4ZWN1dGVkKSB7IHRoaXMuZXhlY3V0ZSgpOyB9XG4gIHJldHVybiB0aGlzLl9kZWZlcnJlZC5wcm9taXNlLnRoZW4uYXBwbHkodGhpcy5fZGVmZXJyZWQucHJvbWlzZSwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogUHJvbWlzZS9BKyBleHRlbnNpb25cbiAqIENhbGwgXCJ0aGVuXCIgdXNpbmcgZ2l2ZW4gbm9kZS1zdHlsZSBjYWxsYmFjayBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtRdWVyeX1cbiAqL1xuUXVlcnkucHJvdG90eXBlLnRoZW5DYWxsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgaWYgKF8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICB0aGlzLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBTdWJRdWVyeSBvYmplY3QgZm9yIHJlcHJlc2VudGluZyBjaGlsZCByZWxhdGlvbnNoaXAgcXVlcnlcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAY2xhc3MgUXVlcnl+U3ViUXVlcnlcbiAqIEBleHRlbmRzIFF1ZXJ5XG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gLSBDb25uZWN0aW9uIG9iamVjdFxuICogQHBhcmFtIHtRdWVyeX0gcGFyZW50IC0gUGFyZW50IHF1ZXJ5IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIFN1YiBxdWVyeSBjb25maWd1cmF0aW9uXG4gKi9cbnZhciBTdWJRdWVyeSA9IGZ1bmN0aW9uKGNvbm4sIHBhcmVudCwgY29uZmlnKSB7XG4gIFN1YlF1ZXJ5LnN1cGVyXy5jYWxsKHRoaXMsIGNvbm4sIGNvbmZpZyk7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbn07XG5cbmluaGVyaXRzKFN1YlF1ZXJ5LCBRdWVyeSk7XG5cbi8qKlxuICogQG1ldGhvZCBRdWVyeX5TdWJRdWVyeSNpbmNsdWRlXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU3ViUXVlcnkucHJvdG90eXBlLmluY2x1ZGUgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGFsbG93ZWQgdG8gaW5jbHVkZSBhbm90aGVyIHN1YnF1ZXJ5IGluIHN1YnF1ZXJ5LlwiKTtcbn07XG5cbi8qKlxuICogQmFjayB0aGUgY29udGV4dCB0byBwYXJlbnQgcXVlcnkgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBRdWVyeX5TdWJRdWVyeSNlbmRcbiAqIEByZXR1cm5zIHtRdWVyeX1cbiAqL1xuU3ViUXVlcnkucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcGFyZW50O1xufTtcblxuLyoqXG4gKiBJZiBleGVjdXRlIGlzIGNhbGxlZCBpbiBzdWJxdWVyeSBjb250ZXh0LCBkZWxlZ2F0ZSBpdCB0byBwYXJlbnQgcXVlcnkgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBRdWVyeX5TdWJRdWVyeSNleGVjdXRlXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU3ViUXVlcnkucHJvdG90eXBlLnJ1biA9XG5TdWJRdWVyeS5wcm90b3R5cGUuZXhlYyA9XG5TdWJRdWVyeS5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcGFyZW50LmV4ZWN1dGUuYXBwbHkodGhpcy5fcGFyZW50LCBhcmd1bWVudHMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/query.js":
/*!*******************************************!*\
  !*** ./node_modules/jsforce/lib/query.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global process*/\n/**\n * @file Manages query for records in Salesforce\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\"),\n    events = __webpack_require__(/*! events */ \"events\"),\n    stream = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/readable.js\"),\n    _      = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    Promise = __webpack_require__(/*! ./promise */ \"(rsc)/./node_modules/jsforce/lib/promise.js\"),\n    SfDate = __webpack_require__(/*! ./date */ \"(rsc)/./node_modules/jsforce/lib/date.js\"),\n    SOQLBuilder = __webpack_require__(/*! ./soql-builder */ \"(rsc)/./node_modules/jsforce/lib/soql-builder.js\"),\n    RecordStream = __webpack_require__(/*! ./record-stream */ \"(rsc)/./node_modules/jsforce/lib/record-stream.js\");\n\n/**\n * Query\n *\n * @protected\n * @class\n * @extends {stream.Readable}\n * @implements Promise.<T>\n * @template T\n * @param {Connection} conn - Connection object\n * @param {Object|String} config - Query config object or SOQL string\n * @param {Object} [options] - Default query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n */\nvar Query = module.exports = function(conn, config, options) {\n  Query.super_.call(this, { objectMode: true });\n\n  this._conn = conn;\n  if (_.isString(config)) { // if query config is string, it is given in SOQL.\n    this._soql = config;\n  } else if (config.locator && config.locator.indexOf(\"/\") >= 0) { // if locator given in url for next records\n    this._locator = config.locator.split(\"/\").pop();\n  } else {\n    this._config = config;\n    this.select(config.fields);\n    if (config.includes) {\n      this.include(config.includes);\n    }\n    if (config.sort) {\n      this.sort(config.sort);\n    }\n  }\n  this._options = _.defaults(options || {}, {\n    maxFetch: 10000,\n    autoFetch: false,\n    scanAll: false,\n    responseTarget: ResponseTargets.QueryResult\n  });\n  this._executed = false;\n  this._finished = false;\n  this._chaining = false;\n\n  this._deferred = Promise.defer();\n\n  var self = this;\n};\n\ninherits(Query, stream.Readable);\n\n/**\n * Select fields to include in the returning result\n *\n * @param {Object|Array.<String>|String} fields - Fields to fetch. Format can be in JSON object (MongoDB-like), array of field names, or comma-separated field names.\n * @returns {Query.<T>}\n */\nQuery.prototype.select = function(fields) {\n  if (this._soql) {\n    throw Error(\"Cannot set select fields for the query which has already built SOQL.\");\n  }\n  fields = fields || '*';\n  if (_.isString(fields)) {\n    fields = fields.split(/\\s*,\\s*/);\n  } else if (_.isObject(fields) && !_.isArray(fields)) {\n    var _fields =  [];\n    for (var k in fields) {\n      if (fields[k]) { _fields.push(k); }\n    }\n    fields = _fields;\n  }\n  this._config.fields = fields;\n  return this;\n};\n\n/**\n * Set query conditions to filter the result records\n *\n * @param {Object|String} conditions - Conditions in JSON object (MongoDB-like), or raw SOQL WHERE clause string.\n * @returns {Query.<T>}\n */\nQuery.prototype.where = function(conditions) {\n  if (this._soql) {\n    throw Error(\"Cannot set where conditions for the query which has already built SOQL.\");\n  }\n  this._config.conditions = conditions;\n  return this;\n};\n\n/**\n * Limit the returning result\n *\n * @param {Number} limit - Maximum number of records the query will return.\n * @returns {Query.<T>}\n */\nQuery.prototype.limit = function(limit) {\n  if (this._soql) {\n    throw Error(\"Cannot set limit for the query which has already built SOQL.\");\n  }\n  this._config.limit = limit;\n  return this;\n};\n\n/**\n * Synonym of Query#offset()\n *\n * @method Query#skip\n * @param {Number} offset - Offset number where begins returning results.\n * @returns {Query.<T>}\n */\n/**\n * Skip records\n *\n * @method Query#offset\n * @param {Number} offset - Offset number where begins returning results.\n * @returns {Query.<T>}\n */\nQuery.prototype.skip =\nQuery.prototype.offset = function(offset) {\n  if (this._soql) {\n    throw Error(\"Cannot set skip/offset for the query which has already built SOQL.\");\n  }\n  this._config.offset = offset;\n  return this;\n};\n\n/**\n * Synonym of Query#sort()\n *\n * @memthod Query#orderby\n * @param {String|Object} sort - Sorting field or hash object with field name and sord direction\n * @param {String|Number} [dir] - Sorting direction (ASC|DESC|1|-1)\n * @returns {Query.<T>}\n */\n/**\n * Set query sort with direction\n *\n * @method Query#sort\n * @param {String|Object} sort - Sorting field or hash object with field name and sord direction\n * @param {String|Number} [dir] - Sorting direction (ASC|DESC|1|-1)\n * @returns {Query.<T>}\n */\nQuery.prototype.sort =\nQuery.prototype.orderby = function(sort, dir) {\n  if (this._soql) {\n    throw Error(\"Cannot set sort for the query which has already built SOQL.\");\n  }\n  if (_.isString(sort) && _.isString(dir)) {\n    sort = [ [ sort, dir ] ];\n  }\n  this._config.sort = sort;\n  return this;\n};\n\n/**\n * Include child relationship query\n *\n * @param {String} childRelName - Child relationship name to include in query result\n * @param {Object|String} [conditions] - Conditions in JSON object (MongoDB-like), or raw SOQL WHERE clause string.\n * @param {Object|Array.<String>|String} [fields] - Fields to fetch. Format can be in JSON object (MongoDB-like), array of field names, or comma-separated field names.\n * @param {Object} [options] - Optional query configulations.\n * @param {Number} [options.limit] - Maximum number of records the query will return.\n * @param {Number} [options.offset] - Offset number where begins returning results.\n * @param {Number} [options.skip] - Synonym of options.offset.\n * @returns {Query~SubQuery}\n */\nQuery.prototype.include = function(childRelName, conditions, fields, options) {\n  if (this._soql) {\n    throw Error(\"Cannot include child relationship into the query which has already built SOQL.\");\n  }\n  if (_.isObject(childRelName)) {\n    var includes = childRelName;\n    for (var crname in includes) {\n      var config = includes[crname];\n      this.include(crname, config.conditions, config.fields, config);\n    }\n    return;\n  }\n  var childConfig = {\n    table: childRelName,\n    conditions: conditions,\n    fields: fields,\n    limit: options && options.limit,\n    offset: options && (options.offset || options.skip),\n    sort: options && options.sort\n  };\n  if (!_.isArray(this._config.includes)) this._config.includes = [];\n  this._config.includes.push(childConfig);\n  var childQuery = new SubQuery(this._conn, this, childConfig);\n  this._children = this._children || [];\n  this._children.push(childQuery);\n  return childQuery;\n};\n\n\n/**\n * Setting maxFetch query option\n *\n * @param {Number} maxFetch - Max fetching records in auto fetch mode\n * @returns {Query.<T>}\n */\nQuery.prototype.maxFetch = function(maxFetch) {\n  this._options.maxFetch = maxFetch;\n  return this;\n};\n\n/**\n * Switching auto fetch mode\n *\n * @param {Boolean} autoFetch - Using auto fetch mode or not\n * @returns {Query.<T>}\n */\nQuery.prototype.autoFetch = function(autoFetch) {\n  this._options.autoFetch = autoFetch;\n  return this;\n};\n\n/**\n * Set flag to scan all records including deleted and archived.\n *\n * @param {Boolean} scanAll - Flag whether include deleted/archived record or not. Default is false.\n * @returns {Query.<T>}\n */\nQuery.prototype.scanAll = function(scanAll) {\n  this._options.scanAll = scanAll;\n  return this;\n};\n\n/**\n * @private\n */\nvar ResponseTargets = Query.ResponseTargets = {};\n[ \"QueryResult\", \"Records\", \"SingleRecord\", \"Count\" ].forEach(function(f) {\n  ResponseTargets[f] = f;\n});\n\n/**\n * @protected\n * @param {String} responseTarget - Query response target\n * @returns {Query.<S>}\n */\nQuery.prototype.setResponseTarget = function(responseTarget) {\n  if (responseTarget in ResponseTargets) {\n    this._options.responseTarget = responseTarget;\n  }\n  return this;\n};\n\n\n/**\n * Synonym of Query#execute()\n *\n * @method Query#run\n * @param {Object} [options] - Query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query.<T>}\n */\nQuery.prototype.run =\n/**\n * Synonym of Query#execute()\n *\n * @method Query#exec\n * @param {Object} [options] - Query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query.<T>}\n */\nQuery.prototype.exec =\n/**\n * Execute query and fetch records from server.\n *\n * @method Query#execute\n * @param {Object} [options] - Query options\n * @param {Boolean} [options.autoFetch] - Using auto fetch mode or not\n * @param {Number} [options.maxFetch] - Max fetching records in auto fetch mode\n * @param {Boolean} [options.scanAll] - Including deleted records for query target or not\n * @param {Object} [options.headers] - Additional HTTP request headers sent in query request\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query.<T>}\n */\nQuery.prototype.execute = function(options, callback) {\n  var self = this;\n  var logger = this._conn._logger;\n  var deferred = this._deferred;\n\n  if (this._executed) {\n    deferred.reject(new Error(\"re-executing already executed query\"));\n    return this;\n  }\n\n  if (this._finished) {\n    deferred.reject(new Error(\"executing already closed query\"));\n    return this;\n  }\n\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  options = {\n    headers: options.headers || self._options.headers,\n    responseTarget: options.responseTarget || self._options.responseTarget,\n    autoFetch: options.autoFetch || self._options.autoFetch,\n    maxFetch: options.maxFetch || self._options.maxFetch,\n    scanAll: options.scanAll || self._options.scanAll\n  };\n\n  // callback and promise resolution;\n  var promiseCallback = function(err, res) {\n    if (_.isFunction(callback)) {\n      try {\n        res = callback(err, res);\n        err = null;\n      } catch(e) {\n        err = e;\n      }\n    }\n    if (err) {\n      deferred.reject(err);\n    } else {\n      deferred.resolve(res);\n    }\n  };\n  this.once('response', function(res) {\n    promiseCallback(null, res);\n  });\n  this.once('error', function(err) {\n    promiseCallback(err);\n  });\n\n  // collect fetched records in array\n  // only when response target is Records and\n  // either callback or chaining promises are available to this query.\n  this.once('fetch', function() {\n    if (options.responseTarget === ResponseTargets.Records && (self._chaining || callback)) {\n      logger.debug('--- collecting all fetched records ---');\n      var records = [];\n      var onRecord = function(record) {\n        records.push(record);\n      };\n      self.on('record', onRecord);\n      self.once('end', function() {\n        self.removeListener('record', onRecord);\n        self.emit('response', records, self);\n      });\n    }\n  });\n\n  // flag to prevent re-execution\n  this._executed = true;\n\n  // start actual query\n  logger.debug('>>> Query start >>>');\n  this._execute(options).then(function() {\n    logger.debug('*** Query finished ***');\n  }).fail(function(err) {\n    logger.debug('--- Query error ---');\n    self.emit('error', err);\n  });\n\n  // return Query instance for chaining\n  return this;\n};\n\n/**\n * @private\n */\nQuery.prototype._execute = function(options) {\n  var self = this;\n  var logger = this._conn._logger;\n  var responseTarget = options.responseTarget;\n  var autoFetch = options.autoFetch;\n  var maxFetch = options.maxFetch;\n  var scanAll = options.scanAll;\n\n  return Promise.resolve(\n    self._locator ?\n    self._conn._baseUrl() + \"/query/\" + self._locator :\n    self.toSOQL().then(function(soql) {\n      self.totalFetched = 0;\n      logger.debug(\"SOQL = \" + soql);\n      return self._conn._baseUrl() + \"/\" + (scanAll ? \"queryAll\" : \"query\") + \"?q=\" + encodeURIComponent(soql);\n    })\n  ).then(function(url) {\n    return self._conn.request({\n      method: 'GET',\n      url: url,\n      headers: options.headers\n    });\n  }).then(function(data) {\n    self.emit(\"fetch\");\n    self.totalSize = data.totalSize;\n    var res;\n    switch(responseTarget) {\n      case ResponseTargets.SingleRecord:\n        res = data.records && data.records.length > 0 ? data.records[0] : null;\n        break;\n      case ResponseTargets.Records:\n        res = data.records;\n        break;\n      case ResponseTargets.Count:\n        res = data.totalSize;\n        break;\n      default:\n        res = data;\n    }\n    // only fire response event when it should be notified per fetch\n    if (responseTarget !== ResponseTargets.Records) {\n      self.emit(\"response\", res, self);\n    }\n\n    // streaming record instances\n    var numRecords = (data.records && data.records.length) || 0;\n    for (var i=0; i<numRecords; i++) {\n      if (self.totalFetched >= maxFetch) {\n        self._finished = true;\n        break;\n      }\n      var record = data.records[i];\n      self.push(record);\n      self.emit('record', record, self.totalFetched++, self);\n    }\n    if (data.nextRecordsUrl) {\n      self._locator = data.nextRecordsUrl.split('/').pop();\n    }\n    self._finished = self._finished || data.done || !autoFetch;\n    if (self._finished) {\n      self.push(null);\n    } else {\n      self._execute(options);\n    }\n    return res;\n  });\n};\n\n/**\n * Readable stream implementation\n *\n * @override\n * @private\n */\nQuery.prototype._read = function(size) {\n  if (!this._finished && !this._executed) {\n    this.execute({ autoFetch: true });\n  }\n};\n\n/** @override **/\nQuery.prototype.on = function(e, fn) {\n  if (e === 'record') {\n    var self = this;\n    this.on('readable', function() {\n      while(self.read() !== null) {} // discard buffered records\n    });\n  }\n  return Query.super_.prototype.on.call(this, e, fn);\n};\n\n/** @override **/\nQuery.prototype.addListener = Query.prototype.on;\n\n\n/**\n * @private\n */\nQuery.prototype._expandFields = function() {\n  if (this._soql) {\n    return Promise.reject(new Error(\"Cannot expand fields for the query which has already built SOQL.\"));\n  }\n  var self = this;\n  var logger = self._conn._logger;\n  var conn = this._conn;\n  var table = this._config.table;\n  var fields = this._config.fields || [];\n\n  logger.debug('_expandFields: table = ' + table + ', fields = ' + fields.join(', '));\n\n  return Promise.all([\n    Promise.resolve(self._parent ? findRelationTable(table) : table)\n      .then(function(table) {\n        return Promise.all(\n          _.map(fields, function(field) { return expandAsteriskField(table, field); })\n        ).then(function(expandedFields) {\n          self._config.fields = _.flatten(expandedFields);\n        });\n      }),\n    Promise.all(\n      _.map(self._children || [], function(childQuery) {\n        return childQuery._expandFields();\n      })\n    )\n  ]);\n\n  function findRelationTable(rname) {\n    var ptable = self._parent._config.table;\n    logger.debug('finding table for relation \"' + rname + '\" in \"' + ptable + '\"...');\n    return describeCache(ptable).then(function(sobject) {\n      var upperRname = rname.toUpperCase();\n      var childRelation = _.find(sobject.childRelationships, function(cr) {\n        return (cr.relationshipName || '').toUpperCase() === upperRname;\n      });\n      return childRelation ? childRelation.childSObject :\n        Promise.reject(new Error(\"No child relationship found: \" + rname ));\n    });\n  }\n\n  function describeCache(table) {\n    logger.debug('describe cache: '+table);\n    var deferred = Promise.defer();\n    conn.describe$(table, function(err, sobject) {\n      logger.debug('... done.');\n      if (err) { deferred.reject(err); }\n      else { deferred.resolve(sobject); }\n    });\n    return deferred.promise;\n  }\n\n  function expandAsteriskField(table, field) {\n    logger.debug('expanding field \"'+ field + '\" in \"' + table + '\"...');\n    var fpath = field.split('.');\n    return fpath[fpath.length - 1] === '*' ?\n      describeCache(table).then(function(sobject) {\n        logger.debug('table '+table+'has been described');\n        if (fpath.length > 1) {\n          var rname = fpath.shift();\n          var rfield = _.find(sobject.fields, function(f) {\n            return f.relationshipName &&\n                   f.relationshipName.toUpperCase() === rname.toUpperCase();\n          });\n          if (rfield) {\n            var rtable = rfield.referenceTo.length === 1 ? rfield.referenceTo[0] : 'Name';\n            return expandAsteriskField(rtable, fpath.join('.')).then(function(fpaths) {\n              return _.map(fpaths, function(fpath) { return rname + '.' + fpath; });\n            });\n          } else {\n            return [];\n          }\n        } else {\n          return _.map(sobject.fields, function(f) { return f.name; });\n        }\n      }) :\n      Promise.resolve([ field ]);\n  }\n};\n\n/**\n * Explain plan for executing query\n *\n * @param {Callback.<ExplainInfo>} [callback] - Callback function\n * @returns {Promise.<ExplainInfo>}\n */\nQuery.prototype.explain = function(callback) {\n  var self = this;\n  var logger = this._conn._logger;\n  return self.toSOQL().then(function(soql) {\n    logger.debug(\"SOQL = \" + soql);\n    var url = \"/query/?explain=\" + encodeURIComponent(soql);\n    return self._conn.request(url);\n  }).thenCall(callback);\n};\n\n/**\n * Return SOQL expression for the query\n *\n * @param {Callback.<String>} [callback] - Callback function\n * @returns {Promise.<String>}\n */\nQuery.prototype.toSOQL = function(callback) {\n  var self = this;\n  return Promise.resolve(self._soql ||\n    self._expandFields().then(function() { return SOQLBuilder.createSOQL(self._config); })\n  ).thenCall(callback);\n};\n\n/**\n * Create data stream of queried records.\n * Automatically resume query if paused.\n *\n * @param {String} [type] - Type of outgoing data format. Currently 'csv' is default value and the only supported.\n * @param {Object} [options] - Options passed to converter\n * @returns {stream.Readable}\n */\nQuery.prototype.stream = RecordStream.Serializable.prototype.stream;\n\n/**\n * Get record stream of queried records applying the given mapping function\n *\n * @param {RecordMapFunction} fn - Record mapping function\n * @returns {RecordStream.Serializable}\n */\nQuery.prototype.map = RecordStream.prototype.map;\n\n/**\n * Get record stream of queried records, applying the given filter function\n *\n * @param {RecordFilterFunction} fn - Record filtering function\n * @returns {RecordStream.Serializable}\n */\nQuery.prototype.filter = RecordStream.prototype.map;\n\n/*\n * Default threshold num of bulk API switching\n */\nvar DEFAULT_BULK_THRESHOLD = 200;\n\n/**\n * Synonym of Query#destroy()\n *\n * @method Query#delete\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\n/**\n * Synonym of Query#destroy()\n *\n * @method Query#del\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\n/**\n * Delete queried records\n *\n * @method Query#destroy\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Object} [options] - Mass delete operation options\n * @param {Boolean} [options.allowBulk] - Allow switching to Bulk API when the num of queried records reached to certain threshold. Default is true.\n * @param {Number} [options.bulkThreshold] - Threshold num to switch to use Bulk API instead of usual `SObject#delete()` call. Default value is 200 after API ver 42.0, and 0.5 * `maxRequest` before API ver 42.0.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\nQuery.prototype[\"delete\"] =\nQuery.prototype.del =\nQuery.prototype.destroy = function(type, options, callback) {\n  if (typeof type === 'function') {\n    callback = type;\n    options = {};\n    type = null;\n  } else if (typeof type === 'object' && type !== null) {\n    callback = options;\n    options = type;\n    type = null;\n  }\n  options = options || {};\n  type = type || (this._config && this._config.table);\n  if (!type) {\n    throw new Error(\"SOQL based query needs SObject type information to bulk delete.\");\n  }\n  // Set the threshold number to pass to bulk API\n  var thresholdNum =\n    options.allowBulk === false ?\n      -1 :\n    typeof options.bulkThreshold === 'number' ?\n      options.bulkThreshold :\n      // determine threshold if the connection version supports SObject collection API or not\n      (this._conn._ensureVersion(42) ? DEFAULT_BULK_THRESHOLD : this._conn.maxRequest / 2);\n  var self = this;\n  return new Promise(function(resolve, reject) {\n    var records = [];\n    var batch = null;\n    var handleRecord = function(rec) {\n      if (!rec.Id) {\n        self.emit('error', new Error('Queried record does not include Salesforce record ID.'))\n        return;\n      }\n      var record = { Id: rec.Id };\n      if (batch) {\n        batch.write(record);\n      } else {\n        records.push(record);\n        if (thresholdNum < 0 || records.length > thresholdNum) {\n          // Use bulk delete instead of SObject REST API\n          batch =\n            self._conn.sobject(type).deleteBulk()\n              .on('response', resolve)\n              .on('error', reject);\n          records.forEach(function(record) {\n            batch.write(record);\n          });\n          records = [];\n        }\n      }\n    };\n    var handleEnd = function() {\n      if (batch) {\n        batch.end();\n      } else {\n        var ids = records.map(function (record) { return record.Id; });\n        self._conn.sobject(type).destroy(ids, { allowRecursive: true }).then(resolve, reject);\n      }\n    };\n    self.on('data', handleRecord)\n      .on('end', handleEnd)\n      .on('error', reject);\n  }).thenCall(callback);\n};\n\n/**\n * Update queried records, using given mapping function/object\n *\n * @param {Record|RecordMapFunction} mapping - Mapping record or record mapping function\n * @param {String} [type] - SObject type. Required for SOQL based query object.\n * @param {Object} [options] - Mass update operation options\n * @param {Boolean} [options.allowBulk] - Allow switching to Bulk API when the num of queried records reached to certain threshold. Default is true.\n * @param {Number} [options.bulkThreshold] - Threshold num to switch to use Bulk API instead of usual `SObject#delete()` call. Default value is 200 after API ver 42.0, and 0.5 * `maxRequest` before API ver 42.0.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\nQuery.prototype.update = function(mapping, type, options, callback) {\n  if (typeof type === 'function') {\n    callback = type;\n    options = {};\n    type = null;\n  } else if (typeof type === 'object' && type !== null) {\n    callback = options;\n    options = type;\n    type = null;\n  }\n  options = options || {};\n  type = type || (this._config && this._config.table);\n  if (!type) {\n    throw new Error(\"SOQL based query needs SObject type information to bulk update.\");\n  }\n  var updateStream = _.isFunction(mapping) ? RecordStream.map(mapping) : RecordStream.recordMapStream(mapping);\n  // Set the threshold number to pass to bulk API\n  var thresholdNum =\n    options.allowBulk === false ?\n      -1 :\n    typeof options.bulkThreshold === 'number' ?\n      options.bulkThreshold :\n      // determine threshold if the connection version supports SObject collection API or not\n      (this._conn._ensureVersion(42) ? DEFAULT_BULK_THRESHOLD : this._conn.maxRequest / 2);\n  var self = this;\n  return new Promise(function(resolve, reject) {\n    var records = [];\n    var batch = null;\n    var handleRecord = function(record) {\n      if (batch) {\n        batch.write(record);\n      } else {\n        records.push(record);\n        if (thresholdNum < 0 || records.length > thresholdNum) {\n          // Use bulk update instead of SObject REST API\n          batch =\n            self._conn.sobject(type).updateBulk()\n              .on('response', resolve)\n              .on('error', reject);\n          records.forEach(function(record) {\n            batch.write(record);\n          });\n          records = [];\n        }\n      }\n    };\n    var handleEnd = function() {\n      if (batch) {\n        batch.end();\n      } else {\n        self._conn.sobject(type).update(records, { allowRecursive: true }).then(resolve, reject);\n      }\n    };\n    self.on('error', reject)\n      .pipe(updateStream)\n      .on('data', handleRecord)\n      .on('end', handleEnd)\n      .on('error', reject);\n  }).thenCall(callback);\n};\n\n/**\n * Promise/A+ interface\n * http://promises-aplus.github.io/promises-spec/\n *\n * Delegate to deferred promise, return promise instance for query result\n *\n * @param {FulfilledCallback.<T, S1>} [onFulfilled]\n * @param {RejectedCallback.<S2>} [onRejected]\n * @returns {Promise.<S1|S2>}\n */\nQuery.prototype.then = function(onResolved, onReject) {\n  this._chaining = true;\n  if (!this._finished && !this._executed) { this.execute(); }\n  return this._deferred.promise.then.apply(this._deferred.promise, arguments);\n};\n\n/**\n * Promise/A+ extension\n * Call \"then\" using given node-style callback function\n *\n * @param {Callback.<T>} [callback] - Callback function\n * @returns {Query}\n */\nQuery.prototype.thenCall = function(callback) {\n  if (_.isFunction(callback)) {\n    this.then(function(res) {\n      process.nextTick(function() {\n        callback(null, res);\n      });\n    }, function(err) {\n      process.nextTick(function() {\n        callback(err);\n      });\n    });\n  }\n  return this;\n};\n\n/*--------------------------------------------*/\n\n/**\n * SubQuery object for representing child relationship query\n *\n * @protected\n * @class Query~SubQuery\n * @extends Query\n * @param {Connection} conn - Connection object\n * @param {Query} parent - Parent query object\n * @param {Object} config - Sub query configuration\n */\nvar SubQuery = function(conn, parent, config) {\n  SubQuery.super_.call(this, conn, config);\n  this._parent = parent;\n};\n\ninherits(SubQuery, Query);\n\n/**\n * @method Query~SubQuery#include\n * @override\n */\nSubQuery.prototype.include = function() {\n  throw new Error(\"Not allowed to include another subquery in subquery.\");\n};\n\n/**\n * Back the context to parent query object\n *\n * @method Query~SubQuery#end\n * @returns {Query}\n */\nSubQuery.prototype.end = function() {\n  return this._parent;\n};\n\n/**\n * If execute is called in subquery context, delegate it to parent query object\n *\n * @method Query~SubQuery#execute\n * @override\n */\nSubQuery.prototype.run =\nSubQuery.prototype.exec =\nSubQuery.prototype.execute = function() {\n  return this._parent.execute.apply(this._parent, arguments);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsMkRBQVU7QUFDakMsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyw4RkFBaUI7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLHdEQUFhO0FBQ2xDLGNBQWMsbUJBQU8sQ0FBQyw4REFBVztBQUNqQyxhQUFhLG1CQUFPLENBQUMsd0RBQVE7QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMsd0VBQWdCO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLDBFQUFpQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCOztBQUU5QztBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLElBQUksK0RBQStEO0FBQ25FO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyw4QkFBOEI7QUFDekMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsY0FBYztBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGNBQWM7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxjQUFjO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyQ0FBMkM7QUFDckY7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw2QkFBNkI7QUFDbEYsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWLHFEQUFxRCxnQkFBZ0I7QUFDckU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw4Q0FBOEM7QUFDekY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixrREFBa0QsbUJBQW1CO0FBQ3JFLGdEQUFnRCxzQkFBc0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsbURBQW1ELHNCQUFzQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QyxXQUFXLHVCQUF1QjtBQUNsQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcXVlcnkuanM/YmM2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBwcm9jZXNzKi9cbi8qKlxuICogQGZpbGUgTWFuYWdlcyBxdWVyeSBmb3IgcmVjb3JkcyBpbiBTYWxlc2ZvcmNlXG4gKiBAYXV0aG9yIFNoaW5pY2hpIFRvbWl0YSA8c2hpbmljaGkudG9taXRhQGdtYWlsLmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyksXG4gICAgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJyksXG4gICAgXyAgICAgID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9wcm9taXNlJyksXG4gICAgU2ZEYXRlID0gcmVxdWlyZShcIi4vZGF0ZVwiKSxcbiAgICBTT1FMQnVpbGRlciA9IHJlcXVpcmUoXCIuL3NvcWwtYnVpbGRlclwiKSxcbiAgICBSZWNvcmRTdHJlYW0gPSByZXF1aXJlKFwiLi9yZWNvcmQtc3RyZWFtXCIpO1xuXG4vKipcbiAqIFF1ZXJ5XG4gKlxuICogQHByb3RlY3RlZFxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyB7c3RyZWFtLlJlYWRhYmxlfVxuICogQGltcGxlbWVudHMgUHJvbWlzZS48VD5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gLSBDb25uZWN0aW9uIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBjb25maWcgLSBRdWVyeSBjb25maWcgb2JqZWN0IG9yIFNPUUwgc3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gRGVmYXVsdCBxdWVyeSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9GZXRjaF0gLSBVc2luZyBhdXRvIGZldGNoIG1vZGUgb3Igbm90XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4RmV0Y2hdIC0gTWF4IGZldGNoaW5nIHJlY29yZHMgaW4gYXV0byBmZXRjaCBtb2RlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNjYW5BbGxdIC0gSW5jbHVkaW5nIGRlbGV0ZWQgcmVjb3JkcyBmb3IgcXVlcnkgdGFyZ2V0IG9yIG5vdFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBIVFRQIHJlcXVlc3QgaGVhZGVycyBzZW50IGluIHF1ZXJ5IHJlcXVlc3RcbiAqL1xudmFyIFF1ZXJ5ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb25uLCBjb25maWcsIG9wdGlvbnMpIHtcbiAgUXVlcnkuc3VwZXJfLmNhbGwodGhpcywgeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuXG4gIHRoaXMuX2Nvbm4gPSBjb25uO1xuICBpZiAoXy5pc1N0cmluZyhjb25maWcpKSB7IC8vIGlmIHF1ZXJ5IGNvbmZpZyBpcyBzdHJpbmcsIGl0IGlzIGdpdmVuIGluIFNPUUwuXG4gICAgdGhpcy5fc29xbCA9IGNvbmZpZztcbiAgfSBlbHNlIGlmIChjb25maWcubG9jYXRvciAmJiBjb25maWcubG9jYXRvci5pbmRleE9mKFwiL1wiKSA+PSAwKSB7IC8vIGlmIGxvY2F0b3IgZ2l2ZW4gaW4gdXJsIGZvciBuZXh0IHJlY29yZHNcbiAgICB0aGlzLl9sb2NhdG9yID0gY29uZmlnLmxvY2F0b3Iuc3BsaXQoXCIvXCIpLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnNlbGVjdChjb25maWcuZmllbGRzKTtcbiAgICBpZiAoY29uZmlnLmluY2x1ZGVzKSB7XG4gICAgICB0aGlzLmluY2x1ZGUoY29uZmlnLmluY2x1ZGVzKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5zb3J0KSB7XG4gICAgICB0aGlzLnNvcnQoY29uZmlnLnNvcnQpO1xuICAgIH1cbiAgfVxuICB0aGlzLl9vcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zIHx8IHt9LCB7XG4gICAgbWF4RmV0Y2g6IDEwMDAwLFxuICAgIGF1dG9GZXRjaDogZmFsc2UsXG4gICAgc2NhbkFsbDogZmFsc2UsXG4gICAgcmVzcG9uc2VUYXJnZXQ6IFJlc3BvbnNlVGFyZ2V0cy5RdWVyeVJlc3VsdFxuICB9KTtcbiAgdGhpcy5fZXhlY3V0ZWQgPSBmYWxzZTtcbiAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgdGhpcy5fY2hhaW5pbmcgPSBmYWxzZTtcblxuICB0aGlzLl9kZWZlcnJlZCA9IFByb21pc2UuZGVmZXIoKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG59O1xuXG5pbmhlcml0cyhRdWVyeSwgc3RyZWFtLlJlYWRhYmxlKTtcblxuLyoqXG4gKiBTZWxlY3QgZmllbGRzIHRvIGluY2x1ZGUgaW4gdGhlIHJldHVybmluZyByZXN1bHRcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheS48U3RyaW5nPnxTdHJpbmd9IGZpZWxkcyAtIEZpZWxkcyB0byBmZXRjaC4gRm9ybWF0IGNhbiBiZSBpbiBKU09OIG9iamVjdCAoTW9uZ29EQi1saWtlKSwgYXJyYXkgb2YgZmllbGQgbmFtZXMsIG9yIGNvbW1hLXNlcGFyYXRlZCBmaWVsZCBuYW1lcy5cbiAqIEByZXR1cm5zIHtRdWVyeS48VD59XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihmaWVsZHMpIHtcbiAgaWYgKHRoaXMuX3NvcWwpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCBzZXQgc2VsZWN0IGZpZWxkcyBmb3IgdGhlIHF1ZXJ5IHdoaWNoIGhhcyBhbHJlYWR5IGJ1aWx0IFNPUUwuXCIpO1xuICB9XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCAnKic7XG4gIGlmIChfLmlzU3RyaW5nKGZpZWxkcykpIHtcbiAgICBmaWVsZHMgPSBmaWVsZHMuc3BsaXQoL1xccyosXFxzKi8pO1xuICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoZmllbGRzKSAmJiAhXy5pc0FycmF5KGZpZWxkcykpIHtcbiAgICB2YXIgX2ZpZWxkcyA9ICBbXTtcbiAgICBmb3IgKHZhciBrIGluIGZpZWxkcykge1xuICAgICAgaWYgKGZpZWxkc1trXSkgeyBfZmllbGRzLnB1c2goayk7IH1cbiAgICB9XG4gICAgZmllbGRzID0gX2ZpZWxkcztcbiAgfVxuICB0aGlzLl9jb25maWcuZmllbGRzID0gZmllbGRzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHF1ZXJ5IGNvbmRpdGlvbnMgdG8gZmlsdGVyIHRoZSByZXN1bHQgcmVjb3Jkc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gY29uZGl0aW9ucyAtIENvbmRpdGlvbnMgaW4gSlNPTiBvYmplY3QgKE1vbmdvREItbGlrZSksIG9yIHJhdyBTT1FMIFdIRVJFIGNsYXVzZSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7UXVlcnkuPFQ+fVxuICovXG5RdWVyeS5wcm90b3R5cGUud2hlcmUgPSBmdW5jdGlvbihjb25kaXRpb25zKSB7XG4gIGlmICh0aGlzLl9zb3FsKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJDYW5ub3Qgc2V0IHdoZXJlIGNvbmRpdGlvbnMgZm9yIHRoZSBxdWVyeSB3aGljaCBoYXMgYWxyZWFkeSBidWlsdCBTT1FMLlwiKTtcbiAgfVxuICB0aGlzLl9jb25maWcuY29uZGl0aW9ucyA9IGNvbmRpdGlvbnM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBMaW1pdCB0aGUgcmV0dXJuaW5nIHJlc3VsdFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdCAtIE1heGltdW0gbnVtYmVyIG9mIHJlY29yZHMgdGhlIHF1ZXJ5IHdpbGwgcmV0dXJuLlxuICogQHJldHVybnMge1F1ZXJ5LjxUPn1cbiAqL1xuUXVlcnkucHJvdG90eXBlLmxpbWl0ID0gZnVuY3Rpb24obGltaXQpIHtcbiAgaWYgKHRoaXMuX3NvcWwpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCBzZXQgbGltaXQgZm9yIHRoZSBxdWVyeSB3aGljaCBoYXMgYWxyZWFkeSBidWlsdCBTT1FMLlwiKTtcbiAgfVxuICB0aGlzLl9jb25maWcubGltaXQgPSBsaW1pdDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN5bm9ueW0gb2YgUXVlcnkjb2Zmc2V0KClcbiAqXG4gKiBAbWV0aG9kIFF1ZXJ5I3NraXBcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgLSBPZmZzZXQgbnVtYmVyIHdoZXJlIGJlZ2lucyByZXR1cm5pbmcgcmVzdWx0cy5cbiAqIEByZXR1cm5zIHtRdWVyeS48VD59XG4gKi9cbi8qKlxuICogU2tpcCByZWNvcmRzXG4gKlxuICogQG1ldGhvZCBRdWVyeSNvZmZzZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgLSBPZmZzZXQgbnVtYmVyIHdoZXJlIGJlZ2lucyByZXR1cm5pbmcgcmVzdWx0cy5cbiAqIEByZXR1cm5zIHtRdWVyeS48VD59XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5za2lwID1cblF1ZXJ5LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgaWYgKHRoaXMuX3NvcWwpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCBzZXQgc2tpcC9vZmZzZXQgZm9yIHRoZSBxdWVyeSB3aGljaCBoYXMgYWxyZWFkeSBidWlsdCBTT1FMLlwiKTtcbiAgfVxuICB0aGlzLl9jb25maWcub2Zmc2V0ID0gb2Zmc2V0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3lub255bSBvZiBRdWVyeSNzb3J0KClcbiAqXG4gKiBAbWVtdGhvZCBRdWVyeSNvcmRlcmJ5XG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHNvcnQgLSBTb3J0aW5nIGZpZWxkIG9yIGhhc2ggb2JqZWN0IHdpdGggZmllbGQgbmFtZSBhbmQgc29yZCBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW2Rpcl0gLSBTb3J0aW5nIGRpcmVjdGlvbiAoQVNDfERFU0N8MXwtMSlcbiAqIEByZXR1cm5zIHtRdWVyeS48VD59XG4gKi9cbi8qKlxuICogU2V0IHF1ZXJ5IHNvcnQgd2l0aCBkaXJlY3Rpb25cbiAqXG4gKiBAbWV0aG9kIFF1ZXJ5I3NvcnRcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gc29ydCAtIFNvcnRpbmcgZmllbGQgb3IgaGFzaCBvYmplY3Qgd2l0aCBmaWVsZCBuYW1lIGFuZCBzb3JkIGRpcmVjdGlvblxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbZGlyXSAtIFNvcnRpbmcgZGlyZWN0aW9uIChBU0N8REVTQ3wxfC0xKVxuICogQHJldHVybnMge1F1ZXJ5LjxUPn1cbiAqL1xuUXVlcnkucHJvdG90eXBlLnNvcnQgPVxuUXVlcnkucHJvdG90eXBlLm9yZGVyYnkgPSBmdW5jdGlvbihzb3J0LCBkaXIpIHtcbiAgaWYgKHRoaXMuX3NvcWwpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCBzZXQgc29ydCBmb3IgdGhlIHF1ZXJ5IHdoaWNoIGhhcyBhbHJlYWR5IGJ1aWx0IFNPUUwuXCIpO1xuICB9XG4gIGlmIChfLmlzU3RyaW5nKHNvcnQpICYmIF8uaXNTdHJpbmcoZGlyKSkge1xuICAgIHNvcnQgPSBbIFsgc29ydCwgZGlyIF0gXTtcbiAgfVxuICB0aGlzLl9jb25maWcuc29ydCA9IHNvcnQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbmNsdWRlIGNoaWxkIHJlbGF0aW9uc2hpcCBxdWVyeVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjaGlsZFJlbE5hbWUgLSBDaGlsZCByZWxhdGlvbnNoaXAgbmFtZSB0byBpbmNsdWRlIGluIHF1ZXJ5IHJlc3VsdFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbY29uZGl0aW9uc10gLSBDb25kaXRpb25zIGluIEpTT04gb2JqZWN0IChNb25nb0RCLWxpa2UpLCBvciByYXcgU09RTCBXSEVSRSBjbGF1c2Ugc3RyaW5nLlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXkuPFN0cmluZz58U3RyaW5nfSBbZmllbGRzXSAtIEZpZWxkcyB0byBmZXRjaC4gRm9ybWF0IGNhbiBiZSBpbiBKU09OIG9iamVjdCAoTW9uZ29EQi1saWtlKSwgYXJyYXkgb2YgZmllbGQgbmFtZXMsIG9yIGNvbW1hLXNlcGFyYXRlZCBmaWVsZCBuYW1lcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBxdWVyeSBjb25maWd1bGF0aW9ucy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5saW1pdF0gLSBNYXhpbXVtIG51bWJlciBvZiByZWNvcmRzIHRoZSBxdWVyeSB3aWxsIHJldHVybi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRdIC0gT2Zmc2V0IG51bWJlciB3aGVyZSBiZWdpbnMgcmV0dXJuaW5nIHJlc3VsdHMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2tpcF0gLSBTeW5vbnltIG9mIG9wdGlvbnMub2Zmc2V0LlxuICogQHJldHVybnMge1F1ZXJ5flN1YlF1ZXJ5fVxuICovXG5RdWVyeS5wcm90b3R5cGUuaW5jbHVkZSA9IGZ1bmN0aW9uKGNoaWxkUmVsTmFtZSwgY29uZGl0aW9ucywgZmllbGRzLCBvcHRpb25zKSB7XG4gIGlmICh0aGlzLl9zb3FsKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgaW5jbHVkZSBjaGlsZCByZWxhdGlvbnNoaXAgaW50byB0aGUgcXVlcnkgd2hpY2ggaGFzIGFscmVhZHkgYnVpbHQgU09RTC5cIik7XG4gIH1cbiAgaWYgKF8uaXNPYmplY3QoY2hpbGRSZWxOYW1lKSkge1xuICAgIHZhciBpbmNsdWRlcyA9IGNoaWxkUmVsTmFtZTtcbiAgICBmb3IgKHZhciBjcm5hbWUgaW4gaW5jbHVkZXMpIHtcbiAgICAgIHZhciBjb25maWcgPSBpbmNsdWRlc1tjcm5hbWVdO1xuICAgICAgdGhpcy5pbmNsdWRlKGNybmFtZSwgY29uZmlnLmNvbmRpdGlvbnMsIGNvbmZpZy5maWVsZHMsIGNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRDb25maWcgPSB7XG4gICAgdGFibGU6IGNoaWxkUmVsTmFtZSxcbiAgICBjb25kaXRpb25zOiBjb25kaXRpb25zLFxuICAgIGZpZWxkczogZmllbGRzLFxuICAgIGxpbWl0OiBvcHRpb25zICYmIG9wdGlvbnMubGltaXQsXG4gICAgb2Zmc2V0OiBvcHRpb25zICYmIChvcHRpb25zLm9mZnNldCB8fCBvcHRpb25zLnNraXApLFxuICAgIHNvcnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5zb3J0XG4gIH07XG4gIGlmICghXy5pc0FycmF5KHRoaXMuX2NvbmZpZy5pbmNsdWRlcykpIHRoaXMuX2NvbmZpZy5pbmNsdWRlcyA9IFtdO1xuICB0aGlzLl9jb25maWcuaW5jbHVkZXMucHVzaChjaGlsZENvbmZpZyk7XG4gIHZhciBjaGlsZFF1ZXJ5ID0gbmV3IFN1YlF1ZXJ5KHRoaXMuX2Nvbm4sIHRoaXMsIGNoaWxkQ29uZmlnKTtcbiAgdGhpcy5fY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbiB8fCBbXTtcbiAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZFF1ZXJ5KTtcbiAgcmV0dXJuIGNoaWxkUXVlcnk7XG59O1xuXG5cbi8qKlxuICogU2V0dGluZyBtYXhGZXRjaCBxdWVyeSBvcHRpb25cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4RmV0Y2ggLSBNYXggZmV0Y2hpbmcgcmVjb3JkcyBpbiBhdXRvIGZldGNoIG1vZGVcbiAqIEByZXR1cm5zIHtRdWVyeS48VD59XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5tYXhGZXRjaCA9IGZ1bmN0aW9uKG1heEZldGNoKSB7XG4gIHRoaXMuX29wdGlvbnMubWF4RmV0Y2ggPSBtYXhGZXRjaDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN3aXRjaGluZyBhdXRvIGZldGNoIG1vZGVcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGF1dG9GZXRjaCAtIFVzaW5nIGF1dG8gZmV0Y2ggbW9kZSBvciBub3RcbiAqIEByZXR1cm5zIHtRdWVyeS48VD59XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5hdXRvRmV0Y2ggPSBmdW5jdGlvbihhdXRvRmV0Y2gpIHtcbiAgdGhpcy5fb3B0aW9ucy5hdXRvRmV0Y2ggPSBhdXRvRmV0Y2g7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgZmxhZyB0byBzY2FuIGFsbCByZWNvcmRzIGluY2x1ZGluZyBkZWxldGVkIGFuZCBhcmNoaXZlZC5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNjYW5BbGwgLSBGbGFnIHdoZXRoZXIgaW5jbHVkZSBkZWxldGVkL2FyY2hpdmVkIHJlY29yZCBvciBub3QuIERlZmF1bHQgaXMgZmFsc2UuXG4gKiBAcmV0dXJucyB7UXVlcnkuPFQ+fVxuICovXG5RdWVyeS5wcm90b3R5cGUuc2NhbkFsbCA9IGZ1bmN0aW9uKHNjYW5BbGwpIHtcbiAgdGhpcy5fb3B0aW9ucy5zY2FuQWxsID0gc2NhbkFsbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBSZXNwb25zZVRhcmdldHMgPSBRdWVyeS5SZXNwb25zZVRhcmdldHMgPSB7fTtcblsgXCJRdWVyeVJlc3VsdFwiLCBcIlJlY29yZHNcIiwgXCJTaW5nbGVSZWNvcmRcIiwgXCJDb3VudFwiIF0uZm9yRWFjaChmdW5jdGlvbihmKSB7XG4gIFJlc3BvbnNlVGFyZ2V0c1tmXSA9IGY7XG59KTtcblxuLyoqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVzcG9uc2VUYXJnZXQgLSBRdWVyeSByZXNwb25zZSB0YXJnZXRcbiAqIEByZXR1cm5zIHtRdWVyeS48Uz59XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5zZXRSZXNwb25zZVRhcmdldCA9IGZ1bmN0aW9uKHJlc3BvbnNlVGFyZ2V0KSB7XG4gIGlmIChyZXNwb25zZVRhcmdldCBpbiBSZXNwb25zZVRhcmdldHMpIHtcbiAgICB0aGlzLl9vcHRpb25zLnJlc3BvbnNlVGFyZ2V0ID0gcmVzcG9uc2VUYXJnZXQ7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogU3lub255bSBvZiBRdWVyeSNleGVjdXRlKClcbiAqXG4gKiBAbWV0aG9kIFF1ZXJ5I3J1blxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFF1ZXJ5IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b0ZldGNoXSAtIFVzaW5nIGF1dG8gZmV0Y2ggbW9kZSBvciBub3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhGZXRjaF0gLSBNYXggZmV0Y2hpbmcgcmVjb3JkcyBpbiBhdXRvIGZldGNoIG1vZGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2NhbkFsbF0gLSBJbmNsdWRpbmcgZGVsZXRlZCByZWNvcmRzIGZvciBxdWVyeSB0YXJnZXQgb3Igbm90XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gLSBBZGRpdGlvbmFsIEhUVFAgcmVxdWVzdCBoZWFkZXJzIHNlbnQgaW4gcXVlcnkgcmVxdWVzdFxuICogQHBhcmFtIHtDYWxsYmFjay48VD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1F1ZXJ5LjxUPn1cbiAqL1xuUXVlcnkucHJvdG90eXBlLnJ1biA9XG4vKipcbiAqIFN5bm9ueW0gb2YgUXVlcnkjZXhlY3V0ZSgpXG4gKlxuICogQG1ldGhvZCBRdWVyeSNleGVjXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gUXVlcnkgb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvRmV0Y2hdIC0gVXNpbmcgYXV0byBmZXRjaCBtb2RlIG9yIG5vdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEZldGNoXSAtIE1heCBmZXRjaGluZyByZWNvcmRzIGluIGF1dG8gZmV0Y2ggbW9kZVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zY2FuQWxsXSAtIEluY2x1ZGluZyBkZWxldGVkIHJlY29yZHMgZm9yIHF1ZXJ5IHRhcmdldCBvciBub3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgSFRUUCByZXF1ZXN0IGhlYWRlcnMgc2VudCBpbiBxdWVyeSByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxUPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UXVlcnkuPFQ+fVxuICovXG5RdWVyeS5wcm90b3R5cGUuZXhlYyA9XG4vKipcbiAqIEV4ZWN1dGUgcXVlcnkgYW5kIGZldGNoIHJlY29yZHMgZnJvbSBzZXJ2ZXIuXG4gKlxuICogQG1ldGhvZCBRdWVyeSNleGVjdXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gUXVlcnkgb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvRmV0Y2hdIC0gVXNpbmcgYXV0byBmZXRjaCBtb2RlIG9yIG5vdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEZldGNoXSAtIE1heCBmZXRjaGluZyByZWNvcmRzIGluIGF1dG8gZmV0Y2ggbW9kZVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zY2FuQWxsXSAtIEluY2x1ZGluZyBkZWxldGVkIHJlY29yZHMgZm9yIHF1ZXJ5IHRhcmdldCBvciBub3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgSFRUUCByZXF1ZXN0IGhlYWRlcnMgc2VudCBpbiBxdWVyeSByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxUPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UXVlcnkuPFQ+fVxuICovXG5RdWVyeS5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxvZ2dlciA9IHRoaXMuX2Nvbm4uX2xvZ2dlcjtcbiAgdmFyIGRlZmVycmVkID0gdGhpcy5fZGVmZXJyZWQ7XG5cbiAgaWYgKHRoaXMuX2V4ZWN1dGVkKSB7XG4gICAgZGVmZXJyZWQucmVqZWN0KG5ldyBFcnJvcihcInJlLWV4ZWN1dGluZyBhbHJlYWR5IGV4ZWN1dGVkIHF1ZXJ5XCIpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICh0aGlzLl9maW5pc2hlZCkge1xuICAgIGRlZmVycmVkLnJlamVjdChuZXcgRXJyb3IoXCJleGVjdXRpbmcgYWxyZWFkeSBjbG9zZWQgcXVlcnlcIikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zID0ge1xuICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyB8fCBzZWxmLl9vcHRpb25zLmhlYWRlcnMsXG4gICAgcmVzcG9uc2VUYXJnZXQ6IG9wdGlvbnMucmVzcG9uc2VUYXJnZXQgfHwgc2VsZi5fb3B0aW9ucy5yZXNwb25zZVRhcmdldCxcbiAgICBhdXRvRmV0Y2g6IG9wdGlvbnMuYXV0b0ZldGNoIHx8IHNlbGYuX29wdGlvbnMuYXV0b0ZldGNoLFxuICAgIG1heEZldGNoOiBvcHRpb25zLm1heEZldGNoIHx8IHNlbGYuX29wdGlvbnMubWF4RmV0Y2gsXG4gICAgc2NhbkFsbDogb3B0aW9ucy5zY2FuQWxsIHx8IHNlbGYuX29wdGlvbnMuc2NhbkFsbFxuICB9O1xuXG4gIC8vIGNhbGxiYWNrIGFuZCBwcm9taXNlIHJlc29sdXRpb247XG4gIHZhciBwcm9taXNlQ2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIHJlcykge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXMgPSBjYWxsYmFjayhlcnIsIHJlcyk7XG4gICAgICAgIGVyciA9IG51bGw7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZXJyID0gZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVycikge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzKTtcbiAgICB9XG4gIH07XG4gIHRoaXMub25jZSgncmVzcG9uc2UnLCBmdW5jdGlvbihyZXMpIHtcbiAgICBwcm9taXNlQ2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgfSk7XG4gIHRoaXMub25jZSgnZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICBwcm9taXNlQ2FsbGJhY2soZXJyKTtcbiAgfSk7XG5cbiAgLy8gY29sbGVjdCBmZXRjaGVkIHJlY29yZHMgaW4gYXJyYXlcbiAgLy8gb25seSB3aGVuIHJlc3BvbnNlIHRhcmdldCBpcyBSZWNvcmRzIGFuZFxuICAvLyBlaXRoZXIgY2FsbGJhY2sgb3IgY2hhaW5pbmcgcHJvbWlzZXMgYXJlIGF2YWlsYWJsZSB0byB0aGlzIHF1ZXJ5LlxuICB0aGlzLm9uY2UoJ2ZldGNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKG9wdGlvbnMucmVzcG9uc2VUYXJnZXQgPT09IFJlc3BvbnNlVGFyZ2V0cy5SZWNvcmRzICYmIChzZWxmLl9jaGFpbmluZyB8fCBjYWxsYmFjaykpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnLS0tIGNvbGxlY3RpbmcgYWxsIGZldGNoZWQgcmVjb3JkcyAtLS0nKTtcbiAgICAgIHZhciByZWNvcmRzID0gW107XG4gICAgICB2YXIgb25SZWNvcmQgPSBmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgICAgcmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gICAgICB9O1xuICAgICAgc2VsZi5vbigncmVjb3JkJywgb25SZWNvcmQpO1xuICAgICAgc2VsZi5vbmNlKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigncmVjb3JkJywgb25SZWNvcmQpO1xuICAgICAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVjb3Jkcywgc2VsZik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGZsYWcgdG8gcHJldmVudCByZS1leGVjdXRpb25cbiAgdGhpcy5fZXhlY3V0ZWQgPSB0cnVlO1xuXG4gIC8vIHN0YXJ0IGFjdHVhbCBxdWVyeVxuICBsb2dnZXIuZGVidWcoJz4+PiBRdWVyeSBzdGFydCA+Pj4nKTtcbiAgdGhpcy5fZXhlY3V0ZShvcHRpb25zKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIGxvZ2dlci5kZWJ1ZygnKioqIFF1ZXJ5IGZpbmlzaGVkICoqKicpO1xuICB9KS5mYWlsKGZ1bmN0aW9uKGVycikge1xuICAgIGxvZ2dlci5kZWJ1ZygnLS0tIFF1ZXJ5IGVycm9yIC0tLScpO1xuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9KTtcblxuICAvLyByZXR1cm4gUXVlcnkgaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5RdWVyeS5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxvZ2dlciA9IHRoaXMuX2Nvbm4uX2xvZ2dlcjtcbiAgdmFyIHJlc3BvbnNlVGFyZ2V0ID0gb3B0aW9ucy5yZXNwb25zZVRhcmdldDtcbiAgdmFyIGF1dG9GZXRjaCA9IG9wdGlvbnMuYXV0b0ZldGNoO1xuICB2YXIgbWF4RmV0Y2ggPSBvcHRpb25zLm1heEZldGNoO1xuICB2YXIgc2NhbkFsbCA9IG9wdGlvbnMuc2NhbkFsbDtcblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgIHNlbGYuX2xvY2F0b3IgP1xuICAgIHNlbGYuX2Nvbm4uX2Jhc2VVcmwoKSArIFwiL3F1ZXJ5L1wiICsgc2VsZi5fbG9jYXRvciA6XG4gICAgc2VsZi50b1NPUUwoKS50aGVuKGZ1bmN0aW9uKHNvcWwpIHtcbiAgICAgIHNlbGYudG90YWxGZXRjaGVkID0gMDtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcIlNPUUwgPSBcIiArIHNvcWwpO1xuICAgICAgcmV0dXJuIHNlbGYuX2Nvbm4uX2Jhc2VVcmwoKSArIFwiL1wiICsgKHNjYW5BbGwgPyBcInF1ZXJ5QWxsXCIgOiBcInF1ZXJ5XCIpICsgXCI/cT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChzb3FsKTtcbiAgICB9KVxuICApLnRoZW4oZnVuY3Rpb24odXJsKSB7XG4gICAgcmV0dXJuIHNlbGYuX2Nvbm4ucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9KTtcbiAgfSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgc2VsZi5lbWl0KFwiZmV0Y2hcIik7XG4gICAgc2VsZi50b3RhbFNpemUgPSBkYXRhLnRvdGFsU2l6ZTtcbiAgICB2YXIgcmVzO1xuICAgIHN3aXRjaChyZXNwb25zZVRhcmdldCkge1xuICAgICAgY2FzZSBSZXNwb25zZVRhcmdldHMuU2luZ2xlUmVjb3JkOlxuICAgICAgICByZXMgPSBkYXRhLnJlY29yZHMgJiYgZGF0YS5yZWNvcmRzLmxlbmd0aCA+IDAgPyBkYXRhLnJlY29yZHNbMF0gOiBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUmVzcG9uc2VUYXJnZXRzLlJlY29yZHM6XG4gICAgICAgIHJlcyA9IGRhdGEucmVjb3JkcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJlc3BvbnNlVGFyZ2V0cy5Db3VudDpcbiAgICAgICAgcmVzID0gZGF0YS50b3RhbFNpemU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzID0gZGF0YTtcbiAgICB9XG4gICAgLy8gb25seSBmaXJlIHJlc3BvbnNlIGV2ZW50IHdoZW4gaXQgc2hvdWxkIGJlIG5vdGlmaWVkIHBlciBmZXRjaFxuICAgIGlmIChyZXNwb25zZVRhcmdldCAhPT0gUmVzcG9uc2VUYXJnZXRzLlJlY29yZHMpIHtcbiAgICAgIHNlbGYuZW1pdChcInJlc3BvbnNlXCIsIHJlcywgc2VsZik7XG4gICAgfVxuXG4gICAgLy8gc3RyZWFtaW5nIHJlY29yZCBpbnN0YW5jZXNcbiAgICB2YXIgbnVtUmVjb3JkcyA9IChkYXRhLnJlY29yZHMgJiYgZGF0YS5yZWNvcmRzLmxlbmd0aCkgfHwgMDtcbiAgICBmb3IgKHZhciBpPTA7IGk8bnVtUmVjb3JkczsgaSsrKSB7XG4gICAgICBpZiAoc2VsZi50b3RhbEZldGNoZWQgPj0gbWF4RmV0Y2gpIHtcbiAgICAgICAgc2VsZi5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhciByZWNvcmQgPSBkYXRhLnJlY29yZHNbaV07XG4gICAgICBzZWxmLnB1c2gocmVjb3JkKTtcbiAgICAgIHNlbGYuZW1pdCgncmVjb3JkJywgcmVjb3JkLCBzZWxmLnRvdGFsRmV0Y2hlZCsrLCBzZWxmKTtcbiAgICB9XG4gICAgaWYgKGRhdGEubmV4dFJlY29yZHNVcmwpIHtcbiAgICAgIHNlbGYuX2xvY2F0b3IgPSBkYXRhLm5leHRSZWNvcmRzVXJsLnNwbGl0KCcvJykucG9wKCk7XG4gICAgfVxuICAgIHNlbGYuX2ZpbmlzaGVkID0gc2VsZi5fZmluaXNoZWQgfHwgZGF0YS5kb25lIHx8ICFhdXRvRmV0Y2g7XG4gICAgaWYgKHNlbGYuX2ZpbmlzaGVkKSB7XG4gICAgICBzZWxmLnB1c2gobnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuX2V4ZWN1dGUob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWFkYWJsZSBzdHJlYW0gaW1wbGVtZW50YXRpb25cbiAqXG4gKiBAb3ZlcnJpZGVcbiAqIEBwcml2YXRlXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYgKCF0aGlzLl9maW5pc2hlZCAmJiAhdGhpcy5fZXhlY3V0ZWQpIHtcbiAgICB0aGlzLmV4ZWN1dGUoeyBhdXRvRmV0Y2g6IHRydWUgfSk7XG4gIH1cbn07XG5cbi8qKiBAb3ZlcnJpZGUgKiovXG5RdWVyeS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihlLCBmbikge1xuICBpZiAoZSA9PT0gJ3JlY29yZCcpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5vbigncmVhZGFibGUnLCBmdW5jdGlvbigpIHtcbiAgICAgIHdoaWxlKHNlbGYucmVhZCgpICE9PSBudWxsKSB7fSAvLyBkaXNjYXJkIGJ1ZmZlcmVkIHJlY29yZHNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gUXVlcnkuc3VwZXJfLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGUsIGZuKTtcbn07XG5cbi8qKiBAb3ZlcnJpZGUgKiovXG5RdWVyeS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBRdWVyeS5wcm90b3R5cGUub247XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5RdWVyeS5wcm90b3R5cGUuX2V4cGFuZEZpZWxkcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fc29xbCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJDYW5ub3QgZXhwYW5kIGZpZWxkcyBmb3IgdGhlIHF1ZXJ5IHdoaWNoIGhhcyBhbHJlYWR5IGJ1aWx0IFNPUUwuXCIpKTtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsb2dnZXIgPSBzZWxmLl9jb25uLl9sb2dnZXI7XG4gIHZhciBjb25uID0gdGhpcy5fY29ubjtcbiAgdmFyIHRhYmxlID0gdGhpcy5fY29uZmlnLnRhYmxlO1xuICB2YXIgZmllbGRzID0gdGhpcy5fY29uZmlnLmZpZWxkcyB8fCBbXTtcblxuICBsb2dnZXIuZGVidWcoJ19leHBhbmRGaWVsZHM6IHRhYmxlID0gJyArIHRhYmxlICsgJywgZmllbGRzID0gJyArIGZpZWxkcy5qb2luKCcsICcpKTtcblxuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIFByb21pc2UucmVzb2x2ZShzZWxmLl9wYXJlbnQgPyBmaW5kUmVsYXRpb25UYWJsZSh0YWJsZSkgOiB0YWJsZSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHRhYmxlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgICBfLm1hcChmaWVsZHMsIGZ1bmN0aW9uKGZpZWxkKSB7IHJldHVybiBleHBhbmRBc3Rlcmlza0ZpZWxkKHRhYmxlLCBmaWVsZCk7IH0pXG4gICAgICAgICkudGhlbihmdW5jdGlvbihleHBhbmRlZEZpZWxkcykge1xuICAgICAgICAgIHNlbGYuX2NvbmZpZy5maWVsZHMgPSBfLmZsYXR0ZW4oZXhwYW5kZWRGaWVsZHMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgIFByb21pc2UuYWxsKFxuICAgICAgXy5tYXAoc2VsZi5fY2hpbGRyZW4gfHwgW10sIGZ1bmN0aW9uKGNoaWxkUXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkUXVlcnkuX2V4cGFuZEZpZWxkcygpO1xuICAgICAgfSlcbiAgICApXG4gIF0pO1xuXG4gIGZ1bmN0aW9uIGZpbmRSZWxhdGlvblRhYmxlKHJuYW1lKSB7XG4gICAgdmFyIHB0YWJsZSA9IHNlbGYuX3BhcmVudC5fY29uZmlnLnRhYmxlO1xuICAgIGxvZ2dlci5kZWJ1ZygnZmluZGluZyB0YWJsZSBmb3IgcmVsYXRpb24gXCInICsgcm5hbWUgKyAnXCIgaW4gXCInICsgcHRhYmxlICsgJ1wiLi4uJyk7XG4gICAgcmV0dXJuIGRlc2NyaWJlQ2FjaGUocHRhYmxlKS50aGVuKGZ1bmN0aW9uKHNvYmplY3QpIHtcbiAgICAgIHZhciB1cHBlclJuYW1lID0gcm5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgIHZhciBjaGlsZFJlbGF0aW9uID0gXy5maW5kKHNvYmplY3QuY2hpbGRSZWxhdGlvbnNoaXBzLCBmdW5jdGlvbihjcikge1xuICAgICAgICByZXR1cm4gKGNyLnJlbGF0aW9uc2hpcE5hbWUgfHwgJycpLnRvVXBwZXJDYXNlKCkgPT09IHVwcGVyUm5hbWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjaGlsZFJlbGF0aW9uID8gY2hpbGRSZWxhdGlvbi5jaGlsZFNPYmplY3QgOlxuICAgICAgICBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyBjaGlsZCByZWxhdGlvbnNoaXAgZm91bmQ6IFwiICsgcm5hbWUgKSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUNhY2hlKHRhYmxlKSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdkZXNjcmliZSBjYWNoZTogJyt0YWJsZSk7XG4gICAgdmFyIGRlZmVycmVkID0gUHJvbWlzZS5kZWZlcigpO1xuICAgIGNvbm4uZGVzY3JpYmUkKHRhYmxlLCBmdW5jdGlvbihlcnIsIHNvYmplY3QpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnLi4uIGRvbmUuJyk7XG4gICAgICBpZiAoZXJyKSB7IGRlZmVycmVkLnJlamVjdChlcnIpOyB9XG4gICAgICBlbHNlIHsgZGVmZXJyZWQucmVzb2x2ZShzb2JqZWN0KTsgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwYW5kQXN0ZXJpc2tGaWVsZCh0YWJsZSwgZmllbGQpIHtcbiAgICBsb2dnZXIuZGVidWcoJ2V4cGFuZGluZyBmaWVsZCBcIicrIGZpZWxkICsgJ1wiIGluIFwiJyArIHRhYmxlICsgJ1wiLi4uJyk7XG4gICAgdmFyIGZwYXRoID0gZmllbGQuc3BsaXQoJy4nKTtcbiAgICByZXR1cm4gZnBhdGhbZnBhdGgubGVuZ3RoIC0gMV0gPT09ICcqJyA/XG4gICAgICBkZXNjcmliZUNhY2hlKHRhYmxlKS50aGVuKGZ1bmN0aW9uKHNvYmplY3QpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd0YWJsZSAnK3RhYmxlKydoYXMgYmVlbiBkZXNjcmliZWQnKTtcbiAgICAgICAgaWYgKGZwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB2YXIgcm5hbWUgPSBmcGF0aC5zaGlmdCgpO1xuICAgICAgICAgIHZhciByZmllbGQgPSBfLmZpbmQoc29iamVjdC5maWVsZHMsIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmLnJlbGF0aW9uc2hpcE5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICBmLnJlbGF0aW9uc2hpcE5hbWUudG9VcHBlckNhc2UoKSA9PT0gcm5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocmZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgcnRhYmxlID0gcmZpZWxkLnJlZmVyZW5jZVRvLmxlbmd0aCA9PT0gMSA/IHJmaWVsZC5yZWZlcmVuY2VUb1swXSA6ICdOYW1lJztcbiAgICAgICAgICAgIHJldHVybiBleHBhbmRBc3Rlcmlza0ZpZWxkKHJ0YWJsZSwgZnBhdGguam9pbignLicpKS50aGVuKGZ1bmN0aW9uKGZwYXRocykge1xuICAgICAgICAgICAgICByZXR1cm4gXy5tYXAoZnBhdGhzLCBmdW5jdGlvbihmcGF0aCkgeyByZXR1cm4gcm5hbWUgKyAnLicgKyBmcGF0aDsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gXy5tYXAoc29iamVjdC5maWVsZHMsIGZ1bmN0aW9uKGYpIHsgcmV0dXJuIGYubmFtZTsgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pIDpcbiAgICAgIFByb21pc2UucmVzb2x2ZShbIGZpZWxkIF0pO1xuICB9XG59O1xuXG4vKipcbiAqIEV4cGxhaW4gcGxhbiBmb3IgZXhlY3V0aW5nIHF1ZXJ5XG4gKlxuICogQHBhcmFtIHtDYWxsYmFjay48RXhwbGFpbkluZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxFeHBsYWluSW5mbz59XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5leHBsYWluID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbG9nZ2VyID0gdGhpcy5fY29ubi5fbG9nZ2VyO1xuICByZXR1cm4gc2VsZi50b1NPUUwoKS50aGVuKGZ1bmN0aW9uKHNvcWwpIHtcbiAgICBsb2dnZXIuZGVidWcoXCJTT1FMID0gXCIgKyBzb3FsKTtcbiAgICB2YXIgdXJsID0gXCIvcXVlcnkvP2V4cGxhaW49XCIgKyBlbmNvZGVVUklDb21wb25lbnQoc29xbCk7XG4gICAgcmV0dXJuIHNlbGYuX2Nvbm4ucmVxdWVzdCh1cmwpO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHVybiBTT1FMIGV4cHJlc3Npb24gZm9yIHRoZSBxdWVyeVxuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFN0cmluZz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFN0cmluZz59XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS50b1NPUUwgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VsZi5fc29xbCB8fFxuICAgIHNlbGYuX2V4cGFuZEZpZWxkcygpLnRoZW4oZnVuY3Rpb24oKSB7IHJldHVybiBTT1FMQnVpbGRlci5jcmVhdGVTT1FMKHNlbGYuX2NvbmZpZyk7IH0pXG4gICkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgZGF0YSBzdHJlYW0gb2YgcXVlcmllZCByZWNvcmRzLlxuICogQXV0b21hdGljYWxseSByZXN1bWUgcXVlcnkgaWYgcGF1c2VkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gLSBUeXBlIG9mIG91dGdvaW5nIGRhdGEgZm9ybWF0LiBDdXJyZW50bHkgJ2NzdicgaXMgZGVmYXVsdCB2YWx1ZSBhbmQgdGhlIG9ubHkgc3VwcG9ydGVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFzc2VkIHRvIGNvbnZlcnRlclxuICogQHJldHVybnMge3N0cmVhbS5SZWFkYWJsZX1cbiAqL1xuUXVlcnkucHJvdG90eXBlLnN0cmVhbSA9IFJlY29yZFN0cmVhbS5TZXJpYWxpemFibGUucHJvdG90eXBlLnN0cmVhbTtcblxuLyoqXG4gKiBHZXQgcmVjb3JkIHN0cmVhbSBvZiBxdWVyaWVkIHJlY29yZHMgYXBwbHlpbmcgdGhlIGdpdmVuIG1hcHBpbmcgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge1JlY29yZE1hcEZ1bmN0aW9ufSBmbiAtIFJlY29yZCBtYXBwaW5nIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UmVjb3JkU3RyZWFtLlNlcmlhbGl6YWJsZX1cbiAqL1xuUXVlcnkucHJvdG90eXBlLm1hcCA9IFJlY29yZFN0cmVhbS5wcm90b3R5cGUubWFwO1xuXG4vKipcbiAqIEdldCByZWNvcmQgc3RyZWFtIG9mIHF1ZXJpZWQgcmVjb3JkcywgYXBwbHlpbmcgdGhlIGdpdmVuIGZpbHRlciBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7UmVjb3JkRmlsdGVyRnVuY3Rpb259IGZuIC0gUmVjb3JkIGZpbHRlcmluZyBmdW5jdGlvblxuICogQHJldHVybnMge1JlY29yZFN0cmVhbS5TZXJpYWxpemFibGV9XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5maWx0ZXIgPSBSZWNvcmRTdHJlYW0ucHJvdG90eXBlLm1hcDtcblxuLypcbiAqIERlZmF1bHQgdGhyZXNob2xkIG51bSBvZiBidWxrIEFQSSBzd2l0Y2hpbmdcbiAqL1xudmFyIERFRkFVTFRfQlVMS19USFJFU0hPTEQgPSAyMDA7XG5cbi8qKlxuICogU3lub255bSBvZiBRdWVyeSNkZXN0cm95KClcbiAqXG4gKiBAbWV0aG9kIFF1ZXJ5I2RlbGV0ZVxuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAtIFNPYmplY3QgdHlwZS4gUmVxdWlyZWQgZm9yIFNPUUwgYmFzZWQgcXVlcnkgb2JqZWN0LlxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cbi8qKlxuICogU3lub255bSBvZiBRdWVyeSNkZXN0cm95KClcbiAqXG4gKiBAbWV0aG9kIFF1ZXJ5I2RlbFxuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAtIFNPYmplY3QgdHlwZS4gUmVxdWlyZWQgZm9yIFNPUUwgYmFzZWQgcXVlcnkgb2JqZWN0LlxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cbi8qKlxuICogRGVsZXRlIHF1ZXJpZWQgcmVjb3Jkc1xuICpcbiAqIEBtZXRob2QgUXVlcnkjZGVzdHJveVxuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAtIFNPYmplY3QgdHlwZS4gUmVxdWlyZWQgZm9yIFNPUUwgYmFzZWQgcXVlcnkgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE1hc3MgZGVsZXRlIG9wZXJhdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93QnVsa10gLSBBbGxvdyBzd2l0Y2hpbmcgdG8gQnVsayBBUEkgd2hlbiB0aGUgbnVtIG9mIHF1ZXJpZWQgcmVjb3JkcyByZWFjaGVkIHRvIGNlcnRhaW4gdGhyZXNob2xkLiBEZWZhdWx0IGlzIHRydWUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnVsa1RocmVzaG9sZF0gLSBUaHJlc2hvbGQgbnVtIHRvIHN3aXRjaCB0byB1c2UgQnVsayBBUEkgaW5zdGVhZCBvZiB1c3VhbCBgU09iamVjdCNkZWxldGUoKWAgY2FsbC4gRGVmYXVsdCB2YWx1ZSBpcyAyMDAgYWZ0ZXIgQVBJIHZlciA0Mi4wLCBhbmQgMC41ICogYG1heFJlcXVlc3RgIGJlZm9yZSBBUEkgdmVyIDQyLjAuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuUXVlcnkucHJvdG90eXBlW1wiZGVsZXRlXCJdID1cblF1ZXJ5LnByb3RvdHlwZS5kZWwgPVxuUXVlcnkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbih0eXBlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHR5cGU7XG4gICAgb3B0aW9ucyA9IHt9O1xuICAgIHR5cGUgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB0eXBlO1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0eXBlID0gdHlwZSB8fCAodGhpcy5fY29uZmlnICYmIHRoaXMuX2NvbmZpZy50YWJsZSk7XG4gIGlmICghdHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNPUUwgYmFzZWQgcXVlcnkgbmVlZHMgU09iamVjdCB0eXBlIGluZm9ybWF0aW9uIHRvIGJ1bGsgZGVsZXRlLlwiKTtcbiAgfVxuICAvLyBTZXQgdGhlIHRocmVzaG9sZCBudW1iZXIgdG8gcGFzcyB0byBidWxrIEFQSVxuICB2YXIgdGhyZXNob2xkTnVtID1cbiAgICBvcHRpb25zLmFsbG93QnVsayA9PT0gZmFsc2UgP1xuICAgICAgLTEgOlxuICAgIHR5cGVvZiBvcHRpb25zLmJ1bGtUaHJlc2hvbGQgPT09ICdudW1iZXInID9cbiAgICAgIG9wdGlvbnMuYnVsa1RocmVzaG9sZCA6XG4gICAgICAvLyBkZXRlcm1pbmUgdGhyZXNob2xkIGlmIHRoZSBjb25uZWN0aW9uIHZlcnNpb24gc3VwcG9ydHMgU09iamVjdCBjb2xsZWN0aW9uIEFQSSBvciBub3RcbiAgICAgICh0aGlzLl9jb25uLl9lbnN1cmVWZXJzaW9uKDQyKSA/IERFRkFVTFRfQlVMS19USFJFU0hPTEQgOiB0aGlzLl9jb25uLm1heFJlcXVlc3QgLyAyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlY29yZHMgPSBbXTtcbiAgICB2YXIgYmF0Y2ggPSBudWxsO1xuICAgIHZhciBoYW5kbGVSZWNvcmQgPSBmdW5jdGlvbihyZWMpIHtcbiAgICAgIGlmICghcmVjLklkKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1F1ZXJpZWQgcmVjb3JkIGRvZXMgbm90IGluY2x1ZGUgU2FsZXNmb3JjZSByZWNvcmQgSUQuJykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByZWNvcmQgPSB7IElkOiByZWMuSWQgfTtcbiAgICAgIGlmIChiYXRjaCkge1xuICAgICAgICBiYXRjaC53cml0ZShyZWNvcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gICAgICAgIGlmICh0aHJlc2hvbGROdW0gPCAwIHx8IHJlY29yZHMubGVuZ3RoID4gdGhyZXNob2xkTnVtKSB7XG4gICAgICAgICAgLy8gVXNlIGJ1bGsgZGVsZXRlIGluc3RlYWQgb2YgU09iamVjdCBSRVNUIEFQSVxuICAgICAgICAgIGJhdGNoID1cbiAgICAgICAgICAgIHNlbGYuX2Nvbm4uc29iamVjdCh0eXBlKS5kZWxldGVCdWxrKClcbiAgICAgICAgICAgICAgLm9uKCdyZXNwb25zZScsIHJlc29sdmUpXG4gICAgICAgICAgICAgIC5vbignZXJyb3InLCByZWplY3QpO1xuICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgICAgICAgIGJhdGNoLndyaXRlKHJlY29yZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVjb3JkcyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoYmF0Y2gpIHtcbiAgICAgICAgYmF0Y2guZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaWRzID0gcmVjb3Jkcy5tYXAoZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gcmVjb3JkLklkOyB9KTtcbiAgICAgICAgc2VsZi5fY29ubi5zb2JqZWN0KHR5cGUpLmRlc3Ryb3koaWRzLCB7IGFsbG93UmVjdXJzaXZlOiB0cnVlIH0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNlbGYub24oJ2RhdGEnLCBoYW5kbGVSZWNvcmQpXG4gICAgICAub24oJ2VuZCcsIGhhbmRsZUVuZClcbiAgICAgIC5vbignZXJyb3InLCByZWplY3QpO1xuICB9KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBxdWVyaWVkIHJlY29yZHMsIHVzaW5nIGdpdmVuIG1hcHBpbmcgZnVuY3Rpb24vb2JqZWN0XG4gKlxuICogQHBhcmFtIHtSZWNvcmR8UmVjb3JkTWFwRnVuY3Rpb259IG1hcHBpbmcgLSBNYXBwaW5nIHJlY29yZCBvciByZWNvcmQgbWFwcGluZyBmdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAtIFNPYmplY3QgdHlwZS4gUmVxdWlyZWQgZm9yIFNPUUwgYmFzZWQgcXVlcnkgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE1hc3MgdXBkYXRlIG9wZXJhdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93QnVsa10gLSBBbGxvdyBzd2l0Y2hpbmcgdG8gQnVsayBBUEkgd2hlbiB0aGUgbnVtIG9mIHF1ZXJpZWQgcmVjb3JkcyByZWFjaGVkIHRvIGNlcnRhaW4gdGhyZXNob2xkLiBEZWZhdWx0IGlzIHRydWUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnVsa1RocmVzaG9sZF0gLSBUaHJlc2hvbGQgbnVtIHRvIHN3aXRjaCB0byB1c2UgQnVsayBBUEkgaW5zdGVhZCBvZiB1c3VhbCBgU09iamVjdCNkZWxldGUoKWAgY2FsbC4gRGVmYXVsdCB2YWx1ZSBpcyAyMDAgYWZ0ZXIgQVBJIHZlciA0Mi4wLCBhbmQgMC41ICogYG1heFJlcXVlc3RgIGJlZm9yZSBBUEkgdmVyIDQyLjAuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuUXVlcnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG1hcHBpbmcsIHR5cGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gdHlwZTtcbiAgICBvcHRpb25zID0ge307XG4gICAgdHlwZSA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHR5cGU7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHR5cGUgPSB0eXBlIHx8ICh0aGlzLl9jb25maWcgJiYgdGhpcy5fY29uZmlnLnRhYmxlKTtcbiAgaWYgKCF0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU09RTCBiYXNlZCBxdWVyeSBuZWVkcyBTT2JqZWN0IHR5cGUgaW5mb3JtYXRpb24gdG8gYnVsayB1cGRhdGUuXCIpO1xuICB9XG4gIHZhciB1cGRhdGVTdHJlYW0gPSBfLmlzRnVuY3Rpb24obWFwcGluZykgPyBSZWNvcmRTdHJlYW0ubWFwKG1hcHBpbmcpIDogUmVjb3JkU3RyZWFtLnJlY29yZE1hcFN0cmVhbShtYXBwaW5nKTtcbiAgLy8gU2V0IHRoZSB0aHJlc2hvbGQgbnVtYmVyIHRvIHBhc3MgdG8gYnVsayBBUElcbiAgdmFyIHRocmVzaG9sZE51bSA9XG4gICAgb3B0aW9ucy5hbGxvd0J1bGsgPT09IGZhbHNlID9cbiAgICAgIC0xIDpcbiAgICB0eXBlb2Ygb3B0aW9ucy5idWxrVGhyZXNob2xkID09PSAnbnVtYmVyJyA/XG4gICAgICBvcHRpb25zLmJ1bGtUaHJlc2hvbGQgOlxuICAgICAgLy8gZGV0ZXJtaW5lIHRocmVzaG9sZCBpZiB0aGUgY29ubmVjdGlvbiB2ZXJzaW9uIHN1cHBvcnRzIFNPYmplY3QgY29sbGVjdGlvbiBBUEkgb3Igbm90XG4gICAgICAodGhpcy5fY29ubi5fZW5zdXJlVmVyc2lvbig0MikgPyBERUZBVUxUX0JVTEtfVEhSRVNIT0xEIDogdGhpcy5fY29ubi5tYXhSZXF1ZXN0IC8gMik7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZWNvcmRzID0gW107XG4gICAgdmFyIGJhdGNoID0gbnVsbDtcbiAgICB2YXIgaGFuZGxlUmVjb3JkID0gZnVuY3Rpb24ocmVjb3JkKSB7XG4gICAgICBpZiAoYmF0Y2gpIHtcbiAgICAgICAgYmF0Y2gud3JpdGUocmVjb3JkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY29yZHMucHVzaChyZWNvcmQpO1xuICAgICAgICBpZiAodGhyZXNob2xkTnVtIDwgMCB8fCByZWNvcmRzLmxlbmd0aCA+IHRocmVzaG9sZE51bSkge1xuICAgICAgICAgIC8vIFVzZSBidWxrIHVwZGF0ZSBpbnN0ZWFkIG9mIFNPYmplY3QgUkVTVCBBUElcbiAgICAgICAgICBiYXRjaCA9XG4gICAgICAgICAgICBzZWxmLl9jb25uLnNvYmplY3QodHlwZSkudXBkYXRlQnVsaygpXG4gICAgICAgICAgICAgIC5vbigncmVzcG9uc2UnLCByZXNvbHZlKVxuICAgICAgICAgICAgICAub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24ocmVjb3JkKSB7XG4gICAgICAgICAgICBiYXRjaC53cml0ZShyZWNvcmQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlY29yZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGhhbmRsZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGJhdGNoKSB7XG4gICAgICAgIGJhdGNoLmVuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5fY29ubi5zb2JqZWN0KHR5cGUpLnVwZGF0ZShyZWNvcmRzLCB7IGFsbG93UmVjdXJzaXZlOiB0cnVlIH0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNlbGYub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgLnBpcGUodXBkYXRlU3RyZWFtKVxuICAgICAgLm9uKCdkYXRhJywgaGFuZGxlUmVjb3JkKVxuICAgICAgLm9uKCdlbmQnLCBoYW5kbGVFbmQpXG4gICAgICAub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBQcm9taXNlL0ErIGludGVyZmFjZVxuICogaHR0cDovL3Byb21pc2VzLWFwbHVzLmdpdGh1Yi5pby9wcm9taXNlcy1zcGVjL1xuICpcbiAqIERlbGVnYXRlIHRvIGRlZmVycmVkIHByb21pc2UsIHJldHVybiBwcm9taXNlIGluc3RhbmNlIGZvciBxdWVyeSByZXN1bHRcbiAqXG4gKiBAcGFyYW0ge0Z1bGZpbGxlZENhbGxiYWNrLjxULCBTMT59IFtvbkZ1bGZpbGxlZF1cbiAqIEBwYXJhbSB7UmVqZWN0ZWRDYWxsYmFjay48UzI+fSBbb25SZWplY3RlZF1cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxTMXxTMj59XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25SZXNvbHZlZCwgb25SZWplY3QpIHtcbiAgdGhpcy5fY2hhaW5pbmcgPSB0cnVlO1xuICBpZiAoIXRoaXMuX2ZpbmlzaGVkICYmICF0aGlzLl9leGVjdXRlZCkgeyB0aGlzLmV4ZWN1dGUoKTsgfVxuICByZXR1cm4gdGhpcy5fZGVmZXJyZWQucHJvbWlzZS50aGVuLmFwcGx5KHRoaXMuX2RlZmVycmVkLnByb21pc2UsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFByb21pc2UvQSsgZXh0ZW5zaW9uXG4gKiBDYWxsIFwidGhlblwiIHVzaW5nIGdpdmVuIG5vZGUtc3R5bGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxUPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UXVlcnl9XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS50aGVuQ2FsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIGlmIChfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgdGhpcy50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKlxuICogU3ViUXVlcnkgb2JqZWN0IGZvciByZXByZXNlbnRpbmcgY2hpbGQgcmVsYXRpb25zaGlwIHF1ZXJ5XG4gKlxuICogQHByb3RlY3RlZFxuICogQGNsYXNzIFF1ZXJ5flN1YlF1ZXJ5XG4gKiBAZXh0ZW5kcyBRdWVyeVxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIC0gQ29ubmVjdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7UXVlcnl9IHBhcmVudCAtIFBhcmVudCBxdWVyeSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBTdWIgcXVlcnkgY29uZmlndXJhdGlvblxuICovXG52YXIgU3ViUXVlcnkgPSBmdW5jdGlvbihjb25uLCBwYXJlbnQsIGNvbmZpZykge1xuICBTdWJRdWVyeS5zdXBlcl8uY2FsbCh0aGlzLCBjb25uLCBjb25maWcpO1xuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG59O1xuXG5pbmhlcml0cyhTdWJRdWVyeSwgUXVlcnkpO1xuXG4vKipcbiAqIEBtZXRob2QgUXVlcnl+U3ViUXVlcnkjaW5jbHVkZVxuICogQG92ZXJyaWRlXG4gKi9cblN1YlF1ZXJ5LnByb3RvdHlwZS5pbmNsdWRlID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIk5vdCBhbGxvd2VkIHRvIGluY2x1ZGUgYW5vdGhlciBzdWJxdWVyeSBpbiBzdWJxdWVyeS5cIik7XG59O1xuXG4vKipcbiAqIEJhY2sgdGhlIGNvbnRleHQgdG8gcGFyZW50IHF1ZXJ5IG9iamVjdFxuICpcbiAqIEBtZXRob2QgUXVlcnl+U3ViUXVlcnkjZW5kXG4gKiBAcmV0dXJucyB7UXVlcnl9XG4gKi9cblN1YlF1ZXJ5LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbn07XG5cbi8qKlxuICogSWYgZXhlY3V0ZSBpcyBjYWxsZWQgaW4gc3VicXVlcnkgY29udGV4dCwgZGVsZWdhdGUgaXQgdG8gcGFyZW50IHF1ZXJ5IG9iamVjdFxuICpcbiAqIEBtZXRob2QgUXVlcnl+U3ViUXVlcnkjZXhlY3V0ZVxuICogQG92ZXJyaWRlXG4gKi9cblN1YlF1ZXJ5LnByb3RvdHlwZS5ydW4gPVxuU3ViUXVlcnkucHJvdG90eXBlLmV4ZWMgPVxuU3ViUXVlcnkucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3BhcmVudC5leGVjdXRlLmFwcGx5KHRoaXMuX3BhcmVudCwgYXJndW1lbnRzKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/query.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/quick-action.js":
/*!**************************************************!*\
  !*** ./node_modules/jsforce/lib/quick-action.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * @file Represents Salesforce QuickAction\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\n\n/**\n * A class for quick action\n *\n * @protected\n * @constructor\n */\nvar QuickAction = module.exports = function(conn, path) {\n  this._conn = conn;\n  this._path = path;\n};\n\n/**\n * @typedef {Object} QuickAction~QuickActionInfo\n * @prop {String} type - Type of the action (e.g. Create, Update, Post, LogACall)\n * @prop {String} name - Name of the action\n * @prop {String} label - Label of the action\n * @prop {Object} urls - Endpoint URL information of the action\n */\n/**\n * @typedef {QuickAction~QuickActionInfo} QuickAction~QuickActionDescriveInfo\n * @prop {String} contextSobjectType - Object type used for the action\n * @prop {String} targetSobjectType - Object type of the action to target\n * @prop {String} targetParentField - Field name in the target object which refers parent(context) object record ID.\n * @prop {String} targetRecordTypeId - Record type of the targeted record\n * @prop {Object} layout - Layout sections that comprise an action\n */\n\n/**\n * Describe the action's information (including layout, etc.)\n *\n * @param {Callback.<QuickAction~QuickActionDescriveInfo>} [callback] - Callback function\n * @returns {Promise.<QuickAction~QuickActionDescriveInfo>}\n */\nQuickAction.prototype.describe = function(callback) {\n  var url = this._path + \"/describe\";\n  return this._conn.request(url).thenCall(callback);\n};\n\n/**\n * Retrieve default field values in the action (for given record, if specified)\n *\n * @param {String} [contextId] - ID of record to get default values specific to the record\n * @param {Callback.<Record>} [callback] - Callback function\n * @returns {Promise.<Record>}\n */\nQuickAction.prototype.defaultValues = function(contextId, callback) {\n  if (typeof contextId === 'function') {\n    callback = contextId;\n    contextId = null;\n  }\n  var url = this._path + \"/defaultValues\";\n  if (contextId) {\n    url += \"/\" + contextId;\n  }\n  return this._conn.request(url).thenCall(callback);\n};\n\n/**\n * @typedef {Object} QuickAction~QuickActionResult\n * @param {String} id - Record id of the action result\n * @param {Array.<String>} feedItemIds - List of IDs for feed item\n * @param {Boolean} success - True if the action successfully completed\n * @param {Boolean} created - True if the action yields a new record\n * @param {String} contextId - Context record ID of the action\n * @param {Array.<Object>} errors - Errors if the action failed\n */\n\n/**\n * Execute the action for given context Id and record information\n * \n * @param {String} contextId - Context record ID of the action\n * @param {Record} record - Input record information for the action\n * @param {Callback.<QuickAction~QuickActionResult>} [callback] - Callback function\n * @returns {Promise.<QuickAction~QuickActionResult>}\n */\nQuickAction.prototype.execute = function(contextId, record, callback) {\n  var body = {\n    contextId: contextId,\n    record: record\n  };\n  return this._conn.requestPost(this._path, body).thenCall(callback);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9xdWljay1hY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7OztBQUdiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUMsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdEQUFnRDtBQUMzRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLDBDQUEwQztBQUNyRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcXVpY2stYWN0aW9uLmpzPzkxN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBSZXByZXNlbnRzIFNhbGVzZm9yY2UgUXVpY2tBY3Rpb25cbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vKipcbiAqIEEgY2xhc3MgZm9yIHF1aWNrIGFjdGlvblxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUXVpY2tBY3Rpb24gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbm4sIHBhdGgpIHtcbiAgdGhpcy5fY29ubiA9IGNvbm47XG4gIHRoaXMuX3BhdGggPSBwYXRoO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBRdWlja0FjdGlvbn5RdWlja0FjdGlvbkluZm9cbiAqIEBwcm9wIHtTdHJpbmd9IHR5cGUgLSBUeXBlIG9mIHRoZSBhY3Rpb24gKGUuZy4gQ3JlYXRlLCBVcGRhdGUsIFBvc3QsIExvZ0FDYWxsKVxuICogQHByb3Age1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGFjdGlvblxuICogQHByb3Age1N0cmluZ30gbGFiZWwgLSBMYWJlbCBvZiB0aGUgYWN0aW9uXG4gKiBAcHJvcCB7T2JqZWN0fSB1cmxzIC0gRW5kcG9pbnQgVVJMIGluZm9ybWF0aW9uIG9mIHRoZSBhY3Rpb25cbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7UXVpY2tBY3Rpb25+UXVpY2tBY3Rpb25JbmZvfSBRdWlja0FjdGlvbn5RdWlja0FjdGlvbkRlc2NyaXZlSW5mb1xuICogQHByb3Age1N0cmluZ30gY29udGV4dFNvYmplY3RUeXBlIC0gT2JqZWN0IHR5cGUgdXNlZCBmb3IgdGhlIGFjdGlvblxuICogQHByb3Age1N0cmluZ30gdGFyZ2V0U29iamVjdFR5cGUgLSBPYmplY3QgdHlwZSBvZiB0aGUgYWN0aW9uIHRvIHRhcmdldFxuICogQHByb3Age1N0cmluZ30gdGFyZ2V0UGFyZW50RmllbGQgLSBGaWVsZCBuYW1lIGluIHRoZSB0YXJnZXQgb2JqZWN0IHdoaWNoIHJlZmVycyBwYXJlbnQoY29udGV4dCkgb2JqZWN0IHJlY29yZCBJRC5cbiAqIEBwcm9wIHtTdHJpbmd9IHRhcmdldFJlY29yZFR5cGVJZCAtIFJlY29yZCB0eXBlIG9mIHRoZSB0YXJnZXRlZCByZWNvcmRcbiAqIEBwcm9wIHtPYmplY3R9IGxheW91dCAtIExheW91dCBzZWN0aW9ucyB0aGF0IGNvbXByaXNlIGFuIGFjdGlvblxuICovXG5cbi8qKlxuICogRGVzY3JpYmUgdGhlIGFjdGlvbidzIGluZm9ybWF0aW9uIChpbmNsdWRpbmcgbGF5b3V0LCBldGMuKVxuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFF1aWNrQWN0aW9uflF1aWNrQWN0aW9uRGVzY3JpdmVJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UXVpY2tBY3Rpb25+UXVpY2tBY3Rpb25EZXNjcml2ZUluZm8+fVxuICovXG5RdWlja0FjdGlvbi5wcm90b3R5cGUuZGVzY3JpYmUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgdXJsID0gdGhpcy5fcGF0aCArIFwiL2Rlc2NyaWJlXCI7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIGRlZmF1bHQgZmllbGQgdmFsdWVzIGluIHRoZSBhY3Rpb24gKGZvciBnaXZlbiByZWNvcmQsIGlmIHNwZWNpZmllZClcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NvbnRleHRJZF0gLSBJRCBvZiByZWNvcmQgdG8gZ2V0IGRlZmF1bHQgdmFsdWVzIHNwZWNpZmljIHRvIHRoZSByZWNvcmRcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZD59XG4gKi9cblF1aWNrQWN0aW9uLnByb3RvdHlwZS5kZWZhdWx0VmFsdWVzID0gZnVuY3Rpb24oY29udGV4dElkLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNvbnRleHRJZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gY29udGV4dElkO1xuICAgIGNvbnRleHRJZCA9IG51bGw7XG4gIH1cbiAgdmFyIHVybCA9IHRoaXMuX3BhdGggKyBcIi9kZWZhdWx0VmFsdWVzXCI7XG4gIGlmIChjb250ZXh0SWQpIHtcbiAgICB1cmwgKz0gXCIvXCIgKyBjb250ZXh0SWQ7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdCh1cmwpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUXVpY2tBY3Rpb25+UXVpY2tBY3Rpb25SZXN1bHRcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIFJlY29yZCBpZCBvZiB0aGUgYWN0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gZmVlZEl0ZW1JZHMgLSBMaXN0IG9mIElEcyBmb3IgZmVlZCBpdGVtXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN1Y2Nlc3MgLSBUcnVlIGlmIHRoZSBhY3Rpb24gc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZFxuICogQHBhcmFtIHtCb29sZWFufSBjcmVhdGVkIC0gVHJ1ZSBpZiB0aGUgYWN0aW9uIHlpZWxkcyBhIG5ldyByZWNvcmRcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZXh0SWQgLSBDb250ZXh0IHJlY29yZCBJRCBvZiB0aGUgYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBlcnJvcnMgLSBFcnJvcnMgaWYgdGhlIGFjdGlvbiBmYWlsZWRcbiAqL1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGFjdGlvbiBmb3IgZ2l2ZW4gY29udGV4dCBJZCBhbmQgcmVjb3JkIGluZm9ybWF0aW9uXG4gKiBcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZXh0SWQgLSBDb250ZXh0IHJlY29yZCBJRCBvZiB0aGUgYWN0aW9uXG4gKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkIC0gSW5wdXQgcmVjb3JkIGluZm9ybWF0aW9uIGZvciB0aGUgYWN0aW9uXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxRdWlja0FjdGlvbn5RdWlja0FjdGlvblJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFF1aWNrQWN0aW9uflF1aWNrQWN0aW9uUmVzdWx0Pn1cbiAqL1xuUXVpY2tBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihjb250ZXh0SWQsIHJlY29yZCwgY2FsbGJhY2spIHtcbiAgdmFyIGJvZHkgPSB7XG4gICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgcmVjb3JkOiByZWNvcmRcbiAgfTtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdFBvc3QodGhpcy5fcGF0aCwgYm9keSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/quick-action.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/quick-action.js":
/*!**************************************************!*\
  !*** ./node_modules/jsforce/lib/quick-action.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * @file Represents Salesforce QuickAction\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\n\n/**\n * A class for quick action\n *\n * @protected\n * @constructor\n */\nvar QuickAction = module.exports = function(conn, path) {\n  this._conn = conn;\n  this._path = path;\n};\n\n/**\n * @typedef {Object} QuickAction~QuickActionInfo\n * @prop {String} type - Type of the action (e.g. Create, Update, Post, LogACall)\n * @prop {String} name - Name of the action\n * @prop {String} label - Label of the action\n * @prop {Object} urls - Endpoint URL information of the action\n */\n/**\n * @typedef {QuickAction~QuickActionInfo} QuickAction~QuickActionDescriveInfo\n * @prop {String} contextSobjectType - Object type used for the action\n * @prop {String} targetSobjectType - Object type of the action to target\n * @prop {String} targetParentField - Field name in the target object which refers parent(context) object record ID.\n * @prop {String} targetRecordTypeId - Record type of the targeted record\n * @prop {Object} layout - Layout sections that comprise an action\n */\n\n/**\n * Describe the action's information (including layout, etc.)\n *\n * @param {Callback.<QuickAction~QuickActionDescriveInfo>} [callback] - Callback function\n * @returns {Promise.<QuickAction~QuickActionDescriveInfo>}\n */\nQuickAction.prototype.describe = function(callback) {\n  var url = this._path + \"/describe\";\n  return this._conn.request(url).thenCall(callback);\n};\n\n/**\n * Retrieve default field values in the action (for given record, if specified)\n *\n * @param {String} [contextId] - ID of record to get default values specific to the record\n * @param {Callback.<Record>} [callback] - Callback function\n * @returns {Promise.<Record>}\n */\nQuickAction.prototype.defaultValues = function(contextId, callback) {\n  if (typeof contextId === 'function') {\n    callback = contextId;\n    contextId = null;\n  }\n  var url = this._path + \"/defaultValues\";\n  if (contextId) {\n    url += \"/\" + contextId;\n  }\n  return this._conn.request(url).thenCall(callback);\n};\n\n/**\n * @typedef {Object} QuickAction~QuickActionResult\n * @param {String} id - Record id of the action result\n * @param {Array.<String>} feedItemIds - List of IDs for feed item\n * @param {Boolean} success - True if the action successfully completed\n * @param {Boolean} created - True if the action yields a new record\n * @param {String} contextId - Context record ID of the action\n * @param {Array.<Object>} errors - Errors if the action failed\n */\n\n/**\n * Execute the action for given context Id and record information\n * \n * @param {String} contextId - Context record ID of the action\n * @param {Record} record - Input record information for the action\n * @param {Callback.<QuickAction~QuickActionResult>} [callback] - Callback function\n * @returns {Promise.<QuickAction~QuickActionResult>}\n */\nQuickAction.prototype.execute = function(contextId, record, callback) {\n  var body = {\n    contextId: contextId,\n    record: record\n  };\n  return this._conn.requestPost(this._path, body).thenCall(callback);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcXVpY2stYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOzs7QUFHYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnREFBZ0Q7QUFDM0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVywwQ0FBMEM7QUFDckQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL3F1aWNrLWFjdGlvbi5qcz80MDgzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgUmVwcmVzZW50cyBTYWxlc2ZvcmNlIFF1aWNrQWN0aW9uXG4gKiBAYXV0aG9yIFNoaW5pY2hpIFRvbWl0YSA8c2hpbmljaGkudG9taXRhQGdtYWlsLmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBBIGNsYXNzIGZvciBxdWljayBhY3Rpb25cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFF1aWNrQWN0aW9uID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb25uLCBwYXRoKSB7XG4gIHRoaXMuX2Nvbm4gPSBjb25uO1xuICB0aGlzLl9wYXRoID0gcGF0aDtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUXVpY2tBY3Rpb25+UXVpY2tBY3Rpb25JbmZvXG4gKiBAcHJvcCB7U3RyaW5nfSB0eXBlIC0gVHlwZSBvZiB0aGUgYWN0aW9uIChlLmcuIENyZWF0ZSwgVXBkYXRlLCBQb3N0LCBMb2dBQ2FsbClcbiAqIEBwcm9wIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBhY3Rpb25cbiAqIEBwcm9wIHtTdHJpbmd9IGxhYmVsIC0gTGFiZWwgb2YgdGhlIGFjdGlvblxuICogQHByb3Age09iamVjdH0gdXJscyAtIEVuZHBvaW50IFVSTCBpbmZvcm1hdGlvbiBvZiB0aGUgYWN0aW9uXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge1F1aWNrQWN0aW9uflF1aWNrQWN0aW9uSW5mb30gUXVpY2tBY3Rpb25+UXVpY2tBY3Rpb25EZXNjcml2ZUluZm9cbiAqIEBwcm9wIHtTdHJpbmd9IGNvbnRleHRTb2JqZWN0VHlwZSAtIE9iamVjdCB0eXBlIHVzZWQgZm9yIHRoZSBhY3Rpb25cbiAqIEBwcm9wIHtTdHJpbmd9IHRhcmdldFNvYmplY3RUeXBlIC0gT2JqZWN0IHR5cGUgb2YgdGhlIGFjdGlvbiB0byB0YXJnZXRcbiAqIEBwcm9wIHtTdHJpbmd9IHRhcmdldFBhcmVudEZpZWxkIC0gRmllbGQgbmFtZSBpbiB0aGUgdGFyZ2V0IG9iamVjdCB3aGljaCByZWZlcnMgcGFyZW50KGNvbnRleHQpIG9iamVjdCByZWNvcmQgSUQuXG4gKiBAcHJvcCB7U3RyaW5nfSB0YXJnZXRSZWNvcmRUeXBlSWQgLSBSZWNvcmQgdHlwZSBvZiB0aGUgdGFyZ2V0ZWQgcmVjb3JkXG4gKiBAcHJvcCB7T2JqZWN0fSBsYXlvdXQgLSBMYXlvdXQgc2VjdGlvbnMgdGhhdCBjb21wcmlzZSBhbiBhY3Rpb25cbiAqL1xuXG4vKipcbiAqIERlc2NyaWJlIHRoZSBhY3Rpb24ncyBpbmZvcm1hdGlvbiAoaW5jbHVkaW5nIGxheW91dCwgZXRjLilcbiAqXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxRdWlja0FjdGlvbn5RdWlja0FjdGlvbkRlc2NyaXZlSW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFF1aWNrQWN0aW9uflF1aWNrQWN0aW9uRGVzY3JpdmVJbmZvPn1cbiAqL1xuUXVpY2tBY3Rpb24ucHJvdG90eXBlLmRlc2NyaWJlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IHRoaXMuX3BhdGggKyBcIi9kZXNjcmliZVwiO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHVybCkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBkZWZhdWx0IGZpZWxkIHZhbHVlcyBpbiB0aGUgYWN0aW9uIChmb3IgZ2l2ZW4gcmVjb3JkLCBpZiBzcGVjaWZpZWQpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtjb250ZXh0SWRdIC0gSUQgb2YgcmVjb3JkIHRvIGdldCBkZWZhdWx0IHZhbHVlcyBzcGVjaWZpYyB0byB0aGUgcmVjb3JkXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmQ+fVxuICovXG5RdWlja0FjdGlvbi5wcm90b3R5cGUuZGVmYXVsdFZhbHVlcyA9IGZ1bmN0aW9uKGNvbnRleHRJZCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjb250ZXh0SWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGNvbnRleHRJZDtcbiAgICBjb250ZXh0SWQgPSBudWxsO1xuICB9XG4gIHZhciB1cmwgPSB0aGlzLl9wYXRoICsgXCIvZGVmYXVsdFZhbHVlc1wiO1xuICBpZiAoY29udGV4dElkKSB7XG4gICAgdXJsICs9IFwiL1wiICsgY29udGV4dElkO1xuICB9XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QodXJsKS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFF1aWNrQWN0aW9uflF1aWNrQWN0aW9uUmVzdWx0XG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBSZWNvcmQgaWQgb2YgdGhlIGFjdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IGZlZWRJdGVtSWRzIC0gTGlzdCBvZiBJRHMgZm9yIGZlZWQgaXRlbVxuICogQHBhcmFtIHtCb29sZWFufSBzdWNjZXNzIC0gVHJ1ZSBpZiB0aGUgYWN0aW9uIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY3JlYXRlZCAtIFRydWUgaWYgdGhlIGFjdGlvbiB5aWVsZHMgYSBuZXcgcmVjb3JkXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGV4dElkIC0gQ29udGV4dCByZWNvcmQgSUQgb2YgdGhlIGFjdGlvblxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gZXJyb3JzIC0gRXJyb3JzIGlmIHRoZSBhY3Rpb24gZmFpbGVkXG4gKi9cblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBhY3Rpb24gZm9yIGdpdmVuIGNvbnRleHQgSWQgYW5kIHJlY29yZCBpbmZvcm1hdGlvblxuICogXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGV4dElkIC0gQ29udGV4dCByZWNvcmQgSUQgb2YgdGhlIGFjdGlvblxuICogQHBhcmFtIHtSZWNvcmR9IHJlY29yZCAtIElucHV0IHJlY29yZCBpbmZvcm1hdGlvbiBmb3IgdGhlIGFjdGlvblxuICogQHBhcmFtIHtDYWxsYmFjay48UXVpY2tBY3Rpb25+UXVpY2tBY3Rpb25SZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxRdWlja0FjdGlvbn5RdWlja0FjdGlvblJlc3VsdD59XG4gKi9cblF1aWNrQWN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oY29udGV4dElkLCByZWNvcmQsIGNhbGxiYWNrKSB7XG4gIHZhciBib2R5ID0ge1xuICAgIGNvbnRleHRJZDogY29udGV4dElkLFxuICAgIHJlY29yZDogcmVjb3JkXG4gIH07XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3RQb3N0KHRoaXMuX3BhdGgsIGJvZHkpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/quick-action.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/record-stream.js":
/*!***************************************************!*\
  !*** ./node_modules/jsforce/lib/record-stream.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Represents stream that handles Salesforce record as stream data\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar events = __webpack_require__(/*! events */ \"events\"),\n    stream = __webpack_require__(/*! readable-stream */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/readable.js\"),\n    Duplex = stream.Duplex,\n    Transform = stream.Transform,\n    PassThrough = stream.PassThrough,\n    inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\"),\n    _      = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    CSV    = __webpack_require__(/*! ./csv */ \"(action-browser)/./node_modules/jsforce/lib/csv.js\");\n\n\n/**\n * Class for Record Stream\n *\n * @class\n * @constructor\n * @extends stream.Transform\n */\nvar RecordStream = module.exports = function() {\n  RecordStream.super_.call(this, { objectMode: true });\n};\n\ninherits(RecordStream, Transform);\n\n\n/*\n * @override\n */\nRecordStream.prototype._transform = function(record, enc, callback) {\n  this.emit('record', record);\n  this.push(record);\n  callback();\n};\n\n/**\n * Get record stream of queried records applying the given mapping function\n *\n * @param {RecordMapFunction} fn - Record mapping function\n * @returns {RecordStream}\n */\nRecordStream.prototype.map = function(fn) {\n  return this.pipe(RecordStream.map(fn));\n};\n\n/**\n * Get record stream of queried records, applying the given filter function\n *\n * @param {RecordFilterFunction} fn - Record filtering function\n * @returns {RecordStream}\n */\nRecordStream.prototype.filter = function(fn) {\n  return this.pipe(RecordStream.filter(fn));\n};\n\n\n/**\n * @class RecordStream.Serializable\n * @extends {RecordStream}\n */\nvar Serializable = RecordStream.Serializable = function() {\n  Serializable.super_.call(this);\n  this._dataStream = null;\n};\n\ninherits(Serializable, RecordStream);\n\n/**\n * Create readable data stream which emits serialized record data\n *\n * @param {String} [type] - Type of outgoing data format. Currently 'csv' is default value and the only supported.\n * @param {Object} [options] - Options passed to converter\n * @returns {stream.Readable}\n*/\nSerializable.prototype.stream = function(type, options) {\n  type = type || 'csv';\n  var converter = DataStreamConverters[type];\n  if (!converter) {\n    throw new Error('Converting [' + type + '] data stream is not supported.');\n  }\n  if (!this._dataStream) {\n    this._dataStream = new PassThrough();\n    this.pipe(converter.serialize(options))\n      .pipe(this._dataStream);\n  }\n  return this._dataStream;\n};\n\n\n/**\n * @class RecordStream.Parsable\n * @extends {RecordStream}\n */\nvar Parsable = RecordStream.Parsable = function() {\n  Parsable.super_.call(this);\n  this._dataStream = null;\n};\n\ninherits(Parsable, RecordStream);\n\n/**\n * Create writable data stream which accepts serialized record data\n *\n * @param {String} [type] - Type of outgoing data format. Currently 'csv' is default value and the only supported.\n * @param {Object} [options] - Options passed to converter\n * @returns {stream.Readable}\n*/\nParsable.prototype.stream = function(type, options) {\n  type = type || 'csv';\n  var converter = DataStreamConverters[type];\n  var self = this;\n  if (!converter) {\n    throw new Error('Converting [' + type + '] data stream is not supported.');\n  }\n  if (!this._dataStream) {\n    this._dataStream = new PassThrough();\n    this._parserStream = converter.parse(options).on('error', function(error) { self.emit('error', error); });\n    this._parserStream.pipe(this).pipe(new PassThrough({ objectMode: true, highWaterMark: ( 500 * 1000 ) }));\n  }\n  return this._dataStream;\n};\n\n\n/* @override */\nParsable.prototype.on = function(ev, fn) {\n  if (ev === 'readable' || ev === 'record') {\n    this._dataStream.pipe(this._parserStream);\n  }\n  return Parsable.super_.prototype.on.call(this, ev, fn);\n};\n\n/* @override */\nParsable.prototype.addListener = Parsable.prototype.on;\n\n/* --------------------------------------------------- */\n\n/**\n * @callback RecordMapFunction\n * @param {Record} record - Source record to map\n * @returns {Record}\n */\n\n/**\n * Create a record stream which maps records and pass them to downstream\n *\n * @param {RecordMapFunction} fn - Record mapping function\n * @returns {RecordStream.Serializable}\n */\nRecordStream.map = function(fn) {\n  var mapStream = new RecordStream.Serializable();\n  mapStream._transform = function(record, enc, callback) {\n    var rec = fn(record) || record; // if not returned record, use same record\n    this.push(rec);\n    callback();\n  };\n  return mapStream;\n};\n\n/**\n * Create mapping stream using given record template\n *\n * @param {Record} record - Mapping record object. In mapping field value, temlate notation can be used to refer field value in source record, if noeval param is not true.\n * @param {Boolean} [noeval] - Disable template evaluation in mapping record.\n * @returns {RecordStream.Serializable}\n */\nRecordStream.recordMapStream = function(record, noeval) {\n  return RecordStream.map(function(rec) {\n    var mapped = { Id: rec.Id };\n    for (var prop in record) {\n      mapped[prop] = noeval ? record[prop] : evalMapping(record[prop], rec);\n    }\n    return mapped;\n  });\n\n  function evalMapping(value, mapping) {\n    if (_.isString(value)) {\n      var m = /^\\$\\{(\\w+)\\}$/.exec(value);\n      if (m) { return mapping[m[1]]; }\n      return value.replace(/\\$\\{(\\w+)\\}/g, function($0, prop) {\n        var v = mapping[prop];\n        return _.isNull(v) || _.isUndefined(v) ? \"\" : String(v);\n      });\n    } else {\n      return value;\n    }\n  }\n};\n\n/**\n * @callback RecordFilterFunction\n * @param {Record} record - Source record to filter\n * @returns {Boolean}\n */\n\n/**\n * Create a record stream which filters records and pass them to downstream\n *\n * @param {RecordFilterFunction} fn - Record filtering function\n * @returns {RecordStream.Serializable}\n */\nRecordStream.filter = function(fn) {\n  var filterStream = new RecordStream.Serializable();\n  filterStream._transform = function(record, enc, callback) {\n    if (fn(record)) { this.push(record); }\n    callback();\n  };\n  return filterStream;\n};\n\n/**\n * @private\n */\nfunction convertRecordForSerialization(record, options) {\n  return Object.keys(record).reduce(function(rec, key) {\n    var value = rec[key];\n    var t = typeof value;\n    var urec = {};\n    if (key === 'attributes') { // 'attributes' prop will be ignored\n      rec = _.extend({}, rec);\n      delete rec[key];\n    } else if (options.nullValue && value === null) {\n      urec[key] = options.nullValue;\n      rec = _.extend({}, rec, urec);\n    } else if (value !== null && typeof value === 'object') {\n      var precord = convertRecordForSerialization(value, options);\n      rec = Object.keys(precord).reduce(function(prec, pkey) {\n        prec[key + '.' + pkey] = precord[pkey];\n        return prec;\n      }, _.extend({}, rec));\n    }\n    return rec;\n  }, record);\n}\n\n/**\n * @private\n */\nfunction createPipelineStream(s1, s2) {\n  var pipeline = new PassThrough();\n  pipeline.on('pipe', function(source) {\n    source.unpipe(pipeline);\n    source.pipe(s1).pipe(s2);\n  });\n  pipeline.pipe = function(dest, options) {\n    return s2.pipe(dest, options);\n  };\n  return pipeline;\n}\n\n/** ---------------------------------------------------------------------- **/\n\n/**\n * @private\n */\nvar CSVStreamConverter = {\n  serialize: function(options) {\n    options = options || {};\n    return createPipelineStream(\n      RecordStream.map(function(record) {\n        return convertRecordForSerialization(record, options);\n      }),\n      CSV.serializeCSVStream(options)\n    );\n  },\n  parse: function(options) {\n    return CSV.parseCSVStream(options);\n  }\n};\n\n/**\n * @private\n */\nvar DataStreamConverters = RecordStream.DataStreamConverters = {\n  csv: CSVStreamConverter\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9yZWNvcmQtc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixhQUFhLG1CQUFPLENBQUMseUdBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxzRUFBVTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsbUVBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLGlFQUFPOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiw0QkFBNEI7QUFDNUcseURBQXlELGlEQUFpRDtBQUMxRztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0IsZUFBZTtBQUNmLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHVCQUF1QjtBQUN2QjtBQUNBLE1BQU07QUFDTjtBQUNBLHVCQUF1QjtBQUN2QixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGFBQWE7QUFDcEI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9yZWNvcmQtc3RyZWFtLmpzPzA3MzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBSZXByZXNlbnRzIHN0cmVhbSB0aGF0IGhhbmRsZXMgU2FsZXNmb3JjZSByZWNvcmQgYXMgc3RyZWFtIGRhdGFcbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpLFxuICAgIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLFxuICAgIER1cGxleCA9IHN0cmVhbS5EdXBsZXgsXG4gICAgVHJhbnNmb3JtID0gc3RyZWFtLlRyYW5zZm9ybSxcbiAgICBQYXNzVGhyb3VnaCA9IHN0cmVhbS5QYXNzVGhyb3VnaCxcbiAgICBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgXyAgICAgID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKSxcbiAgICBDU1YgICAgPSByZXF1aXJlKCcuL2NzdicpO1xuXG5cbi8qKlxuICogQ2xhc3MgZm9yIFJlY29yZCBTdHJlYW1cbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgc3RyZWFtLlRyYW5zZm9ybVxuICovXG52YXIgUmVjb3JkU3RyZWFtID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgUmVjb3JkU3RyZWFtLnN1cGVyXy5jYWxsKHRoaXMsIHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbn07XG5cbmluaGVyaXRzKFJlY29yZFN0cmVhbSwgVHJhbnNmb3JtKTtcblxuXG4vKlxuICogQG92ZXJyaWRlXG4gKi9cblJlY29yZFN0cmVhbS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKHJlY29yZCwgZW5jLCBjYWxsYmFjaykge1xuICB0aGlzLmVtaXQoJ3JlY29yZCcsIHJlY29yZCk7XG4gIHRoaXMucHVzaChyZWNvcmQpO1xuICBjYWxsYmFjaygpO1xufTtcblxuLyoqXG4gKiBHZXQgcmVjb3JkIHN0cmVhbSBvZiBxdWVyaWVkIHJlY29yZHMgYXBwbHlpbmcgdGhlIGdpdmVuIG1hcHBpbmcgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge1JlY29yZE1hcEZ1bmN0aW9ufSBmbiAtIFJlY29yZCBtYXBwaW5nIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UmVjb3JkU3RyZWFtfVxuICovXG5SZWNvcmRTdHJlYW0ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiB0aGlzLnBpcGUoUmVjb3JkU3RyZWFtLm1hcChmbikpO1xufTtcblxuLyoqXG4gKiBHZXQgcmVjb3JkIHN0cmVhbSBvZiBxdWVyaWVkIHJlY29yZHMsIGFwcGx5aW5nIHRoZSBnaXZlbiBmaWx0ZXIgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge1JlY29yZEZpbHRlckZ1bmN0aW9ufSBmbiAtIFJlY29yZCBmaWx0ZXJpbmcgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtSZWNvcmRTdHJlYW19XG4gKi9cblJlY29yZFN0cmVhbS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIHRoaXMucGlwZShSZWNvcmRTdHJlYW0uZmlsdGVyKGZuKSk7XG59O1xuXG5cbi8qKlxuICogQGNsYXNzIFJlY29yZFN0cmVhbS5TZXJpYWxpemFibGVcbiAqIEBleHRlbmRzIHtSZWNvcmRTdHJlYW19XG4gKi9cbnZhciBTZXJpYWxpemFibGUgPSBSZWNvcmRTdHJlYW0uU2VyaWFsaXphYmxlID0gZnVuY3Rpb24oKSB7XG4gIFNlcmlhbGl6YWJsZS5zdXBlcl8uY2FsbCh0aGlzKTtcbiAgdGhpcy5fZGF0YVN0cmVhbSA9IG51bGw7XG59O1xuXG5pbmhlcml0cyhTZXJpYWxpemFibGUsIFJlY29yZFN0cmVhbSk7XG5cbi8qKlxuICogQ3JlYXRlIHJlYWRhYmxlIGRhdGEgc3RyZWFtIHdoaWNoIGVtaXRzIHNlcmlhbGl6ZWQgcmVjb3JkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIC0gVHlwZSBvZiBvdXRnb2luZyBkYXRhIGZvcm1hdC4gQ3VycmVudGx5ICdjc3YnIGlzIGRlZmF1bHQgdmFsdWUgYW5kIHRoZSBvbmx5IHN1cHBvcnRlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIHBhc3NlZCB0byBjb252ZXJ0ZXJcbiAqIEByZXR1cm5zIHtzdHJlYW0uUmVhZGFibGV9XG4qL1xuU2VyaWFsaXphYmxlLnByb3RvdHlwZS5zdHJlYW0gPSBmdW5jdGlvbih0eXBlLCBvcHRpb25zKSB7XG4gIHR5cGUgPSB0eXBlIHx8ICdjc3YnO1xuICB2YXIgY29udmVydGVyID0gRGF0YVN0cmVhbUNvbnZlcnRlcnNbdHlwZV07XG4gIGlmICghY29udmVydGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252ZXJ0aW5nIFsnICsgdHlwZSArICddIGRhdGEgc3RyZWFtIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gIH1cbiAgaWYgKCF0aGlzLl9kYXRhU3RyZWFtKSB7XG4gICAgdGhpcy5fZGF0YVN0cmVhbSA9IG5ldyBQYXNzVGhyb3VnaCgpO1xuICAgIHRoaXMucGlwZShjb252ZXJ0ZXIuc2VyaWFsaXplKG9wdGlvbnMpKVxuICAgICAgLnBpcGUodGhpcy5fZGF0YVN0cmVhbSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2RhdGFTdHJlYW07XG59O1xuXG5cbi8qKlxuICogQGNsYXNzIFJlY29yZFN0cmVhbS5QYXJzYWJsZVxuICogQGV4dGVuZHMge1JlY29yZFN0cmVhbX1cbiAqL1xudmFyIFBhcnNhYmxlID0gUmVjb3JkU3RyZWFtLlBhcnNhYmxlID0gZnVuY3Rpb24oKSB7XG4gIFBhcnNhYmxlLnN1cGVyXy5jYWxsKHRoaXMpO1xuICB0aGlzLl9kYXRhU3RyZWFtID0gbnVsbDtcbn07XG5cbmluaGVyaXRzKFBhcnNhYmxlLCBSZWNvcmRTdHJlYW0pO1xuXG4vKipcbiAqIENyZWF0ZSB3cml0YWJsZSBkYXRhIHN0cmVhbSB3aGljaCBhY2NlcHRzIHNlcmlhbGl6ZWQgcmVjb3JkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIC0gVHlwZSBvZiBvdXRnb2luZyBkYXRhIGZvcm1hdC4gQ3VycmVudGx5ICdjc3YnIGlzIGRlZmF1bHQgdmFsdWUgYW5kIHRoZSBvbmx5IHN1cHBvcnRlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIHBhc3NlZCB0byBjb252ZXJ0ZXJcbiAqIEByZXR1cm5zIHtzdHJlYW0uUmVhZGFibGV9XG4qL1xuUGFyc2FibGUucHJvdG90eXBlLnN0cmVhbSA9IGZ1bmN0aW9uKHR5cGUsIG9wdGlvbnMpIHtcbiAgdHlwZSA9IHR5cGUgfHwgJ2Nzdic7XG4gIHZhciBjb252ZXJ0ZXIgPSBEYXRhU3RyZWFtQ29udmVydGVyc1t0eXBlXTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoIWNvbnZlcnRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29udmVydGluZyBbJyArIHR5cGUgKyAnXSBkYXRhIHN0cmVhbSBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICB9XG4gIGlmICghdGhpcy5fZGF0YVN0cmVhbSkge1xuICAgIHRoaXMuX2RhdGFTdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goKTtcbiAgICB0aGlzLl9wYXJzZXJTdHJlYW0gPSBjb252ZXJ0ZXIucGFyc2Uob3B0aW9ucykub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHsgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTsgfSk7XG4gICAgdGhpcy5fcGFyc2VyU3RyZWFtLnBpcGUodGhpcykucGlwZShuZXcgUGFzc1Rocm91Z2goeyBvYmplY3RNb2RlOiB0cnVlLCBoaWdoV2F0ZXJNYXJrOiAoIDUwMCAqIDEwMDAgKSB9KSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2RhdGFTdHJlYW07XG59O1xuXG5cbi8qIEBvdmVycmlkZSAqL1xuUGFyc2FibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gJ3JlY29yZCcpIHtcbiAgICB0aGlzLl9kYXRhU3RyZWFtLnBpcGUodGhpcy5fcGFyc2VyU3RyZWFtKTtcbiAgfVxuICByZXR1cm4gUGFyc2FibGUuc3VwZXJfLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG59O1xuXG4vKiBAb3ZlcnJpZGUgKi9cblBhcnNhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFBhcnNhYmxlLnByb3RvdHlwZS5vbjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFJlY29yZE1hcEZ1bmN0aW9uXG4gKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkIC0gU291cmNlIHJlY29yZCB0byBtYXBcbiAqIEByZXR1cm5zIHtSZWNvcmR9XG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSByZWNvcmQgc3RyZWFtIHdoaWNoIG1hcHMgcmVjb3JkcyBhbmQgcGFzcyB0aGVtIHRvIGRvd25zdHJlYW1cbiAqXG4gKiBAcGFyYW0ge1JlY29yZE1hcEZ1bmN0aW9ufSBmbiAtIFJlY29yZCBtYXBwaW5nIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UmVjb3JkU3RyZWFtLlNlcmlhbGl6YWJsZX1cbiAqL1xuUmVjb3JkU3RyZWFtLm1hcCA9IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBtYXBTdHJlYW0gPSBuZXcgUmVjb3JkU3RyZWFtLlNlcmlhbGl6YWJsZSgpO1xuICBtYXBTdHJlYW0uX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKHJlY29yZCwgZW5jLCBjYWxsYmFjaykge1xuICAgIHZhciByZWMgPSBmbihyZWNvcmQpIHx8IHJlY29yZDsgLy8gaWYgbm90IHJldHVybmVkIHJlY29yZCwgdXNlIHNhbWUgcmVjb3JkXG4gICAgdGhpcy5wdXNoKHJlYyk7XG4gICAgY2FsbGJhY2soKTtcbiAgfTtcbiAgcmV0dXJuIG1hcFN0cmVhbTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIG1hcHBpbmcgc3RyZWFtIHVzaW5nIGdpdmVuIHJlY29yZCB0ZW1wbGF0ZVxuICpcbiAqIEBwYXJhbSB7UmVjb3JkfSByZWNvcmQgLSBNYXBwaW5nIHJlY29yZCBvYmplY3QuIEluIG1hcHBpbmcgZmllbGQgdmFsdWUsIHRlbWxhdGUgbm90YXRpb24gY2FuIGJlIHVzZWQgdG8gcmVmZXIgZmllbGQgdmFsdWUgaW4gc291cmNlIHJlY29yZCwgaWYgbm9ldmFsIHBhcmFtIGlzIG5vdCB0cnVlLlxuICogQHBhcmFtIHtCb29sZWFufSBbbm9ldmFsXSAtIERpc2FibGUgdGVtcGxhdGUgZXZhbHVhdGlvbiBpbiBtYXBwaW5nIHJlY29yZC5cbiAqIEByZXR1cm5zIHtSZWNvcmRTdHJlYW0uU2VyaWFsaXphYmxlfVxuICovXG5SZWNvcmRTdHJlYW0ucmVjb3JkTWFwU3RyZWFtID0gZnVuY3Rpb24ocmVjb3JkLCBub2V2YWwpIHtcbiAgcmV0dXJuIFJlY29yZFN0cmVhbS5tYXAoZnVuY3Rpb24ocmVjKSB7XG4gICAgdmFyIG1hcHBlZCA9IHsgSWQ6IHJlYy5JZCB9O1xuICAgIGZvciAodmFyIHByb3AgaW4gcmVjb3JkKSB7XG4gICAgICBtYXBwZWRbcHJvcF0gPSBub2V2YWwgPyByZWNvcmRbcHJvcF0gOiBldmFsTWFwcGluZyhyZWNvcmRbcHJvcF0sIHJlYyk7XG4gICAgfVxuICAgIHJldHVybiBtYXBwZWQ7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGV2YWxNYXBwaW5nKHZhbHVlLCBtYXBwaW5nKSB7XG4gICAgaWYgKF8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICB2YXIgbSA9IC9eXFwkXFx7KFxcdyspXFx9JC8uZXhlYyh2YWx1ZSk7XG4gICAgICBpZiAobSkgeyByZXR1cm4gbWFwcGluZ1ttWzFdXTsgfVxuICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1xcJFxceyhcXHcrKVxcfS9nLCBmdW5jdGlvbigkMCwgcHJvcCkge1xuICAgICAgICB2YXIgdiA9IG1hcHBpbmdbcHJvcF07XG4gICAgICAgIHJldHVybiBfLmlzTnVsbCh2KSB8fCBfLmlzVW5kZWZpbmVkKHYpID8gXCJcIiA6IFN0cmluZyh2KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBSZWNvcmRGaWx0ZXJGdW5jdGlvblxuICogQHBhcmFtIHtSZWNvcmR9IHJlY29yZCAtIFNvdXJjZSByZWNvcmQgdG8gZmlsdGVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlY29yZCBzdHJlYW0gd2hpY2ggZmlsdGVycyByZWNvcmRzIGFuZCBwYXNzIHRoZW0gdG8gZG93bnN0cmVhbVxuICpcbiAqIEBwYXJhbSB7UmVjb3JkRmlsdGVyRnVuY3Rpb259IGZuIC0gUmVjb3JkIGZpbHRlcmluZyBmdW5jdGlvblxuICogQHJldHVybnMge1JlY29yZFN0cmVhbS5TZXJpYWxpemFibGV9XG4gKi9cblJlY29yZFN0cmVhbS5maWx0ZXIgPSBmdW5jdGlvbihmbikge1xuICB2YXIgZmlsdGVyU3RyZWFtID0gbmV3IFJlY29yZFN0cmVhbS5TZXJpYWxpemFibGUoKTtcbiAgZmlsdGVyU3RyZWFtLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihyZWNvcmQsIGVuYywgY2FsbGJhY2spIHtcbiAgICBpZiAoZm4ocmVjb3JkKSkgeyB0aGlzLnB1c2gocmVjb3JkKTsgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH07XG4gIHJldHVybiBmaWx0ZXJTdHJlYW07XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSZWNvcmRGb3JTZXJpYWxpemF0aW9uKHJlY29yZCwgb3B0aW9ucykge1xuICByZXR1cm4gT2JqZWN0LmtleXMocmVjb3JkKS5yZWR1Y2UoZnVuY3Rpb24ocmVjLCBrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSByZWNba2V5XTtcbiAgICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YXIgdXJlYyA9IHt9O1xuICAgIGlmIChrZXkgPT09ICdhdHRyaWJ1dGVzJykgeyAvLyAnYXR0cmlidXRlcycgcHJvcCB3aWxsIGJlIGlnbm9yZWRcbiAgICAgIHJlYyA9IF8uZXh0ZW5kKHt9LCByZWMpO1xuICAgICAgZGVsZXRlIHJlY1trZXldO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5udWxsVmFsdWUgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHVyZWNba2V5XSA9IG9wdGlvbnMubnVsbFZhbHVlO1xuICAgICAgcmVjID0gXy5leHRlbmQoe30sIHJlYywgdXJlYyk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgcHJlY29yZCA9IGNvbnZlcnRSZWNvcmRGb3JTZXJpYWxpemF0aW9uKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIHJlYyA9IE9iamVjdC5rZXlzKHByZWNvcmQpLnJlZHVjZShmdW5jdGlvbihwcmVjLCBwa2V5KSB7XG4gICAgICAgIHByZWNba2V5ICsgJy4nICsgcGtleV0gPSBwcmVjb3JkW3BrZXldO1xuICAgICAgICByZXR1cm4gcHJlYztcbiAgICAgIH0sIF8uZXh0ZW5kKHt9LCByZWMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlYztcbiAgfSwgcmVjb3JkKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVQaXBlbGluZVN0cmVhbShzMSwgczIpIHtcbiAgdmFyIHBpcGVsaW5lID0gbmV3IFBhc3NUaHJvdWdoKCk7XG4gIHBpcGVsaW5lLm9uKCdwaXBlJywgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgc291cmNlLnVucGlwZShwaXBlbGluZSk7XG4gICAgc291cmNlLnBpcGUoczEpLnBpcGUoczIpO1xuICB9KTtcbiAgcGlwZWxpbmUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gczIucGlwZShkZXN0LCBvcHRpb25zKTtcbiAgfTtcbiAgcmV0dXJuIHBpcGVsaW5lO1xufVxuXG4vKiogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKi9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgQ1NWU3RyZWFtQ29udmVydGVyID0ge1xuICBzZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gY3JlYXRlUGlwZWxpbmVTdHJlYW0oXG4gICAgICBSZWNvcmRTdHJlYW0ubWFwKGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgICByZXR1cm4gY29udmVydFJlY29yZEZvclNlcmlhbGl6YXRpb24ocmVjb3JkLCBvcHRpb25zKTtcbiAgICAgIH0pLFxuICAgICAgQ1NWLnNlcmlhbGl6ZUNTVlN0cmVhbShvcHRpb25zKVxuICAgICk7XG4gIH0sXG4gIHBhcnNlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIENTVi5wYXJzZUNTVlN0cmVhbShvcHRpb25zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgRGF0YVN0cmVhbUNvbnZlcnRlcnMgPSBSZWNvcmRTdHJlYW0uRGF0YVN0cmVhbUNvbnZlcnRlcnMgPSB7XG4gIGNzdjogQ1NWU3RyZWFtQ29udmVydGVyXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/record-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/record-stream.js":
/*!***************************************************!*\
  !*** ./node_modules/jsforce/lib/record-stream.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Represents stream that handles Salesforce record as stream data\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar events = __webpack_require__(/*! events */ \"events\"),\n    stream = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/readable.js\"),\n    Duplex = stream.Duplex,\n    Transform = stream.Transform,\n    PassThrough = stream.PassThrough,\n    inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\"),\n    _      = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    CSV    = __webpack_require__(/*! ./csv */ \"(rsc)/./node_modules/jsforce/lib/csv.js\");\n\n\n/**\n * Class for Record Stream\n *\n * @class\n * @constructor\n * @extends stream.Transform\n */\nvar RecordStream = module.exports = function() {\n  RecordStream.super_.call(this, { objectMode: true });\n};\n\ninherits(RecordStream, Transform);\n\n\n/*\n * @override\n */\nRecordStream.prototype._transform = function(record, enc, callback) {\n  this.emit('record', record);\n  this.push(record);\n  callback();\n};\n\n/**\n * Get record stream of queried records applying the given mapping function\n *\n * @param {RecordMapFunction} fn - Record mapping function\n * @returns {RecordStream}\n */\nRecordStream.prototype.map = function(fn) {\n  return this.pipe(RecordStream.map(fn));\n};\n\n/**\n * Get record stream of queried records, applying the given filter function\n *\n * @param {RecordFilterFunction} fn - Record filtering function\n * @returns {RecordStream}\n */\nRecordStream.prototype.filter = function(fn) {\n  return this.pipe(RecordStream.filter(fn));\n};\n\n\n/**\n * @class RecordStream.Serializable\n * @extends {RecordStream}\n */\nvar Serializable = RecordStream.Serializable = function() {\n  Serializable.super_.call(this);\n  this._dataStream = null;\n};\n\ninherits(Serializable, RecordStream);\n\n/**\n * Create readable data stream which emits serialized record data\n *\n * @param {String} [type] - Type of outgoing data format. Currently 'csv' is default value and the only supported.\n * @param {Object} [options] - Options passed to converter\n * @returns {stream.Readable}\n*/\nSerializable.prototype.stream = function(type, options) {\n  type = type || 'csv';\n  var converter = DataStreamConverters[type];\n  if (!converter) {\n    throw new Error('Converting [' + type + '] data stream is not supported.');\n  }\n  if (!this._dataStream) {\n    this._dataStream = new PassThrough();\n    this.pipe(converter.serialize(options))\n      .pipe(this._dataStream);\n  }\n  return this._dataStream;\n};\n\n\n/**\n * @class RecordStream.Parsable\n * @extends {RecordStream}\n */\nvar Parsable = RecordStream.Parsable = function() {\n  Parsable.super_.call(this);\n  this._dataStream = null;\n};\n\ninherits(Parsable, RecordStream);\n\n/**\n * Create writable data stream which accepts serialized record data\n *\n * @param {String} [type] - Type of outgoing data format. Currently 'csv' is default value and the only supported.\n * @param {Object} [options] - Options passed to converter\n * @returns {stream.Readable}\n*/\nParsable.prototype.stream = function(type, options) {\n  type = type || 'csv';\n  var converter = DataStreamConverters[type];\n  var self = this;\n  if (!converter) {\n    throw new Error('Converting [' + type + '] data stream is not supported.');\n  }\n  if (!this._dataStream) {\n    this._dataStream = new PassThrough();\n    this._parserStream = converter.parse(options).on('error', function(error) { self.emit('error', error); });\n    this._parserStream.pipe(this).pipe(new PassThrough({ objectMode: true, highWaterMark: ( 500 * 1000 ) }));\n  }\n  return this._dataStream;\n};\n\n\n/* @override */\nParsable.prototype.on = function(ev, fn) {\n  if (ev === 'readable' || ev === 'record') {\n    this._dataStream.pipe(this._parserStream);\n  }\n  return Parsable.super_.prototype.on.call(this, ev, fn);\n};\n\n/* @override */\nParsable.prototype.addListener = Parsable.prototype.on;\n\n/* --------------------------------------------------- */\n\n/**\n * @callback RecordMapFunction\n * @param {Record} record - Source record to map\n * @returns {Record}\n */\n\n/**\n * Create a record stream which maps records and pass them to downstream\n *\n * @param {RecordMapFunction} fn - Record mapping function\n * @returns {RecordStream.Serializable}\n */\nRecordStream.map = function(fn) {\n  var mapStream = new RecordStream.Serializable();\n  mapStream._transform = function(record, enc, callback) {\n    var rec = fn(record) || record; // if not returned record, use same record\n    this.push(rec);\n    callback();\n  };\n  return mapStream;\n};\n\n/**\n * Create mapping stream using given record template\n *\n * @param {Record} record - Mapping record object. In mapping field value, temlate notation can be used to refer field value in source record, if noeval param is not true.\n * @param {Boolean} [noeval] - Disable template evaluation in mapping record.\n * @returns {RecordStream.Serializable}\n */\nRecordStream.recordMapStream = function(record, noeval) {\n  return RecordStream.map(function(rec) {\n    var mapped = { Id: rec.Id };\n    for (var prop in record) {\n      mapped[prop] = noeval ? record[prop] : evalMapping(record[prop], rec);\n    }\n    return mapped;\n  });\n\n  function evalMapping(value, mapping) {\n    if (_.isString(value)) {\n      var m = /^\\$\\{(\\w+)\\}$/.exec(value);\n      if (m) { return mapping[m[1]]; }\n      return value.replace(/\\$\\{(\\w+)\\}/g, function($0, prop) {\n        var v = mapping[prop];\n        return _.isNull(v) || _.isUndefined(v) ? \"\" : String(v);\n      });\n    } else {\n      return value;\n    }\n  }\n};\n\n/**\n * @callback RecordFilterFunction\n * @param {Record} record - Source record to filter\n * @returns {Boolean}\n */\n\n/**\n * Create a record stream which filters records and pass them to downstream\n *\n * @param {RecordFilterFunction} fn - Record filtering function\n * @returns {RecordStream.Serializable}\n */\nRecordStream.filter = function(fn) {\n  var filterStream = new RecordStream.Serializable();\n  filterStream._transform = function(record, enc, callback) {\n    if (fn(record)) { this.push(record); }\n    callback();\n  };\n  return filterStream;\n};\n\n/**\n * @private\n */\nfunction convertRecordForSerialization(record, options) {\n  return Object.keys(record).reduce(function(rec, key) {\n    var value = rec[key];\n    var t = typeof value;\n    var urec = {};\n    if (key === 'attributes') { // 'attributes' prop will be ignored\n      rec = _.extend({}, rec);\n      delete rec[key];\n    } else if (options.nullValue && value === null) {\n      urec[key] = options.nullValue;\n      rec = _.extend({}, rec, urec);\n    } else if (value !== null && typeof value === 'object') {\n      var precord = convertRecordForSerialization(value, options);\n      rec = Object.keys(precord).reduce(function(prec, pkey) {\n        prec[key + '.' + pkey] = precord[pkey];\n        return prec;\n      }, _.extend({}, rec));\n    }\n    return rec;\n  }, record);\n}\n\n/**\n * @private\n */\nfunction createPipelineStream(s1, s2) {\n  var pipeline = new PassThrough();\n  pipeline.on('pipe', function(source) {\n    source.unpipe(pipeline);\n    source.pipe(s1).pipe(s2);\n  });\n  pipeline.pipe = function(dest, options) {\n    return s2.pipe(dest, options);\n  };\n  return pipeline;\n}\n\n/** ---------------------------------------------------------------------- **/\n\n/**\n * @private\n */\nvar CSVStreamConverter = {\n  serialize: function(options) {\n    options = options || {};\n    return createPipelineStream(\n      RecordStream.map(function(record) {\n        return convertRecordForSerialization(record, options);\n      }),\n      CSV.serializeCSVStream(options)\n    );\n  },\n  parse: function(options) {\n    return CSV.parseCSVStream(options);\n  }\n};\n\n/**\n * @private\n */\nvar DataStreamConverters = RecordStream.DataStreamConverters = {\n  csv: CSVStreamConverter\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcmVjb3JkLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLDhGQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsMkRBQVU7QUFDakMsYUFBYSxtQkFBTyxDQUFDLHdEQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxzREFBTzs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNEJBQTRCO0FBQzVHLHlEQUF5RCxpREFBaUQ7QUFDMUc7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLGVBQWU7QUFDZixnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkI7QUFDQSxNQUFNO0FBQ047QUFDQSx1QkFBdUI7QUFDdkIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxhQUFhO0FBQ3BCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcmVjb3JkLXN0cmVhbS5qcz82YmQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgUmVwcmVzZW50cyBzdHJlYW0gdGhhdCBoYW5kbGVzIFNhbGVzZm9yY2UgcmVjb3JkIGFzIHN0cmVhbSBkYXRhXG4gKiBAYXV0aG9yIFNoaW5pY2hpIFRvbWl0YSA8c2hpbmljaGkudG9taXRhQGdtYWlsLmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKSxcbiAgICBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKSxcbiAgICBEdXBsZXggPSBzdHJlYW0uRHVwbGV4LFxuICAgIFRyYW5zZm9ybSA9IHN0cmVhbS5UcmFuc2Zvcm0sXG4gICAgUGFzc1Rocm91Z2ggPSBzdHJlYW0uUGFzc1Rocm91Z2gsXG4gICAgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgIF8gICAgICA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyksXG4gICAgQ1NWICAgID0gcmVxdWlyZSgnLi9jc3YnKTtcblxuXG4vKipcbiAqIENsYXNzIGZvciBSZWNvcmQgU3RyZWFtXG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHN0cmVhbS5UcmFuc2Zvcm1cbiAqL1xudmFyIFJlY29yZFN0cmVhbSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIFJlY29yZFN0cmVhbS5zdXBlcl8uY2FsbCh0aGlzLCB7IG9iamVjdE1vZGU6IHRydWUgfSk7XG59O1xuXG5pbmhlcml0cyhSZWNvcmRTdHJlYW0sIFRyYW5zZm9ybSk7XG5cblxuLypcbiAqIEBvdmVycmlkZVxuICovXG5SZWNvcmRTdHJlYW0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihyZWNvcmQsIGVuYywgY2FsbGJhY2spIHtcbiAgdGhpcy5lbWl0KCdyZWNvcmQnLCByZWNvcmQpO1xuICB0aGlzLnB1c2gocmVjb3JkKTtcbiAgY2FsbGJhY2soKTtcbn07XG5cbi8qKlxuICogR2V0IHJlY29yZCBzdHJlYW0gb2YgcXVlcmllZCByZWNvcmRzIGFwcGx5aW5nIHRoZSBnaXZlbiBtYXBwaW5nIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtSZWNvcmRNYXBGdW5jdGlvbn0gZm4gLSBSZWNvcmQgbWFwcGluZyBmdW5jdGlvblxuICogQHJldHVybnMge1JlY29yZFN0cmVhbX1cbiAqL1xuUmVjb3JkU3RyZWFtLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihmbikge1xuICByZXR1cm4gdGhpcy5waXBlKFJlY29yZFN0cmVhbS5tYXAoZm4pKTtcbn07XG5cbi8qKlxuICogR2V0IHJlY29yZCBzdHJlYW0gb2YgcXVlcmllZCByZWNvcmRzLCBhcHBseWluZyB0aGUgZ2l2ZW4gZmlsdGVyIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtSZWNvcmRGaWx0ZXJGdW5jdGlvbn0gZm4gLSBSZWNvcmQgZmlsdGVyaW5nIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UmVjb3JkU3RyZWFtfVxuICovXG5SZWNvcmRTdHJlYW0ucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiB0aGlzLnBpcGUoUmVjb3JkU3RyZWFtLmZpbHRlcihmbikpO1xufTtcblxuXG4vKipcbiAqIEBjbGFzcyBSZWNvcmRTdHJlYW0uU2VyaWFsaXphYmxlXG4gKiBAZXh0ZW5kcyB7UmVjb3JkU3RyZWFtfVxuICovXG52YXIgU2VyaWFsaXphYmxlID0gUmVjb3JkU3RyZWFtLlNlcmlhbGl6YWJsZSA9IGZ1bmN0aW9uKCkge1xuICBTZXJpYWxpemFibGUuc3VwZXJfLmNhbGwodGhpcyk7XG4gIHRoaXMuX2RhdGFTdHJlYW0gPSBudWxsO1xufTtcblxuaW5oZXJpdHMoU2VyaWFsaXphYmxlLCBSZWNvcmRTdHJlYW0pO1xuXG4vKipcbiAqIENyZWF0ZSByZWFkYWJsZSBkYXRhIHN0cmVhbSB3aGljaCBlbWl0cyBzZXJpYWxpemVkIHJlY29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAtIFR5cGUgb2Ygb3V0Z29pbmcgZGF0YSBmb3JtYXQuIEN1cnJlbnRseSAnY3N2JyBpcyBkZWZhdWx0IHZhbHVlIGFuZCB0aGUgb25seSBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBwYXNzZWQgdG8gY29udmVydGVyXG4gKiBAcmV0dXJucyB7c3RyZWFtLlJlYWRhYmxlfVxuKi9cblNlcmlhbGl6YWJsZS5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24odHlwZSwgb3B0aW9ucykge1xuICB0eXBlID0gdHlwZSB8fCAnY3N2JztcbiAgdmFyIGNvbnZlcnRlciA9IERhdGFTdHJlYW1Db252ZXJ0ZXJzW3R5cGVdO1xuICBpZiAoIWNvbnZlcnRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29udmVydGluZyBbJyArIHR5cGUgKyAnXSBkYXRhIHN0cmVhbSBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICB9XG4gIGlmICghdGhpcy5fZGF0YVN0cmVhbSkge1xuICAgIHRoaXMuX2RhdGFTdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goKTtcbiAgICB0aGlzLnBpcGUoY29udmVydGVyLnNlcmlhbGl6ZShvcHRpb25zKSlcbiAgICAgIC5waXBlKHRoaXMuX2RhdGFTdHJlYW0pO1xuICB9XG4gIHJldHVybiB0aGlzLl9kYXRhU3RyZWFtO1xufTtcblxuXG4vKipcbiAqIEBjbGFzcyBSZWNvcmRTdHJlYW0uUGFyc2FibGVcbiAqIEBleHRlbmRzIHtSZWNvcmRTdHJlYW19XG4gKi9cbnZhciBQYXJzYWJsZSA9IFJlY29yZFN0cmVhbS5QYXJzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICBQYXJzYWJsZS5zdXBlcl8uY2FsbCh0aGlzKTtcbiAgdGhpcy5fZGF0YVN0cmVhbSA9IG51bGw7XG59O1xuXG5pbmhlcml0cyhQYXJzYWJsZSwgUmVjb3JkU3RyZWFtKTtcblxuLyoqXG4gKiBDcmVhdGUgd3JpdGFibGUgZGF0YSBzdHJlYW0gd2hpY2ggYWNjZXB0cyBzZXJpYWxpemVkIHJlY29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAtIFR5cGUgb2Ygb3V0Z29pbmcgZGF0YSBmb3JtYXQuIEN1cnJlbnRseSAnY3N2JyBpcyBkZWZhdWx0IHZhbHVlIGFuZCB0aGUgb25seSBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBwYXNzZWQgdG8gY29udmVydGVyXG4gKiBAcmV0dXJucyB7c3RyZWFtLlJlYWRhYmxlfVxuKi9cblBhcnNhYmxlLnByb3RvdHlwZS5zdHJlYW0gPSBmdW5jdGlvbih0eXBlLCBvcHRpb25zKSB7XG4gIHR5cGUgPSB0eXBlIHx8ICdjc3YnO1xuICB2YXIgY29udmVydGVyID0gRGF0YVN0cmVhbUNvbnZlcnRlcnNbdHlwZV07XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKCFjb252ZXJ0ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnZlcnRpbmcgWycgKyB0eXBlICsgJ10gZGF0YSBzdHJlYW0gaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgfVxuICBpZiAoIXRoaXMuX2RhdGFTdHJlYW0pIHtcbiAgICB0aGlzLl9kYXRhU3RyZWFtID0gbmV3IFBhc3NUaHJvdWdoKCk7XG4gICAgdGhpcy5fcGFyc2VyU3RyZWFtID0gY29udmVydGVyLnBhcnNlKG9wdGlvbnMpLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7IHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcik7IH0pO1xuICAgIHRoaXMuX3BhcnNlclN0cmVhbS5waXBlKHRoaXMpLnBpcGUobmV3IFBhc3NUaHJvdWdoKHsgb2JqZWN0TW9kZTogdHJ1ZSwgaGlnaFdhdGVyTWFyazogKCA1MDAgKiAxMDAwICkgfSkpO1xuICB9XG4gIHJldHVybiB0aGlzLl9kYXRhU3RyZWFtO1xufTtcblxuXG4vKiBAb3ZlcnJpZGUgKi9cblBhcnNhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgfHwgZXYgPT09ICdyZWNvcmQnKSB7XG4gICAgdGhpcy5fZGF0YVN0cmVhbS5waXBlKHRoaXMuX3BhcnNlclN0cmVhbSk7XG4gIH1cbiAgcmV0dXJuIFBhcnNhYmxlLnN1cGVyXy5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xufTtcblxuLyogQG92ZXJyaWRlICovXG5QYXJzYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBQYXJzYWJsZS5wcm90b3R5cGUub247XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBSZWNvcmRNYXBGdW5jdGlvblxuICogQHBhcmFtIHtSZWNvcmR9IHJlY29yZCAtIFNvdXJjZSByZWNvcmQgdG8gbWFwXG4gKiBAcmV0dXJucyB7UmVjb3JkfVxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgcmVjb3JkIHN0cmVhbSB3aGljaCBtYXBzIHJlY29yZHMgYW5kIHBhc3MgdGhlbSB0byBkb3duc3RyZWFtXG4gKlxuICogQHBhcmFtIHtSZWNvcmRNYXBGdW5jdGlvbn0gZm4gLSBSZWNvcmQgbWFwcGluZyBmdW5jdGlvblxuICogQHJldHVybnMge1JlY29yZFN0cmVhbS5TZXJpYWxpemFibGV9XG4gKi9cblJlY29yZFN0cmVhbS5tYXAgPSBmdW5jdGlvbihmbikge1xuICB2YXIgbWFwU3RyZWFtID0gbmV3IFJlY29yZFN0cmVhbS5TZXJpYWxpemFibGUoKTtcbiAgbWFwU3RyZWFtLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihyZWNvcmQsIGVuYywgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVjID0gZm4ocmVjb3JkKSB8fCByZWNvcmQ7IC8vIGlmIG5vdCByZXR1cm5lZCByZWNvcmQsIHVzZSBzYW1lIHJlY29yZFxuICAgIHRoaXMucHVzaChyZWMpO1xuICAgIGNhbGxiYWNrKCk7XG4gIH07XG4gIHJldHVybiBtYXBTdHJlYW07XG59O1xuXG4vKipcbiAqIENyZWF0ZSBtYXBwaW5nIHN0cmVhbSB1c2luZyBnaXZlbiByZWNvcmQgdGVtcGxhdGVcbiAqXG4gKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkIC0gTWFwcGluZyByZWNvcmQgb2JqZWN0LiBJbiBtYXBwaW5nIGZpZWxkIHZhbHVlLCB0ZW1sYXRlIG5vdGF0aW9uIGNhbiBiZSB1c2VkIHRvIHJlZmVyIGZpZWxkIHZhbHVlIGluIHNvdXJjZSByZWNvcmQsIGlmIG5vZXZhbCBwYXJhbSBpcyBub3QgdHJ1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vZXZhbF0gLSBEaXNhYmxlIHRlbXBsYXRlIGV2YWx1YXRpb24gaW4gbWFwcGluZyByZWNvcmQuXG4gKiBAcmV0dXJucyB7UmVjb3JkU3RyZWFtLlNlcmlhbGl6YWJsZX1cbiAqL1xuUmVjb3JkU3RyZWFtLnJlY29yZE1hcFN0cmVhbSA9IGZ1bmN0aW9uKHJlY29yZCwgbm9ldmFsKSB7XG4gIHJldHVybiBSZWNvcmRTdHJlYW0ubWFwKGZ1bmN0aW9uKHJlYykge1xuICAgIHZhciBtYXBwZWQgPSB7IElkOiByZWMuSWQgfTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHJlY29yZCkge1xuICAgICAgbWFwcGVkW3Byb3BdID0gbm9ldmFsID8gcmVjb3JkW3Byb3BdIDogZXZhbE1hcHBpbmcocmVjb3JkW3Byb3BdLCByZWMpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwcGVkO1xuICB9KTtcblxuICBmdW5jdGlvbiBldmFsTWFwcGluZyh2YWx1ZSwgbWFwcGluZykge1xuICAgIGlmIChfLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgdmFyIG0gPSAvXlxcJFxceyhcXHcrKVxcfSQvLmV4ZWModmFsdWUpO1xuICAgICAgaWYgKG0pIHsgcmV0dXJuIG1hcHBpbmdbbVsxXV07IH1cbiAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXCRcXHsoXFx3KylcXH0vZywgZnVuY3Rpb24oJDAsIHByb3ApIHtcbiAgICAgICAgdmFyIHYgPSBtYXBwaW5nW3Byb3BdO1xuICAgICAgICByZXR1cm4gXy5pc051bGwodikgfHwgXy5pc1VuZGVmaW5lZCh2KSA/IFwiXCIgOiBTdHJpbmcodik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgUmVjb3JkRmlsdGVyRnVuY3Rpb25cbiAqIEBwYXJhbSB7UmVjb3JkfSByZWNvcmQgLSBTb3VyY2UgcmVjb3JkIHRvIGZpbHRlclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSByZWNvcmQgc3RyZWFtIHdoaWNoIGZpbHRlcnMgcmVjb3JkcyBhbmQgcGFzcyB0aGVtIHRvIGRvd25zdHJlYW1cbiAqXG4gKiBAcGFyYW0ge1JlY29yZEZpbHRlckZ1bmN0aW9ufSBmbiAtIFJlY29yZCBmaWx0ZXJpbmcgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtSZWNvcmRTdHJlYW0uU2VyaWFsaXphYmxlfVxuICovXG5SZWNvcmRTdHJlYW0uZmlsdGVyID0gZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGZpbHRlclN0cmVhbSA9IG5ldyBSZWNvcmRTdHJlYW0uU2VyaWFsaXphYmxlKCk7XG4gIGZpbHRlclN0cmVhbS5fdHJhbnNmb3JtID0gZnVuY3Rpb24ocmVjb3JkLCBlbmMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGZuKHJlY29yZCkpIHsgdGhpcy5wdXNoKHJlY29yZCk7IH1cbiAgICBjYWxsYmFjaygpO1xuICB9O1xuICByZXR1cm4gZmlsdGVyU3RyZWFtO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb252ZXJ0UmVjb3JkRm9yU2VyaWFsaXphdGlvbihyZWNvcmQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHJlY29yZCkucmVkdWNlKGZ1bmN0aW9uKHJlYywga2V5KSB7XG4gICAgdmFyIHZhbHVlID0gcmVjW2tleV07XG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFyIHVyZWMgPSB7fTtcbiAgICBpZiAoa2V5ID09PSAnYXR0cmlidXRlcycpIHsgLy8gJ2F0dHJpYnV0ZXMnIHByb3Agd2lsbCBiZSBpZ25vcmVkXG4gICAgICByZWMgPSBfLmV4dGVuZCh7fSwgcmVjKTtcbiAgICAgIGRlbGV0ZSByZWNba2V5XTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMubnVsbFZhbHVlICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgICB1cmVjW2tleV0gPSBvcHRpb25zLm51bGxWYWx1ZTtcbiAgICAgIHJlYyA9IF8uZXh0ZW5kKHt9LCByZWMsIHVyZWMpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIHByZWNvcmQgPSBjb252ZXJ0UmVjb3JkRm9yU2VyaWFsaXphdGlvbih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICByZWMgPSBPYmplY3Qua2V5cyhwcmVjb3JkKS5yZWR1Y2UoZnVuY3Rpb24ocHJlYywgcGtleSkge1xuICAgICAgICBwcmVjW2tleSArICcuJyArIHBrZXldID0gcHJlY29yZFtwa2V5XTtcbiAgICAgICAgcmV0dXJuIHByZWM7XG4gICAgICB9LCBfLmV4dGVuZCh7fSwgcmVjKSk7XG4gICAgfVxuICAgIHJldHVybiByZWM7XG4gIH0sIHJlY29yZCk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGlwZWxpbmVTdHJlYW0oczEsIHMyKSB7XG4gIHZhciBwaXBlbGluZSA9IG5ldyBQYXNzVGhyb3VnaCgpO1xuICBwaXBlbGluZS5vbigncGlwZScsIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHNvdXJjZS51bnBpcGUocGlwZWxpbmUpO1xuICAgIHNvdXJjZS5waXBlKHMxKS5waXBlKHMyKTtcbiAgfSk7XG4gIHBpcGVsaW5lLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHMyLnBpcGUoZGVzdCwgb3B0aW9ucyk7XG4gIH07XG4gIHJldHVybiBwaXBlbGluZTtcbn1cblxuLyoqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKiovXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIENTVlN0cmVhbUNvbnZlcnRlciA9IHtcbiAgc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIGNyZWF0ZVBpcGVsaW5lU3RyZWFtKFxuICAgICAgUmVjb3JkU3RyZWFtLm1hcChmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRSZWNvcmRGb3JTZXJpYWxpemF0aW9uKHJlY29yZCwgb3B0aW9ucyk7XG4gICAgICB9KSxcbiAgICAgIENTVi5zZXJpYWxpemVDU1ZTdHJlYW0ob3B0aW9ucylcbiAgICApO1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBDU1YucGFyc2VDU1ZTdHJlYW0ob3B0aW9ucyk7XG4gIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIERhdGFTdHJlYW1Db252ZXJ0ZXJzID0gUmVjb3JkU3RyZWFtLkRhdGFTdHJlYW1Db252ZXJ0ZXJzID0ge1xuICBjc3Y6IENTVlN0cmVhbUNvbnZlcnRlclxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/record-stream.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/record.js":
/*!********************************************!*\
  !*** ./node_modules/jsforce/lib/record.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Represents Salesforce record information\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar _ = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\");\n\n/**\n * A simple hash object including record field information\n *\n * @typedef {Object} Record\n */\n\n/**\n * Remote reference to record information\n *\n * @protected\n * @class\n * @constructor\n * @param {Connection} conn - Connection object\n * @param {String} type - SObject type\n * @param {String} id - Record ID\n */\nvar RecordReference = module.exports = function(conn, type, id) {\n  this._conn = conn;\n  this.type = type;\n  this.id = id;\n};\n\n/**\n * Retrieve record field information\n *\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<Record>} [callback] - Callback function\n * @returns {Promise.<Record>}\n */\nRecordReference.prototype.retrieve = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._conn.retrieve(this.type, this.id, options, callback);\n};\n\n/**\n * Update record field information\n *\n * @param {Record} record - A Record which includes fields to update\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<RecordResult>} [callback] - Callback function\n * @returns {Promise.<RecordResult>}\n */\nRecordReference.prototype.update = function(record, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  record = _.clone(record);\n  record.Id = this.id;\n  return this._conn.update(this.type, record, options, callback);\n};\n\n/**\n * Synonym of Record#destroy()\n *\n * @method RecordReference#delete\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<RecordResult>} [callback] - Callback function\n * @returns {Promise.<RecordResult>}\n */\nRecordReference.prototype[\"delete\"] =\n/**\n * Synonym of Record#destroy()\n *\n * @method RecordReference#del\n * @param {Callback.<RecordResult>} [callback] - Callback function\n * @returns {Promise.<RecordResult>}\n */\nRecordReference.prototype.del =\n/**\n * Delete record field\n *\n * @method RecordReference#destroy\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<RecordResult>} [callback] - Callback function\n * @returns {Promise.<RecordResult>}\n */\nRecordReference.prototype.destroy = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._conn.destroy(this.type, this.id, options, callback);\n};\n\n/**\n * Get blob field as stream\n *\n * @param {String} fieldName - Blob field name\n * @returns {stream.Stream}\n */\nRecordReference.prototype.blob = function(fieldName) {\n  var url = [ this._conn._baseUrl(), 'sobjects', this.type, this.id, fieldName ].join('/');\n  return this._conn.request(url).stream();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9yZWNvcmQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLG1FQUFhOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcseUJBQXlCO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHlCQUF5QjtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHlCQUF5QjtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL3JlY29yZC5qcz81YTBkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgUmVwcmVzZW50cyBTYWxlc2ZvcmNlIHJlY29yZCBpbmZvcm1hdGlvblxuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyk7XG5cbi8qKlxuICogQSBzaW1wbGUgaGFzaCBvYmplY3QgaW5jbHVkaW5nIHJlY29yZCBmaWVsZCBpbmZvcm1hdGlvblxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlY29yZFxuICovXG5cbi8qKlxuICogUmVtb3RlIHJlZmVyZW5jZSB0byByZWNvcmQgaW5mb3JtYXRpb25cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIC0gQ29ubmVjdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gU09iamVjdCB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBSZWNvcmQgSURcbiAqL1xudmFyIFJlY29yZFJlZmVyZW5jZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29ubiwgdHlwZSwgaWQpIHtcbiAgdGhpcy5fY29ubiA9IGNvbm47XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuaWQgPSBpZDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgcmVjb3JkIGZpZWxkIGluZm9ybWF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHJlc3QgYXBpLlxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkPn1cbiAqL1xuUmVjb3JkUmVmZXJlbmNlLnByb3RvdHlwZS5yZXRyaWV2ZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmV0cmlldmUodGhpcy50eXBlLCB0aGlzLmlkLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSByZWNvcmQgZmllbGQgaW5mb3JtYXRpb25cbiAqXG4gKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkIC0gQSBSZWNvcmQgd2hpY2ggaW5jbHVkZXMgZmllbGRzIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHJlc3QgYXBpLlxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0Pn1cbiAqL1xuUmVjb3JkUmVmZXJlbmNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihyZWNvcmQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmVjb3JkID0gXy5jbG9uZShyZWNvcmQpO1xuICByZWNvcmQuSWQgPSB0aGlzLmlkO1xuICByZXR1cm4gdGhpcy5fY29ubi51cGRhdGUodGhpcy50eXBlLCByZWNvcmQsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU3lub255bSBvZiBSZWNvcmQjZGVzdHJveSgpXG4gKlxuICogQG1ldGhvZCBSZWNvcmRSZWZlcmVuY2UjZGVsZXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgcmVzdCBhcGkuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHQ+fVxuICovXG5SZWNvcmRSZWZlcmVuY2UucHJvdG90eXBlW1wiZGVsZXRlXCJdID1cbi8qKlxuICogU3lub255bSBvZiBSZWNvcmQjZGVzdHJveSgpXG4gKlxuICogQG1ldGhvZCBSZWNvcmRSZWZlcmVuY2UjZGVsXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHQ+fVxuICovXG5SZWNvcmRSZWZlcmVuY2UucHJvdG90eXBlLmRlbCA9XG4vKipcbiAqIERlbGV0ZSByZWNvcmQgZmllbGRcbiAqXG4gKiBAbWV0aG9kIFJlY29yZFJlZmVyZW5jZSNkZXN0cm95XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgcmVzdCBhcGkuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHQ+fVxuICovXG5SZWNvcmRSZWZlcmVuY2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB0aGlzLl9jb25uLmRlc3Ryb3kodGhpcy50eXBlLCB0aGlzLmlkLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldCBibG9iIGZpZWxkIGFzIHN0cmVhbVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZE5hbWUgLSBCbG9iIGZpZWxkIG5hbWVcbiAqIEByZXR1cm5zIHtzdHJlYW0uU3RyZWFtfVxuICovXG5SZWNvcmRSZWZlcmVuY2UucHJvdG90eXBlLmJsb2IgPSBmdW5jdGlvbihmaWVsZE5hbWUpIHtcbiAgdmFyIHVybCA9IFsgdGhpcy5fY29ubi5fYmFzZVVybCgpLCAnc29iamVjdHMnLCB0aGlzLnR5cGUsIHRoaXMuaWQsIGZpZWxkTmFtZSBdLmpvaW4oJy8nKTtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdCh1cmwpLnN0cmVhbSgpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/record.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/record.js":
/*!********************************************!*\
  !*** ./node_modules/jsforce/lib/record.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Represents Salesforce record information\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar _ = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\");\n\n/**\n * A simple hash object including record field information\n *\n * @typedef {Object} Record\n */\n\n/**\n * Remote reference to record information\n *\n * @protected\n * @class\n * @constructor\n * @param {Connection} conn - Connection object\n * @param {String} type - SObject type\n * @param {String} id - Record ID\n */\nvar RecordReference = module.exports = function(conn, type, id) {\n  this._conn = conn;\n  this.type = type;\n  this.id = id;\n};\n\n/**\n * Retrieve record field information\n *\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<Record>} [callback] - Callback function\n * @returns {Promise.<Record>}\n */\nRecordReference.prototype.retrieve = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._conn.retrieve(this.type, this.id, options, callback);\n};\n\n/**\n * Update record field information\n *\n * @param {Record} record - A Record which includes fields to update\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<RecordResult>} [callback] - Callback function\n * @returns {Promise.<RecordResult>}\n */\nRecordReference.prototype.update = function(record, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  record = _.clone(record);\n  record.Id = this.id;\n  return this._conn.update(this.type, record, options, callback);\n};\n\n/**\n * Synonym of Record#destroy()\n *\n * @method RecordReference#delete\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<RecordResult>} [callback] - Callback function\n * @returns {Promise.<RecordResult>}\n */\nRecordReference.prototype[\"delete\"] =\n/**\n * Synonym of Record#destroy()\n *\n * @method RecordReference#del\n * @param {Callback.<RecordResult>} [callback] - Callback function\n * @returns {Promise.<RecordResult>}\n */\nRecordReference.prototype.del =\n/**\n * Delete record field\n *\n * @method RecordReference#destroy\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<RecordResult>} [callback] - Callback function\n * @returns {Promise.<RecordResult>}\n */\nRecordReference.prototype.destroy = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._conn.destroy(this.type, this.id, options, callback);\n};\n\n/**\n * Get blob field as stream\n *\n * @param {String} fieldName - Blob field name\n * @returns {stream.Stream}\n */\nRecordReference.prototype.blob = function(fieldName) {\n  var url = [ this._conn._baseUrl(), 'sobjects', this.type, this.id, fieldName ].join('/');\n  return this._conn.request(url).stream();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcmVjb3JkLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyx3REFBYTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHlCQUF5QjtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx5QkFBeUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx5QkFBeUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9yZWNvcmQuanM/NTQ2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIFJlcHJlc2VudHMgU2FsZXNmb3JjZSByZWNvcmQgaW5mb3JtYXRpb25cbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpO1xuXG4vKipcbiAqIEEgc2ltcGxlIGhhc2ggb2JqZWN0IGluY2x1ZGluZyByZWNvcmQgZmllbGQgaW5mb3JtYXRpb25cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZWNvcmRcbiAqL1xuXG4vKipcbiAqIFJlbW90ZSByZWZlcmVuY2UgdG8gcmVjb3JkIGluZm9ybWF0aW9uXG4gKlxuICogQHByb3RlY3RlZFxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiAtIENvbm5lY3Rpb24gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFNPYmplY3QgdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gUmVjb3JkIElEXG4gKi9cbnZhciBSZWNvcmRSZWZlcmVuY2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbm4sIHR5cGUsIGlkKSB7XG4gIHRoaXMuX2Nvbm4gPSBjb25uO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLmlkID0gaWQ7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHJlY29yZCBmaWVsZCBpbmZvcm1hdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciByZXN0IGFwaS5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZD59XG4gKi9cblJlY29yZFJlZmVyZW5jZS5wcm90b3R5cGUucmV0cmlldmUgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB0aGlzLl9jb25uLnJldHJpZXZlKHRoaXMudHlwZSwgdGhpcy5pZCwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgcmVjb3JkIGZpZWxkIGluZm9ybWF0aW9uXG4gKlxuICogQHBhcmFtIHtSZWNvcmR9IHJlY29yZCAtIEEgUmVjb3JkIHdoaWNoIGluY2x1ZGVzIGZpZWxkcyB0byB1cGRhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciByZXN0IGFwaS5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZFJlc3VsdD59XG4gKi9cblJlY29yZFJlZmVyZW5jZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ocmVjb3JkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJlY29yZCA9IF8uY2xvbmUocmVjb3JkKTtcbiAgcmVjb3JkLklkID0gdGhpcy5pZDtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4udXBkYXRlKHRoaXMudHlwZSwgcmVjb3JkLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFN5bm9ueW0gb2YgUmVjb3JkI2Rlc3Ryb3koKVxuICpcbiAqIEBtZXRob2QgUmVjb3JkUmVmZXJlbmNlI2RlbGV0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHJlc3QgYXBpLlxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0Pn1cbiAqL1xuUmVjb3JkUmVmZXJlbmNlLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9XG4vKipcbiAqIFN5bm9ueW0gb2YgUmVjb3JkI2Rlc3Ryb3koKVxuICpcbiAqIEBtZXRob2QgUmVjb3JkUmVmZXJlbmNlI2RlbFxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0Pn1cbiAqL1xuUmVjb3JkUmVmZXJlbmNlLnByb3RvdHlwZS5kZWwgPVxuLyoqXG4gKiBEZWxldGUgcmVjb3JkIGZpZWxkXG4gKlxuICogQG1ldGhvZCBSZWNvcmRSZWZlcmVuY2UjZGVzdHJveVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHJlc3QgYXBpLlxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0Pn1cbiAqL1xuUmVjb3JkUmVmZXJlbmNlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4gdGhpcy5fY29ubi5kZXN0cm95KHRoaXMudHlwZSwgdGhpcy5pZCwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXQgYmxvYiBmaWVsZCBhcyBzdHJlYW1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGROYW1lIC0gQmxvYiBmaWVsZCBuYW1lXG4gKiBAcmV0dXJucyB7c3RyZWFtLlN0cmVhbX1cbiAqL1xuUmVjb3JkUmVmZXJlbmNlLnByb3RvdHlwZS5ibG9iID0gZnVuY3Rpb24oZmllbGROYW1lKSB7XG4gIHZhciB1cmwgPSBbIHRoaXMuX2Nvbm4uX2Jhc2VVcmwoKSwgJ3NvYmplY3RzJywgdGhpcy50eXBlLCB0aGlzLmlkLCBmaWVsZE5hbWUgXS5qb2luKCcvJyk7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QodXJsKS5zdHJlYW0oKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/record.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/registry/file-registry.js":
/*!************************************************************!*\
  !*** ./node_modules/jsforce/lib/registry/file-registry.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar Registry = __webpack_require__(/*! ./registry */ \"(action-browser)/./node_modules/jsforce/lib/registry/registry.js\");\n\n/* ------------------------------------------------------------------------- */\n\nvar FileRegistry = function(configFilePath) {\n  FileRegistry.super_.call(this);\n  this._configFilePath = configFilePath || this._getDefaultConfigFilePath();\n  try {\n    var data = fs.readFileSync(this._configFilePath, 'utf-8');\n    this._registryConfig = JSON.parse(data);\n  } catch(e) {}\n};\n\ninherits(FileRegistry, Registry);\n\n/**\n *\n */\nFileRegistry.prototype._getDefaultConfigFilePath = function() {\n  var homeDir = process.env[(process.platform === 'win32') ? 'USERPROFILE' : 'HOME'];\n  var configDir = homeDir + \"/.jsforce\";\n  return configDir + \"/config.json\";\n};\n\n/**\n * @private\n */\nFileRegistry.prototype._saveConfig = function() {\n  var data = JSON.stringify(this._registryConfig, null, 4);\n  try {\n    fs.writeFileSync(this._configFilePath, data);\n    fs.chmodSync(this._configFilePath, \"600\");\n  } catch(e) {\n    var configDir = path.dirname(this._configFilePath);\n    fs.mkdirSync(configDir);\n    fs.chmodSync(configDir, \"700\");\n    fs.writeFileSync(this._configFilePath, data);\n    fs.chmodSync(this._configFilePath, \"600\");\n  }\n};\n\n/**\n *\n */\nmodule.exports = FileRegistry;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9yZWdpc3RyeS9maWxlLXJlZ2lzdHJ5LmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxzRUFBVTtBQUNqQyxTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsZUFBZSxtQkFBTyxDQUFDLG9GQUFZOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9yZWdpc3RyeS9maWxlLXJlZ2lzdHJ5LmpzP2I4YjEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBSZWdpc3RyeSA9IHJlcXVpcmUoJy4vcmVnaXN0cnknKTtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG52YXIgRmlsZVJlZ2lzdHJ5ID0gZnVuY3Rpb24oY29uZmlnRmlsZVBhdGgpIHtcbiAgRmlsZVJlZ2lzdHJ5LnN1cGVyXy5jYWxsKHRoaXMpO1xuICB0aGlzLl9jb25maWdGaWxlUGF0aCA9IGNvbmZpZ0ZpbGVQYXRoIHx8IHRoaXMuX2dldERlZmF1bHRDb25maWdGaWxlUGF0aCgpO1xuICB0cnkge1xuICAgIHZhciBkYXRhID0gZnMucmVhZEZpbGVTeW5jKHRoaXMuX2NvbmZpZ0ZpbGVQYXRoLCAndXRmLTgnKTtcbiAgICB0aGlzLl9yZWdpc3RyeUNvbmZpZyA9IEpTT04ucGFyc2UoZGF0YSk7XG4gIH0gY2F0Y2goZSkge31cbn07XG5cbmluaGVyaXRzKEZpbGVSZWdpc3RyeSwgUmVnaXN0cnkpO1xuXG4vKipcbiAqXG4gKi9cbkZpbGVSZWdpc3RyeS5wcm90b3R5cGUuX2dldERlZmF1bHRDb25maWdGaWxlUGF0aCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9tZURpciA9IHByb2Nlc3MuZW52Wyhwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSA/ICdVU0VSUFJPRklMRScgOiAnSE9NRSddO1xuICB2YXIgY29uZmlnRGlyID0gaG9tZURpciArIFwiLy5qc2ZvcmNlXCI7XG4gIHJldHVybiBjb25maWdEaXIgKyBcIi9jb25maWcuanNvblwiO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5GaWxlUmVnaXN0cnkucHJvdG90eXBlLl9zYXZlQ29uZmlnID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gSlNPTi5zdHJpbmdpZnkodGhpcy5fcmVnaXN0cnlDb25maWcsIG51bGwsIDQpO1xuICB0cnkge1xuICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy5fY29uZmlnRmlsZVBhdGgsIGRhdGEpO1xuICAgIGZzLmNobW9kU3luYyh0aGlzLl9jb25maWdGaWxlUGF0aCwgXCI2MDBcIik7XG4gIH0gY2F0Y2goZSkge1xuICAgIHZhciBjb25maWdEaXIgPSBwYXRoLmRpcm5hbWUodGhpcy5fY29uZmlnRmlsZVBhdGgpO1xuICAgIGZzLm1rZGlyU3luYyhjb25maWdEaXIpO1xuICAgIGZzLmNobW9kU3luYyhjb25maWdEaXIsIFwiNzAwXCIpO1xuICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy5fY29uZmlnRmlsZVBhdGgsIGRhdGEpO1xuICAgIGZzLmNobW9kU3luYyh0aGlzLl9jb25maWdGaWxlUGF0aCwgXCI2MDBcIik7XG4gIH1cbn07XG5cbi8qKlxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBGaWxlUmVnaXN0cnk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/registry/file-registry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/registry/file-registry.js":
/*!************************************************************!*\
  !*** ./node_modules/jsforce/lib/registry/file-registry.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar Registry = __webpack_require__(/*! ./registry */ \"(rsc)/./node_modules/jsforce/lib/registry/registry.js\");\n\n/* ------------------------------------------------------------------------- */\n\nvar FileRegistry = function(configFilePath) {\n  FileRegistry.super_.call(this);\n  this._configFilePath = configFilePath || this._getDefaultConfigFilePath();\n  try {\n    var data = fs.readFileSync(this._configFilePath, 'utf-8');\n    this._registryConfig = JSON.parse(data);\n  } catch(e) {}\n};\n\ninherits(FileRegistry, Registry);\n\n/**\n *\n */\nFileRegistry.prototype._getDefaultConfigFilePath = function() {\n  var homeDir = process.env[(process.platform === 'win32') ? 'USERPROFILE' : 'HOME'];\n  var configDir = homeDir + \"/.jsforce\";\n  return configDir + \"/config.json\";\n};\n\n/**\n * @private\n */\nFileRegistry.prototype._saveConfig = function() {\n  var data = JSON.stringify(this._registryConfig, null, 4);\n  try {\n    fs.writeFileSync(this._configFilePath, data);\n    fs.chmodSync(this._configFilePath, \"600\");\n  } catch(e) {\n    var configDir = path.dirname(this._configFilePath);\n    fs.mkdirSync(configDir);\n    fs.chmodSync(configDir, \"700\");\n    fs.writeFileSync(this._configFilePath, data);\n    fs.chmodSync(this._configFilePath, \"600\");\n  }\n};\n\n/**\n *\n */\nmodule.exports = FileRegistry;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcmVnaXN0cnkvZmlsZS1yZWdpc3RyeS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsMkRBQVU7QUFDakMsU0FBUyxtQkFBTyxDQUFDLGNBQUk7QUFDckIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLGVBQWUsbUJBQU8sQ0FBQyx5RUFBWTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcmVnaXN0cnkvZmlsZS1yZWdpc3RyeS5qcz8yYzRiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgUmVnaXN0cnkgPSByZXF1aXJlKCcuL3JlZ2lzdHJ5Jyk7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxudmFyIEZpbGVSZWdpc3RyeSA9IGZ1bmN0aW9uKGNvbmZpZ0ZpbGVQYXRoKSB7XG4gIEZpbGVSZWdpc3RyeS5zdXBlcl8uY2FsbCh0aGlzKTtcbiAgdGhpcy5fY29uZmlnRmlsZVBhdGggPSBjb25maWdGaWxlUGF0aCB8fCB0aGlzLl9nZXREZWZhdWx0Q29uZmlnRmlsZVBhdGgoKTtcbiAgdHJ5IHtcbiAgICB2YXIgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLl9jb25maWdGaWxlUGF0aCwgJ3V0Zi04Jyk7XG4gICAgdGhpcy5fcmVnaXN0cnlDb25maWcgPSBKU09OLnBhcnNlKGRhdGEpO1xuICB9IGNhdGNoKGUpIHt9XG59O1xuXG5pbmhlcml0cyhGaWxlUmVnaXN0cnksIFJlZ2lzdHJ5KTtcblxuLyoqXG4gKlxuICovXG5GaWxlUmVnaXN0cnkucHJvdG90eXBlLl9nZXREZWZhdWx0Q29uZmlnRmlsZVBhdGggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvbWVEaXIgPSBwcm9jZXNzLmVudlsocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykgPyAnVVNFUlBST0ZJTEUnIDogJ0hPTUUnXTtcbiAgdmFyIGNvbmZpZ0RpciA9IGhvbWVEaXIgKyBcIi8uanNmb3JjZVwiO1xuICByZXR1cm4gY29uZmlnRGlyICsgXCIvY29uZmlnLmpzb25cIjtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRmlsZVJlZ2lzdHJ5LnByb3RvdHlwZS5fc2F2ZUNvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KHRoaXMuX3JlZ2lzdHJ5Q29uZmlnLCBudWxsLCA0KTtcbiAgdHJ5IHtcbiAgICBmcy53cml0ZUZpbGVTeW5jKHRoaXMuX2NvbmZpZ0ZpbGVQYXRoLCBkYXRhKTtcbiAgICBmcy5jaG1vZFN5bmModGhpcy5fY29uZmlnRmlsZVBhdGgsIFwiNjAwXCIpO1xuICB9IGNhdGNoKGUpIHtcbiAgICB2YXIgY29uZmlnRGlyID0gcGF0aC5kaXJuYW1lKHRoaXMuX2NvbmZpZ0ZpbGVQYXRoKTtcbiAgICBmcy5ta2RpclN5bmMoY29uZmlnRGlyKTtcbiAgICBmcy5jaG1vZFN5bmMoY29uZmlnRGlyLCBcIjcwMFwiKTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKHRoaXMuX2NvbmZpZ0ZpbGVQYXRoLCBkYXRhKTtcbiAgICBmcy5jaG1vZFN5bmModGhpcy5fY29uZmlnRmlsZVBhdGgsIFwiNjAwXCIpO1xuICB9XG59O1xuXG4vKipcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gRmlsZVJlZ2lzdHJ5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/registry/file-registry.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/registry/index.js":
/*!****************************************************!*\
  !*** ./node_modules/jsforce/lib/registry/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("var jsforce = __webpack_require__(/*! ../core */ \"(action-browser)/./node_modules/jsforce/lib/core.js\");\nvar FileRegistry = __webpack_require__(/*! ./file-registry */ \"(action-browser)/./node_modules/jsforce/lib/registry/file-registry.js\");\njsforce.registry = new FileRegistry();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9yZWdpc3RyeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsb0VBQVM7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsOEZBQWlCO0FBQzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9yZWdpc3RyeS9pbmRleC5qcz9lODUzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBqc2ZvcmNlID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIEZpbGVSZWdpc3RyeSA9IHJlcXVpcmUoJy4vZmlsZS1yZWdpc3RyeScpO1xuanNmb3JjZS5yZWdpc3RyeSA9IG5ldyBGaWxlUmVnaXN0cnkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/registry/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/registry/index.js":
/*!****************************************************!*\
  !*** ./node_modules/jsforce/lib/registry/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("var jsforce = __webpack_require__(/*! ../core */ \"(rsc)/./node_modules/jsforce/lib/core.js\");\nvar FileRegistry = __webpack_require__(/*! ./file-registry */ \"(rsc)/./node_modules/jsforce/lib/registry/file-registry.js\");\njsforce.registry = new FileRegistry();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcmVnaXN0cnkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLHlEQUFTO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLG1GQUFpQjtBQUM1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcmVnaXN0cnkvaW5kZXguanM/MWU3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIganNmb3JjZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBGaWxlUmVnaXN0cnkgPSByZXF1aXJlKCcuL2ZpbGUtcmVnaXN0cnknKTtcbmpzZm9yY2UucmVnaXN0cnkgPSBuZXcgRmlsZVJlZ2lzdHJ5KCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/registry/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/registry/registry.js":
/*!*******************************************************!*\
  !*** ./node_modules/jsforce/lib/registry/registry.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global process */\n/**\n * @file Registry for connection information, cached in local file system\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar _  = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\");\nvar Connection = __webpack_require__(/*! ../connection */ \"(action-browser)/./node_modules/jsforce/lib/connection.js\");\n\n/*  */\nvar Registry = function(configFilePath) {\n  this._registryConfig = {};\n};\n\n/**\n * @private\n * @override\n */\nRegistry.prototype._saveConfig = function() {\n  throw new Error('_saveConfig must be implemented in subclass');\n};\n\nRegistry.prototype._getClients = function() {\n  return this._registryConfig.clients || (this._registryConfig.clients = {});\n};\n\nRegistry.prototype._getConnections = function() {\n  return this._registryConfig.connections || (this._registryConfig.connections = {});\n};\n\nRegistry.prototype.getConnectionNames = function() {\n  return Object.keys(this._getConnections());\n};\n\nRegistry.prototype.getConnection = function(name) {\n  return new Connection(this.getConnectionConfig(name));\n};\n\nRegistry.prototype.getConnectionConfig = function(name) {\n  if (!name) { name = this._registryConfig[\"default\"]; }\n  var connections = this._getConnections();\n  var connConfig = connections[name];\n  if (connConfig) {\n    connConfig = _.clone(connConfig);\n    if (connConfig.client) {\n      connConfig.oauth2 = _.clone(this.getClient(connConfig.client));\n    }\n    delete connConfig.client;\n  }\n  return connConfig;\n};\n\nRegistry.prototype.saveConnectionConfig = function(name, connConfig) {\n  var connections = this._getConnections();\n  connConfig = _.clone(connConfig);\n  if (connConfig.oauth2) {\n    var clientName = this._findClientName(connConfig.oauth2);\n    if (clientName) {\n      connConfig.client = clientName;\n    }\n    delete connConfig.oauth2;\n  }\n  connections[name] = connConfig;\n  this._saveConfig();\n};\n\nRegistry.prototype._findClientName = function(clientConfig) {\n  var clients = this._getClients();\n  for (var name in clients) {\n    var client = clients[name];\n    if (client.clientId === clientConfig.clientId &&\n        (client.loginUrl || 'https://login.salesforce.com') === clientConfig.loginUrl) {\n      return name;\n    }\n  }\n  return null;\n};\n\nRegistry.prototype.setDefaultConnection = function(name) {\n  this._registryConfig[\"default\"] = name;\n  this._saveConfig();\n};\n\nRegistry.prototype.removeConnectionConfig = function(name) {\n  var connections = this._getConnections();\n  delete connections[name];\n  this._saveConfig();\n};\n\nRegistry.prototype.getClient = function(name) {\n  var clientConfig = this._getClients()[name];\n  return clientConfig && _.clone(clientConfig);\n};\n\nRegistry.prototype.getClientNames = function() {\n  return Object.keys(this._getClients());\n};\n\nRegistry.prototype.registerClient = function(name, clientConfig) {\n  var clients = this._getClients();\n  clients[name] = clientConfig;\n  this._saveConfig();\n};\n\n\n\n/* ------------------------------------------------------------------------- */\n\nmodule.exports = Registry;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9yZWdpc3RyeS9yZWdpc3RyeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLFNBQVMsbUJBQU8sQ0FBQyxtRUFBYTtBQUM5QixpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBZTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkU7QUFDM0U7O0FBRUE7QUFDQSxtRkFBbUY7QUFDbkY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9yZWdpc3RyeS9yZWdpc3RyeS5qcz85MDQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIHByb2Nlc3MgKi9cbi8qKlxuICogQGZpbGUgUmVnaXN0cnkgZm9yIGNvbm5lY3Rpb24gaW5mb3JtYXRpb24sIGNhY2hlZCBpbiBsb2NhbCBmaWxlIHN5c3RlbVxuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyAgPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpO1xudmFyIENvbm5lY3Rpb24gPSByZXF1aXJlKCcuLi9jb25uZWN0aW9uJyk7XG5cbi8qICAqL1xudmFyIFJlZ2lzdHJ5ID0gZnVuY3Rpb24oY29uZmlnRmlsZVBhdGgpIHtcbiAgdGhpcy5fcmVnaXN0cnlDb25maWcgPSB7fTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBvdmVycmlkZVxuICovXG5SZWdpc3RyeS5wcm90b3R5cGUuX3NhdmVDb25maWcgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfc2F2ZUNvbmZpZyBtdXN0IGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzJyk7XG59O1xuXG5SZWdpc3RyeS5wcm90b3R5cGUuX2dldENsaWVudHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3JlZ2lzdHJ5Q29uZmlnLmNsaWVudHMgfHwgKHRoaXMuX3JlZ2lzdHJ5Q29uZmlnLmNsaWVudHMgPSB7fSk7XG59O1xuXG5SZWdpc3RyeS5wcm90b3R5cGUuX2dldENvbm5lY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9yZWdpc3RyeUNvbmZpZy5jb25uZWN0aW9ucyB8fCAodGhpcy5fcmVnaXN0cnlDb25maWcuY29ubmVjdGlvbnMgPSB7fSk7XG59O1xuXG5SZWdpc3RyeS5wcm90b3R5cGUuZ2V0Q29ubmVjdGlvbk5hbWVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9nZXRDb25uZWN0aW9ucygpKTtcbn07XG5cblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRDb25uZWN0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gbmV3IENvbm5lY3Rpb24odGhpcy5nZXRDb25uZWN0aW9uQ29uZmlnKG5hbWUpKTtcbn07XG5cblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRDb25uZWN0aW9uQ29uZmlnID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAoIW5hbWUpIHsgbmFtZSA9IHRoaXMuX3JlZ2lzdHJ5Q29uZmlnW1wiZGVmYXVsdFwiXTsgfVxuICB2YXIgY29ubmVjdGlvbnMgPSB0aGlzLl9nZXRDb25uZWN0aW9ucygpO1xuICB2YXIgY29ubkNvbmZpZyA9IGNvbm5lY3Rpb25zW25hbWVdO1xuICBpZiAoY29ubkNvbmZpZykge1xuICAgIGNvbm5Db25maWcgPSBfLmNsb25lKGNvbm5Db25maWcpO1xuICAgIGlmIChjb25uQ29uZmlnLmNsaWVudCkge1xuICAgICAgY29ubkNvbmZpZy5vYXV0aDIgPSBfLmNsb25lKHRoaXMuZ2V0Q2xpZW50KGNvbm5Db25maWcuY2xpZW50KSk7XG4gICAgfVxuICAgIGRlbGV0ZSBjb25uQ29uZmlnLmNsaWVudDtcbiAgfVxuICByZXR1cm4gY29ubkNvbmZpZztcbn07XG5cblJlZ2lzdHJ5LnByb3RvdHlwZS5zYXZlQ29ubmVjdGlvbkNvbmZpZyA9IGZ1bmN0aW9uKG5hbWUsIGNvbm5Db25maWcpIHtcbiAgdmFyIGNvbm5lY3Rpb25zID0gdGhpcy5fZ2V0Q29ubmVjdGlvbnMoKTtcbiAgY29ubkNvbmZpZyA9IF8uY2xvbmUoY29ubkNvbmZpZyk7XG4gIGlmIChjb25uQ29uZmlnLm9hdXRoMikge1xuICAgIHZhciBjbGllbnROYW1lID0gdGhpcy5fZmluZENsaWVudE5hbWUoY29ubkNvbmZpZy5vYXV0aDIpO1xuICAgIGlmIChjbGllbnROYW1lKSB7XG4gICAgICBjb25uQ29uZmlnLmNsaWVudCA9IGNsaWVudE5hbWU7XG4gICAgfVxuICAgIGRlbGV0ZSBjb25uQ29uZmlnLm9hdXRoMjtcbiAgfVxuICBjb25uZWN0aW9uc1tuYW1lXSA9IGNvbm5Db25maWc7XG4gIHRoaXMuX3NhdmVDb25maWcoKTtcbn07XG5cblJlZ2lzdHJ5LnByb3RvdHlwZS5fZmluZENsaWVudE5hbWUgPSBmdW5jdGlvbihjbGllbnRDb25maWcpIHtcbiAgdmFyIGNsaWVudHMgPSB0aGlzLl9nZXRDbGllbnRzKCk7XG4gIGZvciAodmFyIG5hbWUgaW4gY2xpZW50cykge1xuICAgIHZhciBjbGllbnQgPSBjbGllbnRzW25hbWVdO1xuICAgIGlmIChjbGllbnQuY2xpZW50SWQgPT09IGNsaWVudENvbmZpZy5jbGllbnRJZCAmJlxuICAgICAgICAoY2xpZW50LmxvZ2luVXJsIHx8ICdodHRwczovL2xvZ2luLnNhbGVzZm9yY2UuY29tJykgPT09IGNsaWVudENvbmZpZy5sb2dpblVybCkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuUmVnaXN0cnkucHJvdG90eXBlLnNldERlZmF1bHRDb25uZWN0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuICB0aGlzLl9yZWdpc3RyeUNvbmZpZ1tcImRlZmF1bHRcIl0gPSBuYW1lO1xuICB0aGlzLl9zYXZlQ29uZmlnKCk7XG59O1xuXG5SZWdpc3RyeS5wcm90b3R5cGUucmVtb3ZlQ29ubmVjdGlvbkNvbmZpZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNvbm5lY3Rpb25zID0gdGhpcy5fZ2V0Q29ubmVjdGlvbnMoKTtcbiAgZGVsZXRlIGNvbm5lY3Rpb25zW25hbWVdO1xuICB0aGlzLl9zYXZlQ29uZmlnKCk7XG59O1xuXG5SZWdpc3RyeS5wcm90b3R5cGUuZ2V0Q2xpZW50ID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgY2xpZW50Q29uZmlnID0gdGhpcy5fZ2V0Q2xpZW50cygpW25hbWVdO1xuICByZXR1cm4gY2xpZW50Q29uZmlnICYmIF8uY2xvbmUoY2xpZW50Q29uZmlnKTtcbn07XG5cblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRDbGllbnROYW1lcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZ2V0Q2xpZW50cygpKTtcbn07XG5cblJlZ2lzdHJ5LnByb3RvdHlwZS5yZWdpc3RlckNsaWVudCA9IGZ1bmN0aW9uKG5hbWUsIGNsaWVudENvbmZpZykge1xuICB2YXIgY2xpZW50cyA9IHRoaXMuX2dldENsaWVudHMoKTtcbiAgY2xpZW50c1tuYW1lXSA9IGNsaWVudENvbmZpZztcbiAgdGhpcy5fc2F2ZUNvbmZpZygpO1xufTtcblxuXG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWdpc3RyeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/registry/registry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/registry/registry.js":
/*!*******************************************************!*\
  !*** ./node_modules/jsforce/lib/registry/registry.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global process */\n/**\n * @file Registry for connection information, cached in local file system\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar _  = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\");\nvar Connection = __webpack_require__(/*! ../connection */ \"(rsc)/./node_modules/jsforce/lib/connection.js\");\n\n/*  */\nvar Registry = function(configFilePath) {\n  this._registryConfig = {};\n};\n\n/**\n * @private\n * @override\n */\nRegistry.prototype._saveConfig = function() {\n  throw new Error('_saveConfig must be implemented in subclass');\n};\n\nRegistry.prototype._getClients = function() {\n  return this._registryConfig.clients || (this._registryConfig.clients = {});\n};\n\nRegistry.prototype._getConnections = function() {\n  return this._registryConfig.connections || (this._registryConfig.connections = {});\n};\n\nRegistry.prototype.getConnectionNames = function() {\n  return Object.keys(this._getConnections());\n};\n\nRegistry.prototype.getConnection = function(name) {\n  return new Connection(this.getConnectionConfig(name));\n};\n\nRegistry.prototype.getConnectionConfig = function(name) {\n  if (!name) { name = this._registryConfig[\"default\"]; }\n  var connections = this._getConnections();\n  var connConfig = connections[name];\n  if (connConfig) {\n    connConfig = _.clone(connConfig);\n    if (connConfig.client) {\n      connConfig.oauth2 = _.clone(this.getClient(connConfig.client));\n    }\n    delete connConfig.client;\n  }\n  return connConfig;\n};\n\nRegistry.prototype.saveConnectionConfig = function(name, connConfig) {\n  var connections = this._getConnections();\n  connConfig = _.clone(connConfig);\n  if (connConfig.oauth2) {\n    var clientName = this._findClientName(connConfig.oauth2);\n    if (clientName) {\n      connConfig.client = clientName;\n    }\n    delete connConfig.oauth2;\n  }\n  connections[name] = connConfig;\n  this._saveConfig();\n};\n\nRegistry.prototype._findClientName = function(clientConfig) {\n  var clients = this._getClients();\n  for (var name in clients) {\n    var client = clients[name];\n    if (client.clientId === clientConfig.clientId &&\n        (client.loginUrl || 'https://login.salesforce.com') === clientConfig.loginUrl) {\n      return name;\n    }\n  }\n  return null;\n};\n\nRegistry.prototype.setDefaultConnection = function(name) {\n  this._registryConfig[\"default\"] = name;\n  this._saveConfig();\n};\n\nRegistry.prototype.removeConnectionConfig = function(name) {\n  var connections = this._getConnections();\n  delete connections[name];\n  this._saveConfig();\n};\n\nRegistry.prototype.getClient = function(name) {\n  var clientConfig = this._getClients()[name];\n  return clientConfig && _.clone(clientConfig);\n};\n\nRegistry.prototype.getClientNames = function() {\n  return Object.keys(this._getClients());\n};\n\nRegistry.prototype.registerClient = function(name, clientConfig) {\n  var clients = this._getClients();\n  clients[name] = clientConfig;\n  this._saveConfig();\n};\n\n\n\n/* ------------------------------------------------------------------------- */\n\nmodule.exports = Registry;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcmVnaXN0cnkvcmVnaXN0cnkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixTQUFTLG1CQUFPLENBQUMsd0RBQWE7QUFDOUIsaUJBQWlCLG1CQUFPLENBQUMscUVBQWU7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkVBQTJFO0FBQzNFOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcmVnaXN0cnkvcmVnaXN0cnkuanM/YTFmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBwcm9jZXNzICovXG4vKipcbiAqIEBmaWxlIFJlZ2lzdHJ5IGZvciBjb25uZWN0aW9uIGluZm9ybWF0aW9uLCBjYWNoZWQgaW4gbG9jYWwgZmlsZSBzeXN0ZW1cbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKTtcbnZhciBDb25uZWN0aW9uID0gcmVxdWlyZSgnLi4vY29ubmVjdGlvbicpO1xuXG4vKiAgKi9cbnZhciBSZWdpc3RyeSA9IGZ1bmN0aW9uKGNvbmZpZ0ZpbGVQYXRoKSB7XG4gIHRoaXMuX3JlZ2lzdHJ5Q29uZmlnID0ge307XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAb3ZlcnJpZGVcbiAqL1xuUmVnaXN0cnkucHJvdG90eXBlLl9zYXZlQ29uZmlnID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3NhdmVDb25maWcgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzcycpO1xufTtcblxuUmVnaXN0cnkucHJvdG90eXBlLl9nZXRDbGllbnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9yZWdpc3RyeUNvbmZpZy5jbGllbnRzIHx8ICh0aGlzLl9yZWdpc3RyeUNvbmZpZy5jbGllbnRzID0ge30pO1xufTtcblxuUmVnaXN0cnkucHJvdG90eXBlLl9nZXRDb25uZWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcmVnaXN0cnlDb25maWcuY29ubmVjdGlvbnMgfHwgKHRoaXMuX3JlZ2lzdHJ5Q29uZmlnLmNvbm5lY3Rpb25zID0ge30pO1xufTtcblxuUmVnaXN0cnkucHJvdG90eXBlLmdldENvbm5lY3Rpb25OYW1lcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZ2V0Q29ubmVjdGlvbnMoKSk7XG59O1xuXG5SZWdpc3RyeS5wcm90b3R5cGUuZ2V0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBDb25uZWN0aW9uKHRoaXMuZ2V0Q29ubmVjdGlvbkNvbmZpZyhuYW1lKSk7XG59O1xuXG5SZWdpc3RyeS5wcm90b3R5cGUuZ2V0Q29ubmVjdGlvbkNvbmZpZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKCFuYW1lKSB7IG5hbWUgPSB0aGlzLl9yZWdpc3RyeUNvbmZpZ1tcImRlZmF1bHRcIl07IH1cbiAgdmFyIGNvbm5lY3Rpb25zID0gdGhpcy5fZ2V0Q29ubmVjdGlvbnMoKTtcbiAgdmFyIGNvbm5Db25maWcgPSBjb25uZWN0aW9uc1tuYW1lXTtcbiAgaWYgKGNvbm5Db25maWcpIHtcbiAgICBjb25uQ29uZmlnID0gXy5jbG9uZShjb25uQ29uZmlnKTtcbiAgICBpZiAoY29ubkNvbmZpZy5jbGllbnQpIHtcbiAgICAgIGNvbm5Db25maWcub2F1dGgyID0gXy5jbG9uZSh0aGlzLmdldENsaWVudChjb25uQ29uZmlnLmNsaWVudCkpO1xuICAgIH1cbiAgICBkZWxldGUgY29ubkNvbmZpZy5jbGllbnQ7XG4gIH1cbiAgcmV0dXJuIGNvbm5Db25maWc7XG59O1xuXG5SZWdpc3RyeS5wcm90b3R5cGUuc2F2ZUNvbm5lY3Rpb25Db25maWcgPSBmdW5jdGlvbihuYW1lLCBjb25uQ29uZmlnKSB7XG4gIHZhciBjb25uZWN0aW9ucyA9IHRoaXMuX2dldENvbm5lY3Rpb25zKCk7XG4gIGNvbm5Db25maWcgPSBfLmNsb25lKGNvbm5Db25maWcpO1xuICBpZiAoY29ubkNvbmZpZy5vYXV0aDIpIHtcbiAgICB2YXIgY2xpZW50TmFtZSA9IHRoaXMuX2ZpbmRDbGllbnROYW1lKGNvbm5Db25maWcub2F1dGgyKTtcbiAgICBpZiAoY2xpZW50TmFtZSkge1xuICAgICAgY29ubkNvbmZpZy5jbGllbnQgPSBjbGllbnROYW1lO1xuICAgIH1cbiAgICBkZWxldGUgY29ubkNvbmZpZy5vYXV0aDI7XG4gIH1cbiAgY29ubmVjdGlvbnNbbmFtZV0gPSBjb25uQ29uZmlnO1xuICB0aGlzLl9zYXZlQ29uZmlnKCk7XG59O1xuXG5SZWdpc3RyeS5wcm90b3R5cGUuX2ZpbmRDbGllbnROYW1lID0gZnVuY3Rpb24oY2xpZW50Q29uZmlnKSB7XG4gIHZhciBjbGllbnRzID0gdGhpcy5fZ2V0Q2xpZW50cygpO1xuICBmb3IgKHZhciBuYW1lIGluIGNsaWVudHMpIHtcbiAgICB2YXIgY2xpZW50ID0gY2xpZW50c1tuYW1lXTtcbiAgICBpZiAoY2xpZW50LmNsaWVudElkID09PSBjbGllbnRDb25maWcuY2xpZW50SWQgJiZcbiAgICAgICAgKGNsaWVudC5sb2dpblVybCB8fCAnaHR0cHM6Ly9sb2dpbi5zYWxlc2ZvcmNlLmNvbScpID09PSBjbGllbnRDb25maWcubG9naW5VcmwpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cblJlZ2lzdHJ5LnByb3RvdHlwZS5zZXREZWZhdWx0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdGhpcy5fcmVnaXN0cnlDb25maWdbXCJkZWZhdWx0XCJdID0gbmFtZTtcbiAgdGhpcy5fc2F2ZUNvbmZpZygpO1xufTtcblxuUmVnaXN0cnkucHJvdG90eXBlLnJlbW92ZUNvbm5lY3Rpb25Db25maWcgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBjb25uZWN0aW9ucyA9IHRoaXMuX2dldENvbm5lY3Rpb25zKCk7XG4gIGRlbGV0ZSBjb25uZWN0aW9uc1tuYW1lXTtcbiAgdGhpcy5fc2F2ZUNvbmZpZygpO1xufTtcblxuUmVnaXN0cnkucHJvdG90eXBlLmdldENsaWVudCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNsaWVudENvbmZpZyA9IHRoaXMuX2dldENsaWVudHMoKVtuYW1lXTtcbiAgcmV0dXJuIGNsaWVudENvbmZpZyAmJiBfLmNsb25lKGNsaWVudENvbmZpZyk7XG59O1xuXG5SZWdpc3RyeS5wcm90b3R5cGUuZ2V0Q2xpZW50TmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2dldENsaWVudHMoKSk7XG59O1xuXG5SZWdpc3RyeS5wcm90b3R5cGUucmVnaXN0ZXJDbGllbnQgPSBmdW5jdGlvbihuYW1lLCBjbGllbnRDb25maWcpIHtcbiAgdmFyIGNsaWVudHMgPSB0aGlzLl9nZXRDbGllbnRzKCk7XG4gIGNsaWVudHNbbmFtZV0gPSBjbGllbnRDb25maWc7XG4gIHRoaXMuX3NhdmVDb25maWcoKTtcbn07XG5cblxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVnaXN0cnk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/registry/registry.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/require.js":
/*!*********************************************!*\
  !*** ./node_modules/jsforce/lib/require.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar required = __webpack_require__(/*! ./_required */ \"(action-browser)/./node_modules/jsforce/lib/_required.js\");\n\nmodule.exports = function(name) {\n  if (name === './jsforce' || name === 'jsforce') {\n    name = './core';\n  }\n  var m = required[name];\n  if (typeof m === 'undefined') {\n    throw new Error(\"Cannot find module '\" + name + \"'\");\n  }\n  return m;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9yZXF1aXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyw2RUFBYTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL3JlcXVpcmUuanM/NmI0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJy4vX3JlcXVpcmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAobmFtZSA9PT0gJy4vanNmb3JjZScgfHwgbmFtZSA9PT0gJ2pzZm9yY2UnKSB7XG4gICAgbmFtZSA9ICcuL2NvcmUnO1xuICB9XG4gIHZhciBtID0gcmVxdWlyZWRbbmFtZV07XG4gIGlmICh0eXBlb2YgbSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgbmFtZSArIFwiJ1wiKTtcbiAgfVxuICByZXR1cm4gbTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/require.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/require.js":
/*!*********************************************!*\
  !*** ./node_modules/jsforce/lib/require.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar required = __webpack_require__(/*! ./_required */ \"(rsc)/./node_modules/jsforce/lib/_required.js\");\n\nmodule.exports = function(name) {\n  if (name === './jsforce' || name === 'jsforce') {\n    name = './core';\n  }\n  var m = required[name];\n  if (typeof m === 'undefined') {\n    throw new Error(\"Cannot find module '\" + name + \"'\");\n  }\n  return m;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvcmVxdWlyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsa0VBQWE7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9yZXF1aXJlLmpzPzE2ZjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZWQgPSByZXF1aXJlKCcuL19yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKG5hbWUgPT09ICcuL2pzZm9yY2UnIHx8IG5hbWUgPT09ICdqc2ZvcmNlJykge1xuICAgIG5hbWUgPSAnLi9jb3JlJztcbiAgfVxuICB2YXIgbSA9IHJlcXVpcmVkW25hbWVdO1xuICBpZiAodHlwZW9mIG0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIG5hbWUgKyBcIidcIik7XG4gIH1cbiAgcmV0dXJuIG07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/require.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/soap.js":
/*!******************************************!*\
  !*** ./node_modules/jsforce/lib/soap.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages method call to SOAP endpoint\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\"),\n    _ = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    xml2js = __webpack_require__(/*! xml2js */ \"(action-browser)/./node_modules/xml2js/lib/xml2js.js\"),\n    HttpApi = __webpack_require__(/*! ./http-api */ \"(action-browser)/./node_modules/jsforce/lib/http-api.js\");\n\n\n/**\n * Class for SOAP endpoint of Salesforce\n *\n * @protected\n * @class\n * @constructor\n * @param {Connection} conn - Connection instance\n * @param {Object} options - SOAP endpoint setting options\n * @param {String} options.endpointUrl - SOAP endpoint URL\n * @param {String} [options.xmlns] - XML namespace for method call (default is \"urn:partner.soap.sforce.com\")\n */\nvar SOAP = module.exports = function(conn, options) {\n  SOAP.super_.apply(this, arguments);\n  this._endpointUrl = options.endpointUrl;\n  this._xmlns = options.xmlns || 'urn:partner.soap.sforce.com';\n};\n\ninherits(SOAP, HttpApi);\n\n/**\n * Invoke SOAP call using method and arguments\n *\n * @param {String} method - Method name\n * @param {Object} args - Arguments for the method call\n * @param {Object} [schema] - Schema definition of response message\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nSOAP.prototype.invoke = function(method, args, schema, callback) {\n  if (typeof schema === 'function') {\n    callback = schema;\n    schema = null;\n  }\n  var message = {};\n  message[method] = args;\n  return this.request({\n    method: 'POST',\n    url: this._endpointUrl,\n    headers: {\n      'Content-Type': 'text/xml',\n      'SOAPAction': '\"\"'\n    },\n    message: message\n  }).then(function(res) {\n    return schema ? convertType(res, schema) : res;\n  }).thenCall(callback);\n};\n\n/* @private */\nfunction convertType(value, schema) {\n  if (_.isArray(value)) {\n    return value.map(function(v) {\n      return convertType(v, schema && schema[0])\n    });\n  } else if (_.isObject(value)) {\n    if (value.$ && value.$['xsi:nil'] === 'true') {\n      return null;\n    } else if (_.isArray(schema)) {\n      return [ convertType(value, schema[0]) ];\n    } else {\n      var o = {};\n      for (var key in value) {\n        o[key] = convertType(value[key], schema && schema[key]);\n      }\n      return o;\n    }\n  } else {\n    if (_.isArray(schema)) {\n      return [ convertType(value, schema[0]) ];\n    } else if (_.isObject(schema)) {\n      return {};\n    } else {\n      switch(schema) {\n        case 'string':\n          return String(value);\n        case 'number':\n          return Number(value);\n        case 'boolean':\n          return value === 'true';\n        default:\n          return value;\n      }\n    }\n  }\n}\n\n/** @override **/\nSOAP.prototype.beforeSend = function(request) {\n  request.body = this._createEnvelope(request.message);\n};\n\n/** @override **/\nSOAP.prototype.isSessionExpired = function(response) {\n  return response.statusCode === 500 &&\n    /<faultcode>[a-zA-Z]+:INVALID_SESSION_ID<\\/faultcode>/.test(response.body);\n};\n\n/** @override **/\nSOAP.prototype.parseError = function(body) {\n  var error = lookupValue(body, [ /:Envelope$/, /:Body$/, /:Fault$/ ]);\n  return {\n    errorCode: error.faultcode,\n    message: error.faultstring\n  };\n};\n\n/** @override **/\nSOAP.prototype.getResponseBody = function(response) {\n  var body = SOAP.super_.prototype.getResponseBody.call(this, response);\n  return lookupValue(body, [ /:Envelope$/, /:Body$/, /.+/ ]);\n};\n\n/**\n * @private\n */\nfunction lookupValue(obj, propRegExps) {\n  var regexp = propRegExps.shift();\n  if (!regexp) {\n    return obj;\n  }\n  else {\n    for (var prop in obj) {\n      if (regexp.test(prop)) {\n        return lookupValue(obj[prop], propRegExps);\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * @private\n */\nfunction toXML(name, value) {\n  if (_.isObject(name)) {\n    value = name;\n    name = null;\n  }\n  if (_.isArray(value)) {\n    return _.map(value, function(v) { return toXML(name, v); }).join('');\n  } else {\n    var attrs = [];\n    var elems = [];\n    if (_.isObject(value)) {\n      for (var k in value) {\n        var v = value[k];\n        if (k[0] === '@') {\n          k = k.substring(1);\n          attrs.push(k + '=\"' + v + '\"');\n        } else {\n          elems.push(toXML(k, v));\n        }\n      }\n      value = elems.join('');\n    } else {\n      value = String(value)\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&apos;');\n    }\n    var startTag = name ? '<' + name + (attrs.length > 0 ? ' ' + attrs.join(' ') : '') + '>' : '';\n    var endTag = name ? '</' + name + '>' : '';\n    return  startTag + value + endTag;\n  }\n}\n\n/**\n * @private\n */\nSOAP.prototype._createEnvelope = function(message) {\n  var header = {};\n  var conn = this._conn;\n  if (conn.accessToken) {\n    header.SessionHeader = { sessionId: this._conn.accessToken };\n  }\n  if (conn.callOptions) {\n    header.CallOptions = conn.callOptions;\n  }\n  return [\n    '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n    '<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"',\n    ' xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"',\n    ' xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">',\n    '<soapenv:Header xmlns=\"' + this._xmlns + '\">',\n    toXML(header),\n    '</soapenv:Header>',\n    '<soapenv:Body xmlns=\"' + this._xmlns + '\">',\n    toXML(message),\n    '</soapenv:Body>',\n    '</soapenv:Envelope>'\n  ].join('');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9zb2FwLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxzRUFBVTtBQUNqQyxRQUFRLG1CQUFPLENBQUMsbUVBQWE7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLG9FQUFRO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQywyRUFBWTs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx3QkFBd0I7QUFDOUQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL3NvYXAuanM/N2EzYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIE1hbmFnZXMgbWV0aG9kIGNhbGwgdG8gU09BUCBlbmRwb2ludFxuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgIF8gPSByZXF1aXJlKCdsb2Rhc2gvY29yZScpLFxuICAgIHhtbDJqcyA9IHJlcXVpcmUoJ3htbDJqcycpLFxuICAgIEh0dHBBcGkgPSByZXF1aXJlKCcuL2h0dHAtYXBpJyk7XG5cblxuLyoqXG4gKiBDbGFzcyBmb3IgU09BUCBlbmRwb2ludCBvZiBTYWxlc2ZvcmNlXG4gKlxuICogQHByb3RlY3RlZFxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiAtIENvbm5lY3Rpb24gaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gU09BUCBlbmRwb2ludCBzZXR0aW5nIG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmVuZHBvaW50VXJsIC0gU09BUCBlbmRwb2ludCBVUkxcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy54bWxuc10gLSBYTUwgbmFtZXNwYWNlIGZvciBtZXRob2QgY2FsbCAoZGVmYXVsdCBpcyBcInVybjpwYXJ0bmVyLnNvYXAuc2ZvcmNlLmNvbVwiKVxuICovXG52YXIgU09BUCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29ubiwgb3B0aW9ucykge1xuICBTT0FQLnN1cGVyXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB0aGlzLl9lbmRwb2ludFVybCA9IG9wdGlvbnMuZW5kcG9pbnRVcmw7XG4gIHRoaXMuX3htbG5zID0gb3B0aW9ucy54bWxucyB8fCAndXJuOnBhcnRuZXIuc29hcC5zZm9yY2UuY29tJztcbn07XG5cbmluaGVyaXRzKFNPQVAsIEh0dHBBcGkpO1xuXG4vKipcbiAqIEludm9rZSBTT0FQIGNhbGwgdXNpbmcgbWV0aG9kIGFuZCBhcmd1bWVudHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIC0gTWV0aG9kIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gQXJndW1lbnRzIGZvciB0aGUgbWV0aG9kIGNhbGxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NoZW1hXSAtIFNjaGVtYSBkZWZpbml0aW9uIG9mIHJlc3BvbnNlIG1lc3NhZ2VcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE9iamVjdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59XG4gKi9cblNPQVAucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uKG1ldGhvZCwgYXJncywgc2NoZW1hLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc2NoZW1hO1xuICAgIHNjaGVtYSA9IG51bGw7XG4gIH1cbiAgdmFyIG1lc3NhZ2UgPSB7fTtcbiAgbWVzc2FnZVttZXRob2RdID0gYXJncztcbiAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgdXJsOiB0aGlzLl9lbmRwb2ludFVybCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQveG1sJyxcbiAgICAgICdTT0FQQWN0aW9uJzogJ1wiXCInXG4gICAgfSxcbiAgICBtZXNzYWdlOiBtZXNzYWdlXG4gIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgcmV0dXJuIHNjaGVtYSA/IGNvbnZlcnRUeXBlKHJlcywgc2NoZW1hKSA6IHJlcztcbiAgfSkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyogQHByaXZhdGUgKi9cbmZ1bmN0aW9uIGNvbnZlcnRUeXBlKHZhbHVlLCBzY2hlbWEpIHtcbiAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBjb252ZXJ0VHlwZSh2LCBzY2hlbWEgJiYgc2NoZW1hWzBdKVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgaWYgKHZhbHVlLiQgJiYgdmFsdWUuJFsneHNpOm5pbCddID09PSAndHJ1ZScpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgIHJldHVybiBbIGNvbnZlcnRUeXBlKHZhbHVlLCBzY2hlbWFbMF0pIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgb1trZXldID0gY29udmVydFR5cGUodmFsdWVba2V5XSwgc2NoZW1hICYmIHNjaGVtYVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoXy5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgIHJldHVybiBbIGNvbnZlcnRUeXBlKHZhbHVlLCBzY2hlbWFbMF0pIF07XG4gICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHNjaGVtYSkpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoKHNjaGVtYSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09ICd0cnVlJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKiBAb3ZlcnJpZGUgKiovXG5TT0FQLnByb3RvdHlwZS5iZWZvcmVTZW5kID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICByZXF1ZXN0LmJvZHkgPSB0aGlzLl9jcmVhdGVFbnZlbG9wZShyZXF1ZXN0Lm1lc3NhZ2UpO1xufTtcblxuLyoqIEBvdmVycmlkZSAqKi9cblNPQVAucHJvdG90eXBlLmlzU2Vzc2lvbkV4cGlyZWQgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICByZXR1cm4gcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNTAwICYmXG4gICAgLzxmYXVsdGNvZGU+W2EtekEtWl0rOklOVkFMSURfU0VTU0lPTl9JRDxcXC9mYXVsdGNvZGU+Ly50ZXN0KHJlc3BvbnNlLmJvZHkpO1xufTtcblxuLyoqIEBvdmVycmlkZSAqKi9cblNPQVAucHJvdG90eXBlLnBhcnNlRXJyb3IgPSBmdW5jdGlvbihib2R5KSB7XG4gIHZhciBlcnJvciA9IGxvb2t1cFZhbHVlKGJvZHksIFsgLzpFbnZlbG9wZSQvLCAvOkJvZHkkLywgLzpGYXVsdCQvIF0pO1xuICByZXR1cm4ge1xuICAgIGVycm9yQ29kZTogZXJyb3IuZmF1bHRjb2RlLFxuICAgIG1lc3NhZ2U6IGVycm9yLmZhdWx0c3RyaW5nXG4gIH07XG59O1xuXG4vKiogQG92ZXJyaWRlICoqL1xuU09BUC5wcm90b3R5cGUuZ2V0UmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgdmFyIGJvZHkgPSBTT0FQLnN1cGVyXy5wcm90b3R5cGUuZ2V0UmVzcG9uc2VCb2R5LmNhbGwodGhpcywgcmVzcG9uc2UpO1xuICByZXR1cm4gbG9va3VwVmFsdWUoYm9keSwgWyAvOkVudmVsb3BlJC8sIC86Qm9keSQvLCAvLisvIF0pO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb29rdXBWYWx1ZShvYmosIHByb3BSZWdFeHBzKSB7XG4gIHZhciByZWdleHAgPSBwcm9wUmVnRXhwcy5zaGlmdCgpO1xuICBpZiAoIXJlZ2V4cCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgZWxzZSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIGlmIChyZWdleHAudGVzdChwcm9wKSkge1xuICAgICAgICByZXR1cm4gbG9va3VwVmFsdWUob2JqW3Byb3BdLCBwcm9wUmVnRXhwcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdG9YTUwobmFtZSwgdmFsdWUpIHtcbiAgaWYgKF8uaXNPYmplY3QobmFtZSkpIHtcbiAgICB2YWx1ZSA9IG5hbWU7XG4gICAgbmFtZSA9IG51bGw7XG4gIH1cbiAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXy5tYXAodmFsdWUsIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHRvWE1MKG5hbWUsIHYpOyB9KS5qb2luKCcnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYXR0cnMgPSBbXTtcbiAgICB2YXIgZWxlbXMgPSBbXTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIGZvciAodmFyIGsgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIHYgPSB2YWx1ZVtrXTtcbiAgICAgICAgaWYgKGtbMF0gPT09ICdAJykge1xuICAgICAgICAgIGsgPSBrLnN1YnN0cmluZygxKTtcbiAgICAgICAgICBhdHRycy5wdXNoKGsgKyAnPVwiJyArIHYgKyAnXCInKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtcy5wdXNoKHRvWE1MKGssIHYpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgPSBlbGVtcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXG4gICAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgICAgIC5yZXBsYWNlKC8nL2csICcmYXBvczsnKTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0VGFnID0gbmFtZSA/ICc8JyArIG5hbWUgKyAoYXR0cnMubGVuZ3RoID4gMCA/ICcgJyArIGF0dHJzLmpvaW4oJyAnKSA6ICcnKSArICc+JyA6ICcnO1xuICAgIHZhciBlbmRUYWcgPSBuYW1lID8gJzwvJyArIG5hbWUgKyAnPicgOiAnJztcbiAgICByZXR1cm4gIHN0YXJ0VGFnICsgdmFsdWUgKyBlbmRUYWc7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5TT0FQLnByb3RvdHlwZS5fY3JlYXRlRW52ZWxvcGUgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIHZhciBoZWFkZXIgPSB7fTtcbiAgdmFyIGNvbm4gPSB0aGlzLl9jb25uO1xuICBpZiAoY29ubi5hY2Nlc3NUb2tlbikge1xuICAgIGhlYWRlci5TZXNzaW9uSGVhZGVyID0geyBzZXNzaW9uSWQ6IHRoaXMuX2Nvbm4uYWNjZXNzVG9rZW4gfTtcbiAgfVxuICBpZiAoY29ubi5jYWxsT3B0aW9ucykge1xuICAgIGhlYWRlci5DYWxsT3B0aW9ucyA9IGNvbm4uY2FsbE9wdGlvbnM7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+JyxcbiAgICAnPHNvYXBlbnY6RW52ZWxvcGUgeG1sbnM6c29hcGVudj1cImh0dHA6Ly9zY2hlbWFzLnhtbHNvYXAub3JnL3NvYXAvZW52ZWxvcGUvXCInLFxuICAgICcgeG1sbnM6eHNkPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWFcIicsXG4gICAgJyB4bWxuczp4c2k9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYS1pbnN0YW5jZVwiPicsXG4gICAgJzxzb2FwZW52OkhlYWRlciB4bWxucz1cIicgKyB0aGlzLl94bWxucyArICdcIj4nLFxuICAgIHRvWE1MKGhlYWRlciksXG4gICAgJzwvc29hcGVudjpIZWFkZXI+JyxcbiAgICAnPHNvYXBlbnY6Qm9keSB4bWxucz1cIicgKyB0aGlzLl94bWxucyArICdcIj4nLFxuICAgIHRvWE1MKG1lc3NhZ2UpLFxuICAgICc8L3NvYXBlbnY6Qm9keT4nLFxuICAgICc8L3NvYXBlbnY6RW52ZWxvcGU+J1xuICBdLmpvaW4oJycpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/soap.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/soap.js":
/*!******************************************!*\
  !*** ./node_modules/jsforce/lib/soap.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Manages method call to SOAP endpoint\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\"),\n    _ = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    xml2js = __webpack_require__(/*! xml2js */ \"(rsc)/./node_modules/xml2js/lib/xml2js.js\"),\n    HttpApi = __webpack_require__(/*! ./http-api */ \"(rsc)/./node_modules/jsforce/lib/http-api.js\");\n\n\n/**\n * Class for SOAP endpoint of Salesforce\n *\n * @protected\n * @class\n * @constructor\n * @param {Connection} conn - Connection instance\n * @param {Object} options - SOAP endpoint setting options\n * @param {String} options.endpointUrl - SOAP endpoint URL\n * @param {String} [options.xmlns] - XML namespace for method call (default is \"urn:partner.soap.sforce.com\")\n */\nvar SOAP = module.exports = function(conn, options) {\n  SOAP.super_.apply(this, arguments);\n  this._endpointUrl = options.endpointUrl;\n  this._xmlns = options.xmlns || 'urn:partner.soap.sforce.com';\n};\n\ninherits(SOAP, HttpApi);\n\n/**\n * Invoke SOAP call using method and arguments\n *\n * @param {String} method - Method name\n * @param {Object} args - Arguments for the method call\n * @param {Object} [schema] - Schema definition of response message\n * @param {Callback.<Object>} [callback] - Callback function\n * @returns {Promise.<Object>}\n */\nSOAP.prototype.invoke = function(method, args, schema, callback) {\n  if (typeof schema === 'function') {\n    callback = schema;\n    schema = null;\n  }\n  var message = {};\n  message[method] = args;\n  return this.request({\n    method: 'POST',\n    url: this._endpointUrl,\n    headers: {\n      'Content-Type': 'text/xml',\n      'SOAPAction': '\"\"'\n    },\n    message: message\n  }).then(function(res) {\n    return schema ? convertType(res, schema) : res;\n  }).thenCall(callback);\n};\n\n/* @private */\nfunction convertType(value, schema) {\n  if (_.isArray(value)) {\n    return value.map(function(v) {\n      return convertType(v, schema && schema[0])\n    });\n  } else if (_.isObject(value)) {\n    if (value.$ && value.$['xsi:nil'] === 'true') {\n      return null;\n    } else if (_.isArray(schema)) {\n      return [ convertType(value, schema[0]) ];\n    } else {\n      var o = {};\n      for (var key in value) {\n        o[key] = convertType(value[key], schema && schema[key]);\n      }\n      return o;\n    }\n  } else {\n    if (_.isArray(schema)) {\n      return [ convertType(value, schema[0]) ];\n    } else if (_.isObject(schema)) {\n      return {};\n    } else {\n      switch(schema) {\n        case 'string':\n          return String(value);\n        case 'number':\n          return Number(value);\n        case 'boolean':\n          return value === 'true';\n        default:\n          return value;\n      }\n    }\n  }\n}\n\n/** @override **/\nSOAP.prototype.beforeSend = function(request) {\n  request.body = this._createEnvelope(request.message);\n};\n\n/** @override **/\nSOAP.prototype.isSessionExpired = function(response) {\n  return response.statusCode === 500 &&\n    /<faultcode>[a-zA-Z]+:INVALID_SESSION_ID<\\/faultcode>/.test(response.body);\n};\n\n/** @override **/\nSOAP.prototype.parseError = function(body) {\n  var error = lookupValue(body, [ /:Envelope$/, /:Body$/, /:Fault$/ ]);\n  return {\n    errorCode: error.faultcode,\n    message: error.faultstring\n  };\n};\n\n/** @override **/\nSOAP.prototype.getResponseBody = function(response) {\n  var body = SOAP.super_.prototype.getResponseBody.call(this, response);\n  return lookupValue(body, [ /:Envelope$/, /:Body$/, /.+/ ]);\n};\n\n/**\n * @private\n */\nfunction lookupValue(obj, propRegExps) {\n  var regexp = propRegExps.shift();\n  if (!regexp) {\n    return obj;\n  }\n  else {\n    for (var prop in obj) {\n      if (regexp.test(prop)) {\n        return lookupValue(obj[prop], propRegExps);\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * @private\n */\nfunction toXML(name, value) {\n  if (_.isObject(name)) {\n    value = name;\n    name = null;\n  }\n  if (_.isArray(value)) {\n    return _.map(value, function(v) { return toXML(name, v); }).join('');\n  } else {\n    var attrs = [];\n    var elems = [];\n    if (_.isObject(value)) {\n      for (var k in value) {\n        var v = value[k];\n        if (k[0] === '@') {\n          k = k.substring(1);\n          attrs.push(k + '=\"' + v + '\"');\n        } else {\n          elems.push(toXML(k, v));\n        }\n      }\n      value = elems.join('');\n    } else {\n      value = String(value)\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&apos;');\n    }\n    var startTag = name ? '<' + name + (attrs.length > 0 ? ' ' + attrs.join(' ') : '') + '>' : '';\n    var endTag = name ? '</' + name + '>' : '';\n    return  startTag + value + endTag;\n  }\n}\n\n/**\n * @private\n */\nSOAP.prototype._createEnvelope = function(message) {\n  var header = {};\n  var conn = this._conn;\n  if (conn.accessToken) {\n    header.SessionHeader = { sessionId: this._conn.accessToken };\n  }\n  if (conn.callOptions) {\n    header.CallOptions = conn.callOptions;\n  }\n  return [\n    '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n    '<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"',\n    ' xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"',\n    ' xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">',\n    '<soapenv:Header xmlns=\"' + this._xmlns + '\">',\n    toXML(header),\n    '</soapenv:Header>',\n    '<soapenv:Body xmlns=\"' + this._xmlns + '\">',\n    toXML(message),\n    '</soapenv:Body>',\n    '</soapenv:Envelope>'\n  ].join('');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvc29hcC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsMkRBQVU7QUFDakMsUUFBUSxtQkFBTyxDQUFDLHdEQUFhO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyx5REFBUTtBQUM3QixjQUFjLG1CQUFPLENBQUMsZ0VBQVk7OztBQUdsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0JBQXdCO0FBQzlELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9zb2FwLmpzPzAyYzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBNYW5hZ2VzIG1ldGhvZCBjYWxsIHRvIFNPQVAgZW5kcG9pbnRcbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKSxcbiAgICBfID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKSxcbiAgICB4bWwyanMgPSByZXF1aXJlKCd4bWwyanMnKSxcbiAgICBIdHRwQXBpID0gcmVxdWlyZSgnLi9odHRwLWFwaScpO1xuXG5cbi8qKlxuICogQ2xhc3MgZm9yIFNPQVAgZW5kcG9pbnQgb2YgU2FsZXNmb3JjZVxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gLSBDb25uZWN0aW9uIGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFNPQVAgZW5kcG9pbnQgc2V0dGluZyBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5lbmRwb2ludFVybCAtIFNPQVAgZW5kcG9pbnQgVVJMXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMueG1sbnNdIC0gWE1MIG5hbWVzcGFjZSBmb3IgbWV0aG9kIGNhbGwgKGRlZmF1bHQgaXMgXCJ1cm46cGFydG5lci5zb2FwLnNmb3JjZS5jb21cIilcbiAqL1xudmFyIFNPQVAgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbm4sIG9wdGlvbnMpIHtcbiAgU09BUC5zdXBlcl8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhpcy5fZW5kcG9pbnRVcmwgPSBvcHRpb25zLmVuZHBvaW50VXJsO1xuICB0aGlzLl94bWxucyA9IG9wdGlvbnMueG1sbnMgfHwgJ3VybjpwYXJ0bmVyLnNvYXAuc2ZvcmNlLmNvbSc7XG59O1xuXG5pbmhlcml0cyhTT0FQLCBIdHRwQXBpKTtcblxuLyoqXG4gKiBJbnZva2UgU09BUCBjYWxsIHVzaW5nIG1ldGhvZCBhbmQgYXJndW1lbnRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCAtIE1ldGhvZCBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIEFyZ3VtZW50cyBmb3IgdGhlIG1ldGhvZCBjYWxsXG4gKiBAcGFyYW0ge09iamVjdH0gW3NjaGVtYV0gLSBTY2hlbWEgZGVmaW5pdGlvbiBvZiByZXNwb25zZSBtZXNzYWdlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxPYmplY3Q+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxPYmplY3Q+fVxuICovXG5TT0FQLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbihtZXRob2QsIGFyZ3MsIHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHNjaGVtYTtcbiAgICBzY2hlbWEgPSBudWxsO1xuICB9XG4gIHZhciBtZXNzYWdlID0ge307XG4gIG1lc3NhZ2VbbWV0aG9kXSA9IGFyZ3M7XG4gIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogdGhpcy5fZW5kcG9pbnRVcmwsXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3htbCcsXG4gICAgICAnU09BUEFjdGlvbic6ICdcIlwiJ1xuICAgIH0sXG4gICAgbWVzc2FnZTogbWVzc2FnZVxuICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgIHJldHVybiBzY2hlbWEgPyBjb252ZXJ0VHlwZShyZXMsIHNjaGVtYSkgOiByZXM7XG4gIH0pLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qIEBwcml2YXRlICovXG5mdW5jdGlvbiBjb252ZXJ0VHlwZSh2YWx1ZSwgc2NoZW1hKSB7XG4gIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gY29udmVydFR5cGUodiwgc2NoZW1hICYmIHNjaGVtYVswXSlcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGlmICh2YWx1ZS4kICYmIHZhbHVlLiRbJ3hzaTpuaWwnXSA9PT0gJ3RydWUnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICByZXR1cm4gWyBjb252ZXJ0VHlwZSh2YWx1ZSwgc2NoZW1hWzBdKSBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbyA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIG9ba2V5XSA9IGNvbnZlcnRUeXBlKHZhbHVlW2tleV0sIHNjaGVtYSAmJiBzY2hlbWFba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKF8uaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICByZXR1cm4gWyBjb252ZXJ0VHlwZSh2YWx1ZSwgc2NoZW1hWzBdKSBdO1xuICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChzY2hlbWEpKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaChzY2hlbWEpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09PSAndHJ1ZSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiogQG92ZXJyaWRlICoqL1xuU09BUC5wcm90b3R5cGUuYmVmb3JlU2VuZCA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgcmVxdWVzdC5ib2R5ID0gdGhpcy5fY3JlYXRlRW52ZWxvcGUocmVxdWVzdC5tZXNzYWdlKTtcbn07XG5cbi8qKiBAb3ZlcnJpZGUgKiovXG5TT0FQLnByb3RvdHlwZS5pc1Nlc3Npb25FeHBpcmVkID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDUwMCAmJlxuICAgIC88ZmF1bHRjb2RlPlthLXpBLVpdKzpJTlZBTElEX1NFU1NJT05fSUQ8XFwvZmF1bHRjb2RlPi8udGVzdChyZXNwb25zZS5ib2R5KTtcbn07XG5cbi8qKiBAb3ZlcnJpZGUgKiovXG5TT0FQLnByb3RvdHlwZS5wYXJzZUVycm9yID0gZnVuY3Rpb24oYm9keSkge1xuICB2YXIgZXJyb3IgPSBsb29rdXBWYWx1ZShib2R5LCBbIC86RW52ZWxvcGUkLywgLzpCb2R5JC8sIC86RmF1bHQkLyBdKTtcbiAgcmV0dXJuIHtcbiAgICBlcnJvckNvZGU6IGVycm9yLmZhdWx0Y29kZSxcbiAgICBtZXNzYWdlOiBlcnJvci5mYXVsdHN0cmluZ1xuICB9O1xufTtcblxuLyoqIEBvdmVycmlkZSAqKi9cblNPQVAucHJvdG90eXBlLmdldFJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gIHZhciBib2R5ID0gU09BUC5zdXBlcl8ucHJvdG90eXBlLmdldFJlc3BvbnNlQm9keS5jYWxsKHRoaXMsIHJlc3BvbnNlKTtcbiAgcmV0dXJuIGxvb2t1cFZhbHVlKGJvZHksIFsgLzpFbnZlbG9wZSQvLCAvOkJvZHkkLywgLy4rLyBdKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9va3VwVmFsdWUob2JqLCBwcm9wUmVnRXhwcykge1xuICB2YXIgcmVnZXhwID0gcHJvcFJlZ0V4cHMuc2hpZnQoKTtcbiAgaWYgKCFyZWdleHApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGVsc2Uge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBpZiAocmVnZXhwLnRlc3QocHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIGxvb2t1cFZhbHVlKG9ialtwcm9wXSwgcHJvcFJlZ0V4cHMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRvWE1MKG5hbWUsIHZhbHVlKSB7XG4gIGlmIChfLmlzT2JqZWN0KG5hbWUpKSB7XG4gICAgdmFsdWUgPSBuYW1lO1xuICAgIG5hbWUgPSBudWxsO1xuICB9XG4gIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIF8ubWFwKHZhbHVlLCBmdW5jdGlvbih2KSB7IHJldHVybiB0b1hNTChuYW1lLCB2KTsgfSkuam9pbignJyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGF0dHJzID0gW107XG4gICAgdmFyIGVsZW1zID0gW107XG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBmb3IgKHZhciBrIGluIHZhbHVlKSB7XG4gICAgICAgIHZhciB2ID0gdmFsdWVba107XG4gICAgICAgIGlmIChrWzBdID09PSAnQCcpIHtcbiAgICAgICAgICBrID0gay5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgYXR0cnMucHVzaChrICsgJz1cIicgKyB2ICsgJ1wiJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbXMucHVzaCh0b1hNTChrLCB2KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhbHVlID0gZWxlbXMuam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgICAgICAucmVwbGFjZSgvJy9nLCAnJmFwb3M7Jyk7XG4gICAgfVxuICAgIHZhciBzdGFydFRhZyA9IG5hbWUgPyAnPCcgKyBuYW1lICsgKGF0dHJzLmxlbmd0aCA+IDAgPyAnICcgKyBhdHRycy5qb2luKCcgJykgOiAnJykgKyAnPicgOiAnJztcbiAgICB2YXIgZW5kVGFnID0gbmFtZSA/ICc8LycgKyBuYW1lICsgJz4nIDogJyc7XG4gICAgcmV0dXJuICBzdGFydFRhZyArIHZhbHVlICsgZW5kVGFnO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuU09BUC5wcm90b3R5cGUuX2NyZWF0ZUVudmVsb3BlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICB2YXIgaGVhZGVyID0ge307XG4gIHZhciBjb25uID0gdGhpcy5fY29ubjtcbiAgaWYgKGNvbm4uYWNjZXNzVG9rZW4pIHtcbiAgICBoZWFkZXIuU2Vzc2lvbkhlYWRlciA9IHsgc2Vzc2lvbklkOiB0aGlzLl9jb25uLmFjY2Vzc1Rva2VuIH07XG4gIH1cbiAgaWYgKGNvbm4uY2FsbE9wdGlvbnMpIHtcbiAgICBoZWFkZXIuQ2FsbE9wdGlvbnMgPSBjb25uLmNhbGxPcHRpb25zO1xuICB9XG4gIHJldHVybiBbXG4gICAgJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCI/PicsXG4gICAgJzxzb2FwZW52OkVudmVsb3BlIHhtbG5zOnNvYXBlbnY9XCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy9zb2FwL2VudmVsb3BlL1wiJyxcbiAgICAnIHhtbG5zOnhzZD1cImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hXCInLFxuICAgICcgeG1sbnM6eHNpPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2VcIj4nLFxuICAgICc8c29hcGVudjpIZWFkZXIgeG1sbnM9XCInICsgdGhpcy5feG1sbnMgKyAnXCI+JyxcbiAgICB0b1hNTChoZWFkZXIpLFxuICAgICc8L3NvYXBlbnY6SGVhZGVyPicsXG4gICAgJzxzb2FwZW52OkJvZHkgeG1sbnM9XCInICsgdGhpcy5feG1sbnMgKyAnXCI+JyxcbiAgICB0b1hNTChtZXNzYWdlKSxcbiAgICAnPC9zb2FwZW52OkJvZHk+JyxcbiAgICAnPC9zb2FwZW52OkVudmVsb3BlPidcbiAgXS5qb2luKCcnKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/soap.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/sobject.js":
/*!*********************************************!*\
  !*** ./node_modules/jsforce/lib/sobject.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Represents Salesforce SObject\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar _      = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    Record = __webpack_require__(/*! ./record */ \"(action-browser)/./node_modules/jsforce/lib/record.js\"),\n    Query  = __webpack_require__(/*! ./query */ \"(action-browser)/./node_modules/jsforce/lib/query.js\"),\n    Cache  = __webpack_require__(/*! ./cache */ \"(action-browser)/./node_modules/jsforce/lib/cache.js\"),\n    QuickAction = __webpack_require__(/*! ./quick-action */ \"(action-browser)/./node_modules/jsforce/lib/quick-action.js\");\n\n/**\n * A class for organizing all SObject access\n *\n * @constructor\n */\nvar SObject = module.exports = function(conn, type) {\n  this._conn = conn;\n  this.type = type;\n  var cacheOptions = { key: \"describe.\" + this.type };\n  this.describe$ = conn.cache.makeCacheable(this.describe, this, cacheOptions);\n  this.describe = conn.cache.makeResponseCacheable(this.describe, this, cacheOptions);\n\n  cacheOptions = { key: \"layouts.\" + this.type };\n  this.layouts$ = conn.cache.makeCacheable(this.layouts, this, cacheOptions);\n  this.layouts = conn.cache.makeResponseCacheable(this.layouts, this, cacheOptions);\n\n  cacheOptions = { key: \"compactLayouts.\" + this.type };\n  this.compactLayouts$ = conn.cache.makeCacheable(this.compactLayouts, this, cacheOptions);\n  this.compactLayouts = conn.cache.makeResponseCacheable(this.compactLayouts, this, cacheOptions);\n\n  cacheOptions = { key: \"approvalLayouts.\" + this.type };\n  this.approvalLayouts$ = conn.cache.makeCacheable(this.approvalLayouts, this, cacheOptions);\n  this.approvalLayouts = conn.cache.makeResponseCacheable(this.approvalLayouts, this, cacheOptions);\n};\n\n/**\n * Synonym of SObject#create()\n *\n * @method SObject#insert\n * @param {Record|Array.<Record>} records - A record or array of records to create\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Create records\n *\n * @method SObject#create\n * @param {Record|Array.<Record>} records - A record or array of records to create\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nSObject.prototype.insert =\nSObject.prototype.create = function(records, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._conn.create(this.type, records, options, callback);\n};\n\n/**\n * Retrieve specified records\n *\n * @param {String|Array.<String>} ids - A record ID or array of record IDs\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<Record|Array.<Record>>} [callback] - Callback function\n * @returns {Promise.<Record|Array.<Record>>}\n */\nSObject.prototype.retrieve = function(ids, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._conn.retrieve(this.type, ids, options, callback);\n};\n\n/**\n * Update records\n *\n * @param {Record|Array.<Record>} records - A record or array of records to update\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nSObject.prototype.update = function(records, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._conn.update(this.type, records, options, callback);\n};\n\n/**\n * Upsert records\n *\n * @param {Record|Array.<Record>} records - Record or array of records to upsert\n * @param {String} extIdField - External ID field name\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nSObject.prototype.upsert = function(records, extIdField, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._conn.upsert(this.type, records, extIdField, options, callback);\n};\n\n/**\n * Synonym of SObject#destroy()\n *\n * @method SObject#delete\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Synonym of SObject#destroy()\n *\n * @method SObject#del\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Delete records\n *\n * @method SObject#destroy\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nSObject.prototype[\"delete\"] =\nSObject.prototype.del =\nSObject.prototype.destroy = function(ids, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._conn.destroy(this.type, ids, options, callback);\n};\n\n/**\n * Describe SObject metadata\n *\n * @param {Callback.<DescribeSObjectResult>} [callback] - Callback function\n * @returns {Promise.<DescribeSObjectResult>}\n */\nSObject.prototype.describe = function(callback) {\n  return this._conn.describe(this.type, callback);\n};\n\n/**\n * Get record representation instance by given id\n *\n * @param {String} id - A record ID\n * @returns {RecordReference}\n */\nSObject.prototype.record = function(id) {\n  return new Record(this._conn, this.type, id);\n};\n\n/**\n * Find and fetch records which matches given conditions\n *\n * @param {Object|String} [conditions] - Conditions in JSON object (MongoDB-like), or raw SOQL WHERE clause string.\n * @param {Object|Array.<String>|String} [fields] - Fields to fetch. Format can be in JSON object (MongoDB-like), array of field names, or comma-separated field names.\n * @param {Object} [options] - Query options.\n * @param {Number} [options.limit] - Maximum number of records the query will return.\n * @param {Number} [options.offset] - Offset number where begins returning results.\n * @param {Number} [options.skip] - Synonym of options.offset.\n * @param {Callback.<Array.<Record>>} [callback] - Callback function\n * @returns {Query.<Array.<Record>>}\n */\nSObject.prototype.find = function(conditions, fields, options, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n    fields = null;\n    options = null;\n  } else if (typeof fields === 'function') {\n    callback = fields;\n    fields = null;\n    options = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  options = options || {};\n  var config = {\n    fields: fields,\n    includes: options.includes,\n    table: this.type,\n    conditions: conditions,\n    limit: options.limit,\n    sort: options.sort,\n    offset: options.offset || options.skip\n  };\n  var query = new Query(this._conn, config, options);\n  query.setResponseTarget(Query.ResponseTargets.Records);\n  if (callback) { query.run(callback); }\n  return query;\n};\n\n/**\n * Fetch one record which matches given conditions\n *\n * @param {Object|String} [conditions] - Conditions in JSON object (MongoDB-like), or raw SOQL WHERE clause string.\n * @param {Object|Array.<String>|String} [fields] - Fields to fetch. Format can be in JSON object (MongoDB-like), array of field names, or comma-separated field names.\n * @param {Object} [options] - Query options.\n * @param {Number} [options.limit] - Maximum number of records the query will return.\n * @param {Number} [options.offset] - Offset number where begins returning results.\n * @param {Number} [options.skip] - Synonym of options.offset.\n * @param {Callback.<Record>} [callback] - Callback function\n * @returns {Query.<Record>}\n */\nSObject.prototype.findOne = function(conditions, fields, options, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n    fields = null;\n    options = null;\n  } else if (typeof fields === 'function') {\n    callback = fields;\n    fields = null;\n    options = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  options = _.extend(options || {}, { limit: 1 });\n  var query = this.find(conditions, fields, options);\n  query.setResponseTarget(Query.ResponseTargets.SingleRecord);\n  if (callback) { query.run(callback); }\n  return query;\n};\n\n/**\n * Find and fetch records only by specifying fields to fetch.\n *\n * @param {Object|Array.<String>|String} [fields] - Fields to fetch. Format can be in JSON object (MongoDB-like), array of field names, or comma-separated field names.\n * @param {Callback.<Array.<Record>>} [callback] - Callback function\n * @returns {Query.<Array.<Record>>}\n */\nSObject.prototype.select = function(fields, callback) {\n  return this.find(null, fields, null, callback);\n};\n\n/**\n * Count num of records which matches given conditions\n *\n * @param {Object|String} [conditions] - Conditions in JSON object (MongoDB-like), or raw SOQL WHERE clause string.\n * @param {Callback.<Number>} [callback] - Callback function\n * @returns {Query.<Number>}\n */\nSObject.prototype.count = function(conditions, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n  }\n  var query = this.find(conditions, { \"count()\" : true });\n  query.setResponseTarget(\"Count\");\n  if (callback) { query.run(callback); }\n  return query;\n};\n\n\n/**\n * Call Bulk#load() to execute bulkload, returning batch object\n *\n * @param {String} operation - Bulk load operation ('insert', 'update', 'upsert', 'delete', or 'hardDelete')\n * @param {Object} [options] - Options for bulk loading operation\n * @param {String} [options.extIdField] - External ID field name (used when upsert operation).\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulkload. Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nSObject.prototype.bulkload = function(operation, options, input, callback) {\n  return this._conn.bulk.load(this.type, operation, options, input, callback);\n};\n\n/**\n * Synonym of SObject#createBulk()\n *\n * @method SObject#insertBulk\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk insert. Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\n/**\n * Bulkly insert input data using bulk API\n *\n * @method SObject#createBulk\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk insert. Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nSObject.prototype.insertBulk =\nSObject.prototype.createBulk = function(input, callback) {\n  return this.bulkload(\"insert\", input, callback);\n};\n\n/**\n * Bulkly update records by input data using bulk API\n *\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk update Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nSObject.prototype.updateBulk = function(input, callback) {\n  return this.bulkload(\"update\", input, callback);\n};\n\n/**\n * Bulkly upsert records by input data using bulk API\n *\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk upsert. Accepts array of records, CSv string, and CSV data input stream.\n * @param {String} [options.extIdField] - External ID field name\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nSObject.prototype.upsertBulk = function(input, extIdField, callback) {\n  return this.bulkload(\"upsert\", { extIdField: extIdField }, input, callback);\n};\n\n/**\n * Synonym of SObject#destroyBulk()\n *\n * @method SObject#deleteBulk\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk delete. Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\n/**\n * Bulkly delete records specified by input data using bulk API\n *\n * @method SObject#destroyBulk\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk delete. Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nSObject.prototype.deleteBulk =\nSObject.prototype.destroyBulk = function(input, callback) {\n  return this.bulkload(\"delete\", input, callback);\n};\n\n/**\n * Synonym of SObject#destroyHardBulk()\n *\n * @method SObject#deleteHardBulk\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk delete. Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\n/**\n * Bulkly hard delete records specified in input data using bulk API\n *\n * @method SObject#destroyHardBulk\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk delete. Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nSObject.prototype.deleteHardBulk =\nSObject.prototype.destroyHardBulk = function(input, callback) {\n  return this.bulkload(\"hardDelete\", input, callback);\n};\n\n/**\n * Retrieve recently accessed records\n *\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\nSObject.prototype.recent = function (callback) {\n  return this._conn.recent(this.type, callback);\n};\n\n/**\n * Retrieve the updated records\n *\n * @param {String|Date} start - start date or string representing the start of the interval\n * @param {String|Date} end - start date or string representing the end of the interval, must be > start\n * @param {Callback.<UpdatedRecordsInfo>} [callback] - Callback function\n * @returns {Promise.<UpdatedRecordsInfo>}\n */\nSObject.prototype.updated = function (start, end, callback) {\n  return this._conn.updated(this.type, start, end, callback);\n};\n\n/**\n * Retrieve the deleted records\n *\n * @param {String|Date} start - start date or string representing the start of the interval\n * @param {String|Date} end - start date or string representing the end of the interval, must be > start\n * @param {Callback.<DeletedRecordsInfo>} [callback] - Callback function\n * @returns {Promise.<DeletedRecordsInfo>}\n */\nSObject.prototype.deleted = function (start, end, callback) {\n  return this._conn.deleted(this.type, start, end, callback);\n};\n\n/**\n * @typedef {Object} LayoutInfo\n * @prop {Array.<Object>} layouts - Array of layouts\n * @prop {Array.<Object>} recordTypeMappings - Array of record type mappings\n */\n/**\n * Describe layout information for SObject\n *\n * @param {String} [layoutName] - Name of named layout. (e.g. UserAlt in User SObject)\n * @param {Callback.<LayoutInfo>} [callback] - Callback function\n * @returns {Promise.<LayoutInfo>}\n */\nSObject.prototype.layouts = function(layoutName, callback) {\n  if (typeof layoutName === 'function') {\n    callback = layoutName;\n    layoutName = null;\n  }\n  var url = \"/sobjects/\" + this.type + \"/describe/\" + (layoutName ? \"namedLayouts/\"+layoutName : \"layouts\");\n  return this._conn.request(url, callback);\n};\n\n/**\n * @typedef {Object} CompactLayoutInfo\n * @prop {Array.<Object>} compactLayouts - Array of compact layouts\n * @prop {String} defaultCompactLayoutId - ID of default compact layout\n * @prop {Array.<Object>} recordTypeCompactLayoutMappings - Array of record type mappings\n */\n/**\n * Describe compact layout information defined for SObject\n *\n * @param {Callback.<CompactLayoutInfo>} [callback] - Callback function\n * @returns {Promise.<CompactLayoutInfo>}\n */\nSObject.prototype.compactLayouts = function(callback) {\n  var url = \"/sobjects/\" + this.type + \"/describe/compactLayouts\";\n  return this._conn.request(url, callback);\n};\n\n\n/**\n * @typedef {Object} ApprovalLayoutInfo\n * @prop {Array.<Object>} approvalLayouts - Array of approval layouts\n */\n/**\n * Describe compact layout information defined for SObject\n *\n * @param {Callback.<ApprovalLayoutInfo>} [callback] - Callback function\n * @returns {Promise.<ApprovalLayoutInfo>}\n */\nSObject.prototype.approvalLayouts = function(callback) {\n  var url = \"/sobjects/\" + this.type + \"/describe/approvalLayouts\";\n  return this._conn.request(url, callback);\n};\n\n/**\n * Returns the list of list views for the SObject\n *\n * @param {Callback.<ListViewsInfo>} [callback] - Callback function\n * @returns {Promise.<ListViewsInfo>}\n */\nSObject.prototype.listviews = function(callback) {\n  var url = this._conn._baseUrl() + '/sobjects/' + this.type + '/listviews';\n  return this._conn.request(url, callback);\n};\n\n/**\n * Returns the list view info in specifed view id\n *\n * @param {String} id - List view ID\n * @returns {ListView}\n */\nSObject.prototype.listview = function(id) {\n  return new ListView(this._conn, this.type, id);\n};\n\n/**\n * Returns all registered quick actions for the SObject\n *\n * @param {Callback.<Array.<QuickAction~QuickActionInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<QuickAction~QuickActionInfo>>}\n */\nSObject.prototype.quickActions = function(callback) {\n  return this._conn.request(\"/sobjects/\" + this.type + \"/quickActions\").thenCall(callback);\n};\n\n/**\n * Get reference for specified quick aciton in the SObject\n *\n * @param {String} actionName - Name of the quick action\n * @returns {QuickAction}\n */\nSObject.prototype.quickAction = function(actionName) {\n  return new QuickAction(this._conn, \"/sobjects/\" + this.type + \"/quickActions/\" + actionName);\n};\n\n\n/**\n * A class for organizing list view information\n *\n * @protected\n * @class ListView\n * @param {Connection} conn - Connection instance\n * @param {SObject} type - SObject type\n * @param {String} id - List view ID\n */\nvar ListView = function(conn, type, id) {\n  this._conn = conn;\n  this.type = type;\n  this.id = id;\n};\n\n/**\n * Executes query for the list view and returns the resulting data and presentation information.\n *\n * @param {Callback.<ListViewResultInfo>} [callback] - Callback function\n * @returns {Promise.<ListViewResultInfo>}\n */\nListView.prototype.results = function(callback) {\n  var url =  this._conn._baseUrl() + '/sobjects/' + this.type + '/listviews/' + this.id + '/results';\n  return this._conn.request(url, callback);\n};\n\n\n/**\n * Returns detailed information about a list view\n *\n * @param {Object} [options] - Identity call options\n * @param {Object} [options.headers] - Additional HTTP request headers sent in identity request\n * @param {Callback.<ListViewDescribeInfo>} [callback] - Callback function\n * @returns {Promise.<ListViewDescribeInfo>}\n */\nListView.prototype.describe = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  var url =  this._conn._baseUrl() + '/sobjects/' + this.type + '/listviews/' + this.id + '/describe';\n  return this._conn.request({ method: 'GET', url: url, headers: options.headers }, callback);\n};\n\n/**\n * Explain plan for executing list view\n *\n * @param {Callback.<ExplainInfo>} [callback] - Callback function\n * @returns {Promise.<ExplainInfo>}\n */\nListView.prototype.explain = function(callback) {\n  var url = \"/query/?explain=\" + this.id;\n  return this._conn.request(url, callback);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9zb2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxtRUFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsdUVBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLHFFQUFTO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyxxRUFBUztBQUM5QixrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBZ0I7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyw4Q0FBOEM7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyw4Q0FBOEM7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxrQ0FBa0M7QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyw4Q0FBOEM7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLDhDQUE4QztBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtDQUFrQztBQUM3QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyw4QkFBOEI7QUFDekMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsMkJBQTJCO0FBQ3RDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsOEJBQThCO0FBQ3pDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJLFVBQVU7QUFDaEQ7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDLFdBQVcsMkJBQTJCO0FBQ3RDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFDQUFxQztBQUNoRCxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFDQUFxQztBQUNoRCxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUNBQWlDO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUNBQXFDO0FBQ2hELFdBQVcsaUNBQWlDO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFDQUFxQztBQUNoRCxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUNBQXFDO0FBQ2hELFdBQVcsaUNBQWlDO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsK0JBQStCO0FBQzFDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsK0JBQStCO0FBQzFDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLGdCQUFnQjtBQUMxQixVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsUUFBUTtBQUNsQixVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnREFBZ0Q7QUFDM0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbURBQW1EO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9zb2JqZWN0LmpzPzZiOGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBSZXByZXNlbnRzIFNhbGVzZm9yY2UgU09iamVjdFxuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyAgICAgID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKSxcbiAgICBSZWNvcmQgPSByZXF1aXJlKCcuL3JlY29yZCcpLFxuICAgIFF1ZXJ5ICA9IHJlcXVpcmUoJy4vcXVlcnknKSxcbiAgICBDYWNoZSAgPSByZXF1aXJlKCcuL2NhY2hlJyksXG4gICAgUXVpY2tBY3Rpb24gPSByZXF1aXJlKCcuL3F1aWNrLWFjdGlvbicpO1xuXG4vKipcbiAqIEEgY2xhc3MgZm9yIG9yZ2FuaXppbmcgYWxsIFNPYmplY3QgYWNjZXNzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTT2JqZWN0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb25uLCB0eXBlKSB7XG4gIHRoaXMuX2Nvbm4gPSBjb25uO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB2YXIgY2FjaGVPcHRpb25zID0geyBrZXk6IFwiZGVzY3JpYmUuXCIgKyB0aGlzLnR5cGUgfTtcbiAgdGhpcy5kZXNjcmliZSQgPSBjb25uLmNhY2hlLm1ha2VDYWNoZWFibGUodGhpcy5kZXNjcmliZSwgdGhpcywgY2FjaGVPcHRpb25zKTtcbiAgdGhpcy5kZXNjcmliZSA9IGNvbm4uY2FjaGUubWFrZVJlc3BvbnNlQ2FjaGVhYmxlKHRoaXMuZGVzY3JpYmUsIHRoaXMsIGNhY2hlT3B0aW9ucyk7XG5cbiAgY2FjaGVPcHRpb25zID0geyBrZXk6IFwibGF5b3V0cy5cIiArIHRoaXMudHlwZSB9O1xuICB0aGlzLmxheW91dHMkID0gY29ubi5jYWNoZS5tYWtlQ2FjaGVhYmxlKHRoaXMubGF5b3V0cywgdGhpcywgY2FjaGVPcHRpb25zKTtcbiAgdGhpcy5sYXlvdXRzID0gY29ubi5jYWNoZS5tYWtlUmVzcG9uc2VDYWNoZWFibGUodGhpcy5sYXlvdXRzLCB0aGlzLCBjYWNoZU9wdGlvbnMpO1xuXG4gIGNhY2hlT3B0aW9ucyA9IHsga2V5OiBcImNvbXBhY3RMYXlvdXRzLlwiICsgdGhpcy50eXBlIH07XG4gIHRoaXMuY29tcGFjdExheW91dHMkID0gY29ubi5jYWNoZS5tYWtlQ2FjaGVhYmxlKHRoaXMuY29tcGFjdExheW91dHMsIHRoaXMsIGNhY2hlT3B0aW9ucyk7XG4gIHRoaXMuY29tcGFjdExheW91dHMgPSBjb25uLmNhY2hlLm1ha2VSZXNwb25zZUNhY2hlYWJsZSh0aGlzLmNvbXBhY3RMYXlvdXRzLCB0aGlzLCBjYWNoZU9wdGlvbnMpO1xuXG4gIGNhY2hlT3B0aW9ucyA9IHsga2V5OiBcImFwcHJvdmFsTGF5b3V0cy5cIiArIHRoaXMudHlwZSB9O1xuICB0aGlzLmFwcHJvdmFsTGF5b3V0cyQgPSBjb25uLmNhY2hlLm1ha2VDYWNoZWFibGUodGhpcy5hcHByb3ZhbExheW91dHMsIHRoaXMsIGNhY2hlT3B0aW9ucyk7XG4gIHRoaXMuYXBwcm92YWxMYXlvdXRzID0gY29ubi5jYWNoZS5tYWtlUmVzcG9uc2VDYWNoZWFibGUodGhpcy5hcHByb3ZhbExheW91dHMsIHRoaXMsIGNhY2hlT3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFN5bm9ueW0gb2YgU09iamVjdCNjcmVhdGUoKVxuICpcbiAqIEBtZXRob2QgU09iamVjdCNpbnNlcnRcbiAqIEBwYXJhbSB7UmVjb3JkfEFycmF5LjxSZWNvcmQ+fSByZWNvcmRzIC0gQSByZWNvcmQgb3IgYXJyYXkgb2YgcmVjb3JkcyB0byBjcmVhdGVcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cbi8qKlxuICogQ3JlYXRlIHJlY29yZHNcbiAqXG4gKiBAbWV0aG9kIFNPYmplY3QjY3JlYXRlXG4gKiBAcGFyYW0ge1JlY29yZHxBcnJheS48UmVjb3JkPn0gcmVjb3JkcyAtIEEgcmVjb3JkIG9yIGFycmF5IG9mIHJlY29yZHMgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgcmVzdCBhcGkuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS5pbnNlcnQgPVxuU09iamVjdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24ocmVjb3Jkcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4gdGhpcy5fY29ubi5jcmVhdGUodGhpcy50eXBlLCByZWNvcmRzLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHNwZWNpZmllZCByZWNvcmRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGlkcyAtIEEgcmVjb3JkIElEIG9yIGFycmF5IG9mIHJlY29yZCBJRHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciByZXN0IGFwaS5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZHxBcnJheS48UmVjb3JkPj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZHxBcnJheS48UmVjb3JkPj59XG4gKi9cblNPYmplY3QucHJvdG90eXBlLnJldHJpZXZlID0gZnVuY3Rpb24oaWRzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB0aGlzLl9jb25uLnJldHJpZXZlKHRoaXMudHlwZSwgaWRzLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSByZWNvcmRzXG4gKlxuICogQHBhcmFtIHtSZWNvcmR8QXJyYXkuPFJlY29yZD59IHJlY29yZHMgLSBBIHJlY29yZCBvciBhcnJheSBvZiByZWNvcmRzIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHJlc3QgYXBpLlxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuU09iamVjdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ocmVjb3Jkcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4gdGhpcy5fY29ubi51cGRhdGUodGhpcy50eXBlLCByZWNvcmRzLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVwc2VydCByZWNvcmRzXG4gKlxuICogQHBhcmFtIHtSZWNvcmR8QXJyYXkuPFJlY29yZD59IHJlY29yZHMgLSBSZWNvcmQgb3IgYXJyYXkgb2YgcmVjb3JkcyB0byB1cHNlcnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHRJZEZpZWxkIC0gRXh0ZXJuYWwgSUQgZmllbGQgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHJlc3QgYXBpLlxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuU09iamVjdC5wcm90b3R5cGUudXBzZXJ0ID0gZnVuY3Rpb24ocmVjb3JkcywgZXh0SWRGaWVsZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4gdGhpcy5fY29ubi51cHNlcnQodGhpcy50eXBlLCByZWNvcmRzLCBleHRJZEZpZWxkLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFN5bm9ueW0gb2YgU09iamVjdCNkZXN0cm95KClcbiAqXG4gKiBAbWV0aG9kIFNPYmplY3QjZGVsZXRlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaWRzIC0gQSBJRCBvciBhcnJheSBvZiBJRHMgdG8gZGVsZXRlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG4vKipcbiAqIFN5bm9ueW0gb2YgU09iamVjdCNkZXN0cm95KClcbiAqXG4gKiBAbWV0aG9kIFNPYmplY3QjZGVsXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaWRzIC0gQSBJRCBvciBhcnJheSBvZiBJRHMgdG8gZGVsZXRlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG4vKipcbiAqIERlbGV0ZSByZWNvcmRzXG4gKlxuICogQG1ldGhvZCBTT2JqZWN0I2Rlc3Ryb3lcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBpZHMgLSBBIElEIG9yIGFycmF5IG9mIElEcyB0byBkZWxldGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciByZXN0IGFwaS5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cblNPYmplY3QucHJvdG90eXBlW1wiZGVsZXRlXCJdID1cblNPYmplY3QucHJvdG90eXBlLmRlbCA9XG5TT2JqZWN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oaWRzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB0aGlzLl9jb25uLmRlc3Ryb3kodGhpcy50eXBlLCBpZHMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRGVzY3JpYmUgU09iamVjdCBtZXRhZGF0YVxuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPERlc2NyaWJlU09iamVjdFJlc3VsdD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPERlc2NyaWJlU09iamVjdFJlc3VsdD59XG4gKi9cblNPYmplY3QucHJvdG90eXBlLmRlc2NyaWJlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4uZGVzY3JpYmUodGhpcy50eXBlLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldCByZWNvcmQgcmVwcmVzZW50YXRpb24gaW5zdGFuY2UgYnkgZ2l2ZW4gaWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBBIHJlY29yZCBJRFxuICogQHJldHVybnMge1JlY29yZFJlZmVyZW5jZX1cbiAqL1xuU09iamVjdC5wcm90b3R5cGUucmVjb3JkID0gZnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIG5ldyBSZWNvcmQodGhpcy5fY29ubiwgdGhpcy50eXBlLCBpZCk7XG59O1xuXG4vKipcbiAqIEZpbmQgYW5kIGZldGNoIHJlY29yZHMgd2hpY2ggbWF0Y2hlcyBnaXZlbiBjb25kaXRpb25zXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbY29uZGl0aW9uc10gLSBDb25kaXRpb25zIGluIEpTT04gb2JqZWN0IChNb25nb0RCLWxpa2UpLCBvciByYXcgU09RTCBXSEVSRSBjbGF1c2Ugc3RyaW5nLlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXkuPFN0cmluZz58U3RyaW5nfSBbZmllbGRzXSAtIEZpZWxkcyB0byBmZXRjaC4gRm9ybWF0IGNhbiBiZSBpbiBKU09OIG9iamVjdCAoTW9uZ29EQi1saWtlKSwgYXJyYXkgb2YgZmllbGQgbmFtZXMsIG9yIGNvbW1hLXNlcGFyYXRlZCBmaWVsZCBuYW1lcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBRdWVyeSBvcHRpb25zLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxpbWl0XSAtIE1heGltdW0gbnVtYmVyIG9mIHJlY29yZHMgdGhlIHF1ZXJ5IHdpbGwgcmV0dXJuLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldF0gLSBPZmZzZXQgbnVtYmVyIHdoZXJlIGJlZ2lucyByZXR1cm5pbmcgcmVzdWx0cy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5za2lwXSAtIFN5bm9ueW0gb2Ygb3B0aW9ucy5vZmZzZXQuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkPj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1F1ZXJ5LjxBcnJheS48UmVjb3JkPj59XG4gKi9cblNPYmplY3QucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihjb25kaXRpb25zLCBmaWVsZHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gY29uZGl0aW9ucztcbiAgICBjb25kaXRpb25zID0ge307XG4gICAgZmllbGRzID0gbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmllbGRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBmaWVsZHM7XG4gICAgZmllbGRzID0gbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGNvbmZpZyA9IHtcbiAgICBmaWVsZHM6IGZpZWxkcyxcbiAgICBpbmNsdWRlczogb3B0aW9ucy5pbmNsdWRlcyxcbiAgICB0YWJsZTogdGhpcy50eXBlLFxuICAgIGNvbmRpdGlvbnM6IGNvbmRpdGlvbnMsXG4gICAgbGltaXQ6IG9wdGlvbnMubGltaXQsXG4gICAgc29ydDogb3B0aW9ucy5zb3J0LFxuICAgIG9mZnNldDogb3B0aW9ucy5vZmZzZXQgfHwgb3B0aW9ucy5za2lwXG4gIH07XG4gIHZhciBxdWVyeSA9IG5ldyBRdWVyeSh0aGlzLl9jb25uLCBjb25maWcsIG9wdGlvbnMpO1xuICBxdWVyeS5zZXRSZXNwb25zZVRhcmdldChRdWVyeS5SZXNwb25zZVRhcmdldHMuUmVjb3Jkcyk7XG4gIGlmIChjYWxsYmFjaykgeyBxdWVyeS5ydW4oY2FsbGJhY2spOyB9XG4gIHJldHVybiBxdWVyeTtcbn07XG5cbi8qKlxuICogRmV0Y2ggb25lIHJlY29yZCB3aGljaCBtYXRjaGVzIGdpdmVuIGNvbmRpdGlvbnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtjb25kaXRpb25zXSAtIENvbmRpdGlvbnMgaW4gSlNPTiBvYmplY3QgKE1vbmdvREItbGlrZSksIG9yIHJhdyBTT1FMIFdIRVJFIGNsYXVzZSBzdHJpbmcuXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheS48U3RyaW5nPnxTdHJpbmd9IFtmaWVsZHNdIC0gRmllbGRzIHRvIGZldGNoLiBGb3JtYXQgY2FuIGJlIGluIEpTT04gb2JqZWN0IChNb25nb0RCLWxpa2UpLCBhcnJheSBvZiBmaWVsZCBuYW1lcywgb3IgY29tbWEtc2VwYXJhdGVkIGZpZWxkIG5hbWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFF1ZXJ5IG9wdGlvbnMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGltaXRdIC0gTWF4aW11bSBudW1iZXIgb2YgcmVjb3JkcyB0aGUgcXVlcnkgd2lsbCByZXR1cm4uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0XSAtIE9mZnNldCBudW1iZXIgd2hlcmUgYmVnaW5zIHJldHVybmluZyByZXN1bHRzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNraXBdIC0gU3lub255bSBvZiBvcHRpb25zLm9mZnNldC5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZD59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1F1ZXJ5LjxSZWNvcmQ+fVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS5maW5kT25lID0gZnVuY3Rpb24oY29uZGl0aW9ucywgZmllbGRzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNvbmRpdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHt9O1xuICAgIGZpZWxkcyA9IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZpZWxkcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gZmllbGRzO1xuICAgIGZpZWxkcyA9IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IF8uZXh0ZW5kKG9wdGlvbnMgfHwge30sIHsgbGltaXQ6IDEgfSk7XG4gIHZhciBxdWVyeSA9IHRoaXMuZmluZChjb25kaXRpb25zLCBmaWVsZHMsIG9wdGlvbnMpO1xuICBxdWVyeS5zZXRSZXNwb25zZVRhcmdldChRdWVyeS5SZXNwb25zZVRhcmdldHMuU2luZ2xlUmVjb3JkKTtcbiAgaWYgKGNhbGxiYWNrKSB7IHF1ZXJ5LnJ1bihjYWxsYmFjayk7IH1cbiAgcmV0dXJuIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBGaW5kIGFuZCBmZXRjaCByZWNvcmRzIG9ubHkgYnkgc3BlY2lmeWluZyBmaWVsZHMgdG8gZmV0Y2guXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXkuPFN0cmluZz58U3RyaW5nfSBbZmllbGRzXSAtIEZpZWxkcyB0byBmZXRjaC4gRm9ybWF0IGNhbiBiZSBpbiBKU09OIG9iamVjdCAoTW9uZ29EQi1saWtlKSwgYXJyYXkgb2YgZmllbGQgbmFtZXMsIG9yIGNvbW1hLXNlcGFyYXRlZCBmaWVsZCBuYW1lcy5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxSZWNvcmQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UXVlcnkuPEFycmF5LjxSZWNvcmQ+Pn1cbiAqL1xuU09iamVjdC5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oZmllbGRzLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5maW5kKG51bGwsIGZpZWxkcywgbnVsbCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDb3VudCBudW0gb2YgcmVjb3JkcyB3aGljaCBtYXRjaGVzIGdpdmVuIGNvbmRpdGlvbnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtjb25kaXRpb25zXSAtIENvbmRpdGlvbnMgaW4gSlNPTiBvYmplY3QgKE1vbmdvREItbGlrZSksIG9yIHJhdyBTT1FMIFdIRVJFIGNsYXVzZSBzdHJpbmcuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxOdW1iZXI+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtRdWVyeS48TnVtYmVyPn1cbiAqL1xuU09iamVjdC5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbihjb25kaXRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNvbmRpdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHt9O1xuICB9XG4gIHZhciBxdWVyeSA9IHRoaXMuZmluZChjb25kaXRpb25zLCB7IFwiY291bnQoKVwiIDogdHJ1ZSB9KTtcbiAgcXVlcnkuc2V0UmVzcG9uc2VUYXJnZXQoXCJDb3VudFwiKTtcbiAgaWYgKGNhbGxiYWNrKSB7IHF1ZXJ5LnJ1bihjYWxsYmFjayk7IH1cbiAgcmV0dXJuIHF1ZXJ5O1xufTtcblxuXG4vKipcbiAqIENhbGwgQnVsayNsb2FkKCkgdG8gZXhlY3V0ZSBidWxrbG9hZCwgcmV0dXJuaW5nIGJhdGNoIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRpb24gLSBCdWxrIGxvYWQgb3BlcmF0aW9uICgnaW5zZXJ0JywgJ3VwZGF0ZScsICd1cHNlcnQnLCAnZGVsZXRlJywgb3IgJ2hhcmREZWxldGUnKVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIGJ1bGsgbG9hZGluZyBvcGVyYXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5leHRJZEZpZWxkXSAtIEV4dGVybmFsIElEIGZpZWxkIG5hbWUgKHVzZWQgd2hlbiB1cHNlcnQgb3BlcmF0aW9uKS5cbiAqIEBwYXJhbSB7QXJyYXkuPFJlY29yZD58c3RyZWFtLlN0cmVhbXxTdHJpbmd9IFtpbnB1dF0gLSBJbnB1dCBzb3VyY2UgZm9yIGJ1bGtsb2FkLiBBY2NlcHRzIGFycmF5IG9mIHJlY29yZHMsIENTdiBzdHJpbmcsIGFuZCBDU1YgZGF0YSBpbnB1dCBzdHJlYW0uXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0J1bGt+QmF0Y2h9XG4gKi9cblNPYmplY3QucHJvdG90eXBlLmJ1bGtsb2FkID0gZnVuY3Rpb24ob3BlcmF0aW9uLCBvcHRpb25zLCBpbnB1dCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4uYnVsay5sb2FkKHRoaXMudHlwZSwgb3BlcmF0aW9uLCBvcHRpb25zLCBpbnB1dCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTeW5vbnltIG9mIFNPYmplY3QjY3JlYXRlQnVsaygpXG4gKlxuICogQG1ldGhvZCBTT2JqZWN0I2luc2VydEJ1bGtcbiAqIEBwYXJhbSB7QXJyYXkuPFJlY29yZD58c3RyZWFtLlN0cmVhbXxTdHJpbmd9IFtpbnB1dF0gLSBJbnB1dCBzb3VyY2UgZm9yIGJ1bGsgaW5zZXJ0LiBBY2NlcHRzIGFycmF5IG9mIHJlY29yZHMsIENTdiBzdHJpbmcsIGFuZCBDU1YgZGF0YSBpbnB1dCBzdHJlYW0uXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0J1bGt+QmF0Y2h9XG4gKi9cbi8qKlxuICogQnVsa2x5IGluc2VydCBpbnB1dCBkYXRhIHVzaW5nIGJ1bGsgQVBJXG4gKlxuICogQG1ldGhvZCBTT2JqZWN0I2NyZWF0ZUJ1bGtcbiAqIEBwYXJhbSB7QXJyYXkuPFJlY29yZD58c3RyZWFtLlN0cmVhbXxTdHJpbmd9IFtpbnB1dF0gLSBJbnB1dCBzb3VyY2UgZm9yIGJ1bGsgaW5zZXJ0LiBBY2NlcHRzIGFycmF5IG9mIHJlY29yZHMsIENTdiBzdHJpbmcsIGFuZCBDU1YgZGF0YSBpbnB1dCBzdHJlYW0uXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0J1bGt+QmF0Y2h9XG4gKi9cblNPYmplY3QucHJvdG90eXBlLmluc2VydEJ1bGsgPVxuU09iamVjdC5wcm90b3R5cGUuY3JlYXRlQnVsayA9IGZ1bmN0aW9uKGlucHV0LCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5idWxrbG9hZChcImluc2VydFwiLCBpbnB1dCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBCdWxrbHkgdXBkYXRlIHJlY29yZHMgYnkgaW5wdXQgZGF0YSB1c2luZyBidWxrIEFQSVxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPFJlY29yZD58c3RyZWFtLlN0cmVhbXxTdHJpbmd9IFtpbnB1dF0gLSBJbnB1dCBzb3VyY2UgZm9yIGJ1bGsgdXBkYXRlIEFjY2VwdHMgYXJyYXkgb2YgcmVjb3JkcywgQ1N2IHN0cmluZywgYW5kIENTViBkYXRhIGlucHV0IHN0cmVhbS5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVsa35CYXRjaH1cbiAqL1xuU09iamVjdC5wcm90b3R5cGUudXBkYXRlQnVsayA9IGZ1bmN0aW9uKGlucHV0LCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5idWxrbG9hZChcInVwZGF0ZVwiLCBpbnB1dCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBCdWxrbHkgdXBzZXJ0IHJlY29yZHMgYnkgaW5wdXQgZGF0YSB1c2luZyBidWxrIEFQSVxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPFJlY29yZD58c3RyZWFtLlN0cmVhbXxTdHJpbmd9IFtpbnB1dF0gLSBJbnB1dCBzb3VyY2UgZm9yIGJ1bGsgdXBzZXJ0LiBBY2NlcHRzIGFycmF5IG9mIHJlY29yZHMsIENTdiBzdHJpbmcsIGFuZCBDU1YgZGF0YSBpbnB1dCBzdHJlYW0uXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZXh0SWRGaWVsZF0gLSBFeHRlcm5hbCBJRCBmaWVsZCBuYW1lXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0J1bGt+QmF0Y2h9XG4gKi9cblNPYmplY3QucHJvdG90eXBlLnVwc2VydEJ1bGsgPSBmdW5jdGlvbihpbnB1dCwgZXh0SWRGaWVsZCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuYnVsa2xvYWQoXCJ1cHNlcnRcIiwgeyBleHRJZEZpZWxkOiBleHRJZEZpZWxkIH0sIGlucHV0LCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFN5bm9ueW0gb2YgU09iamVjdCNkZXN0cm95QnVsaygpXG4gKlxuICogQG1ldGhvZCBTT2JqZWN0I2RlbGV0ZUJ1bGtcbiAqIEBwYXJhbSB7QXJyYXkuPFJlY29yZD58c3RyZWFtLlN0cmVhbXxTdHJpbmd9IFtpbnB1dF0gLSBJbnB1dCBzb3VyY2UgZm9yIGJ1bGsgZGVsZXRlLiBBY2NlcHRzIGFycmF5IG9mIHJlY29yZHMsIENTdiBzdHJpbmcsIGFuZCBDU1YgZGF0YSBpbnB1dCBzdHJlYW0uXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0J1bGt+QmF0Y2h9XG4gKi9cbi8qKlxuICogQnVsa2x5IGRlbGV0ZSByZWNvcmRzIHNwZWNpZmllZCBieSBpbnB1dCBkYXRhIHVzaW5nIGJ1bGsgQVBJXG4gKlxuICogQG1ldGhvZCBTT2JqZWN0I2Rlc3Ryb3lCdWxrXG4gKiBAcGFyYW0ge0FycmF5LjxSZWNvcmQ+fHN0cmVhbS5TdHJlYW18U3RyaW5nfSBbaW5wdXRdIC0gSW5wdXQgc291cmNlIGZvciBidWxrIGRlbGV0ZS4gQWNjZXB0cyBhcnJheSBvZiByZWNvcmRzLCBDU3Ygc3RyaW5nLCBhbmQgQ1NWIGRhdGEgaW5wdXQgc3RyZWFtLlxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWxrfkJhdGNofVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS5kZWxldGVCdWxrID1cblNPYmplY3QucHJvdG90eXBlLmRlc3Ryb3lCdWxrID0gZnVuY3Rpb24oaW5wdXQsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmJ1bGtsb2FkKFwiZGVsZXRlXCIsIGlucHV0LCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFN5bm9ueW0gb2YgU09iamVjdCNkZXN0cm95SGFyZEJ1bGsoKVxuICpcbiAqIEBtZXRob2QgU09iamVjdCNkZWxldGVIYXJkQnVsa1xuICogQHBhcmFtIHtBcnJheS48UmVjb3JkPnxzdHJlYW0uU3RyZWFtfFN0cmluZ30gW2lucHV0XSAtIElucHV0IHNvdXJjZSBmb3IgYnVsayBkZWxldGUuIEFjY2VwdHMgYXJyYXkgb2YgcmVjb3JkcywgQ1N2IHN0cmluZywgYW5kIENTViBkYXRhIGlucHV0IHN0cmVhbS5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVsa35CYXRjaH1cbiAqL1xuLyoqXG4gKiBCdWxrbHkgaGFyZCBkZWxldGUgcmVjb3JkcyBzcGVjaWZpZWQgaW4gaW5wdXQgZGF0YSB1c2luZyBidWxrIEFQSVxuICpcbiAqIEBtZXRob2QgU09iamVjdCNkZXN0cm95SGFyZEJ1bGtcbiAqIEBwYXJhbSB7QXJyYXkuPFJlY29yZD58c3RyZWFtLlN0cmVhbXxTdHJpbmd9IFtpbnB1dF0gLSBJbnB1dCBzb3VyY2UgZm9yIGJ1bGsgZGVsZXRlLiBBY2NlcHRzIGFycmF5IG9mIHJlY29yZHMsIENTdiBzdHJpbmcsIGFuZCBDU1YgZGF0YSBpbnB1dCBzdHJlYW0uXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0J1bGt+QmF0Y2h9XG4gKi9cblNPYmplY3QucHJvdG90eXBlLmRlbGV0ZUhhcmRCdWxrID1cblNPYmplY3QucHJvdG90eXBlLmRlc3Ryb3lIYXJkQnVsayA9IGZ1bmN0aW9uKGlucHV0LCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5idWxrbG9hZChcImhhcmREZWxldGVcIiwgaW5wdXQsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgcmVjZW50bHkgYWNjZXNzZWQgcmVjb3Jkc1xuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS5yZWNlbnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVjZW50KHRoaXMudHlwZSwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgdXBkYXRlZCByZWNvcmRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RGF0ZX0gc3RhcnQgLSBzdGFydCBkYXRlIG9yIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IG9mIHRoZSBpbnRlcnZhbFxuICogQHBhcmFtIHtTdHJpbmd8RGF0ZX0gZW5kIC0gc3RhcnQgZGF0ZSBvciBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBlbmQgb2YgdGhlIGludGVydmFsLCBtdXN0IGJlID4gc3RhcnRcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFVwZGF0ZWRSZWNvcmRzSW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFVwZGF0ZWRSZWNvcmRzSW5mbz59XG4gKi9cblNPYmplY3QucHJvdG90eXBlLnVwZGF0ZWQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4udXBkYXRlZCh0aGlzLnR5cGUsIHN0YXJ0LCBlbmQsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGRlbGV0ZWQgcmVjb3Jkc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfERhdGV9IHN0YXJ0IC0gc3RhcnQgZGF0ZSBvciBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzdGFydCBvZiB0aGUgaW50ZXJ2YWxcbiAqIEBwYXJhbSB7U3RyaW5nfERhdGV9IGVuZCAtIHN0YXJ0IGRhdGUgb3Igc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZW5kIG9mIHRoZSBpbnRlcnZhbCwgbXVzdCBiZSA+IHN0YXJ0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxEZWxldGVkUmVjb3Jkc0luZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxEZWxldGVkUmVjb3Jkc0luZm8+fVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS5kZWxldGVkID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jb25uLmRlbGV0ZWQodGhpcy50eXBlLCBzdGFydCwgZW5kLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExheW91dEluZm9cbiAqIEBwcm9wIHtBcnJheS48T2JqZWN0Pn0gbGF5b3V0cyAtIEFycmF5IG9mIGxheW91dHNcbiAqIEBwcm9wIHtBcnJheS48T2JqZWN0Pn0gcmVjb3JkVHlwZU1hcHBpbmdzIC0gQXJyYXkgb2YgcmVjb3JkIHR5cGUgbWFwcGluZ3NcbiAqL1xuLyoqXG4gKiBEZXNjcmliZSBsYXlvdXQgaW5mb3JtYXRpb24gZm9yIFNPYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW2xheW91dE5hbWVdIC0gTmFtZSBvZiBuYW1lZCBsYXlvdXQuIChlLmcuIFVzZXJBbHQgaW4gVXNlciBTT2JqZWN0KVxuICogQHBhcmFtIHtDYWxsYmFjay48TGF5b3V0SW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPExheW91dEluZm8+fVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS5sYXlvdXRzID0gZnVuY3Rpb24obGF5b3V0TmFtZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBsYXlvdXROYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBsYXlvdXROYW1lO1xuICAgIGxheW91dE5hbWUgPSBudWxsO1xuICB9XG4gIHZhciB1cmwgPSBcIi9zb2JqZWN0cy9cIiArIHRoaXMudHlwZSArIFwiL2Rlc2NyaWJlL1wiICsgKGxheW91dE5hbWUgPyBcIm5hbWVkTGF5b3V0cy9cIitsYXlvdXROYW1lIDogXCJsYXlvdXRzXCIpO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHVybCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb21wYWN0TGF5b3V0SW5mb1xuICogQHByb3Age0FycmF5LjxPYmplY3Q+fSBjb21wYWN0TGF5b3V0cyAtIEFycmF5IG9mIGNvbXBhY3QgbGF5b3V0c1xuICogQHByb3Age1N0cmluZ30gZGVmYXVsdENvbXBhY3RMYXlvdXRJZCAtIElEIG9mIGRlZmF1bHQgY29tcGFjdCBsYXlvdXRcbiAqIEBwcm9wIHtBcnJheS48T2JqZWN0Pn0gcmVjb3JkVHlwZUNvbXBhY3RMYXlvdXRNYXBwaW5ncyAtIEFycmF5IG9mIHJlY29yZCB0eXBlIG1hcHBpbmdzXG4gKi9cbi8qKlxuICogRGVzY3JpYmUgY29tcGFjdCBsYXlvdXQgaW5mb3JtYXRpb24gZGVmaW5lZCBmb3IgU09iamVjdFxuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPENvbXBhY3RMYXlvdXRJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48Q29tcGFjdExheW91dEluZm8+fVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS5jb21wYWN0TGF5b3V0cyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSBcIi9zb2JqZWN0cy9cIiArIHRoaXMudHlwZSArIFwiL2Rlc2NyaWJlL2NvbXBhY3RMYXlvdXRzXCI7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QodXJsLCBjYWxsYmFjayk7XG59O1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQXBwcm92YWxMYXlvdXRJbmZvXG4gKiBAcHJvcCB7QXJyYXkuPE9iamVjdD59IGFwcHJvdmFsTGF5b3V0cyAtIEFycmF5IG9mIGFwcHJvdmFsIGxheW91dHNcbiAqL1xuLyoqXG4gKiBEZXNjcmliZSBjb21wYWN0IGxheW91dCBpbmZvcm1hdGlvbiBkZWZpbmVkIGZvciBTT2JqZWN0XG4gKlxuICogQHBhcmFtIHtDYWxsYmFjay48QXBwcm92YWxMYXlvdXRJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXBwcm92YWxMYXlvdXRJbmZvPn1cbiAqL1xuU09iamVjdC5wcm90b3R5cGUuYXBwcm92YWxMYXlvdXRzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFwiL3NvYmplY3RzL1wiICsgdGhpcy50eXBlICsgXCIvZGVzY3JpYmUvYXBwcm92YWxMYXlvdXRzXCI7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QodXJsLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbGlzdCB2aWV3cyBmb3IgdGhlIFNPYmplY3RcbiAqXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxMaXN0Vmlld3NJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TGlzdFZpZXdzSW5mbz59XG4gKi9cblNPYmplY3QucHJvdG90eXBlLmxpc3R2aWV3cyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSB0aGlzLl9jb25uLl9iYXNlVXJsKCkgKyAnL3NvYmplY3RzLycgKyB0aGlzLnR5cGUgKyAnL2xpc3R2aWV3cyc7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QodXJsLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGxpc3QgdmlldyBpbmZvIGluIHNwZWNpZmVkIHZpZXcgaWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBMaXN0IHZpZXcgSURcbiAqIEByZXR1cm5zIHtMaXN0Vmlld31cbiAqL1xuU09iamVjdC5wcm90b3R5cGUubGlzdHZpZXcgPSBmdW5jdGlvbihpZCkge1xuICByZXR1cm4gbmV3IExpc3RWaWV3KHRoaXMuX2Nvbm4sIHRoaXMudHlwZSwgaWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCByZWdpc3RlcmVkIHF1aWNrIGFjdGlvbnMgZm9yIHRoZSBTT2JqZWN0XG4gKlxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFF1aWNrQWN0aW9uflF1aWNrQWN0aW9uSW5mbz4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheS48UXVpY2tBY3Rpb25+UXVpY2tBY3Rpb25JbmZvPj59XG4gKi9cblNPYmplY3QucHJvdG90eXBlLnF1aWNrQWN0aW9ucyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QoXCIvc29iamVjdHMvXCIgKyB0aGlzLnR5cGUgKyBcIi9xdWlja0FjdGlvbnNcIikudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXQgcmVmZXJlbmNlIGZvciBzcGVjaWZpZWQgcXVpY2sgYWNpdG9uIGluIHRoZSBTT2JqZWN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBxdWljayBhY3Rpb25cbiAqIEByZXR1cm5zIHtRdWlja0FjdGlvbn1cbiAqL1xuU09iamVjdC5wcm90b3R5cGUucXVpY2tBY3Rpb24gPSBmdW5jdGlvbihhY3Rpb25OYW1lKSB7XG4gIHJldHVybiBuZXcgUXVpY2tBY3Rpb24odGhpcy5fY29ubiwgXCIvc29iamVjdHMvXCIgKyB0aGlzLnR5cGUgKyBcIi9xdWlja0FjdGlvbnMvXCIgKyBhY3Rpb25OYW1lKTtcbn07XG5cblxuLyoqXG4gKiBBIGNsYXNzIGZvciBvcmdhbml6aW5nIGxpc3QgdmlldyBpbmZvcm1hdGlvblxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBjbGFzcyBMaXN0Vmlld1xuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIC0gQ29ubmVjdGlvbiBpbnN0YW5jZVxuICogQHBhcmFtIHtTT2JqZWN0fSB0eXBlIC0gU09iamVjdCB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBMaXN0IHZpZXcgSURcbiAqL1xudmFyIExpc3RWaWV3ID0gZnVuY3Rpb24oY29ubiwgdHlwZSwgaWQpIHtcbiAgdGhpcy5fY29ubiA9IGNvbm47XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuaWQgPSBpZDtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgcXVlcnkgZm9yIHRoZSBsaXN0IHZpZXcgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBkYXRhIGFuZCBwcmVzZW50YXRpb24gaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIHtDYWxsYmFjay48TGlzdFZpZXdSZXN1bHRJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TGlzdFZpZXdSZXN1bHRJbmZvPn1cbiAqL1xuTGlzdFZpZXcucHJvdG90eXBlLnJlc3VsdHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgdXJsID0gIHRoaXMuX2Nvbm4uX2Jhc2VVcmwoKSArICcvc29iamVjdHMvJyArIHRoaXMudHlwZSArICcvbGlzdHZpZXdzLycgKyB0aGlzLmlkICsgJy9yZXN1bHRzJztcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdCh1cmwsIGNhbGxiYWNrKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IGEgbGlzdCB2aWV3XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIElkZW50aXR5IGNhbGwgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBIVFRQIHJlcXVlc3QgaGVhZGVycyBzZW50IGluIGlkZW50aXR5IHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPExpc3RWaWV3RGVzY3JpYmVJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48TGlzdFZpZXdEZXNjcmliZUluZm8+fVxuICovXG5MaXN0Vmlldy5wcm90b3R5cGUuZGVzY3JpYmUgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdXJsID0gIHRoaXMuX2Nvbm4uX2Jhc2VVcmwoKSArICcvc29iamVjdHMvJyArIHRoaXMudHlwZSArICcvbGlzdHZpZXdzLycgKyB0aGlzLmlkICsgJy9kZXNjcmliZSc7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QoeyBtZXRob2Q6ICdHRVQnLCB1cmw6IHVybCwgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzIH0sIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRXhwbGFpbiBwbGFuIGZvciBleGVjdXRpbmcgbGlzdCB2aWV3XG4gKlxuICogQHBhcmFtIHtDYWxsYmFjay48RXhwbGFpbkluZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxFeHBsYWluSW5mbz59XG4gKi9cbkxpc3RWaWV3LnByb3RvdHlwZS5leHBsYWluID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IFwiL3F1ZXJ5Lz9leHBsYWluPVwiICsgdGhpcy5pZDtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdCh1cmwsIGNhbGxiYWNrKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/sobject.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/sobject.js":
/*!*********************************************!*\
  !*** ./node_modules/jsforce/lib/sobject.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Represents Salesforce SObject\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar _      = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    Record = __webpack_require__(/*! ./record */ \"(rsc)/./node_modules/jsforce/lib/record.js\"),\n    Query  = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/jsforce/lib/query.js\"),\n    Cache  = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/jsforce/lib/cache.js\"),\n    QuickAction = __webpack_require__(/*! ./quick-action */ \"(rsc)/./node_modules/jsforce/lib/quick-action.js\");\n\n/**\n * A class for organizing all SObject access\n *\n * @constructor\n */\nvar SObject = module.exports = function(conn, type) {\n  this._conn = conn;\n  this.type = type;\n  var cacheOptions = { key: \"describe.\" + this.type };\n  this.describe$ = conn.cache.makeCacheable(this.describe, this, cacheOptions);\n  this.describe = conn.cache.makeResponseCacheable(this.describe, this, cacheOptions);\n\n  cacheOptions = { key: \"layouts.\" + this.type };\n  this.layouts$ = conn.cache.makeCacheable(this.layouts, this, cacheOptions);\n  this.layouts = conn.cache.makeResponseCacheable(this.layouts, this, cacheOptions);\n\n  cacheOptions = { key: \"compactLayouts.\" + this.type };\n  this.compactLayouts$ = conn.cache.makeCacheable(this.compactLayouts, this, cacheOptions);\n  this.compactLayouts = conn.cache.makeResponseCacheable(this.compactLayouts, this, cacheOptions);\n\n  cacheOptions = { key: \"approvalLayouts.\" + this.type };\n  this.approvalLayouts$ = conn.cache.makeCacheable(this.approvalLayouts, this, cacheOptions);\n  this.approvalLayouts = conn.cache.makeResponseCacheable(this.approvalLayouts, this, cacheOptions);\n};\n\n/**\n * Synonym of SObject#create()\n *\n * @method SObject#insert\n * @param {Record|Array.<Record>} records - A record or array of records to create\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Create records\n *\n * @method SObject#create\n * @param {Record|Array.<Record>} records - A record or array of records to create\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nSObject.prototype.insert =\nSObject.prototype.create = function(records, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._conn.create(this.type, records, options, callback);\n};\n\n/**\n * Retrieve specified records\n *\n * @param {String|Array.<String>} ids - A record ID or array of record IDs\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<Record|Array.<Record>>} [callback] - Callback function\n * @returns {Promise.<Record|Array.<Record>>}\n */\nSObject.prototype.retrieve = function(ids, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._conn.retrieve(this.type, ids, options, callback);\n};\n\n/**\n * Update records\n *\n * @param {Record|Array.<Record>} records - A record or array of records to update\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nSObject.prototype.update = function(records, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._conn.update(this.type, records, options, callback);\n};\n\n/**\n * Upsert records\n *\n * @param {Record|Array.<Record>} records - Record or array of records to upsert\n * @param {String} extIdField - External ID field name\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nSObject.prototype.upsert = function(records, extIdField, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._conn.upsert(this.type, records, extIdField, options, callback);\n};\n\n/**\n * Synonym of SObject#destroy()\n *\n * @method SObject#delete\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Synonym of SObject#destroy()\n *\n * @method SObject#del\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\n/**\n * Delete records\n *\n * @method SObject#destroy\n * @param {String|Array.<String>} ids - A ID or array of IDs to delete\n * @param {Object} [options] - Options for rest api.\n * @param {Callback.<RecordResult|Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<RecordResult|Array.<RecordResult>>}\n */\nSObject.prototype[\"delete\"] =\nSObject.prototype.del =\nSObject.prototype.destroy = function(ids, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._conn.destroy(this.type, ids, options, callback);\n};\n\n/**\n * Describe SObject metadata\n *\n * @param {Callback.<DescribeSObjectResult>} [callback] - Callback function\n * @returns {Promise.<DescribeSObjectResult>}\n */\nSObject.prototype.describe = function(callback) {\n  return this._conn.describe(this.type, callback);\n};\n\n/**\n * Get record representation instance by given id\n *\n * @param {String} id - A record ID\n * @returns {RecordReference}\n */\nSObject.prototype.record = function(id) {\n  return new Record(this._conn, this.type, id);\n};\n\n/**\n * Find and fetch records which matches given conditions\n *\n * @param {Object|String} [conditions] - Conditions in JSON object (MongoDB-like), or raw SOQL WHERE clause string.\n * @param {Object|Array.<String>|String} [fields] - Fields to fetch. Format can be in JSON object (MongoDB-like), array of field names, or comma-separated field names.\n * @param {Object} [options] - Query options.\n * @param {Number} [options.limit] - Maximum number of records the query will return.\n * @param {Number} [options.offset] - Offset number where begins returning results.\n * @param {Number} [options.skip] - Synonym of options.offset.\n * @param {Callback.<Array.<Record>>} [callback] - Callback function\n * @returns {Query.<Array.<Record>>}\n */\nSObject.prototype.find = function(conditions, fields, options, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n    fields = null;\n    options = null;\n  } else if (typeof fields === 'function') {\n    callback = fields;\n    fields = null;\n    options = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  options = options || {};\n  var config = {\n    fields: fields,\n    includes: options.includes,\n    table: this.type,\n    conditions: conditions,\n    limit: options.limit,\n    sort: options.sort,\n    offset: options.offset || options.skip\n  };\n  var query = new Query(this._conn, config, options);\n  query.setResponseTarget(Query.ResponseTargets.Records);\n  if (callback) { query.run(callback); }\n  return query;\n};\n\n/**\n * Fetch one record which matches given conditions\n *\n * @param {Object|String} [conditions] - Conditions in JSON object (MongoDB-like), or raw SOQL WHERE clause string.\n * @param {Object|Array.<String>|String} [fields] - Fields to fetch. Format can be in JSON object (MongoDB-like), array of field names, or comma-separated field names.\n * @param {Object} [options] - Query options.\n * @param {Number} [options.limit] - Maximum number of records the query will return.\n * @param {Number} [options.offset] - Offset number where begins returning results.\n * @param {Number} [options.skip] - Synonym of options.offset.\n * @param {Callback.<Record>} [callback] - Callback function\n * @returns {Query.<Record>}\n */\nSObject.prototype.findOne = function(conditions, fields, options, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n    fields = null;\n    options = null;\n  } else if (typeof fields === 'function') {\n    callback = fields;\n    fields = null;\n    options = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  options = _.extend(options || {}, { limit: 1 });\n  var query = this.find(conditions, fields, options);\n  query.setResponseTarget(Query.ResponseTargets.SingleRecord);\n  if (callback) { query.run(callback); }\n  return query;\n};\n\n/**\n * Find and fetch records only by specifying fields to fetch.\n *\n * @param {Object|Array.<String>|String} [fields] - Fields to fetch. Format can be in JSON object (MongoDB-like), array of field names, or comma-separated field names.\n * @param {Callback.<Array.<Record>>} [callback] - Callback function\n * @returns {Query.<Array.<Record>>}\n */\nSObject.prototype.select = function(fields, callback) {\n  return this.find(null, fields, null, callback);\n};\n\n/**\n * Count num of records which matches given conditions\n *\n * @param {Object|String} [conditions] - Conditions in JSON object (MongoDB-like), or raw SOQL WHERE clause string.\n * @param {Callback.<Number>} [callback] - Callback function\n * @returns {Query.<Number>}\n */\nSObject.prototype.count = function(conditions, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n  }\n  var query = this.find(conditions, { \"count()\" : true });\n  query.setResponseTarget(\"Count\");\n  if (callback) { query.run(callback); }\n  return query;\n};\n\n\n/**\n * Call Bulk#load() to execute bulkload, returning batch object\n *\n * @param {String} operation - Bulk load operation ('insert', 'update', 'upsert', 'delete', or 'hardDelete')\n * @param {Object} [options] - Options for bulk loading operation\n * @param {String} [options.extIdField] - External ID field name (used when upsert operation).\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulkload. Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nSObject.prototype.bulkload = function(operation, options, input, callback) {\n  return this._conn.bulk.load(this.type, operation, options, input, callback);\n};\n\n/**\n * Synonym of SObject#createBulk()\n *\n * @method SObject#insertBulk\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk insert. Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\n/**\n * Bulkly insert input data using bulk API\n *\n * @method SObject#createBulk\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk insert. Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nSObject.prototype.insertBulk =\nSObject.prototype.createBulk = function(input, callback) {\n  return this.bulkload(\"insert\", input, callback);\n};\n\n/**\n * Bulkly update records by input data using bulk API\n *\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk update Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nSObject.prototype.updateBulk = function(input, callback) {\n  return this.bulkload(\"update\", input, callback);\n};\n\n/**\n * Bulkly upsert records by input data using bulk API\n *\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk upsert. Accepts array of records, CSv string, and CSV data input stream.\n * @param {String} [options.extIdField] - External ID field name\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nSObject.prototype.upsertBulk = function(input, extIdField, callback) {\n  return this.bulkload(\"upsert\", { extIdField: extIdField }, input, callback);\n};\n\n/**\n * Synonym of SObject#destroyBulk()\n *\n * @method SObject#deleteBulk\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk delete. Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\n/**\n * Bulkly delete records specified by input data using bulk API\n *\n * @method SObject#destroyBulk\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk delete. Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nSObject.prototype.deleteBulk =\nSObject.prototype.destroyBulk = function(input, callback) {\n  return this.bulkload(\"delete\", input, callback);\n};\n\n/**\n * Synonym of SObject#destroyHardBulk()\n *\n * @method SObject#deleteHardBulk\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk delete. Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\n/**\n * Bulkly hard delete records specified in input data using bulk API\n *\n * @method SObject#destroyHardBulk\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulk delete. Accepts array of records, CSv string, and CSV data input stream.\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Bulk~Batch}\n */\nSObject.prototype.deleteHardBulk =\nSObject.prototype.destroyHardBulk = function(input, callback) {\n  return this.bulkload(\"hardDelete\", input, callback);\n};\n\n/**\n * Retrieve recently accessed records\n *\n * @param {Callback.<Array.<RecordResult>>} [callback] - Callback function\n * @returns {Promise.<Array.<RecordResult>>}\n */\nSObject.prototype.recent = function (callback) {\n  return this._conn.recent(this.type, callback);\n};\n\n/**\n * Retrieve the updated records\n *\n * @param {String|Date} start - start date or string representing the start of the interval\n * @param {String|Date} end - start date or string representing the end of the interval, must be > start\n * @param {Callback.<UpdatedRecordsInfo>} [callback] - Callback function\n * @returns {Promise.<UpdatedRecordsInfo>}\n */\nSObject.prototype.updated = function (start, end, callback) {\n  return this._conn.updated(this.type, start, end, callback);\n};\n\n/**\n * Retrieve the deleted records\n *\n * @param {String|Date} start - start date or string representing the start of the interval\n * @param {String|Date} end - start date or string representing the end of the interval, must be > start\n * @param {Callback.<DeletedRecordsInfo>} [callback] - Callback function\n * @returns {Promise.<DeletedRecordsInfo>}\n */\nSObject.prototype.deleted = function (start, end, callback) {\n  return this._conn.deleted(this.type, start, end, callback);\n};\n\n/**\n * @typedef {Object} LayoutInfo\n * @prop {Array.<Object>} layouts - Array of layouts\n * @prop {Array.<Object>} recordTypeMappings - Array of record type mappings\n */\n/**\n * Describe layout information for SObject\n *\n * @param {String} [layoutName] - Name of named layout. (e.g. UserAlt in User SObject)\n * @param {Callback.<LayoutInfo>} [callback] - Callback function\n * @returns {Promise.<LayoutInfo>}\n */\nSObject.prototype.layouts = function(layoutName, callback) {\n  if (typeof layoutName === 'function') {\n    callback = layoutName;\n    layoutName = null;\n  }\n  var url = \"/sobjects/\" + this.type + \"/describe/\" + (layoutName ? \"namedLayouts/\"+layoutName : \"layouts\");\n  return this._conn.request(url, callback);\n};\n\n/**\n * @typedef {Object} CompactLayoutInfo\n * @prop {Array.<Object>} compactLayouts - Array of compact layouts\n * @prop {String} defaultCompactLayoutId - ID of default compact layout\n * @prop {Array.<Object>} recordTypeCompactLayoutMappings - Array of record type mappings\n */\n/**\n * Describe compact layout information defined for SObject\n *\n * @param {Callback.<CompactLayoutInfo>} [callback] - Callback function\n * @returns {Promise.<CompactLayoutInfo>}\n */\nSObject.prototype.compactLayouts = function(callback) {\n  var url = \"/sobjects/\" + this.type + \"/describe/compactLayouts\";\n  return this._conn.request(url, callback);\n};\n\n\n/**\n * @typedef {Object} ApprovalLayoutInfo\n * @prop {Array.<Object>} approvalLayouts - Array of approval layouts\n */\n/**\n * Describe compact layout information defined for SObject\n *\n * @param {Callback.<ApprovalLayoutInfo>} [callback] - Callback function\n * @returns {Promise.<ApprovalLayoutInfo>}\n */\nSObject.prototype.approvalLayouts = function(callback) {\n  var url = \"/sobjects/\" + this.type + \"/describe/approvalLayouts\";\n  return this._conn.request(url, callback);\n};\n\n/**\n * Returns the list of list views for the SObject\n *\n * @param {Callback.<ListViewsInfo>} [callback] - Callback function\n * @returns {Promise.<ListViewsInfo>}\n */\nSObject.prototype.listviews = function(callback) {\n  var url = this._conn._baseUrl() + '/sobjects/' + this.type + '/listviews';\n  return this._conn.request(url, callback);\n};\n\n/**\n * Returns the list view info in specifed view id\n *\n * @param {String} id - List view ID\n * @returns {ListView}\n */\nSObject.prototype.listview = function(id) {\n  return new ListView(this._conn, this.type, id);\n};\n\n/**\n * Returns all registered quick actions for the SObject\n *\n * @param {Callback.<Array.<QuickAction~QuickActionInfo>>} [callback] - Callback function\n * @returns {Promise.<Array.<QuickAction~QuickActionInfo>>}\n */\nSObject.prototype.quickActions = function(callback) {\n  return this._conn.request(\"/sobjects/\" + this.type + \"/quickActions\").thenCall(callback);\n};\n\n/**\n * Get reference for specified quick aciton in the SObject\n *\n * @param {String} actionName - Name of the quick action\n * @returns {QuickAction}\n */\nSObject.prototype.quickAction = function(actionName) {\n  return new QuickAction(this._conn, \"/sobjects/\" + this.type + \"/quickActions/\" + actionName);\n};\n\n\n/**\n * A class for organizing list view information\n *\n * @protected\n * @class ListView\n * @param {Connection} conn - Connection instance\n * @param {SObject} type - SObject type\n * @param {String} id - List view ID\n */\nvar ListView = function(conn, type, id) {\n  this._conn = conn;\n  this.type = type;\n  this.id = id;\n};\n\n/**\n * Executes query for the list view and returns the resulting data and presentation information.\n *\n * @param {Callback.<ListViewResultInfo>} [callback] - Callback function\n * @returns {Promise.<ListViewResultInfo>}\n */\nListView.prototype.results = function(callback) {\n  var url =  this._conn._baseUrl() + '/sobjects/' + this.type + '/listviews/' + this.id + '/results';\n  return this._conn.request(url, callback);\n};\n\n\n/**\n * Returns detailed information about a list view\n *\n * @param {Object} [options] - Identity call options\n * @param {Object} [options.headers] - Additional HTTP request headers sent in identity request\n * @param {Callback.<ListViewDescribeInfo>} [callback] - Callback function\n * @returns {Promise.<ListViewDescribeInfo>}\n */\nListView.prototype.describe = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  var url =  this._conn._baseUrl() + '/sobjects/' + this.type + '/listviews/' + this.id + '/describe';\n  return this._conn.request({ method: 'GET', url: url, headers: options.headers }, callback);\n};\n\n/**\n * Explain plan for executing list view\n *\n * @param {Callback.<ExplainInfo>} [callback] - Callback function\n * @returns {Promise.<ExplainInfo>}\n */\nListView.prototype.explain = function(callback) {\n  var url = \"/query/?explain=\" + this.id;\n  return this._conn.request(url, callback);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvc29iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsd0RBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDREQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQywwREFBUztBQUM5QixhQUFhLG1CQUFPLENBQUMsMERBQVM7QUFDOUIsa0JBQWtCLG1CQUFPLENBQUMsd0VBQWdCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsa0NBQWtDO0FBQzdDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQixXQUFXLDhDQUE4QztBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsOENBQThDO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyw4Q0FBOEM7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLDhDQUE4QztBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQixXQUFXLDhDQUE4QztBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQ0FBa0M7QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsOEJBQThCO0FBQ3pDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLDJCQUEyQjtBQUN0QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSSxVQUFVO0FBQ2hEO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLDJCQUEyQjtBQUN0QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCO0FBQ3hEO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUNBQXFDO0FBQ2hELFdBQVcsaUNBQWlDO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUNBQXFDO0FBQ2hELFdBQVcsaUNBQWlDO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUNBQXFDO0FBQ2hELFdBQVcsUUFBUTtBQUNuQixXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyx3QkFBd0I7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFDQUFxQztBQUNoRCxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUNBQXFDO0FBQ2hELFdBQVcsaUNBQWlDO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFDQUFxQztBQUNoRCxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLCtCQUErQjtBQUMxQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLCtCQUErQjtBQUMxQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxnQkFBZ0I7QUFDMUIsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLGdCQUFnQjtBQUMxQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQWdEO0FBQzNELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUNBQWlDO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1EQUFtRDtBQUNqRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvc29iamVjdC5qcz9iZmViIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgUmVwcmVzZW50cyBTYWxlc2ZvcmNlIFNPYmplY3RcbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gICAgICA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyksXG4gICAgUmVjb3JkID0gcmVxdWlyZSgnLi9yZWNvcmQnKSxcbiAgICBRdWVyeSAgPSByZXF1aXJlKCcuL3F1ZXJ5JyksXG4gICAgQ2FjaGUgID0gcmVxdWlyZSgnLi9jYWNoZScpLFxuICAgIFF1aWNrQWN0aW9uID0gcmVxdWlyZSgnLi9xdWljay1hY3Rpb24nKTtcblxuLyoqXG4gKiBBIGNsYXNzIGZvciBvcmdhbml6aW5nIGFsbCBTT2JqZWN0IGFjY2Vzc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU09iamVjdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29ubiwgdHlwZSkge1xuICB0aGlzLl9jb25uID0gY29ubjtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdmFyIGNhY2hlT3B0aW9ucyA9IHsga2V5OiBcImRlc2NyaWJlLlwiICsgdGhpcy50eXBlIH07XG4gIHRoaXMuZGVzY3JpYmUkID0gY29ubi5jYWNoZS5tYWtlQ2FjaGVhYmxlKHRoaXMuZGVzY3JpYmUsIHRoaXMsIGNhY2hlT3B0aW9ucyk7XG4gIHRoaXMuZGVzY3JpYmUgPSBjb25uLmNhY2hlLm1ha2VSZXNwb25zZUNhY2hlYWJsZSh0aGlzLmRlc2NyaWJlLCB0aGlzLCBjYWNoZU9wdGlvbnMpO1xuXG4gIGNhY2hlT3B0aW9ucyA9IHsga2V5OiBcImxheW91dHMuXCIgKyB0aGlzLnR5cGUgfTtcbiAgdGhpcy5sYXlvdXRzJCA9IGNvbm4uY2FjaGUubWFrZUNhY2hlYWJsZSh0aGlzLmxheW91dHMsIHRoaXMsIGNhY2hlT3B0aW9ucyk7XG4gIHRoaXMubGF5b3V0cyA9IGNvbm4uY2FjaGUubWFrZVJlc3BvbnNlQ2FjaGVhYmxlKHRoaXMubGF5b3V0cywgdGhpcywgY2FjaGVPcHRpb25zKTtcblxuICBjYWNoZU9wdGlvbnMgPSB7IGtleTogXCJjb21wYWN0TGF5b3V0cy5cIiArIHRoaXMudHlwZSB9O1xuICB0aGlzLmNvbXBhY3RMYXlvdXRzJCA9IGNvbm4uY2FjaGUubWFrZUNhY2hlYWJsZSh0aGlzLmNvbXBhY3RMYXlvdXRzLCB0aGlzLCBjYWNoZU9wdGlvbnMpO1xuICB0aGlzLmNvbXBhY3RMYXlvdXRzID0gY29ubi5jYWNoZS5tYWtlUmVzcG9uc2VDYWNoZWFibGUodGhpcy5jb21wYWN0TGF5b3V0cywgdGhpcywgY2FjaGVPcHRpb25zKTtcblxuICBjYWNoZU9wdGlvbnMgPSB7IGtleTogXCJhcHByb3ZhbExheW91dHMuXCIgKyB0aGlzLnR5cGUgfTtcbiAgdGhpcy5hcHByb3ZhbExheW91dHMkID0gY29ubi5jYWNoZS5tYWtlQ2FjaGVhYmxlKHRoaXMuYXBwcm92YWxMYXlvdXRzLCB0aGlzLCBjYWNoZU9wdGlvbnMpO1xuICB0aGlzLmFwcHJvdmFsTGF5b3V0cyA9IGNvbm4uY2FjaGUubWFrZVJlc3BvbnNlQ2FjaGVhYmxlKHRoaXMuYXBwcm92YWxMYXlvdXRzLCB0aGlzLCBjYWNoZU9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTeW5vbnltIG9mIFNPYmplY3QjY3JlYXRlKClcbiAqXG4gKiBAbWV0aG9kIFNPYmplY3QjaW5zZXJ0XG4gKiBAcGFyYW0ge1JlY29yZHxBcnJheS48UmVjb3JkPn0gcmVjb3JkcyAtIEEgcmVjb3JkIG9yIGFycmF5IG9mIHJlY29yZHMgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG4vKipcbiAqIENyZWF0ZSByZWNvcmRzXG4gKlxuICogQG1ldGhvZCBTT2JqZWN0I2NyZWF0ZVxuICogQHBhcmFtIHtSZWNvcmR8QXJyYXkuPFJlY29yZD59IHJlY29yZHMgLSBBIHJlY29yZCBvciBhcnJheSBvZiByZWNvcmRzIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHJlc3QgYXBpLlxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuU09iamVjdC5wcm90b3R5cGUuaW5zZXJ0ID1cblNPYmplY3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHJlY29yZHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Nvbm4uY3JlYXRlKHRoaXMudHlwZSwgcmVjb3Jkcywgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBzcGVjaWZpZWQgcmVjb3Jkc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBpZHMgLSBBIHJlY29yZCBJRCBvciBhcnJheSBvZiByZWNvcmQgSURzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgcmVzdCBhcGkuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmR8QXJyYXkuPFJlY29yZD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmR8QXJyYXkuPFJlY29yZD4+fVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS5yZXRyaWV2ZSA9IGZ1bmN0aW9uKGlkcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4gdGhpcy5fY29ubi5yZXRyaWV2ZSh0aGlzLnR5cGUsIGlkcywgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgcmVjb3Jkc1xuICpcbiAqIEBwYXJhbSB7UmVjb3JkfEFycmF5LjxSZWNvcmQ+fSByZWNvcmRzIC0gQSByZWNvcmQgb3IgYXJyYXkgb2YgcmVjb3JkcyB0byB1cGRhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciByZXN0IGFwaS5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cblNPYmplY3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHJlY29yZHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Nvbm4udXBkYXRlKHRoaXMudHlwZSwgcmVjb3Jkcywgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBVcHNlcnQgcmVjb3Jkc1xuICpcbiAqIEBwYXJhbSB7UmVjb3JkfEFycmF5LjxSZWNvcmQ+fSByZWNvcmRzIC0gUmVjb3JkIG9yIGFycmF5IG9mIHJlY29yZHMgdG8gdXBzZXJ0XG4gKiBAcGFyYW0ge1N0cmluZ30gZXh0SWRGaWVsZCAtIEV4dGVybmFsIElEIGZpZWxkIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciByZXN0IGFwaS5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFja1xuICogQHJldHVybnMge1Byb21pc2UuPFJlY29yZFJlc3VsdHxBcnJheS48UmVjb3JkUmVzdWx0Pj59XG4gKi9cblNPYmplY3QucHJvdG90eXBlLnVwc2VydCA9IGZ1bmN0aW9uKHJlY29yZHMsIGV4dElkRmllbGQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Nvbm4udXBzZXJ0KHRoaXMudHlwZSwgcmVjb3JkcywgZXh0SWRGaWVsZCwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTeW5vbnltIG9mIFNPYmplY3QjZGVzdHJveSgpXG4gKlxuICogQG1ldGhvZCBTT2JqZWN0I2RlbGV0ZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGlkcyAtIEEgSUQgb3IgYXJyYXkgb2YgSURzIHRvIGRlbGV0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuLyoqXG4gKiBTeW5vbnltIG9mIFNPYmplY3QjZGVzdHJveSgpXG4gKlxuICogQG1ldGhvZCBTT2JqZWN0I2RlbFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGlkcyAtIEEgSUQgb3IgYXJyYXkgb2YgSURzIHRvIGRlbGV0ZVxuICogQHBhcmFtIHtDYWxsYmFjay48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48UmVjb3JkUmVzdWx0fEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuLyoqXG4gKiBEZWxldGUgcmVjb3Jkc1xuICpcbiAqIEBtZXRob2QgU09iamVjdCNkZXN0cm95XG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaWRzIC0gQSBJRCBvciBhcnJheSBvZiBJRHMgdG8gZGVsZXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgcmVzdCBhcGkuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxSZWNvcmRSZXN1bHR8QXJyYXkuPFJlY29yZFJlc3VsdD4+fVxuICovXG5TT2JqZWN0LnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9XG5TT2JqZWN0LnByb3RvdHlwZS5kZWwgPVxuU09iamVjdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGlkcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4gdGhpcy5fY29ubi5kZXN0cm95KHRoaXMudHlwZSwgaWRzLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIERlc2NyaWJlIFNPYmplY3QgbWV0YWRhdGFcbiAqXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxEZXNjcmliZVNPYmplY3RSZXN1bHQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxEZXNjcmliZVNPYmplY3RSZXN1bHQ+fVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS5kZXNjcmliZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jb25uLmRlc2NyaWJlKHRoaXMudHlwZSwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXQgcmVjb3JkIHJlcHJlc2VudGF0aW9uIGluc3RhbmNlIGJ5IGdpdmVuIGlkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gQSByZWNvcmQgSURcbiAqIEByZXR1cm5zIHtSZWNvcmRSZWZlcmVuY2V9XG4gKi9cblNPYmplY3QucHJvdG90eXBlLnJlY29yZCA9IGZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiBuZXcgUmVjb3JkKHRoaXMuX2Nvbm4sIHRoaXMudHlwZSwgaWQpO1xufTtcblxuLyoqXG4gKiBGaW5kIGFuZCBmZXRjaCByZWNvcmRzIHdoaWNoIG1hdGNoZXMgZ2l2ZW4gY29uZGl0aW9uc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW2NvbmRpdGlvbnNdIC0gQ29uZGl0aW9ucyBpbiBKU09OIG9iamVjdCAoTW9uZ29EQi1saWtlKSwgb3IgcmF3IFNPUUwgV0hFUkUgY2xhdXNlIHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5LjxTdHJpbmc+fFN0cmluZ30gW2ZpZWxkc10gLSBGaWVsZHMgdG8gZmV0Y2guIEZvcm1hdCBjYW4gYmUgaW4gSlNPTiBvYmplY3QgKE1vbmdvREItbGlrZSksIGFycmF5IG9mIGZpZWxkIG5hbWVzLCBvciBjb21tYS1zZXBhcmF0ZWQgZmllbGQgbmFtZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gUXVlcnkgb3B0aW9ucy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5saW1pdF0gLSBNYXhpbXVtIG51bWJlciBvZiByZWNvcmRzIHRoZSBxdWVyeSB3aWxsIHJldHVybi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRdIC0gT2Zmc2V0IG51bWJlciB3aGVyZSBiZWdpbnMgcmV0dXJuaW5nIHJlc3VsdHMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2tpcF0gLSBTeW5vbnltIG9mIG9wdGlvbnMub2Zmc2V0LlxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFJlY29yZD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtRdWVyeS48QXJyYXkuPFJlY29yZD4+fVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oY29uZGl0aW9ucywgZmllbGRzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNvbmRpdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHt9O1xuICAgIGZpZWxkcyA9IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZpZWxkcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gZmllbGRzO1xuICAgIGZpZWxkcyA9IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBjb25maWcgPSB7XG4gICAgZmllbGRzOiBmaWVsZHMsXG4gICAgaW5jbHVkZXM6IG9wdGlvbnMuaW5jbHVkZXMsXG4gICAgdGFibGU6IHRoaXMudHlwZSxcbiAgICBjb25kaXRpb25zOiBjb25kaXRpb25zLFxuICAgIGxpbWl0OiBvcHRpb25zLmxpbWl0LFxuICAgIHNvcnQ6IG9wdGlvbnMuc29ydCxcbiAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0IHx8IG9wdGlvbnMuc2tpcFxuICB9O1xuICB2YXIgcXVlcnkgPSBuZXcgUXVlcnkodGhpcy5fY29ubiwgY29uZmlnLCBvcHRpb25zKTtcbiAgcXVlcnkuc2V0UmVzcG9uc2VUYXJnZXQoUXVlcnkuUmVzcG9uc2VUYXJnZXRzLlJlY29yZHMpO1xuICBpZiAoY2FsbGJhY2spIHsgcXVlcnkucnVuKGNhbGxiYWNrKTsgfVxuICByZXR1cm4gcXVlcnk7XG59O1xuXG4vKipcbiAqIEZldGNoIG9uZSByZWNvcmQgd2hpY2ggbWF0Y2hlcyBnaXZlbiBjb25kaXRpb25zXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbY29uZGl0aW9uc10gLSBDb25kaXRpb25zIGluIEpTT04gb2JqZWN0IChNb25nb0RCLWxpa2UpLCBvciByYXcgU09RTCBXSEVSRSBjbGF1c2Ugc3RyaW5nLlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXkuPFN0cmluZz58U3RyaW5nfSBbZmllbGRzXSAtIEZpZWxkcyB0byBmZXRjaC4gRm9ybWF0IGNhbiBiZSBpbiBKU09OIG9iamVjdCAoTW9uZ29EQi1saWtlKSwgYXJyYXkgb2YgZmllbGQgbmFtZXMsIG9yIGNvbW1hLXNlcGFyYXRlZCBmaWVsZCBuYW1lcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBRdWVyeSBvcHRpb25zLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxpbWl0XSAtIE1heGltdW0gbnVtYmVyIG9mIHJlY29yZHMgdGhlIHF1ZXJ5IHdpbGwgcmV0dXJuLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldF0gLSBPZmZzZXQgbnVtYmVyIHdoZXJlIGJlZ2lucyByZXR1cm5pbmcgcmVzdWx0cy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5za2lwXSAtIFN5bm9ueW0gb2Ygb3B0aW9ucy5vZmZzZXQuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxSZWNvcmQ+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtRdWVyeS48UmVjb3JkPn1cbiAqL1xuU09iamVjdC5wcm90b3R5cGUuZmluZE9uZSA9IGZ1bmN0aW9uKGNvbmRpdGlvbnMsIGZpZWxkcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBjb25kaXRpb25zO1xuICAgIGNvbmRpdGlvbnMgPSB7fTtcbiAgICBmaWVsZHMgPSBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmaWVsZHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGZpZWxkcztcbiAgICBmaWVsZHMgPSBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBfLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7IGxpbWl0OiAxIH0pO1xuICB2YXIgcXVlcnkgPSB0aGlzLmZpbmQoY29uZGl0aW9ucywgZmllbGRzLCBvcHRpb25zKTtcbiAgcXVlcnkuc2V0UmVzcG9uc2VUYXJnZXQoUXVlcnkuUmVzcG9uc2VUYXJnZXRzLlNpbmdsZVJlY29yZCk7XG4gIGlmIChjYWxsYmFjaykgeyBxdWVyeS5ydW4oY2FsbGJhY2spOyB9XG4gIHJldHVybiBxdWVyeTtcbn07XG5cbi8qKlxuICogRmluZCBhbmQgZmV0Y2ggcmVjb3JkcyBvbmx5IGJ5IHNwZWNpZnlpbmcgZmllbGRzIHRvIGZldGNoLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5LjxTdHJpbmc+fFN0cmluZ30gW2ZpZWxkc10gLSBGaWVsZHMgdG8gZmV0Y2guIEZvcm1hdCBjYW4gYmUgaW4gSlNPTiBvYmplY3QgKE1vbmdvREItbGlrZSksIGFycmF5IG9mIGZpZWxkIG5hbWVzLCBvciBjb21tYS1zZXBhcmF0ZWQgZmllbGQgbmFtZXMuXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkPj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1F1ZXJ5LjxBcnJheS48UmVjb3JkPj59XG4gKi9cblNPYmplY3QucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKGZpZWxkcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuZmluZChudWxsLCBmaWVsZHMsIG51bGwsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQ291bnQgbnVtIG9mIHJlY29yZHMgd2hpY2ggbWF0Y2hlcyBnaXZlbiBjb25kaXRpb25zXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbY29uZGl0aW9uc10gLSBDb25kaXRpb25zIGluIEpTT04gb2JqZWN0IChNb25nb0RCLWxpa2UpLCBvciByYXcgU09RTCBXSEVSRSBjbGF1c2Ugc3RyaW5nLlxuICogQHBhcmFtIHtDYWxsYmFjay48TnVtYmVyPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UXVlcnkuPE51bWJlcj59XG4gKi9cblNPYmplY3QucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24oY29uZGl0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBjb25kaXRpb25zO1xuICAgIGNvbmRpdGlvbnMgPSB7fTtcbiAgfVxuICB2YXIgcXVlcnkgPSB0aGlzLmZpbmQoY29uZGl0aW9ucywgeyBcImNvdW50KClcIiA6IHRydWUgfSk7XG4gIHF1ZXJ5LnNldFJlc3BvbnNlVGFyZ2V0KFwiQ291bnRcIik7XG4gIGlmIChjYWxsYmFjaykgeyBxdWVyeS5ydW4oY2FsbGJhY2spOyB9XG4gIHJldHVybiBxdWVyeTtcbn07XG5cblxuLyoqXG4gKiBDYWxsIEJ1bGsjbG9hZCgpIHRvIGV4ZWN1dGUgYnVsa2xvYWQsIHJldHVybmluZyBiYXRjaCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0aW9uIC0gQnVsayBsb2FkIG9wZXJhdGlvbiAoJ2luc2VydCcsICd1cGRhdGUnLCAndXBzZXJ0JywgJ2RlbGV0ZScsIG9yICdoYXJkRGVsZXRlJylcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciBidWxrIGxvYWRpbmcgb3BlcmF0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZXh0SWRGaWVsZF0gLSBFeHRlcm5hbCBJRCBmaWVsZCBuYW1lICh1c2VkIHdoZW4gdXBzZXJ0IG9wZXJhdGlvbikuXG4gKiBAcGFyYW0ge0FycmF5LjxSZWNvcmQ+fHN0cmVhbS5TdHJlYW18U3RyaW5nfSBbaW5wdXRdIC0gSW5wdXQgc291cmNlIGZvciBidWxrbG9hZC4gQWNjZXB0cyBhcnJheSBvZiByZWNvcmRzLCBDU3Ygc3RyaW5nLCBhbmQgQ1NWIGRhdGEgaW5wdXQgc3RyZWFtLlxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWxrfkJhdGNofVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS5idWxrbG9hZCA9IGZ1bmN0aW9uKG9wZXJhdGlvbiwgb3B0aW9ucywgaW5wdXQsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jb25uLmJ1bGsubG9hZCh0aGlzLnR5cGUsIG9wZXJhdGlvbiwgb3B0aW9ucywgaW5wdXQsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU3lub255bSBvZiBTT2JqZWN0I2NyZWF0ZUJ1bGsoKVxuICpcbiAqIEBtZXRob2QgU09iamVjdCNpbnNlcnRCdWxrXG4gKiBAcGFyYW0ge0FycmF5LjxSZWNvcmQ+fHN0cmVhbS5TdHJlYW18U3RyaW5nfSBbaW5wdXRdIC0gSW5wdXQgc291cmNlIGZvciBidWxrIGluc2VydC4gQWNjZXB0cyBhcnJheSBvZiByZWNvcmRzLCBDU3Ygc3RyaW5nLCBhbmQgQ1NWIGRhdGEgaW5wdXQgc3RyZWFtLlxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWxrfkJhdGNofVxuICovXG4vKipcbiAqIEJ1bGtseSBpbnNlcnQgaW5wdXQgZGF0YSB1c2luZyBidWxrIEFQSVxuICpcbiAqIEBtZXRob2QgU09iamVjdCNjcmVhdGVCdWxrXG4gKiBAcGFyYW0ge0FycmF5LjxSZWNvcmQ+fHN0cmVhbS5TdHJlYW18U3RyaW5nfSBbaW5wdXRdIC0gSW5wdXQgc291cmNlIGZvciBidWxrIGluc2VydC4gQWNjZXB0cyBhcnJheSBvZiByZWNvcmRzLCBDU3Ygc3RyaW5nLCBhbmQgQ1NWIGRhdGEgaW5wdXQgc3RyZWFtLlxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWxrfkJhdGNofVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS5pbnNlcnRCdWxrID1cblNPYmplY3QucHJvdG90eXBlLmNyZWF0ZUJ1bGsgPSBmdW5jdGlvbihpbnB1dCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuYnVsa2xvYWQoXCJpbnNlcnRcIiwgaW5wdXQsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQnVsa2x5IHVwZGF0ZSByZWNvcmRzIGJ5IGlucHV0IGRhdGEgdXNpbmcgYnVsayBBUElcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxSZWNvcmQ+fHN0cmVhbS5TdHJlYW18U3RyaW5nfSBbaW5wdXRdIC0gSW5wdXQgc291cmNlIGZvciBidWxrIHVwZGF0ZSBBY2NlcHRzIGFycmF5IG9mIHJlY29yZHMsIENTdiBzdHJpbmcsIGFuZCBDU1YgZGF0YSBpbnB1dCBzdHJlYW0uXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0J1bGt+QmF0Y2h9XG4gKi9cblNPYmplY3QucHJvdG90eXBlLnVwZGF0ZUJ1bGsgPSBmdW5jdGlvbihpbnB1dCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuYnVsa2xvYWQoXCJ1cGRhdGVcIiwgaW5wdXQsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQnVsa2x5IHVwc2VydCByZWNvcmRzIGJ5IGlucHV0IGRhdGEgdXNpbmcgYnVsayBBUElcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxSZWNvcmQ+fHN0cmVhbS5TdHJlYW18U3RyaW5nfSBbaW5wdXRdIC0gSW5wdXQgc291cmNlIGZvciBidWxrIHVwc2VydC4gQWNjZXB0cyBhcnJheSBvZiByZWNvcmRzLCBDU3Ygc3RyaW5nLCBhbmQgQ1NWIGRhdGEgaW5wdXQgc3RyZWFtLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmV4dElkRmllbGRdIC0gRXh0ZXJuYWwgSUQgZmllbGQgbmFtZVxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWxrfkJhdGNofVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS51cHNlcnRCdWxrID0gZnVuY3Rpb24oaW5wdXQsIGV4dElkRmllbGQsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLmJ1bGtsb2FkKFwidXBzZXJ0XCIsIHsgZXh0SWRGaWVsZDogZXh0SWRGaWVsZCB9LCBpbnB1dCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTeW5vbnltIG9mIFNPYmplY3QjZGVzdHJveUJ1bGsoKVxuICpcbiAqIEBtZXRob2QgU09iamVjdCNkZWxldGVCdWxrXG4gKiBAcGFyYW0ge0FycmF5LjxSZWNvcmQ+fHN0cmVhbS5TdHJlYW18U3RyaW5nfSBbaW5wdXRdIC0gSW5wdXQgc291cmNlIGZvciBidWxrIGRlbGV0ZS4gQWNjZXB0cyBhcnJheSBvZiByZWNvcmRzLCBDU3Ygc3RyaW5nLCBhbmQgQ1NWIGRhdGEgaW5wdXQgc3RyZWFtLlxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWxrfkJhdGNofVxuICovXG4vKipcbiAqIEJ1bGtseSBkZWxldGUgcmVjb3JkcyBzcGVjaWZpZWQgYnkgaW5wdXQgZGF0YSB1c2luZyBidWxrIEFQSVxuICpcbiAqIEBtZXRob2QgU09iamVjdCNkZXN0cm95QnVsa1xuICogQHBhcmFtIHtBcnJheS48UmVjb3JkPnxzdHJlYW0uU3RyZWFtfFN0cmluZ30gW2lucHV0XSAtIElucHV0IHNvdXJjZSBmb3IgYnVsayBkZWxldGUuIEFjY2VwdHMgYXJyYXkgb2YgcmVjb3JkcywgQ1N2IHN0cmluZywgYW5kIENTViBkYXRhIGlucHV0IHN0cmVhbS5cbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVsa35CYXRjaH1cbiAqL1xuU09iamVjdC5wcm90b3R5cGUuZGVsZXRlQnVsayA9XG5TT2JqZWN0LnByb3RvdHlwZS5kZXN0cm95QnVsayA9IGZ1bmN0aW9uKGlucHV0LCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5idWxrbG9hZChcImRlbGV0ZVwiLCBpbnB1dCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTeW5vbnltIG9mIFNPYmplY3QjZGVzdHJveUhhcmRCdWxrKClcbiAqXG4gKiBAbWV0aG9kIFNPYmplY3QjZGVsZXRlSGFyZEJ1bGtcbiAqIEBwYXJhbSB7QXJyYXkuPFJlY29yZD58c3RyZWFtLlN0cmVhbXxTdHJpbmd9IFtpbnB1dF0gLSBJbnB1dCBzb3VyY2UgZm9yIGJ1bGsgZGVsZXRlLiBBY2NlcHRzIGFycmF5IG9mIHJlY29yZHMsIENTdiBzdHJpbmcsIGFuZCBDU1YgZGF0YSBpbnB1dCBzdHJlYW0uXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0J1bGt+QmF0Y2h9XG4gKi9cbi8qKlxuICogQnVsa2x5IGhhcmQgZGVsZXRlIHJlY29yZHMgc3BlY2lmaWVkIGluIGlucHV0IGRhdGEgdXNpbmcgYnVsayBBUElcbiAqXG4gKiBAbWV0aG9kIFNPYmplY3QjZGVzdHJveUhhcmRCdWxrXG4gKiBAcGFyYW0ge0FycmF5LjxSZWNvcmQ+fHN0cmVhbS5TdHJlYW18U3RyaW5nfSBbaW5wdXRdIC0gSW5wdXQgc291cmNlIGZvciBidWxrIGRlbGV0ZS4gQWNjZXB0cyBhcnJheSBvZiByZWNvcmRzLCBDU3Ygc3RyaW5nLCBhbmQgQ1NWIGRhdGEgaW5wdXQgc3RyZWFtLlxuICogQHBhcmFtIHtDYWxsYmFjay48QXJyYXkuPFJlY29yZFJlc3VsdD4+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWxrfkJhdGNofVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS5kZWxldGVIYXJkQnVsayA9XG5TT2JqZWN0LnByb3RvdHlwZS5kZXN0cm95SGFyZEJ1bGsgPSBmdW5jdGlvbihpbnB1dCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuYnVsa2xvYWQoXCJoYXJkRGVsZXRlXCIsIGlucHV0LCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHJlY2VudGx5IGFjY2Vzc2VkIHJlY29yZHNcbiAqXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxBcnJheS48UmVjb3JkUmVzdWx0Pj59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5LjxSZWNvcmRSZXN1bHQ+Pn1cbiAqL1xuU09iamVjdC5wcm90b3R5cGUucmVjZW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlY2VudCh0aGlzLnR5cGUsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHVwZGF0ZWQgcmVjb3Jkc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfERhdGV9IHN0YXJ0IC0gc3RhcnQgZGF0ZSBvciBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzdGFydCBvZiB0aGUgaW50ZXJ2YWxcbiAqIEBwYXJhbSB7U3RyaW5nfERhdGV9IGVuZCAtIHN0YXJ0IGRhdGUgb3Igc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZW5kIG9mIHRoZSBpbnRlcnZhbCwgbXVzdCBiZSA+IHN0YXJ0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxVcGRhdGVkUmVjb3Jkc0luZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxVcGRhdGVkUmVjb3Jkc0luZm8+fVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS51cGRhdGVkID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jb25uLnVwZGF0ZWQodGhpcy50eXBlLCBzdGFydCwgZW5kLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBkZWxldGVkIHJlY29yZHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xEYXRlfSBzdGFydCAtIHN0YXJ0IGRhdGUgb3Igc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3RhcnQgb2YgdGhlIGludGVydmFsXG4gKiBAcGFyYW0ge1N0cmluZ3xEYXRlfSBlbmQgLSBzdGFydCBkYXRlIG9yIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVuZCBvZiB0aGUgaW50ZXJ2YWwsIG11c3QgYmUgPiBzdGFydFxuICogQHBhcmFtIHtDYWxsYmFjay48RGVsZXRlZFJlY29yZHNJbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48RGVsZXRlZFJlY29yZHNJbmZvPn1cbiAqL1xuU09iamVjdC5wcm90b3R5cGUuZGVsZXRlZCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fY29ubi5kZWxldGVkKHRoaXMudHlwZSwgc3RhcnQsIGVuZCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMYXlvdXRJbmZvXG4gKiBAcHJvcCB7QXJyYXkuPE9iamVjdD59IGxheW91dHMgLSBBcnJheSBvZiBsYXlvdXRzXG4gKiBAcHJvcCB7QXJyYXkuPE9iamVjdD59IHJlY29yZFR5cGVNYXBwaW5ncyAtIEFycmF5IG9mIHJlY29yZCB0eXBlIG1hcHBpbmdzXG4gKi9cbi8qKlxuICogRGVzY3JpYmUgbGF5b3V0IGluZm9ybWF0aW9uIGZvciBTT2JqZWN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtsYXlvdXROYW1lXSAtIE5hbWUgb2YgbmFtZWQgbGF5b3V0LiAoZS5nLiBVc2VyQWx0IGluIFVzZXIgU09iamVjdClcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPExheW91dEluZm8+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxMYXlvdXRJbmZvPn1cbiAqL1xuU09iamVjdC5wcm90b3R5cGUubGF5b3V0cyA9IGZ1bmN0aW9uKGxheW91dE5hbWUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgbGF5b3V0TmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gbGF5b3V0TmFtZTtcbiAgICBsYXlvdXROYW1lID0gbnVsbDtcbiAgfVxuICB2YXIgdXJsID0gXCIvc29iamVjdHMvXCIgKyB0aGlzLnR5cGUgKyBcIi9kZXNjcmliZS9cIiArIChsYXlvdXROYW1lID8gXCJuYW1lZExheW91dHMvXCIrbGF5b3V0TmFtZSA6IFwibGF5b3V0c1wiKTtcbiAgcmV0dXJuIHRoaXMuX2Nvbm4ucmVxdWVzdCh1cmwsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29tcGFjdExheW91dEluZm9cbiAqIEBwcm9wIHtBcnJheS48T2JqZWN0Pn0gY29tcGFjdExheW91dHMgLSBBcnJheSBvZiBjb21wYWN0IGxheW91dHNcbiAqIEBwcm9wIHtTdHJpbmd9IGRlZmF1bHRDb21wYWN0TGF5b3V0SWQgLSBJRCBvZiBkZWZhdWx0IGNvbXBhY3QgbGF5b3V0XG4gKiBAcHJvcCB7QXJyYXkuPE9iamVjdD59IHJlY29yZFR5cGVDb21wYWN0TGF5b3V0TWFwcGluZ3MgLSBBcnJheSBvZiByZWNvcmQgdHlwZSBtYXBwaW5nc1xuICovXG4vKipcbiAqIERlc2NyaWJlIGNvbXBhY3QgbGF5b3V0IGluZm9ybWF0aW9uIGRlZmluZWQgZm9yIFNPYmplY3RcbiAqXG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxDb21wYWN0TGF5b3V0SW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPENvbXBhY3RMYXlvdXRJbmZvPn1cbiAqL1xuU09iamVjdC5wcm90b3R5cGUuY29tcGFjdExheW91dHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgdXJsID0gXCIvc29iamVjdHMvXCIgKyB0aGlzLnR5cGUgKyBcIi9kZXNjcmliZS9jb21wYWN0TGF5b3V0c1wiO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHVybCwgY2FsbGJhY2spO1xufTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFwcHJvdmFsTGF5b3V0SW5mb1xuICogQHByb3Age0FycmF5LjxPYmplY3Q+fSBhcHByb3ZhbExheW91dHMgLSBBcnJheSBvZiBhcHByb3ZhbCBsYXlvdXRzXG4gKi9cbi8qKlxuICogRGVzY3JpYmUgY29tcGFjdCBsYXlvdXQgaW5mb3JtYXRpb24gZGVmaW5lZCBmb3IgU09iamVjdFxuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFwcHJvdmFsTGF5b3V0SW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPEFwcHJvdmFsTGF5b3V0SW5mbz59XG4gKi9cblNPYmplY3QucHJvdG90eXBlLmFwcHJvdmFsTGF5b3V0cyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSBcIi9zb2JqZWN0cy9cIiArIHRoaXMudHlwZSArIFwiL2Rlc2NyaWJlL2FwcHJvdmFsTGF5b3V0c1wiO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHVybCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGxpc3Qgdmlld3MgZm9yIHRoZSBTT2JqZWN0XG4gKlxuICogQHBhcmFtIHtDYWxsYmFjay48TGlzdFZpZXdzSW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPExpc3RWaWV3c0luZm8+fVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS5saXN0dmlld3MgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgdXJsID0gdGhpcy5fY29ubi5fYmFzZVVybCgpICsgJy9zb2JqZWN0cy8nICsgdGhpcy50eXBlICsgJy9saXN0dmlld3MnO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHVybCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsaXN0IHZpZXcgaW5mbyBpbiBzcGVjaWZlZCB2aWV3IGlkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gTGlzdCB2aWV3IElEXG4gKiBAcmV0dXJucyB7TGlzdFZpZXd9XG4gKi9cblNPYmplY3QucHJvdG90eXBlLmxpc3R2aWV3ID0gZnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIG5ldyBMaXN0Vmlldyh0aGlzLl9jb25uLCB0aGlzLnR5cGUsIGlkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgcmVnaXN0ZXJlZCBxdWljayBhY3Rpb25zIGZvciB0aGUgU09iamVjdFxuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEFycmF5LjxRdWlja0FjdGlvbn5RdWlja0FjdGlvbkluZm8+Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXkuPFF1aWNrQWN0aW9uflF1aWNrQWN0aW9uSW5mbz4+fVxuICovXG5TT2JqZWN0LnByb3RvdHlwZS5xdWlja0FjdGlvbnMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KFwiL3NvYmplY3RzL1wiICsgdGhpcy50eXBlICsgXCIvcXVpY2tBY3Rpb25zXCIpLnRoZW5DYWxsKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogR2V0IHJlZmVyZW5jZSBmb3Igc3BlY2lmaWVkIHF1aWNrIGFjaXRvbiBpbiB0aGUgU09iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25OYW1lIC0gTmFtZSBvZiB0aGUgcXVpY2sgYWN0aW9uXG4gKiBAcmV0dXJucyB7UXVpY2tBY3Rpb259XG4gKi9cblNPYmplY3QucHJvdG90eXBlLnF1aWNrQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uTmFtZSkge1xuICByZXR1cm4gbmV3IFF1aWNrQWN0aW9uKHRoaXMuX2Nvbm4sIFwiL3NvYmplY3RzL1wiICsgdGhpcy50eXBlICsgXCIvcXVpY2tBY3Rpb25zL1wiICsgYWN0aW9uTmFtZSk7XG59O1xuXG5cbi8qKlxuICogQSBjbGFzcyBmb3Igb3JnYW5pemluZyBsaXN0IHZpZXcgaW5mb3JtYXRpb25cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAY2xhc3MgTGlzdFZpZXdcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiAtIENvbm5lY3Rpb24gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U09iamVjdH0gdHlwZSAtIFNPYmplY3QgdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gTGlzdCB2aWV3IElEXG4gKi9cbnZhciBMaXN0VmlldyA9IGZ1bmN0aW9uKGNvbm4sIHR5cGUsIGlkKSB7XG4gIHRoaXMuX2Nvbm4gPSBjb25uO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLmlkID0gaWQ7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHF1ZXJ5IGZvciB0aGUgbGlzdCB2aWV3IGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgZGF0YSBhbmQgcHJlc2VudGF0aW9uIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPExpc3RWaWV3UmVzdWx0SW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPExpc3RWaWV3UmVzdWx0SW5mbz59XG4gKi9cbkxpc3RWaWV3LnByb3RvdHlwZS5yZXN1bHRzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9ICB0aGlzLl9jb25uLl9iYXNlVXJsKCkgKyAnL3NvYmplY3RzLycgKyB0aGlzLnR5cGUgKyAnL2xpc3R2aWV3cy8nICsgdGhpcy5pZCArICcvcmVzdWx0cyc7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QodXJsLCBjYWxsYmFjayk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBhIGxpc3Qgdmlld1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBJZGVudGl0eSBjYWxsIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgSFRUUCByZXF1ZXN0IGhlYWRlcnMgc2VudCBpbiBpZGVudGl0eSByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxMaXN0Vmlld0Rlc2NyaWJlSW5mbz59IFtjYWxsYmFja10gLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPExpc3RWaWV3RGVzY3JpYmVJbmZvPn1cbiAqL1xuTGlzdFZpZXcucHJvdG90eXBlLmRlc2NyaWJlID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHVybCA9ICB0aGlzLl9jb25uLl9iYXNlVXJsKCkgKyAnL3NvYmplY3RzLycgKyB0aGlzLnR5cGUgKyAnL2xpc3R2aWV3cy8nICsgdGhpcy5pZCArICcvZGVzY3JpYmUnO1xuICByZXR1cm4gdGhpcy5fY29ubi5yZXF1ZXN0KHsgbWV0aG9kOiAnR0VUJywgdXJsOiB1cmwsIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyB9LCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEV4cGxhaW4gcGxhbiBmb3IgZXhlY3V0aW5nIGxpc3Qgdmlld1xuICpcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPEV4cGxhaW5JbmZvPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48RXhwbGFpbkluZm8+fVxuICovXG5MaXN0Vmlldy5wcm90b3R5cGUuZXhwbGFpbiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSBcIi9xdWVyeS8/ZXhwbGFpbj1cIiArIHRoaXMuaWQ7XG4gIHJldHVybiB0aGlzLl9jb25uLnJlcXVlc3QodXJsLCBjYWxsYmFjayk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/sobject.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/soql-builder.js":
/*!**************************************************!*\
  !*** ./node_modules/jsforce/lib/soql-builder.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Create and build SOQL string from configuration\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar _      = __webpack_require__(/*! lodash/core */ \"(action-browser)/./node_modules/lodash/core.js\"),\n    SfDate = __webpack_require__(/*! ./date */ \"(action-browser)/./node_modules/jsforce/lib/date.js\");\n\n\n/**\n * Create SOQL\n * @private\n */\nfunction createSOQL(query) {\n  var soql = [\n    \"SELECT \",\n    createFieldsClause(query.fields, query.includes),\n    \" FROM \",\n    query.table\n  ].join(\"\");\n  var cond = createConditionClause(query.conditions);\n  if (cond) {\n    soql += \" WHERE \" + cond;\n  }\n  var orderby = createOrderByClause(query.sort);\n  if (orderby) {\n    soql += \" ORDER BY \" + orderby;\n  }\n  if (query.limit) {\n    soql += \" LIMIT \" + query.limit;\n  }\n  if (query.offset) {\n    soql += \" OFFSET \" + query.offset;\n  }\n  return soql;\n}\n\n/** @private **/\nfunction createFieldsClause(fields, childQueries) {\n  childQueries = _.map(_.values(childQueries || {}), function(cquery) {\n    return '(' + createSOQL(cquery) + ')';\n  });\n  return (fields || [ \"Id\" ]).concat(childQueries).join(', ');\n}\n\n/** @private **/\nfunction createConditionClause(conditions, operator, depth) {\n  if (_.isString(conditions)) {\n    return conditions;\n  }\n  conditions = conditions || [];\n  operator = operator || \"AND\";\n  depth = depth || 0;\n  if (!isArray(conditions)) { // if passed in hash object\n    conditions = _.keys(conditions).map(function(key) {\n      return {\n        key: key,\n        value: conditions[key]\n      };\n    });\n  } else {\n    conditions = conditions.map(function(cond) {\n      var conds = [];\n      for (var key in cond) {\n        conds.push({\n          key: key,\n          value: cond[key]\n        });\n      }\n      return conds.length>1 ? conds : conds[0];\n    });\n  }\n  conditions = conditions.map(function(cond) {\n    var d = depth+1, op;\n    switch (cond.key) {\n      case \"$or\" :\n      case \"$and\" :\n      case \"$not\" :\n        if (operator !== \"NOT\" && conditions.length === 1) {\n          d = depth; // not change tree depth\n        }\n        op = cond.key === \"$or\" ? \"OR\" :\n             cond.key === \"$and\" ? \"AND\" :\n             \"NOT\";\n        return createConditionClause(cond.value, op, d);\n      default:\n        return createFieldExpression(cond.key, cond.value);\n    }\n  }).filter(function(expr) { return expr; });\n\n  var paren;\n  if (operator === 'NOT') {\n    paren = depth > 0;\n    return (paren ? \"(\" : \"\") + \"NOT \" + conditions[0] + (paren ? \")\" : \"\");\n  } else {\n    paren = depth > 0 && conditions.length > 1;\n    return (paren ? \"(\" : \"\") + conditions.join(\" \"+operator+\" \") + (paren ? \")\" : \"\");\n  }\n}\n\nvar opMap = {\n  \"=\"     : \"=\",\n  \"$eq\"   : \"=\",\n  \"!=\"    : \"!=\",\n  \"$ne\"   : \"!=\",\n  \">\"     : \">\",\n  \"$gt\"   : \">\",\n  \"<\"     : \"<\",\n  \"$lt\"   : \"<\",\n  \">=\"    : \">=\",\n  \"$gte\"  : \">=\",\n  \"<=\"    : \"<=\",\n  \"$lte\"  : \"<=\",\n  \"$like\" : \"LIKE\",\n  \"$nlike\" : \"NOT LIKE\",\n  \"$in\"   : \"IN\",\n  \"$nin\"  : \"NOT IN\",\n  \"$includes\" : \"INCLUDES\",\n  \"$excludes\" : \"EXCLUDES\",\n  \"$exists\" : \"EXISTS\"\n};\n\n/** @private **/\nfunction createFieldExpression(field, value) {\n  // Assume the `$in` operator if value is an array and none was supplied.\n  if (_.isArray(value)) {\n    return createOpExpression(field, \"$in\", value);\n  }\n  // Otherwise, if an object was passed then process the supplied ops.\n  else if (_.isObject(value)) {\n    var expressions = _.map(value, function (v, k) {\n      if (k[0] === \"$\") return createOpExpression(field, k, v);\n    });\n    return expressions.join(' AND ');\n  }\n  // If the value is a scalar, it's an equality condition.\n  else return createOpExpression(field, \"$eq\", value);\n}\n\n/** @private **/\nfunction createOpExpression(field, op, value) {\n  var sfop = opMap[op];\n  if (!sfop || _.isUndefined(value)) { return null; }\n  var valueExpr = createValueExpression(value);\n  if (_.isUndefined(valueExpr)) { return null; }\n  switch (sfop) {\n    case \"NOT LIKE\":\n      return \"(\" + [ \"NOT\", field, 'LIKE', valueExpr ].join(\" \") + \")\";\n    case \"EXISTS\":\n      return [ field, value ? \"!=\" : \"=\", \"null\" ].join(\" \");\n    default:\n      return [ field, sfop, valueExpr ].join(\" \");\n  }\n}\n\n/** @private **/\nfunction createValueExpression(value) {\n  if (isArray(value)) {\n    return value.length > 0 ?\n           \"(\" + value.map(createValueExpression).join(\", \") + \")\" :\n           undefined;\n  }\n  if (value instanceof SfDate) {\n    return value.toString();\n  }\n  if (_.isString(value)) {\n    return \"'\" + escapeSOQLString(value) + \"'\";\n  }\n  if (_.isNumber(value)) {\n    return (value).toString();\n  }\n  if (_.isNull(value)) {\n    return \"null\";\n  }\n  return value;\n}\n\n/** @private **/\nfunction escapeSOQLString(str) {\n  return String(str || '').replace(/'/g, \"\\\\'\");\n}\n\n/** @private **/\nfunction isArray(a) {\n  return _.isObject(a) && _.isFunction(a.pop);\n}\n\n\n/** @private **/\nfunction createOrderByClause(sort) {\n  sort = sort || [];\n  if (_.isString(sort)) {\n    if (/,|\\s+(asc|desc)\\s*$/.test(sort)) {\n      // must be specified in pure \"order by\" clause. Return raw config.\n      return sort;\n    }\n    // sort order in mongoose-style expression.\n    // e.g. \"FieldA -FieldB\" => \"ORDER BY FieldA ASC, FieldB DESC\"\n    sort = sort.split(/\\s+/).map(function(field) {\n      var dir = \"ASC\"; // ascending\n      var flag = field[0];\n      if (flag === '-') {\n        dir = \"DESC\";\n        field = field.substring(1);\n      } else if (flag === '+') {\n        field = field.substring(1);\n      }\n      return [ field, dir ];\n    });\n  } else if (!isArray(sort)) {\n    sort = _.keys(sort).map(function(field) {\n      var dir = sort[field];\n      return [ field, dir ];\n    });\n  }\n  return sort.map(function(s) {\n    var field = s[0], dir = s[1];\n    switch (String(dir)) {\n      case \"DESC\":\n      case \"desc\":\n      case \"descending\":\n      case \"-\":\n      case \"-1\":\n        dir = \"DESC\";\n        break;\n      default:\n        dir = \"ASC\";\n    }\n    return field + \" \" + dir;\n  }).join(\", \");\n}\n\n\nexports.createSOQL = createSOQL;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi9zb3FsLWJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLG1FQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxtRUFBUTs7O0FBRzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDBCQUEwQixjQUFjOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvc29xbC1idWlsZGVyLmpzPzA0ZmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBDcmVhdGUgYW5kIGJ1aWxkIFNPUUwgc3RyaW5nIGZyb20gY29uZmlndXJhdGlvblxuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyAgICAgID0gcmVxdWlyZSgnbG9kYXNoL2NvcmUnKSxcbiAgICBTZkRhdGUgPSByZXF1aXJlKFwiLi9kYXRlXCIpO1xuXG5cbi8qKlxuICogQ3JlYXRlIFNPUUxcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNPUUwocXVlcnkpIHtcbiAgdmFyIHNvcWwgPSBbXG4gICAgXCJTRUxFQ1QgXCIsXG4gICAgY3JlYXRlRmllbGRzQ2xhdXNlKHF1ZXJ5LmZpZWxkcywgcXVlcnkuaW5jbHVkZXMpLFxuICAgIFwiIEZST00gXCIsXG4gICAgcXVlcnkudGFibGVcbiAgXS5qb2luKFwiXCIpO1xuICB2YXIgY29uZCA9IGNyZWF0ZUNvbmRpdGlvbkNsYXVzZShxdWVyeS5jb25kaXRpb25zKTtcbiAgaWYgKGNvbmQpIHtcbiAgICBzb3FsICs9IFwiIFdIRVJFIFwiICsgY29uZDtcbiAgfVxuICB2YXIgb3JkZXJieSA9IGNyZWF0ZU9yZGVyQnlDbGF1c2UocXVlcnkuc29ydCk7XG4gIGlmIChvcmRlcmJ5KSB7XG4gICAgc29xbCArPSBcIiBPUkRFUiBCWSBcIiArIG9yZGVyYnk7XG4gIH1cbiAgaWYgKHF1ZXJ5LmxpbWl0KSB7XG4gICAgc29xbCArPSBcIiBMSU1JVCBcIiArIHF1ZXJ5LmxpbWl0O1xuICB9XG4gIGlmIChxdWVyeS5vZmZzZXQpIHtcbiAgICBzb3FsICs9IFwiIE9GRlNFVCBcIiArIHF1ZXJ5Lm9mZnNldDtcbiAgfVxuICByZXR1cm4gc29xbDtcbn1cblxuLyoqIEBwcml2YXRlICoqL1xuZnVuY3Rpb24gY3JlYXRlRmllbGRzQ2xhdXNlKGZpZWxkcywgY2hpbGRRdWVyaWVzKSB7XG4gIGNoaWxkUXVlcmllcyA9IF8ubWFwKF8udmFsdWVzKGNoaWxkUXVlcmllcyB8fCB7fSksIGZ1bmN0aW9uKGNxdWVyeSkge1xuICAgIHJldHVybiAnKCcgKyBjcmVhdGVTT1FMKGNxdWVyeSkgKyAnKSc7XG4gIH0pO1xuICByZXR1cm4gKGZpZWxkcyB8fCBbIFwiSWRcIiBdKS5jb25jYXQoY2hpbGRRdWVyaWVzKS5qb2luKCcsICcpO1xufVxuXG4vKiogQHByaXZhdGUgKiovXG5mdW5jdGlvbiBjcmVhdGVDb25kaXRpb25DbGF1c2UoY29uZGl0aW9ucywgb3BlcmF0b3IsIGRlcHRoKSB7XG4gIGlmIChfLmlzU3RyaW5nKGNvbmRpdGlvbnMpKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbnM7XG4gIH1cbiAgY29uZGl0aW9ucyA9IGNvbmRpdGlvbnMgfHwgW107XG4gIG9wZXJhdG9yID0gb3BlcmF0b3IgfHwgXCJBTkRcIjtcbiAgZGVwdGggPSBkZXB0aCB8fCAwO1xuICBpZiAoIWlzQXJyYXkoY29uZGl0aW9ucykpIHsgLy8gaWYgcGFzc2VkIGluIGhhc2ggb2JqZWN0XG4gICAgY29uZGl0aW9ucyA9IF8ua2V5cyhjb25kaXRpb25zKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IGNvbmRpdGlvbnNba2V5XVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25kaXRpb25zID0gY29uZGl0aW9ucy5tYXAoZnVuY3Rpb24oY29uZCkge1xuICAgICAgdmFyIGNvbmRzID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gY29uZCkge1xuICAgICAgICBjb25kcy5wdXNoKHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICB2YWx1ZTogY29uZFtrZXldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmRzLmxlbmd0aD4xID8gY29uZHMgOiBjb25kc1swXTtcbiAgICB9KTtcbiAgfVxuICBjb25kaXRpb25zID0gY29uZGl0aW9ucy5tYXAoZnVuY3Rpb24oY29uZCkge1xuICAgIHZhciBkID0gZGVwdGgrMSwgb3A7XG4gICAgc3dpdGNoIChjb25kLmtleSkge1xuICAgICAgY2FzZSBcIiRvclwiIDpcbiAgICAgIGNhc2UgXCIkYW5kXCIgOlxuICAgICAgY2FzZSBcIiRub3RcIiA6XG4gICAgICAgIGlmIChvcGVyYXRvciAhPT0gXCJOT1RcIiAmJiBjb25kaXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGQgPSBkZXB0aDsgLy8gbm90IGNoYW5nZSB0cmVlIGRlcHRoXG4gICAgICAgIH1cbiAgICAgICAgb3AgPSBjb25kLmtleSA9PT0gXCIkb3JcIiA/IFwiT1JcIiA6XG4gICAgICAgICAgICAgY29uZC5rZXkgPT09IFwiJGFuZFwiID8gXCJBTkRcIiA6XG4gICAgICAgICAgICAgXCJOT1RcIjtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbmRpdGlvbkNsYXVzZShjb25kLnZhbHVlLCBvcCwgZCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gY3JlYXRlRmllbGRFeHByZXNzaW9uKGNvbmQua2V5LCBjb25kLnZhbHVlKTtcbiAgICB9XG4gIH0pLmZpbHRlcihmdW5jdGlvbihleHByKSB7IHJldHVybiBleHByOyB9KTtcblxuICB2YXIgcGFyZW47XG4gIGlmIChvcGVyYXRvciA9PT0gJ05PVCcpIHtcbiAgICBwYXJlbiA9IGRlcHRoID4gMDtcbiAgICByZXR1cm4gKHBhcmVuID8gXCIoXCIgOiBcIlwiKSArIFwiTk9UIFwiICsgY29uZGl0aW9uc1swXSArIChwYXJlbiA/IFwiKVwiIDogXCJcIik7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW4gPSBkZXB0aCA+IDAgJiYgY29uZGl0aW9ucy5sZW5ndGggPiAxO1xuICAgIHJldHVybiAocGFyZW4gPyBcIihcIiA6IFwiXCIpICsgY29uZGl0aW9ucy5qb2luKFwiIFwiK29wZXJhdG9yK1wiIFwiKSArIChwYXJlbiA/IFwiKVwiIDogXCJcIik7XG4gIH1cbn1cblxudmFyIG9wTWFwID0ge1xuICBcIj1cIiAgICAgOiBcIj1cIixcbiAgXCIkZXFcIiAgIDogXCI9XCIsXG4gIFwiIT1cIiAgICA6IFwiIT1cIixcbiAgXCIkbmVcIiAgIDogXCIhPVwiLFxuICBcIj5cIiAgICAgOiBcIj5cIixcbiAgXCIkZ3RcIiAgIDogXCI+XCIsXG4gIFwiPFwiICAgICA6IFwiPFwiLFxuICBcIiRsdFwiICAgOiBcIjxcIixcbiAgXCI+PVwiICAgIDogXCI+PVwiLFxuICBcIiRndGVcIiAgOiBcIj49XCIsXG4gIFwiPD1cIiAgICA6IFwiPD1cIixcbiAgXCIkbHRlXCIgIDogXCI8PVwiLFxuICBcIiRsaWtlXCIgOiBcIkxJS0VcIixcbiAgXCIkbmxpa2VcIiA6IFwiTk9UIExJS0VcIixcbiAgXCIkaW5cIiAgIDogXCJJTlwiLFxuICBcIiRuaW5cIiAgOiBcIk5PVCBJTlwiLFxuICBcIiRpbmNsdWRlc1wiIDogXCJJTkNMVURFU1wiLFxuICBcIiRleGNsdWRlc1wiIDogXCJFWENMVURFU1wiLFxuICBcIiRleGlzdHNcIiA6IFwiRVhJU1RTXCJcbn07XG5cbi8qKiBAcHJpdmF0ZSAqKi9cbmZ1bmN0aW9uIGNyZWF0ZUZpZWxkRXhwcmVzc2lvbihmaWVsZCwgdmFsdWUpIHtcbiAgLy8gQXNzdW1lIHRoZSBgJGluYCBvcGVyYXRvciBpZiB2YWx1ZSBpcyBhbiBhcnJheSBhbmQgbm9uZSB3YXMgc3VwcGxpZWQuXG4gIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU9wRXhwcmVzc2lvbihmaWVsZCwgXCIkaW5cIiwgdmFsdWUpO1xuICB9XG4gIC8vIE90aGVyd2lzZSwgaWYgYW4gb2JqZWN0IHdhcyBwYXNzZWQgdGhlbiBwcm9jZXNzIHRoZSBzdXBwbGllZCBvcHMuXG4gIGVsc2UgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIGV4cHJlc3Npb25zID0gXy5tYXAodmFsdWUsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICBpZiAoa1swXSA9PT0gXCIkXCIpIHJldHVybiBjcmVhdGVPcEV4cHJlc3Npb24oZmllbGQsIGssIHYpO1xuICAgIH0pO1xuICAgIHJldHVybiBleHByZXNzaW9ucy5qb2luKCcgQU5EICcpO1xuICB9XG4gIC8vIElmIHRoZSB2YWx1ZSBpcyBhIHNjYWxhciwgaXQncyBhbiBlcXVhbGl0eSBjb25kaXRpb24uXG4gIGVsc2UgcmV0dXJuIGNyZWF0ZU9wRXhwcmVzc2lvbihmaWVsZCwgXCIkZXFcIiwgdmFsdWUpO1xufVxuXG4vKiogQHByaXZhdGUgKiovXG5mdW5jdGlvbiBjcmVhdGVPcEV4cHJlc3Npb24oZmllbGQsIG9wLCB2YWx1ZSkge1xuICB2YXIgc2ZvcCA9IG9wTWFwW29wXTtcbiAgaWYgKCFzZm9wIHx8IF8uaXNVbmRlZmluZWQodmFsdWUpKSB7IHJldHVybiBudWxsOyB9XG4gIHZhciB2YWx1ZUV4cHIgPSBjcmVhdGVWYWx1ZUV4cHJlc3Npb24odmFsdWUpO1xuICBpZiAoXy5pc1VuZGVmaW5lZCh2YWx1ZUV4cHIpKSB7IHJldHVybiBudWxsOyB9XG4gIHN3aXRjaCAoc2ZvcCkge1xuICAgIGNhc2UgXCJOT1QgTElLRVwiOlxuICAgICAgcmV0dXJuIFwiKFwiICsgWyBcIk5PVFwiLCBmaWVsZCwgJ0xJS0UnLCB2YWx1ZUV4cHIgXS5qb2luKFwiIFwiKSArIFwiKVwiO1xuICAgIGNhc2UgXCJFWElTVFNcIjpcbiAgICAgIHJldHVybiBbIGZpZWxkLCB2YWx1ZSA/IFwiIT1cIiA6IFwiPVwiLCBcIm51bGxcIiBdLmpvaW4oXCIgXCIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gWyBmaWVsZCwgc2ZvcCwgdmFsdWVFeHByIF0uam9pbihcIiBcIik7XG4gIH1cbn1cblxuLyoqIEBwcml2YXRlICoqL1xuZnVuY3Rpb24gY3JlYXRlVmFsdWVFeHByZXNzaW9uKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPiAwID9cbiAgICAgICAgICAgXCIoXCIgKyB2YWx1ZS5tYXAoY3JlYXRlVmFsdWVFeHByZXNzaW9uKS5qb2luKFwiLCBcIikgKyBcIilcIiA6XG4gICAgICAgICAgIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZkRhdGUpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoXy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCInXCIgKyBlc2NhcGVTT1FMU3RyaW5nKHZhbHVlKSArIFwiJ1wiO1xuICB9XG4gIGlmIChfLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiAodmFsdWUpLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKF8uaXNOdWxsKHZhbHVlKSkge1xuICAgIHJldHVybiBcIm51bGxcIjtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKiBAcHJpdmF0ZSAqKi9cbmZ1bmN0aW9uIGVzY2FwZVNPUUxTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyIHx8ICcnKS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIik7XG59XG5cbi8qKiBAcHJpdmF0ZSAqKi9cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gXy5pc09iamVjdChhKSAmJiBfLmlzRnVuY3Rpb24oYS5wb3ApO1xufVxuXG5cbi8qKiBAcHJpdmF0ZSAqKi9cbmZ1bmN0aW9uIGNyZWF0ZU9yZGVyQnlDbGF1c2Uoc29ydCkge1xuICBzb3J0ID0gc29ydCB8fCBbXTtcbiAgaWYgKF8uaXNTdHJpbmcoc29ydCkpIHtcbiAgICBpZiAoLyx8XFxzKyhhc2N8ZGVzYylcXHMqJC8udGVzdChzb3J0KSkge1xuICAgICAgLy8gbXVzdCBiZSBzcGVjaWZpZWQgaW4gcHVyZSBcIm9yZGVyIGJ5XCIgY2xhdXNlLiBSZXR1cm4gcmF3IGNvbmZpZy5cbiAgICAgIHJldHVybiBzb3J0O1xuICAgIH1cbiAgICAvLyBzb3J0IG9yZGVyIGluIG1vbmdvb3NlLXN0eWxlIGV4cHJlc3Npb24uXG4gICAgLy8gZS5nLiBcIkZpZWxkQSAtRmllbGRCXCIgPT4gXCJPUkRFUiBCWSBGaWVsZEEgQVNDLCBGaWVsZEIgREVTQ1wiXG4gICAgc29ydCA9IHNvcnQuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgIHZhciBkaXIgPSBcIkFTQ1wiOyAvLyBhc2NlbmRpbmdcbiAgICAgIHZhciBmbGFnID0gZmllbGRbMF07XG4gICAgICBpZiAoZmxhZyA9PT0gJy0nKSB7XG4gICAgICAgIGRpciA9IFwiREVTQ1wiO1xuICAgICAgICBmaWVsZCA9IGZpZWxkLnN1YnN0cmluZygxKTtcbiAgICAgIH0gZWxzZSBpZiAoZmxhZyA9PT0gJysnKSB7XG4gICAgICAgIGZpZWxkID0gZmllbGQuc3Vic3RyaW5nKDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsgZmllbGQsIGRpciBdO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCFpc0FycmF5KHNvcnQpKSB7XG4gICAgc29ydCA9IF8ua2V5cyhzb3J0KS5tYXAoZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgIHZhciBkaXIgPSBzb3J0W2ZpZWxkXTtcbiAgICAgIHJldHVybiBbIGZpZWxkLCBkaXIgXTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc29ydC5tYXAoZnVuY3Rpb24ocykge1xuICAgIHZhciBmaWVsZCA9IHNbMF0sIGRpciA9IHNbMV07XG4gICAgc3dpdGNoIChTdHJpbmcoZGlyKSkge1xuICAgICAgY2FzZSBcIkRFU0NcIjpcbiAgICAgIGNhc2UgXCJkZXNjXCI6XG4gICAgICBjYXNlIFwiZGVzY2VuZGluZ1wiOlxuICAgICAgY2FzZSBcIi1cIjpcbiAgICAgIGNhc2UgXCItMVwiOlxuICAgICAgICBkaXIgPSBcIkRFU0NcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBkaXIgPSBcIkFTQ1wiO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGQgKyBcIiBcIiArIGRpcjtcbiAgfSkuam9pbihcIiwgXCIpO1xufVxuXG5cbmV4cG9ydHMuY3JlYXRlU09RTCA9IGNyZWF0ZVNPUUw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/soql-builder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/soql-builder.js":
/*!**************************************************!*\
  !*** ./node_modules/jsforce/lib/soql-builder.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file Create and build SOQL string from configuration\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n\n\nvar _      = __webpack_require__(/*! lodash/core */ \"(rsc)/./node_modules/lodash/core.js\"),\n    SfDate = __webpack_require__(/*! ./date */ \"(rsc)/./node_modules/jsforce/lib/date.js\");\n\n\n/**\n * Create SOQL\n * @private\n */\nfunction createSOQL(query) {\n  var soql = [\n    \"SELECT \",\n    createFieldsClause(query.fields, query.includes),\n    \" FROM \",\n    query.table\n  ].join(\"\");\n  var cond = createConditionClause(query.conditions);\n  if (cond) {\n    soql += \" WHERE \" + cond;\n  }\n  var orderby = createOrderByClause(query.sort);\n  if (orderby) {\n    soql += \" ORDER BY \" + orderby;\n  }\n  if (query.limit) {\n    soql += \" LIMIT \" + query.limit;\n  }\n  if (query.offset) {\n    soql += \" OFFSET \" + query.offset;\n  }\n  return soql;\n}\n\n/** @private **/\nfunction createFieldsClause(fields, childQueries) {\n  childQueries = _.map(_.values(childQueries || {}), function(cquery) {\n    return '(' + createSOQL(cquery) + ')';\n  });\n  return (fields || [ \"Id\" ]).concat(childQueries).join(', ');\n}\n\n/** @private **/\nfunction createConditionClause(conditions, operator, depth) {\n  if (_.isString(conditions)) {\n    return conditions;\n  }\n  conditions = conditions || [];\n  operator = operator || \"AND\";\n  depth = depth || 0;\n  if (!isArray(conditions)) { // if passed in hash object\n    conditions = _.keys(conditions).map(function(key) {\n      return {\n        key: key,\n        value: conditions[key]\n      };\n    });\n  } else {\n    conditions = conditions.map(function(cond) {\n      var conds = [];\n      for (var key in cond) {\n        conds.push({\n          key: key,\n          value: cond[key]\n        });\n      }\n      return conds.length>1 ? conds : conds[0];\n    });\n  }\n  conditions = conditions.map(function(cond) {\n    var d = depth+1, op;\n    switch (cond.key) {\n      case \"$or\" :\n      case \"$and\" :\n      case \"$not\" :\n        if (operator !== \"NOT\" && conditions.length === 1) {\n          d = depth; // not change tree depth\n        }\n        op = cond.key === \"$or\" ? \"OR\" :\n             cond.key === \"$and\" ? \"AND\" :\n             \"NOT\";\n        return createConditionClause(cond.value, op, d);\n      default:\n        return createFieldExpression(cond.key, cond.value);\n    }\n  }).filter(function(expr) { return expr; });\n\n  var paren;\n  if (operator === 'NOT') {\n    paren = depth > 0;\n    return (paren ? \"(\" : \"\") + \"NOT \" + conditions[0] + (paren ? \")\" : \"\");\n  } else {\n    paren = depth > 0 && conditions.length > 1;\n    return (paren ? \"(\" : \"\") + conditions.join(\" \"+operator+\" \") + (paren ? \")\" : \"\");\n  }\n}\n\nvar opMap = {\n  \"=\"     : \"=\",\n  \"$eq\"   : \"=\",\n  \"!=\"    : \"!=\",\n  \"$ne\"   : \"!=\",\n  \">\"     : \">\",\n  \"$gt\"   : \">\",\n  \"<\"     : \"<\",\n  \"$lt\"   : \"<\",\n  \">=\"    : \">=\",\n  \"$gte\"  : \">=\",\n  \"<=\"    : \"<=\",\n  \"$lte\"  : \"<=\",\n  \"$like\" : \"LIKE\",\n  \"$nlike\" : \"NOT LIKE\",\n  \"$in\"   : \"IN\",\n  \"$nin\"  : \"NOT IN\",\n  \"$includes\" : \"INCLUDES\",\n  \"$excludes\" : \"EXCLUDES\",\n  \"$exists\" : \"EXISTS\"\n};\n\n/** @private **/\nfunction createFieldExpression(field, value) {\n  // Assume the `$in` operator if value is an array and none was supplied.\n  if (_.isArray(value)) {\n    return createOpExpression(field, \"$in\", value);\n  }\n  // Otherwise, if an object was passed then process the supplied ops.\n  else if (_.isObject(value)) {\n    var expressions = _.map(value, function (v, k) {\n      if (k[0] === \"$\") return createOpExpression(field, k, v);\n    });\n    return expressions.join(' AND ');\n  }\n  // If the value is a scalar, it's an equality condition.\n  else return createOpExpression(field, \"$eq\", value);\n}\n\n/** @private **/\nfunction createOpExpression(field, op, value) {\n  var sfop = opMap[op];\n  if (!sfop || _.isUndefined(value)) { return null; }\n  var valueExpr = createValueExpression(value);\n  if (_.isUndefined(valueExpr)) { return null; }\n  switch (sfop) {\n    case \"NOT LIKE\":\n      return \"(\" + [ \"NOT\", field, 'LIKE', valueExpr ].join(\" \") + \")\";\n    case \"EXISTS\":\n      return [ field, value ? \"!=\" : \"=\", \"null\" ].join(\" \");\n    default:\n      return [ field, sfop, valueExpr ].join(\" \");\n  }\n}\n\n/** @private **/\nfunction createValueExpression(value) {\n  if (isArray(value)) {\n    return value.length > 0 ?\n           \"(\" + value.map(createValueExpression).join(\", \") + \")\" :\n           undefined;\n  }\n  if (value instanceof SfDate) {\n    return value.toString();\n  }\n  if (_.isString(value)) {\n    return \"'\" + escapeSOQLString(value) + \"'\";\n  }\n  if (_.isNumber(value)) {\n    return (value).toString();\n  }\n  if (_.isNull(value)) {\n    return \"null\";\n  }\n  return value;\n}\n\n/** @private **/\nfunction escapeSOQLString(str) {\n  return String(str || '').replace(/'/g, \"\\\\'\");\n}\n\n/** @private **/\nfunction isArray(a) {\n  return _.isObject(a) && _.isFunction(a.pop);\n}\n\n\n/** @private **/\nfunction createOrderByClause(sort) {\n  sort = sort || [];\n  if (_.isString(sort)) {\n    if (/,|\\s+(asc|desc)\\s*$/.test(sort)) {\n      // must be specified in pure \"order by\" clause. Return raw config.\n      return sort;\n    }\n    // sort order in mongoose-style expression.\n    // e.g. \"FieldA -FieldB\" => \"ORDER BY FieldA ASC, FieldB DESC\"\n    sort = sort.split(/\\s+/).map(function(field) {\n      var dir = \"ASC\"; // ascending\n      var flag = field[0];\n      if (flag === '-') {\n        dir = \"DESC\";\n        field = field.substring(1);\n      } else if (flag === '+') {\n        field = field.substring(1);\n      }\n      return [ field, dir ];\n    });\n  } else if (!isArray(sort)) {\n    sort = _.keys(sort).map(function(field) {\n      var dir = sort[field];\n      return [ field, dir ];\n    });\n  }\n  return sort.map(function(s) {\n    var field = s[0], dir = s[1];\n    switch (String(dir)) {\n      case \"DESC\":\n      case \"desc\":\n      case \"descending\":\n      case \"-\":\n      case \"-1\":\n        dir = \"DESC\";\n        break;\n      default:\n        dir = \"ASC\";\n    }\n    return field + \" \" + dir;\n  }).join(\", \");\n}\n\n\nexports.createSOQL = createSOQL;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvc29xbC1idWlsZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyx3REFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsd0RBQVE7OztBQUc3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywwQkFBMEIsY0FBYzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL3NvcWwtYnVpbGRlci5qcz9hZDljIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgQ3JlYXRlIGFuZCBidWlsZCBTT1FMIHN0cmluZyBmcm9tIGNvbmZpZ3VyYXRpb25cbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gICAgICA9IHJlcXVpcmUoJ2xvZGFzaC9jb3JlJyksXG4gICAgU2ZEYXRlID0gcmVxdWlyZShcIi4vZGF0ZVwiKTtcblxuXG4vKipcbiAqIENyZWF0ZSBTT1FMXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVTT1FMKHF1ZXJ5KSB7XG4gIHZhciBzb3FsID0gW1xuICAgIFwiU0VMRUNUIFwiLFxuICAgIGNyZWF0ZUZpZWxkc0NsYXVzZShxdWVyeS5maWVsZHMsIHF1ZXJ5LmluY2x1ZGVzKSxcbiAgICBcIiBGUk9NIFwiLFxuICAgIHF1ZXJ5LnRhYmxlXG4gIF0uam9pbihcIlwiKTtcbiAgdmFyIGNvbmQgPSBjcmVhdGVDb25kaXRpb25DbGF1c2UocXVlcnkuY29uZGl0aW9ucyk7XG4gIGlmIChjb25kKSB7XG4gICAgc29xbCArPSBcIiBXSEVSRSBcIiArIGNvbmQ7XG4gIH1cbiAgdmFyIG9yZGVyYnkgPSBjcmVhdGVPcmRlckJ5Q2xhdXNlKHF1ZXJ5LnNvcnQpO1xuICBpZiAob3JkZXJieSkge1xuICAgIHNvcWwgKz0gXCIgT1JERVIgQlkgXCIgKyBvcmRlcmJ5O1xuICB9XG4gIGlmIChxdWVyeS5saW1pdCkge1xuICAgIHNvcWwgKz0gXCIgTElNSVQgXCIgKyBxdWVyeS5saW1pdDtcbiAgfVxuICBpZiAocXVlcnkub2Zmc2V0KSB7XG4gICAgc29xbCArPSBcIiBPRkZTRVQgXCIgKyBxdWVyeS5vZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIHNvcWw7XG59XG5cbi8qKiBAcHJpdmF0ZSAqKi9cbmZ1bmN0aW9uIGNyZWF0ZUZpZWxkc0NsYXVzZShmaWVsZHMsIGNoaWxkUXVlcmllcykge1xuICBjaGlsZFF1ZXJpZXMgPSBfLm1hcChfLnZhbHVlcyhjaGlsZFF1ZXJpZXMgfHwge30pLCBmdW5jdGlvbihjcXVlcnkpIHtcbiAgICByZXR1cm4gJygnICsgY3JlYXRlU09RTChjcXVlcnkpICsgJyknO1xuICB9KTtcbiAgcmV0dXJuIChmaWVsZHMgfHwgWyBcIklkXCIgXSkuY29uY2F0KGNoaWxkUXVlcmllcykuam9pbignLCAnKTtcbn1cblxuLyoqIEBwcml2YXRlICoqL1xuZnVuY3Rpb24gY3JlYXRlQ29uZGl0aW9uQ2xhdXNlKGNvbmRpdGlvbnMsIG9wZXJhdG9yLCBkZXB0aCkge1xuICBpZiAoXy5pc1N0cmluZyhjb25kaXRpb25zKSkge1xuICAgIHJldHVybiBjb25kaXRpb25zO1xuICB9XG4gIGNvbmRpdGlvbnMgPSBjb25kaXRpb25zIHx8IFtdO1xuICBvcGVyYXRvciA9IG9wZXJhdG9yIHx8IFwiQU5EXCI7XG4gIGRlcHRoID0gZGVwdGggfHwgMDtcbiAgaWYgKCFpc0FycmF5KGNvbmRpdGlvbnMpKSB7IC8vIGlmIHBhc3NlZCBpbiBoYXNoIG9iamVjdFxuICAgIGNvbmRpdGlvbnMgPSBfLmtleXMoY29uZGl0aW9ucykubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiBjb25kaXRpb25zW2tleV1cbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uZGl0aW9ucyA9IGNvbmRpdGlvbnMubWFwKGZ1bmN0aW9uKGNvbmQpIHtcbiAgICAgIHZhciBjb25kcyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIGNvbmQpIHtcbiAgICAgICAgY29uZHMucHVzaCh7XG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgdmFsdWU6IGNvbmRba2V5XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25kcy5sZW5ndGg+MSA/IGNvbmRzIDogY29uZHNbMF07XG4gICAgfSk7XG4gIH1cbiAgY29uZGl0aW9ucyA9IGNvbmRpdGlvbnMubWFwKGZ1bmN0aW9uKGNvbmQpIHtcbiAgICB2YXIgZCA9IGRlcHRoKzEsIG9wO1xuICAgIHN3aXRjaCAoY29uZC5rZXkpIHtcbiAgICAgIGNhc2UgXCIkb3JcIiA6XG4gICAgICBjYXNlIFwiJGFuZFwiIDpcbiAgICAgIGNhc2UgXCIkbm90XCIgOlxuICAgICAgICBpZiAob3BlcmF0b3IgIT09IFwiTk9UXCIgJiYgY29uZGl0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBkID0gZGVwdGg7IC8vIG5vdCBjaGFuZ2UgdHJlZSBkZXB0aFxuICAgICAgICB9XG4gICAgICAgIG9wID0gY29uZC5rZXkgPT09IFwiJG9yXCIgPyBcIk9SXCIgOlxuICAgICAgICAgICAgIGNvbmQua2V5ID09PSBcIiRhbmRcIiA/IFwiQU5EXCIgOlxuICAgICAgICAgICAgIFwiTk9UXCI7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb25kaXRpb25DbGF1c2UoY29uZC52YWx1ZSwgb3AsIGQpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpZWxkRXhwcmVzc2lvbihjb25kLmtleSwgY29uZC52YWx1ZSk7XG4gICAgfVxuICB9KS5maWx0ZXIoZnVuY3Rpb24oZXhwcikgeyByZXR1cm4gZXhwcjsgfSk7XG5cbiAgdmFyIHBhcmVuO1xuICBpZiAob3BlcmF0b3IgPT09ICdOT1QnKSB7XG4gICAgcGFyZW4gPSBkZXB0aCA+IDA7XG4gICAgcmV0dXJuIChwYXJlbiA/IFwiKFwiIDogXCJcIikgKyBcIk5PVCBcIiArIGNvbmRpdGlvbnNbMF0gKyAocGFyZW4gPyBcIilcIiA6IFwiXCIpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVuID0gZGVwdGggPiAwICYmIGNvbmRpdGlvbnMubGVuZ3RoID4gMTtcbiAgICByZXR1cm4gKHBhcmVuID8gXCIoXCIgOiBcIlwiKSArIGNvbmRpdGlvbnMuam9pbihcIiBcIitvcGVyYXRvcitcIiBcIikgKyAocGFyZW4gPyBcIilcIiA6IFwiXCIpO1xuICB9XG59XG5cbnZhciBvcE1hcCA9IHtcbiAgXCI9XCIgICAgIDogXCI9XCIsXG4gIFwiJGVxXCIgICA6IFwiPVwiLFxuICBcIiE9XCIgICAgOiBcIiE9XCIsXG4gIFwiJG5lXCIgICA6IFwiIT1cIixcbiAgXCI+XCIgICAgIDogXCI+XCIsXG4gIFwiJGd0XCIgICA6IFwiPlwiLFxuICBcIjxcIiAgICAgOiBcIjxcIixcbiAgXCIkbHRcIiAgIDogXCI8XCIsXG4gIFwiPj1cIiAgICA6IFwiPj1cIixcbiAgXCIkZ3RlXCIgIDogXCI+PVwiLFxuICBcIjw9XCIgICAgOiBcIjw9XCIsXG4gIFwiJGx0ZVwiICA6IFwiPD1cIixcbiAgXCIkbGlrZVwiIDogXCJMSUtFXCIsXG4gIFwiJG5saWtlXCIgOiBcIk5PVCBMSUtFXCIsXG4gIFwiJGluXCIgICA6IFwiSU5cIixcbiAgXCIkbmluXCIgIDogXCJOT1QgSU5cIixcbiAgXCIkaW5jbHVkZXNcIiA6IFwiSU5DTFVERVNcIixcbiAgXCIkZXhjbHVkZXNcIiA6IFwiRVhDTFVERVNcIixcbiAgXCIkZXhpc3RzXCIgOiBcIkVYSVNUU1wiXG59O1xuXG4vKiogQHByaXZhdGUgKiovXG5mdW5jdGlvbiBjcmVhdGVGaWVsZEV4cHJlc3Npb24oZmllbGQsIHZhbHVlKSB7XG4gIC8vIEFzc3VtZSB0aGUgYCRpbmAgb3BlcmF0b3IgaWYgdmFsdWUgaXMgYW4gYXJyYXkgYW5kIG5vbmUgd2FzIHN1cHBsaWVkLlxuICBpZiAoXy5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBjcmVhdGVPcEV4cHJlc3Npb24oZmllbGQsIFwiJGluXCIsIHZhbHVlKTtcbiAgfVxuICAvLyBPdGhlcndpc2UsIGlmIGFuIG9iamVjdCB3YXMgcGFzc2VkIHRoZW4gcHJvY2VzcyB0aGUgc3VwcGxpZWQgb3BzLlxuICBlbHNlIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBleHByZXNzaW9ucyA9IF8ubWFwKHZhbHVlLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgaWYgKGtbMF0gPT09IFwiJFwiKSByZXR1cm4gY3JlYXRlT3BFeHByZXNzaW9uKGZpZWxkLCBrLCB2KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXhwcmVzc2lvbnMuam9pbignIEFORCAnKTtcbiAgfVxuICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBzY2FsYXIsIGl0J3MgYW4gZXF1YWxpdHkgY29uZGl0aW9uLlxuICBlbHNlIHJldHVybiBjcmVhdGVPcEV4cHJlc3Npb24oZmllbGQsIFwiJGVxXCIsIHZhbHVlKTtcbn1cblxuLyoqIEBwcml2YXRlICoqL1xuZnVuY3Rpb24gY3JlYXRlT3BFeHByZXNzaW9uKGZpZWxkLCBvcCwgdmFsdWUpIHtcbiAgdmFyIHNmb3AgPSBvcE1hcFtvcF07XG4gIGlmICghc2ZvcCB8fCBfLmlzVW5kZWZpbmVkKHZhbHVlKSkgeyByZXR1cm4gbnVsbDsgfVxuICB2YXIgdmFsdWVFeHByID0gY3JlYXRlVmFsdWVFeHByZXNzaW9uKHZhbHVlKTtcbiAgaWYgKF8uaXNVbmRlZmluZWQodmFsdWVFeHByKSkgeyByZXR1cm4gbnVsbDsgfVxuICBzd2l0Y2ggKHNmb3ApIHtcbiAgICBjYXNlIFwiTk9UIExJS0VcIjpcbiAgICAgIHJldHVybiBcIihcIiArIFsgXCJOT1RcIiwgZmllbGQsICdMSUtFJywgdmFsdWVFeHByIF0uam9pbihcIiBcIikgKyBcIilcIjtcbiAgICBjYXNlIFwiRVhJU1RTXCI6XG4gICAgICByZXR1cm4gWyBmaWVsZCwgdmFsdWUgPyBcIiE9XCIgOiBcIj1cIiwgXCJudWxsXCIgXS5qb2luKFwiIFwiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFsgZmllbGQsIHNmb3AsIHZhbHVlRXhwciBdLmpvaW4oXCIgXCIpO1xuICB9XG59XG5cbi8qKiBAcHJpdmF0ZSAqKi9cbmZ1bmN0aW9uIGNyZWF0ZVZhbHVlRXhwcmVzc2lvbih2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoID4gMCA/XG4gICAgICAgICAgIFwiKFwiICsgdmFsdWUubWFwKGNyZWF0ZVZhbHVlRXhwcmVzc2lvbikuam9pbihcIiwgXCIpICsgXCIpXCIgOlxuICAgICAgICAgICB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2ZEYXRlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKF8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIFwiJ1wiICsgZXNjYXBlU09RTFN0cmluZyh2YWx1ZSkgKyBcIidcIjtcbiAgfVxuICBpZiAoXy5pc051bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gKHZhbHVlKS50b1N0cmluZygpO1xuICB9XG4gIGlmIChfLmlzTnVsbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKiogQHByaXZhdGUgKiovXG5mdW5jdGlvbiBlc2NhcGVTT1FMU3RyaW5nKHN0cikge1xuICByZXR1cm4gU3RyaW5nKHN0ciB8fCAnJykucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpO1xufVxuXG4vKiogQHByaXZhdGUgKiovXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIF8uaXNPYmplY3QoYSkgJiYgXy5pc0Z1bmN0aW9uKGEucG9wKTtcbn1cblxuXG4vKiogQHByaXZhdGUgKiovXG5mdW5jdGlvbiBjcmVhdGVPcmRlckJ5Q2xhdXNlKHNvcnQpIHtcbiAgc29ydCA9IHNvcnQgfHwgW107XG4gIGlmIChfLmlzU3RyaW5nKHNvcnQpKSB7XG4gICAgaWYgKC8sfFxccysoYXNjfGRlc2MpXFxzKiQvLnRlc3Qoc29ydCkpIHtcbiAgICAgIC8vIG11c3QgYmUgc3BlY2lmaWVkIGluIHB1cmUgXCJvcmRlciBieVwiIGNsYXVzZS4gUmV0dXJuIHJhdyBjb25maWcuXG4gICAgICByZXR1cm4gc29ydDtcbiAgICB9XG4gICAgLy8gc29ydCBvcmRlciBpbiBtb25nb29zZS1zdHlsZSBleHByZXNzaW9uLlxuICAgIC8vIGUuZy4gXCJGaWVsZEEgLUZpZWxkQlwiID0+IFwiT1JERVIgQlkgRmllbGRBIEFTQywgRmllbGRCIERFU0NcIlxuICAgIHNvcnQgPSBzb3J0LnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICB2YXIgZGlyID0gXCJBU0NcIjsgLy8gYXNjZW5kaW5nXG4gICAgICB2YXIgZmxhZyA9IGZpZWxkWzBdO1xuICAgICAgaWYgKGZsYWcgPT09ICctJykge1xuICAgICAgICBkaXIgPSBcIkRFU0NcIjtcbiAgICAgICAgZmllbGQgPSBmaWVsZC5zdWJzdHJpbmcoMSk7XG4gICAgICB9IGVsc2UgaWYgKGZsYWcgPT09ICcrJykge1xuICAgICAgICBmaWVsZCA9IGZpZWxkLnN1YnN0cmluZygxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbIGZpZWxkLCBkaXIgXTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICghaXNBcnJheShzb3J0KSkge1xuICAgIHNvcnQgPSBfLmtleXMoc29ydCkubWFwKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICB2YXIgZGlyID0gc29ydFtmaWVsZF07XG4gICAgICByZXR1cm4gWyBmaWVsZCwgZGlyIF07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNvcnQubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgZmllbGQgPSBzWzBdLCBkaXIgPSBzWzFdO1xuICAgIHN3aXRjaCAoU3RyaW5nKGRpcikpIHtcbiAgICAgIGNhc2UgXCJERVNDXCI6XG4gICAgICBjYXNlIFwiZGVzY1wiOlxuICAgICAgY2FzZSBcImRlc2NlbmRpbmdcIjpcbiAgICAgIGNhc2UgXCItXCI6XG4gICAgICBjYXNlIFwiLTFcIjpcbiAgICAgICAgZGlyID0gXCJERVNDXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZGlyID0gXCJBU0NcIjtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkICsgXCIgXCIgKyBkaXI7XG4gIH0pLmpvaW4oXCIsIFwiKTtcbn1cblxuXG5leHBvcnRzLmNyZWF0ZVNPUUwgPSBjcmVhdGVTT1FMO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/soql-builder.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/lib/transport.js":
/*!***********************************************!*\
  !*** ./node_modules/jsforce/lib/transport.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global process, Sfdc */\n\n\n\nvar inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\"),\n    Promise = __webpack_require__(/*! ./promise */ \"(action-browser)/./node_modules/jsforce/lib/promise.js\");\n\n/* */\n\nvar request = __webpack_require__(/*! request */ \"(action-browser)/./node_modules/request/index.js\"),\n    canvas = __webpack_require__(/*! ./browser/canvas */ \"(action-browser)/./node_modules/jsforce/lib/browser/canvas.js\"),\n    jsonp = __webpack_require__(/*! ./browser/jsonp */ \"(action-browser)/./node_modules/jsforce/lib/browser/jsonp.js\");\n\n// set options if defaults setting is available in request, which is not available in xhr module.\nif (request.defaults) {\n  var defaults = {\n    followAllRedirects: true\n  };\n  if (process.env.HTTP_PROXY) {\n    defaults.proxy = process.env.HTTP_PROXY;\n  }\n  if (parseInt(process.env.HTTP_TIMEOUT)) {\n    defaults.timeout = parseInt(process.env.HTTP_TIMEOUT);\n  }\n  request = request.defaults(defaults);\n}\n\nvar baseUrl;\nif (typeof window === 'undefined') {\n  baseUrl = process.env.LOCATION_BASE_URL || \"\";\n} else {\n  var apiHost = normalizeApiHost(window.location.host);\n  baseUrl = apiHost ? \"https://\" + apiHost : \"\";\n}\n\n/**\n * Add stream() method to promise (and following promise chain), to access original request stream.\n * @private\n */\nfunction streamify(promise, factory) {\n  var _then = promise.then;\n  promise.then = function() {\n    factory();\n    var newPromise = _then.apply(promise, arguments);\n    return streamify(newPromise, factory);\n  };\n  promise.stream = factory;\n  return promise;\n}\n\n/**\n * Normarize Salesforce API host name\n * @private\n */\nfunction normalizeApiHost(apiHost) {\n  var m = /(\\w+)\\.(visual\\.force|salesforce)\\.com$/.exec(apiHost);\n  if (m) {\n    apiHost = m[1] + \".salesforce.com\";\n  }\n  return apiHost;\n}\n\n/**\n * Class for HTTP request transport\n *\n * @class\n * @protected\n */\nvar Transport = module.exports = function() {};\n\n/**\n * Make HTTP request, returns promise instead of stream\n *\n * @param {Object} params - HTTP request\n * @param {Callback.<Object>} [callback] - Calback Function\n * @returns {Promise.<Object>}\n */\nTransport.prototype.httpRequest = function(params, callback) {\n  var deferred = Promise.defer();\n  var req;\n  var httpRequest = this._getHttpRequestModule();\n  var createRequest = function() {\n    if (!req) {\n      req = httpRequest(params, function(err, response) {\n        if (err) {\n          deferred.reject(err);\n        } else {\n          deferred.resolve(response);\n        }\n      });\n    }\n    return req;\n  };\n  return streamify(deferred.promise, createRequest).thenCall(callback);\n};\n\n/** @protected **/\nTransport.prototype._getHttpRequestModule = function() {\n  return request;\n};\n\n\n/**\n * Class for JSONP request transport\n * @class Transport~JsonpTransport\n * @protected\n * @extends Transport\n * @param {String} jsonpParam - Callback parameter name for JSONP invokation.\n */\nvar JsonpTransport = Transport.JsonpTransport = function(jsonpParam) {\n  this._jsonpParam = jsonpParam;\n};\n\ninherits(JsonpTransport, Transport);\n\n/** @protected **/\nJsonpTransport.prototype._getHttpRequestModule = function() {\n  return jsonp.createRequest(this._jsonpParam);\n};\n\nJsonpTransport.supported = jsonp.supported;\n\n\n/**\n * Class for Sfdc Canvas request transport\n * @class Transport~CanvasTransport\n * @protected\n * @extends Transport\n * @param {Object} signedRequest - Parsed signed request object\n */\nvar CanvasTransport = Transport.CanvasTransport = function(signedRequest) {\n  this._signedRequest = signedRequest;\n};\n\ninherits(CanvasTransport, Transport);\n\n/** @protected **/\nCanvasTransport.prototype._getHttpRequestModule = function() {\n  return canvas.createRequest(this._signedRequest);\n};\n\nCanvasTransport.supported = canvas.supported;\n\n\n/**\n * Class for HTTP request transport using AJAX proxy service\n *\n * @class Transport~ProxyTransport\n * @protected\n * @extends Transport\n * @param {String} proxyUrl - AJAX Proxy server URL\n */\nvar ProxyTransport = Transport.ProxyTransport = function(proxyUrl) {\n  this._proxyUrl = proxyUrl;\n};\n\ninherits(ProxyTransport, Transport);\n\n/**\n * Make HTTP request via AJAX proxy\n *\n * @method Transport~ProxyTransport#httpRequest\n * @param {Object} params - HTTP request\n * @param {Callback.<Object>} [callback] - Calback Function\n * @returns {Promise.<Object>}\n */\nProxyTransport.prototype.httpRequest = function(params, callback) {\n  var url = params.url;\n  if (url.indexOf(\"/\") === 0) {\n    url = baseUrl + url;\n  }\n  var proxyParams = {\n    method: params.method,\n    url: this._proxyUrl + '?' + Date.now() + \".\" + (\"\" + Math.random()).substring(2),\n    headers: {\n      'salesforceproxy-endpoint': url\n    }\n  };\n  if (params.body || params.body === \"\") {\n    proxyParams.body = params.body;\n  }\n  if (params.headers) {\n    for (var name in params.headers) {\n      proxyParams.headers[name] = params.headers[name];\n    }\n  }\n  return ProxyTransport.super_.prototype.httpRequest.call(this, proxyParams, callback);\n};\n\n\n/**\n * Class for HTTP request transport using a proxy server\n *\n * @class Transport~HttpProxyTransport\n * @protected\n * @extends Transport\n * @param {String} httpProxy - URL of the HTTP proxy server\n */\nvar HttpProxyTransport = Transport.HttpProxyTransport = function(httpProxy) {\n  this._httpProxy = httpProxy;\n};\n\ninherits(HttpProxyTransport, Transport);\n\n/**\n * Make HTTP request via proxy server\n *\n * @method Transport~HttpProxyTransport#httpRequest\n * @param {Object} params - HTTP request\n * @param {Callback.<Object>} [callback] - Callback Function\n * @returns {Promise.<Object>}\n */\nHttpProxyTransport.prototype.httpRequest = function(params, callback) {\n  var url = params.url;\n  if (url.indexOf(\"/\") === 0) {\n    url = baseUrl + url;\n  }\n  var proxyParams = {\n    method: params.method,\n    url: params.url,\n    proxy: this._httpProxy,\n    headers: {}\n  };\n  if (params.body || params.body === \"\") {\n    proxyParams.body = params.body;\n  }\n  if (params.headers) {\n    for (var name in params.headers) {\n      proxyParams.headers[name] = params.headers[name];\n    }\n  }\n  return HttpProxyTransport.super_.prototype.httpRequest.call(this, proxyParams, callback);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL2xpYi90cmFuc3BvcnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHNFQUFVO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyx5RUFBVzs7QUFFakM7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLGlFQUFTO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyx1RkFBa0I7QUFDdkMsWUFBWSxtQkFBTyxDQUFDLHFGQUFpQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvdHJhbnNwb3J0LmpzP2Y1Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiLypnbG9iYWwgcHJvY2VzcywgU2ZkYyAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vcHJvbWlzZScpO1xuXG4vKiAqL1xuXG52YXIgcmVxdWVzdCA9IHJlcXVpcmUoJ3JlcXVlc3QnKSxcbiAgICBjYW52YXMgPSByZXF1aXJlKCcuL2Jyb3dzZXIvY2FudmFzJyksXG4gICAganNvbnAgPSByZXF1aXJlKCcuL2Jyb3dzZXIvanNvbnAnKTtcblxuLy8gc2V0IG9wdGlvbnMgaWYgZGVmYXVsdHMgc2V0dGluZyBpcyBhdmFpbGFibGUgaW4gcmVxdWVzdCwgd2hpY2ggaXMgbm90IGF2YWlsYWJsZSBpbiB4aHIgbW9kdWxlLlxuaWYgKHJlcXVlc3QuZGVmYXVsdHMpIHtcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICB9O1xuICBpZiAocHJvY2Vzcy5lbnYuSFRUUF9QUk9YWSkge1xuICAgIGRlZmF1bHRzLnByb3h5ID0gcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWTtcbiAgfVxuICBpZiAocGFyc2VJbnQocHJvY2Vzcy5lbnYuSFRUUF9USU1FT1VUKSkge1xuICAgIGRlZmF1bHRzLnRpbWVvdXQgPSBwYXJzZUludChwcm9jZXNzLmVudi5IVFRQX1RJTUVPVVQpO1xuICB9XG4gIHJlcXVlc3QgPSByZXF1ZXN0LmRlZmF1bHRzKGRlZmF1bHRzKTtcbn1cblxudmFyIGJhc2VVcmw7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgYmFzZVVybCA9IHByb2Nlc3MuZW52LkxPQ0FUSU9OX0JBU0VfVVJMIHx8IFwiXCI7XG59IGVsc2Uge1xuICB2YXIgYXBpSG9zdCA9IG5vcm1hbGl6ZUFwaUhvc3Qod2luZG93LmxvY2F0aW9uLmhvc3QpO1xuICBiYXNlVXJsID0gYXBpSG9zdCA/IFwiaHR0cHM6Ly9cIiArIGFwaUhvc3QgOiBcIlwiO1xufVxuXG4vKipcbiAqIEFkZCBzdHJlYW0oKSBtZXRob2QgdG8gcHJvbWlzZSAoYW5kIGZvbGxvd2luZyBwcm9taXNlIGNoYWluKSwgdG8gYWNjZXNzIG9yaWdpbmFsIHJlcXVlc3Qgc3RyZWFtLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc3RyZWFtaWZ5KHByb21pc2UsIGZhY3RvcnkpIHtcbiAgdmFyIF90aGVuID0gcHJvbWlzZS50aGVuO1xuICBwcm9taXNlLnRoZW4gPSBmdW5jdGlvbigpIHtcbiAgICBmYWN0b3J5KCk7XG4gICAgdmFyIG5ld1Byb21pc2UgPSBfdGhlbi5hcHBseShwcm9taXNlLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBzdHJlYW1pZnkobmV3UHJvbWlzZSwgZmFjdG9yeSk7XG4gIH07XG4gIHByb21pc2Uuc3RyZWFtID0gZmFjdG9yeTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8qKlxuICogTm9ybWFyaXplIFNhbGVzZm9yY2UgQVBJIGhvc3QgbmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQXBpSG9zdChhcGlIb3N0KSB7XG4gIHZhciBtID0gLyhcXHcrKVxcLih2aXN1YWxcXC5mb3JjZXxzYWxlc2ZvcmNlKVxcLmNvbSQvLmV4ZWMoYXBpSG9zdCk7XG4gIGlmIChtKSB7XG4gICAgYXBpSG9zdCA9IG1bMV0gKyBcIi5zYWxlc2ZvcmNlLmNvbVwiO1xuICB9XG4gIHJldHVybiBhcGlIb3N0O1xufVxuXG4vKipcbiAqIENsYXNzIGZvciBIVFRQIHJlcXVlc3QgdHJhbnNwb3J0XG4gKlxuICogQGNsYXNzXG4gKiBAcHJvdGVjdGVkXG4gKi9cbnZhciBUcmFuc3BvcnQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogTWFrZSBIVFRQIHJlcXVlc3QsIHJldHVybnMgcHJvbWlzZSBpbnN0ZWFkIG9mIHN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBIVFRQIHJlcXVlc3RcbiAqIEBwYXJhbSB7Q2FsbGJhY2suPE9iamVjdD59IFtjYWxsYmFja10gLSBDYWxiYWNrIEZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48T2JqZWN0Pn1cbiAqL1xuVHJhbnNwb3J0LnByb3RvdHlwZS5odHRwUmVxdWVzdCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgdmFyIGRlZmVycmVkID0gUHJvbWlzZS5kZWZlcigpO1xuICB2YXIgcmVxO1xuICB2YXIgaHR0cFJlcXVlc3QgPSB0aGlzLl9nZXRIdHRwUmVxdWVzdE1vZHVsZSgpO1xuICB2YXIgY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghcmVxKSB7XG4gICAgICByZXEgPSBodHRwUmVxdWVzdChwYXJhbXMsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcTtcbiAgfTtcbiAgcmV0dXJuIHN0cmVhbWlmeShkZWZlcnJlZC5wcm9taXNlLCBjcmVhdGVSZXF1ZXN0KS50aGVuQ2FsbChjYWxsYmFjayk7XG59O1xuXG4vKiogQHByb3RlY3RlZCAqKi9cblRyYW5zcG9ydC5wcm90b3R5cGUuX2dldEh0dHBSZXF1ZXN0TW9kdWxlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByZXF1ZXN0O1xufTtcblxuXG4vKipcbiAqIENsYXNzIGZvciBKU09OUCByZXF1ZXN0IHRyYW5zcG9ydFxuICogQGNsYXNzIFRyYW5zcG9ydH5Kc29ucFRyYW5zcG9ydFxuICogQHByb3RlY3RlZFxuICogQGV4dGVuZHMgVHJhbnNwb3J0XG4gKiBAcGFyYW0ge1N0cmluZ30ganNvbnBQYXJhbSAtIENhbGxiYWNrIHBhcmFtZXRlciBuYW1lIGZvciBKU09OUCBpbnZva2F0aW9uLlxuICovXG52YXIgSnNvbnBUcmFuc3BvcnQgPSBUcmFuc3BvcnQuSnNvbnBUcmFuc3BvcnQgPSBmdW5jdGlvbihqc29ucFBhcmFtKSB7XG4gIHRoaXMuX2pzb25wUGFyYW0gPSBqc29ucFBhcmFtO1xufTtcblxuaW5oZXJpdHMoSnNvbnBUcmFuc3BvcnQsIFRyYW5zcG9ydCk7XG5cbi8qKiBAcHJvdGVjdGVkICoqL1xuSnNvbnBUcmFuc3BvcnQucHJvdG90eXBlLl9nZXRIdHRwUmVxdWVzdE1vZHVsZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ganNvbnAuY3JlYXRlUmVxdWVzdCh0aGlzLl9qc29ucFBhcmFtKTtcbn07XG5cbkpzb25wVHJhbnNwb3J0LnN1cHBvcnRlZCA9IGpzb25wLnN1cHBvcnRlZDtcblxuXG4vKipcbiAqIENsYXNzIGZvciBTZmRjIENhbnZhcyByZXF1ZXN0IHRyYW5zcG9ydFxuICogQGNsYXNzIFRyYW5zcG9ydH5DYW52YXNUcmFuc3BvcnRcbiAqIEBwcm90ZWN0ZWRcbiAqIEBleHRlbmRzIFRyYW5zcG9ydFxuICogQHBhcmFtIHtPYmplY3R9IHNpZ25lZFJlcXVlc3QgLSBQYXJzZWQgc2lnbmVkIHJlcXVlc3Qgb2JqZWN0XG4gKi9cbnZhciBDYW52YXNUcmFuc3BvcnQgPSBUcmFuc3BvcnQuQ2FudmFzVHJhbnNwb3J0ID0gZnVuY3Rpb24oc2lnbmVkUmVxdWVzdCkge1xuICB0aGlzLl9zaWduZWRSZXF1ZXN0ID0gc2lnbmVkUmVxdWVzdDtcbn07XG5cbmluaGVyaXRzKENhbnZhc1RyYW5zcG9ydCwgVHJhbnNwb3J0KTtcblxuLyoqIEBwcm90ZWN0ZWQgKiovXG5DYW52YXNUcmFuc3BvcnQucHJvdG90eXBlLl9nZXRIdHRwUmVxdWVzdE1vZHVsZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY2FudmFzLmNyZWF0ZVJlcXVlc3QodGhpcy5fc2lnbmVkUmVxdWVzdCk7XG59O1xuXG5DYW52YXNUcmFuc3BvcnQuc3VwcG9ydGVkID0gY2FudmFzLnN1cHBvcnRlZDtcblxuXG4vKipcbiAqIENsYXNzIGZvciBIVFRQIHJlcXVlc3QgdHJhbnNwb3J0IHVzaW5nIEFKQVggcHJveHkgc2VydmljZVxuICpcbiAqIEBjbGFzcyBUcmFuc3BvcnR+UHJveHlUcmFuc3BvcnRcbiAqIEBwcm90ZWN0ZWRcbiAqIEBleHRlbmRzIFRyYW5zcG9ydFxuICogQHBhcmFtIHtTdHJpbmd9IHByb3h5VXJsIC0gQUpBWCBQcm94eSBzZXJ2ZXIgVVJMXG4gKi9cbnZhciBQcm94eVRyYW5zcG9ydCA9IFRyYW5zcG9ydC5Qcm94eVRyYW5zcG9ydCA9IGZ1bmN0aW9uKHByb3h5VXJsKSB7XG4gIHRoaXMuX3Byb3h5VXJsID0gcHJveHlVcmw7XG59O1xuXG5pbmhlcml0cyhQcm94eVRyYW5zcG9ydCwgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBNYWtlIEhUVFAgcmVxdWVzdCB2aWEgQUpBWCBwcm94eVxuICpcbiAqIEBtZXRob2QgVHJhbnNwb3J0flByb3h5VHJhbnNwb3J0I2h0dHBSZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gSFRUUCByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxPYmplY3Q+fSBbY2FsbGJhY2tdIC0gQ2FsYmFjayBGdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59XG4gKi9cblByb3h5VHJhbnNwb3J0LnByb3RvdHlwZS5odHRwUmVxdWVzdCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IHBhcmFtcy51cmw7XG4gIGlmICh1cmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcbiAgICB1cmwgPSBiYXNlVXJsICsgdXJsO1xuICB9XG4gIHZhciBwcm94eVBhcmFtcyA9IHtcbiAgICBtZXRob2Q6IHBhcmFtcy5tZXRob2QsXG4gICAgdXJsOiB0aGlzLl9wcm94eVVybCArICc/JyArIERhdGUubm93KCkgKyBcIi5cIiArIChcIlwiICsgTWF0aC5yYW5kb20oKSkuc3Vic3RyaW5nKDIpLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdzYWxlc2ZvcmNlcHJveHktZW5kcG9pbnQnOiB1cmxcbiAgICB9XG4gIH07XG4gIGlmIChwYXJhbXMuYm9keSB8fCBwYXJhbXMuYm9keSA9PT0gXCJcIikge1xuICAgIHByb3h5UGFyYW1zLmJvZHkgPSBwYXJhbXMuYm9keTtcbiAgfVxuICBpZiAocGFyYW1zLmhlYWRlcnMpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHBhcmFtcy5oZWFkZXJzKSB7XG4gICAgICBwcm94eVBhcmFtcy5oZWFkZXJzW25hbWVdID0gcGFyYW1zLmhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9XG4gIHJldHVybiBQcm94eVRyYW5zcG9ydC5zdXBlcl8ucHJvdG90eXBlLmh0dHBSZXF1ZXN0LmNhbGwodGhpcywgcHJveHlQYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cblxuLyoqXG4gKiBDbGFzcyBmb3IgSFRUUCByZXF1ZXN0IHRyYW5zcG9ydCB1c2luZyBhIHByb3h5IHNlcnZlclxuICpcbiAqIEBjbGFzcyBUcmFuc3BvcnR+SHR0cFByb3h5VHJhbnNwb3J0XG4gKiBAcHJvdGVjdGVkXG4gKiBAZXh0ZW5kcyBUcmFuc3BvcnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBodHRwUHJveHkgLSBVUkwgb2YgdGhlIEhUVFAgcHJveHkgc2VydmVyXG4gKi9cbnZhciBIdHRwUHJveHlUcmFuc3BvcnQgPSBUcmFuc3BvcnQuSHR0cFByb3h5VHJhbnNwb3J0ID0gZnVuY3Rpb24oaHR0cFByb3h5KSB7XG4gIHRoaXMuX2h0dHBQcm94eSA9IGh0dHBQcm94eTtcbn07XG5cbmluaGVyaXRzKEh0dHBQcm94eVRyYW5zcG9ydCwgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBNYWtlIEhUVFAgcmVxdWVzdCB2aWEgcHJveHkgc2VydmVyXG4gKlxuICogQG1ldGhvZCBUcmFuc3BvcnR+SHR0cFByb3h5VHJhbnNwb3J0I2h0dHBSZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gSFRUUCByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxPYmplY3Q+fSBbY2FsbGJhY2tdIC0gQ2FsbGJhY2sgRnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxPYmplY3Q+fVxuICovXG5IdHRwUHJveHlUcmFuc3BvcnQucHJvdG90eXBlLmh0dHBSZXF1ZXN0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICB2YXIgdXJsID0gcGFyYW1zLnVybDtcbiAgaWYgKHVybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuICAgIHVybCA9IGJhc2VVcmwgKyB1cmw7XG4gIH1cbiAgdmFyIHByb3h5UGFyYW1zID0ge1xuICAgIG1ldGhvZDogcGFyYW1zLm1ldGhvZCxcbiAgICB1cmw6IHBhcmFtcy51cmwsXG4gICAgcHJveHk6IHRoaXMuX2h0dHBQcm94eSxcbiAgICBoZWFkZXJzOiB7fVxuICB9O1xuICBpZiAocGFyYW1zLmJvZHkgfHwgcGFyYW1zLmJvZHkgPT09IFwiXCIpIHtcbiAgICBwcm94eVBhcmFtcy5ib2R5ID0gcGFyYW1zLmJvZHk7XG4gIH1cbiAgaWYgKHBhcmFtcy5oZWFkZXJzKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBwYXJhbXMuaGVhZGVycykge1xuICAgICAgcHJveHlQYXJhbXMuaGVhZGVyc1tuYW1lXSA9IHBhcmFtcy5oZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gSHR0cFByb3h5VHJhbnNwb3J0LnN1cGVyXy5wcm90b3R5cGUuaHR0cFJlcXVlc3QuY2FsbCh0aGlzLCBwcm94eVBhcmFtcywgY2FsbGJhY2spO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/lib/transport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/lib/transport.js":
/*!***********************************************!*\
  !*** ./node_modules/jsforce/lib/transport.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*global process, Sfdc */\n\n\n\nvar inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\"),\n    Promise = __webpack_require__(/*! ./promise */ \"(rsc)/./node_modules/jsforce/lib/promise.js\");\n\n/* */\n\nvar request = __webpack_require__(/*! request */ \"(rsc)/./node_modules/request/index.js\"),\n    canvas = __webpack_require__(/*! ./browser/canvas */ \"(rsc)/./node_modules/jsforce/lib/browser/canvas.js\"),\n    jsonp = __webpack_require__(/*! ./browser/jsonp */ \"(rsc)/./node_modules/jsforce/lib/browser/jsonp.js\");\n\n// set options if defaults setting is available in request, which is not available in xhr module.\nif (request.defaults) {\n  var defaults = {\n    followAllRedirects: true\n  };\n  if (process.env.HTTP_PROXY) {\n    defaults.proxy = process.env.HTTP_PROXY;\n  }\n  if (parseInt(process.env.HTTP_TIMEOUT)) {\n    defaults.timeout = parseInt(process.env.HTTP_TIMEOUT);\n  }\n  request = request.defaults(defaults);\n}\n\nvar baseUrl;\nif (typeof window === 'undefined') {\n  baseUrl = process.env.LOCATION_BASE_URL || \"\";\n} else {\n  var apiHost = normalizeApiHost(window.location.host);\n  baseUrl = apiHost ? \"https://\" + apiHost : \"\";\n}\n\n/**\n * Add stream() method to promise (and following promise chain), to access original request stream.\n * @private\n */\nfunction streamify(promise, factory) {\n  var _then = promise.then;\n  promise.then = function() {\n    factory();\n    var newPromise = _then.apply(promise, arguments);\n    return streamify(newPromise, factory);\n  };\n  promise.stream = factory;\n  return promise;\n}\n\n/**\n * Normarize Salesforce API host name\n * @private\n */\nfunction normalizeApiHost(apiHost) {\n  var m = /(\\w+)\\.(visual\\.force|salesforce)\\.com$/.exec(apiHost);\n  if (m) {\n    apiHost = m[1] + \".salesforce.com\";\n  }\n  return apiHost;\n}\n\n/**\n * Class for HTTP request transport\n *\n * @class\n * @protected\n */\nvar Transport = module.exports = function() {};\n\n/**\n * Make HTTP request, returns promise instead of stream\n *\n * @param {Object} params - HTTP request\n * @param {Callback.<Object>} [callback] - Calback Function\n * @returns {Promise.<Object>}\n */\nTransport.prototype.httpRequest = function(params, callback) {\n  var deferred = Promise.defer();\n  var req;\n  var httpRequest = this._getHttpRequestModule();\n  var createRequest = function() {\n    if (!req) {\n      req = httpRequest(params, function(err, response) {\n        if (err) {\n          deferred.reject(err);\n        } else {\n          deferred.resolve(response);\n        }\n      });\n    }\n    return req;\n  };\n  return streamify(deferred.promise, createRequest).thenCall(callback);\n};\n\n/** @protected **/\nTransport.prototype._getHttpRequestModule = function() {\n  return request;\n};\n\n\n/**\n * Class for JSONP request transport\n * @class Transport~JsonpTransport\n * @protected\n * @extends Transport\n * @param {String} jsonpParam - Callback parameter name for JSONP invokation.\n */\nvar JsonpTransport = Transport.JsonpTransport = function(jsonpParam) {\n  this._jsonpParam = jsonpParam;\n};\n\ninherits(JsonpTransport, Transport);\n\n/** @protected **/\nJsonpTransport.prototype._getHttpRequestModule = function() {\n  return jsonp.createRequest(this._jsonpParam);\n};\n\nJsonpTransport.supported = jsonp.supported;\n\n\n/**\n * Class for Sfdc Canvas request transport\n * @class Transport~CanvasTransport\n * @protected\n * @extends Transport\n * @param {Object} signedRequest - Parsed signed request object\n */\nvar CanvasTransport = Transport.CanvasTransport = function(signedRequest) {\n  this._signedRequest = signedRequest;\n};\n\ninherits(CanvasTransport, Transport);\n\n/** @protected **/\nCanvasTransport.prototype._getHttpRequestModule = function() {\n  return canvas.createRequest(this._signedRequest);\n};\n\nCanvasTransport.supported = canvas.supported;\n\n\n/**\n * Class for HTTP request transport using AJAX proxy service\n *\n * @class Transport~ProxyTransport\n * @protected\n * @extends Transport\n * @param {String} proxyUrl - AJAX Proxy server URL\n */\nvar ProxyTransport = Transport.ProxyTransport = function(proxyUrl) {\n  this._proxyUrl = proxyUrl;\n};\n\ninherits(ProxyTransport, Transport);\n\n/**\n * Make HTTP request via AJAX proxy\n *\n * @method Transport~ProxyTransport#httpRequest\n * @param {Object} params - HTTP request\n * @param {Callback.<Object>} [callback] - Calback Function\n * @returns {Promise.<Object>}\n */\nProxyTransport.prototype.httpRequest = function(params, callback) {\n  var url = params.url;\n  if (url.indexOf(\"/\") === 0) {\n    url = baseUrl + url;\n  }\n  var proxyParams = {\n    method: params.method,\n    url: this._proxyUrl + '?' + Date.now() + \".\" + (\"\" + Math.random()).substring(2),\n    headers: {\n      'salesforceproxy-endpoint': url\n    }\n  };\n  if (params.body || params.body === \"\") {\n    proxyParams.body = params.body;\n  }\n  if (params.headers) {\n    for (var name in params.headers) {\n      proxyParams.headers[name] = params.headers[name];\n    }\n  }\n  return ProxyTransport.super_.prototype.httpRequest.call(this, proxyParams, callback);\n};\n\n\n/**\n * Class for HTTP request transport using a proxy server\n *\n * @class Transport~HttpProxyTransport\n * @protected\n * @extends Transport\n * @param {String} httpProxy - URL of the HTTP proxy server\n */\nvar HttpProxyTransport = Transport.HttpProxyTransport = function(httpProxy) {\n  this._httpProxy = httpProxy;\n};\n\ninherits(HttpProxyTransport, Transport);\n\n/**\n * Make HTTP request via proxy server\n *\n * @method Transport~HttpProxyTransport#httpRequest\n * @param {Object} params - HTTP request\n * @param {Callback.<Object>} [callback] - Callback Function\n * @returns {Promise.<Object>}\n */\nHttpProxyTransport.prototype.httpRequest = function(params, callback) {\n  var url = params.url;\n  if (url.indexOf(\"/\") === 0) {\n    url = baseUrl + url;\n  }\n  var proxyParams = {\n    method: params.method,\n    url: params.url,\n    proxy: this._httpProxy,\n    headers: {}\n  };\n  if (params.body || params.body === \"\") {\n    proxyParams.body = params.body;\n  }\n  if (params.headers) {\n    for (var name in params.headers) {\n      proxyParams.headers[name] = params.headers[name];\n    }\n  }\n  return HttpProxyTransport.super_.prototype.httpRequest.call(this, proxyParams, callback);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9saWIvdHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVhOztBQUViLGVBQWUsbUJBQU8sQ0FBQywyREFBVTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsOERBQVc7O0FBRWpDOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyxzREFBUztBQUMvQixhQUFhLG1CQUFPLENBQUMsNEVBQWtCO0FBQ3ZDLFlBQVksbUJBQU8sQ0FBQywwRUFBaUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2UvbGliL3RyYW5zcG9ydC5qcz9mZjcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIHByb2Nlc3MsIFNmZGMgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL3Byb21pc2UnKTtcblxuLyogKi9cblxudmFyIHJlcXVlc3QgPSByZXF1aXJlKCdyZXF1ZXN0JyksXG4gICAgY2FudmFzID0gcmVxdWlyZSgnLi9icm93c2VyL2NhbnZhcycpLFxuICAgIGpzb25wID0gcmVxdWlyZSgnLi9icm93c2VyL2pzb25wJyk7XG5cbi8vIHNldCBvcHRpb25zIGlmIGRlZmF1bHRzIHNldHRpbmcgaXMgYXZhaWxhYmxlIGluIHJlcXVlc3QsIHdoaWNoIGlzIG5vdCBhdmFpbGFibGUgaW4geGhyIG1vZHVsZS5cbmlmIChyZXF1ZXN0LmRlZmF1bHRzKSB7XG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWVcbiAgfTtcbiAgaWYgKHByb2Nlc3MuZW52LkhUVFBfUFJPWFkpIHtcbiAgICBkZWZhdWx0cy5wcm94eSA9IHByb2Nlc3MuZW52LkhUVFBfUFJPWFk7XG4gIH1cbiAgaWYgKHBhcnNlSW50KHByb2Nlc3MuZW52LkhUVFBfVElNRU9VVCkpIHtcbiAgICBkZWZhdWx0cy50aW1lb3V0ID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuSFRUUF9USU1FT1VUKTtcbiAgfVxuICByZXF1ZXN0ID0gcmVxdWVzdC5kZWZhdWx0cyhkZWZhdWx0cyk7XG59XG5cbnZhciBiYXNlVXJsO1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIGJhc2VVcmwgPSBwcm9jZXNzLmVudi5MT0NBVElPTl9CQVNFX1VSTCB8fCBcIlwiO1xufSBlbHNlIHtcbiAgdmFyIGFwaUhvc3QgPSBub3JtYWxpemVBcGlIb3N0KHdpbmRvdy5sb2NhdGlvbi5ob3N0KTtcbiAgYmFzZVVybCA9IGFwaUhvc3QgPyBcImh0dHBzOi8vXCIgKyBhcGlIb3N0IDogXCJcIjtcbn1cblxuLyoqXG4gKiBBZGQgc3RyZWFtKCkgbWV0aG9kIHRvIHByb21pc2UgKGFuZCBmb2xsb3dpbmcgcHJvbWlzZSBjaGFpbiksIHRvIGFjY2VzcyBvcmlnaW5hbCByZXF1ZXN0IHN0cmVhbS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHN0cmVhbWlmeShwcm9taXNlLCBmYWN0b3J5KSB7XG4gIHZhciBfdGhlbiA9IHByb21pc2UudGhlbjtcbiAgcHJvbWlzZS50aGVuID0gZnVuY3Rpb24oKSB7XG4gICAgZmFjdG9yeSgpO1xuICAgIHZhciBuZXdQcm9taXNlID0gX3RoZW4uYXBwbHkocHJvbWlzZSwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gc3RyZWFtaWZ5KG5ld1Byb21pc2UsIGZhY3RvcnkpO1xuICB9O1xuICBwcm9taXNlLnN0cmVhbSA9IGZhY3Rvcnk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG4vKipcbiAqIE5vcm1hcml6ZSBTYWxlc2ZvcmNlIEFQSSBob3N0IG5hbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFwaUhvc3QoYXBpSG9zdCkge1xuICB2YXIgbSA9IC8oXFx3KylcXC4odmlzdWFsXFwuZm9yY2V8c2FsZXNmb3JjZSlcXC5jb20kLy5leGVjKGFwaUhvc3QpO1xuICBpZiAobSkge1xuICAgIGFwaUhvc3QgPSBtWzFdICsgXCIuc2FsZXNmb3JjZS5jb21cIjtcbiAgfVxuICByZXR1cm4gYXBpSG9zdDtcbn1cblxuLyoqXG4gKiBDbGFzcyBmb3IgSFRUUCByZXF1ZXN0IHRyYW5zcG9ydFxuICpcbiAqIEBjbGFzc1xuICogQHByb3RlY3RlZFxuICovXG52YXIgVHJhbnNwb3J0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIE1ha2UgSFRUUCByZXF1ZXN0LCByZXR1cm5zIHByb21pc2UgaW5zdGVhZCBvZiBzdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gSFRUUCByZXF1ZXN0XG4gKiBAcGFyYW0ge0NhbGxiYWNrLjxPYmplY3Q+fSBbY2FsbGJhY2tdIC0gQ2FsYmFjayBGdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59XG4gKi9cblRyYW5zcG9ydC5wcm90b3R5cGUuaHR0cFJlcXVlc3QgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHZhciBkZWZlcnJlZCA9IFByb21pc2UuZGVmZXIoKTtcbiAgdmFyIHJlcTtcbiAgdmFyIGh0dHBSZXF1ZXN0ID0gdGhpcy5fZ2V0SHR0cFJlcXVlc3RNb2R1bGUoKTtcbiAgdmFyIGNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXJlcSkge1xuICAgICAgcmVxID0gaHR0cFJlcXVlc3QocGFyYW1zLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXE7XG4gIH07XG4gIHJldHVybiBzdHJlYW1pZnkoZGVmZXJyZWQucHJvbWlzZSwgY3JlYXRlUmVxdWVzdCkudGhlbkNhbGwoY2FsbGJhY2spO1xufTtcblxuLyoqIEBwcm90ZWN0ZWQgKiovXG5UcmFuc3BvcnQucHJvdG90eXBlLl9nZXRIdHRwUmVxdWVzdE1vZHVsZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcmVxdWVzdDtcbn07XG5cblxuLyoqXG4gKiBDbGFzcyBmb3IgSlNPTlAgcmVxdWVzdCB0cmFuc3BvcnRcbiAqIEBjbGFzcyBUcmFuc3BvcnR+SnNvbnBUcmFuc3BvcnRcbiAqIEBwcm90ZWN0ZWRcbiAqIEBleHRlbmRzIFRyYW5zcG9ydFxuICogQHBhcmFtIHtTdHJpbmd9IGpzb25wUGFyYW0gLSBDYWxsYmFjayBwYXJhbWV0ZXIgbmFtZSBmb3IgSlNPTlAgaW52b2thdGlvbi5cbiAqL1xudmFyIEpzb25wVHJhbnNwb3J0ID0gVHJhbnNwb3J0Lkpzb25wVHJhbnNwb3J0ID0gZnVuY3Rpb24oanNvbnBQYXJhbSkge1xuICB0aGlzLl9qc29ucFBhcmFtID0ganNvbnBQYXJhbTtcbn07XG5cbmluaGVyaXRzKEpzb25wVHJhbnNwb3J0LCBUcmFuc3BvcnQpO1xuXG4vKiogQHByb3RlY3RlZCAqKi9cbkpzb25wVHJhbnNwb3J0LnByb3RvdHlwZS5fZ2V0SHR0cFJlcXVlc3RNb2R1bGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGpzb25wLmNyZWF0ZVJlcXVlc3QodGhpcy5fanNvbnBQYXJhbSk7XG59O1xuXG5Kc29ucFRyYW5zcG9ydC5zdXBwb3J0ZWQgPSBqc29ucC5zdXBwb3J0ZWQ7XG5cblxuLyoqXG4gKiBDbGFzcyBmb3IgU2ZkYyBDYW52YXMgcmVxdWVzdCB0cmFuc3BvcnRcbiAqIEBjbGFzcyBUcmFuc3BvcnR+Q2FudmFzVHJhbnNwb3J0XG4gKiBAcHJvdGVjdGVkXG4gKiBAZXh0ZW5kcyBUcmFuc3BvcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzaWduZWRSZXF1ZXN0IC0gUGFyc2VkIHNpZ25lZCByZXF1ZXN0IG9iamVjdFxuICovXG52YXIgQ2FudmFzVHJhbnNwb3J0ID0gVHJhbnNwb3J0LkNhbnZhc1RyYW5zcG9ydCA9IGZ1bmN0aW9uKHNpZ25lZFJlcXVlc3QpIHtcbiAgdGhpcy5fc2lnbmVkUmVxdWVzdCA9IHNpZ25lZFJlcXVlc3Q7XG59O1xuXG5pbmhlcml0cyhDYW52YXNUcmFuc3BvcnQsIFRyYW5zcG9ydCk7XG5cbi8qKiBAcHJvdGVjdGVkICoqL1xuQ2FudmFzVHJhbnNwb3J0LnByb3RvdHlwZS5fZ2V0SHR0cFJlcXVlc3RNb2R1bGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGNhbnZhcy5jcmVhdGVSZXF1ZXN0KHRoaXMuX3NpZ25lZFJlcXVlc3QpO1xufTtcblxuQ2FudmFzVHJhbnNwb3J0LnN1cHBvcnRlZCA9IGNhbnZhcy5zdXBwb3J0ZWQ7XG5cblxuLyoqXG4gKiBDbGFzcyBmb3IgSFRUUCByZXF1ZXN0IHRyYW5zcG9ydCB1c2luZyBBSkFYIHByb3h5IHNlcnZpY2VcbiAqXG4gKiBAY2xhc3MgVHJhbnNwb3J0flByb3h5VHJhbnNwb3J0XG4gKiBAcHJvdGVjdGVkXG4gKiBAZXh0ZW5kcyBUcmFuc3BvcnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm94eVVybCAtIEFKQVggUHJveHkgc2VydmVyIFVSTFxuICovXG52YXIgUHJveHlUcmFuc3BvcnQgPSBUcmFuc3BvcnQuUHJveHlUcmFuc3BvcnQgPSBmdW5jdGlvbihwcm94eVVybCkge1xuICB0aGlzLl9wcm94eVVybCA9IHByb3h5VXJsO1xufTtcblxuaW5oZXJpdHMoUHJveHlUcmFuc3BvcnQsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogTWFrZSBIVFRQIHJlcXVlc3QgdmlhIEFKQVggcHJveHlcbiAqXG4gKiBAbWV0aG9kIFRyYW5zcG9ydH5Qcm94eVRyYW5zcG9ydCNodHRwUmVxdWVzdFxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIEhUVFAgcmVxdWVzdFxuICogQHBhcmFtIHtDYWxsYmFjay48T2JqZWN0Pn0gW2NhbGxiYWNrXSAtIENhbGJhY2sgRnVuY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxPYmplY3Q+fVxuICovXG5Qcm94eVRyYW5zcG9ydC5wcm90b3R5cGUuaHR0cFJlcXVlc3QgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHZhciB1cmwgPSBwYXJhbXMudXJsO1xuICBpZiAodXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG4gICAgdXJsID0gYmFzZVVybCArIHVybDtcbiAgfVxuICB2YXIgcHJveHlQYXJhbXMgPSB7XG4gICAgbWV0aG9kOiBwYXJhbXMubWV0aG9kLFxuICAgIHVybDogdGhpcy5fcHJveHlVcmwgKyAnPycgKyBEYXRlLm5vdygpICsgXCIuXCIgKyAoXCJcIiArIE1hdGgucmFuZG9tKCkpLnN1YnN0cmluZygyKSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnc2FsZXNmb3JjZXByb3h5LWVuZHBvaW50JzogdXJsXG4gICAgfVxuICB9O1xuICBpZiAocGFyYW1zLmJvZHkgfHwgcGFyYW1zLmJvZHkgPT09IFwiXCIpIHtcbiAgICBwcm94eVBhcmFtcy5ib2R5ID0gcGFyYW1zLmJvZHk7XG4gIH1cbiAgaWYgKHBhcmFtcy5oZWFkZXJzKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBwYXJhbXMuaGVhZGVycykge1xuICAgICAgcHJveHlQYXJhbXMuaGVhZGVyc1tuYW1lXSA9IHBhcmFtcy5oZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gUHJveHlUcmFuc3BvcnQuc3VwZXJfLnByb3RvdHlwZS5odHRwUmVxdWVzdC5jYWxsKHRoaXMsIHByb3h5UGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG5cbi8qKlxuICogQ2xhc3MgZm9yIEhUVFAgcmVxdWVzdCB0cmFuc3BvcnQgdXNpbmcgYSBwcm94eSBzZXJ2ZXJcbiAqXG4gKiBAY2xhc3MgVHJhbnNwb3J0fkh0dHBQcm94eVRyYW5zcG9ydFxuICogQHByb3RlY3RlZFxuICogQGV4dGVuZHMgVHJhbnNwb3J0XG4gKiBAcGFyYW0ge1N0cmluZ30gaHR0cFByb3h5IC0gVVJMIG9mIHRoZSBIVFRQIHByb3h5IHNlcnZlclxuICovXG52YXIgSHR0cFByb3h5VHJhbnNwb3J0ID0gVHJhbnNwb3J0Lkh0dHBQcm94eVRyYW5zcG9ydCA9IGZ1bmN0aW9uKGh0dHBQcm94eSkge1xuICB0aGlzLl9odHRwUHJveHkgPSBodHRwUHJveHk7XG59O1xuXG5pbmhlcml0cyhIdHRwUHJveHlUcmFuc3BvcnQsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogTWFrZSBIVFRQIHJlcXVlc3QgdmlhIHByb3h5IHNlcnZlclxuICpcbiAqIEBtZXRob2QgVHJhbnNwb3J0fkh0dHBQcm94eVRyYW5zcG9ydCNodHRwUmVxdWVzdFxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIEhUVFAgcmVxdWVzdFxuICogQHBhcmFtIHtDYWxsYmFjay48T2JqZWN0Pn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIEZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48T2JqZWN0Pn1cbiAqL1xuSHR0cFByb3h5VHJhbnNwb3J0LnByb3RvdHlwZS5odHRwUmVxdWVzdCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgdmFyIHVybCA9IHBhcmFtcy51cmw7XG4gIGlmICh1cmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcbiAgICB1cmwgPSBiYXNlVXJsICsgdXJsO1xuICB9XG4gIHZhciBwcm94eVBhcmFtcyA9IHtcbiAgICBtZXRob2Q6IHBhcmFtcy5tZXRob2QsXG4gICAgdXJsOiBwYXJhbXMudXJsLFxuICAgIHByb3h5OiB0aGlzLl9odHRwUHJveHksXG4gICAgaGVhZGVyczoge31cbiAgfTtcbiAgaWYgKHBhcmFtcy5ib2R5IHx8IHBhcmFtcy5ib2R5ID09PSBcIlwiKSB7XG4gICAgcHJveHlQYXJhbXMuYm9keSA9IHBhcmFtcy5ib2R5O1xuICB9XG4gIGlmIChwYXJhbXMuaGVhZGVycykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gcGFyYW1zLmhlYWRlcnMpIHtcbiAgICAgIHByb3h5UGFyYW1zLmhlYWRlcnNbbmFtZV0gPSBwYXJhbXMuaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEh0dHBQcm94eVRyYW5zcG9ydC5zdXBlcl8ucHJvdG90eXBlLmh0dHBSZXF1ZXN0LmNhbGwodGhpcywgcHJveHlQYXJhbXMsIGNhbGxiYWNrKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/lib/transport.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"(action-browser)/./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"(action-browser)/./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_writable.js\");\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLDJGQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw4RUFBYztBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBVTtBQUNsQzs7QUFFQSxlQUFlLG1CQUFPLENBQUMsd0hBQW9CO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyx3SEFBb0I7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzPzM2MTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"(rsc)/./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"(rsc)/./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_writable.js\");\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBLFVBQVUsbUJBQU8sQ0FBQyxnRkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsbUVBQWM7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVU7QUFDbEM7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLDZHQUFvQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsNkdBQW9COztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcz80MDc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_transform.js\");\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"(action-browser)/./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsMEhBQXFCOztBQUU3QztBQUNBLHlCQUF5QixtQkFBTyxDQUFDLDhFQUFjO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFVO0FBQ2xDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2Uvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcz8zYjY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_passthrough.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_transform.js\");\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"(rsc)/./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLCtHQUFxQjs7QUFFN0M7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyxtRUFBYztBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQywyREFBVTtBQUNsQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanM/YzM2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_passthrough.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_readable.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/_stream_readable.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"(action-browser)/./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = __webpack_require__(/*! isarray */ \"(action-browser)/./node_modules/isarray/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/stream.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(action-browser)/./node_modules/jsforce/node_modules/safe-buffer/index.js\").Buffer);\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"(action-browser)/./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = __webpack_require__(/*! util */ \"util\");\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/BufferList.js\");\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"(action-browser)/./node_modules/jsforce/node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"(action-browser)/./node_modules/jsforce/node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, { hasUnpiped: false });\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxVQUFVLG1CQUFPLENBQUMsMkZBQXNCO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGlFQUFTO0FBQy9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVMsMERBQThCOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxzSUFBMkI7QUFDaEQ7O0FBRUE7O0FBRUEsYUFBYSw0SEFBNkI7QUFDMUMsOElBQThJO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLDhFQUFjO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFVO0FBQ2xDOztBQUVBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsa0JBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyw4SUFBK0I7QUFDeEQsa0JBQWtCLG1CQUFPLENBQUMsd0lBQTRCO0FBQ3REOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDZFQUE2RTtBQUN0Sjs7QUFFQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLG9IQUFrQjs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCwwRkFBMEY7O0FBRTNJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUpBQXdDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsb0hBQWtCOztBQUUvQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0dBQWtHO0FBQ2xHLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUYsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyx1SkFBd0M7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCLHNDQUFzQyxtQkFBbUI7QUFDekQsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBNEU7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsbURBQW1ELGlFQUFpRTtBQUNwSDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2Uvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcz80ZTMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgeyBoYXNVbnBpcGVkOiBmYWxzZSB9KTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_readable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_readable.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/_stream_readable.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"(rsc)/./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = __webpack_require__(/*! isarray */ \"(rsc)/./node_modules/isarray/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/stream.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/jsforce/node_modules/safe-buffer/index.js\").Buffer);\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"(rsc)/./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = __webpack_require__(/*! util */ \"util\");\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/BufferList.js\");\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"(rsc)/./node_modules/jsforce/node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"(rsc)/./node_modules/jsforce/node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, { hasUnpiped: false });\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLGdGQUFzQjtBQUN4Qzs7QUFFQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxzREFBUztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTLDBEQUE4Qjs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG1CQUFPLENBQUMsMkhBQTJCO0FBQ2hEOztBQUVBOztBQUVBLGFBQWEsaUhBQTZCO0FBQzFDLDhJQUE4STtBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyxtRUFBYztBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQywyREFBVTtBQUNsQzs7QUFFQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGtCQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsbUlBQStCO0FBQ3hELGtCQUFrQixtQkFBTyxDQUFDLDZIQUE0QjtBQUN0RDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw2RUFBNkU7QUFDdEo7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyx5R0FBa0I7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsMEZBQTBGOztBQUUzSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDRJQUF3QztBQUNoRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHlHQUFrQjs7QUFFL0M7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtHQUFrRztBQUNsRyxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsNElBQXdDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QixzQ0FBc0MsbUJBQW1CO0FBQ3pELEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLG1EQUFtRCxpRUFBaUU7QUFDcEg7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanM/NWYzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9ICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9KS5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHsgaGFzVW5waXBlZDogZmFsc2UgfSk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_readable.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_transform.js":
/*!************************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/_stream_transform.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"(action-browser)/./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLG9IQUFrQjs7QUFFdkM7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw4RUFBYztBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBVTtBQUNsQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzPzg1ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_transform.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_transform.js":
/*!************************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/_stream_transform.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"(rsc)/./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx5R0FBa0I7O0FBRXZDO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsbUVBQWM7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVU7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcz9lZjkwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_transform.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_writable.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/_stream_writable.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"(action-browser)/./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite =  true && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"(action-browser)/./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"(action-browser)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"(action-browser)/./node_modules/util-deprecate/node.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/stream.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(action-browser)/./node_modules/jsforce/node_modules/safe-buffer/index.js\").Buffer);\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLDJGQUFzQjtBQUN4Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixLQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw4RUFBYztBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBVTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDhFQUFnQjtBQUNyQztBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHNJQUEyQjtBQUNoRDs7QUFFQTs7QUFFQSxhQUFhLDRIQUE2QjtBQUMxQyw4SUFBOEk7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHdJQUE0Qjs7QUFFdEQ7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxvSEFBa0I7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCwwRkFBMEY7O0FBRTNJO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsSUFBSTtBQUNKLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsb0hBQWtCOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQzs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzPzBiMGIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG5cbiAgLy8gcmV1c2UgdGhlIGZyZWUgY29ya1JlcS5cbiAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMuZW5kKCk7XG4gIGNiKGVycik7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_writable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_writable.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/_stream_writable.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"(rsc)/./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite =  true && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"(rsc)/./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"(rsc)/./node_modules/util-deprecate/node.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/stream.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/jsforce/node_modules/safe-buffer/index.js\").Buffer);\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBLFVBQVUsbUJBQU8sQ0FBQyxnRkFBc0I7QUFDeEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsS0FBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsbUVBQWM7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVU7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxtRUFBZ0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQywySEFBMkI7QUFDaEQ7O0FBRUE7O0FBRUEsYUFBYSxpSEFBNkI7QUFDMUMsOElBQThJO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyw2SEFBNEI7O0FBRXREOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMseUdBQWtCOztBQUUvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsMEZBQTBGOztBQUUzSTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHlHQUFrQjs7QUFFL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2Uvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcz9lNGY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9ICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9KS5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZykgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuXG4gIC8vIHJldXNlIHRoZSBmcmVlIGNvcmtSZXEuXG4gIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_writable.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(action-browser)/./node_modules/jsforce/node_modules/safe-buffer/index.js\").Buffer);\nvar util = __webpack_require__(/*! util */ \"util\");\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrREFBa0QsMENBQTBDOztBQUU1RixhQUFhLDRIQUE2QjtBQUMxQyxXQUFXLG1CQUFPLENBQUMsa0JBQU07O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEIsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanM/YTgyMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/BufferList.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/jsforce/node_modules/safe-buffer/index.js\").Buffer);\nvar util = __webpack_require__(/*! util */ \"util\");\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0RBQWtELDBDQUEwQzs7QUFFNUYsYUFBYSxpSEFBNkI7QUFDMUMsV0FBVyxtQkFBTyxDQUFDLGtCQUFNOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2Uvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzPzE1YmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/BufferList.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"(action-browser)/./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        pna.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        pna.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        pna.nextTick(emitErrorNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        pna.nextTick(emitErrorNT, _this, err);\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQSxVQUFVLG1CQUFPLENBQUMsMkZBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcz85MGRmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/destroy.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"(rsc)/./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        pna.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        pna.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        pna.nextTick(emitErrorNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        pna.nextTick(emitErrorNT, _this, err);\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLGdGQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanM/NzJiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/destroy.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/stream.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/stream.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! stream */ \"stream\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBLDREQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS5qcz81Mzc5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnc3RyZWFtJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/stream.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/stream.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! stream */ \"stream\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQSw0REFBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2Uvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0uanM/YTQwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/internal/streams/stream.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/node_modules/readable-stream/readable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/readable.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var Stream = __webpack_require__(/*! stream */ \"stream\");\nif (process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream;\n  exports = module.exports = Stream.Readable;\n  exports.Readable = Stream.Readable;\n  exports.Writable = Stream.Writable;\n  exports.Duplex = Stream.Duplex;\n  exports.Transform = Stream.Transform;\n  exports.PassThrough = Stream.PassThrough;\n  exports.Stream = Stream;\n} else {\n  exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_readable.js\");\n  exports.Stream = Stream || exports;\n  exports.Readable = exports;\n  exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_writable.js\");\n  exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js\");\n  exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_transform.js\");\n  exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"(action-browser)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_passthrough.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCO0FBQ2xCLEVBQUUsZ0JBQWdCO0FBQ2xCLEVBQUUsY0FBYztBQUNoQixFQUFFLGlCQUFpQjtBQUNuQixFQUFFLG1CQUFtQjtBQUNyQixFQUFFLGNBQWM7QUFDaEIsRUFBRTtBQUNGLFlBQVkscUtBQXFEO0FBQ2pFLEVBQUUsY0FBYztBQUNoQixFQUFFLGdCQUFnQjtBQUNsQixFQUFFLHVLQUF1RDtBQUN6RCxFQUFFLGlLQUFtRDtBQUNyRCxFQUFFLDBLQUF5RDtBQUMzRCxFQUFFLGdMQUE2RDtBQUMvRCIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzP2MxODIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuaWYgKHByb2Nlc3MuZW52LlJFQURBQkxFX1NUUkVBTSA9PT0gJ2Rpc2FibGUnICYmIFN0cmVhbSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcbiAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU3RyZWFtLlJlYWRhYmxlO1xuICBleHBvcnRzLlJlYWRhYmxlID0gU3RyZWFtLlJlYWRhYmxlO1xuICBleHBvcnRzLldyaXRhYmxlID0gU3RyZWFtLldyaXRhYmxlO1xuICBleHBvcnRzLkR1cGxleCA9IFN0cmVhbS5EdXBsZXg7XG4gIGV4cG9ydHMuVHJhbnNmb3JtID0gU3RyZWFtLlRyYW5zZm9ybTtcbiAgZXhwb3J0cy5QYXNzVGhyb3VnaCA9IFN0cmVhbS5QYXNzVGhyb3VnaDtcbiAgZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW07XG59IGVsc2Uge1xuICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG4gIGV4cG9ydHMuU3RyZWFtID0gU3RyZWFtIHx8IGV4cG9ydHM7XG4gIGV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuICBleHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuICBleHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4gIGV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbiAgZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/node_modules/readable-stream/readable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/node_modules/readable-stream/readable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/readable-stream/readable.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var Stream = __webpack_require__(/*! stream */ \"stream\");\nif (process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream;\n  exports = module.exports = Stream.Readable;\n  exports.Readable = Stream.Readable;\n  exports.Writable = Stream.Writable;\n  exports.Duplex = Stream.Duplex;\n  exports.Transform = Stream.Transform;\n  exports.PassThrough = Stream.PassThrough;\n  exports.Stream = Stream;\n} else {\n  exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_readable.js\");\n  exports.Stream = Stream || exports;\n  exports.Readable = exports;\n  exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_writable.js\");\n  exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_duplex.js\");\n  exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_transform.js\");\n  exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"(rsc)/./node_modules/jsforce/node_modules/readable-stream/lib/_stream_passthrough.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQixFQUFFLGdCQUFnQjtBQUNsQixFQUFFLGNBQWM7QUFDaEIsRUFBRSxpQkFBaUI7QUFDbkIsRUFBRSxtQkFBbUI7QUFDckIsRUFBRSxjQUFjO0FBQ2hCLEVBQUU7QUFDRixZQUFZLDBKQUFxRDtBQUNqRSxFQUFFLGNBQWM7QUFDaEIsRUFBRSxnQkFBZ0I7QUFDbEIsRUFBRSw0SkFBdUQ7QUFDekQsRUFBRSxzSkFBbUQ7QUFDckQsRUFBRSwrSkFBeUQ7QUFDM0QsRUFBRSxxS0FBNkQ7QUFDL0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2Uvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcz8yMmYyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmlmIChwcm9jZXNzLmVudi5SRUFEQUJMRV9TVFJFQU0gPT09ICdkaXNhYmxlJyAmJiBTdHJlYW0pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG4gIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFN0cmVhbS5SZWFkYWJsZTtcbiAgZXhwb3J0cy5SZWFkYWJsZSA9IFN0cmVhbS5SZWFkYWJsZTtcbiAgZXhwb3J0cy5Xcml0YWJsZSA9IFN0cmVhbS5Xcml0YWJsZTtcbiAgZXhwb3J0cy5EdXBsZXggPSBTdHJlYW0uRHVwbGV4O1xuICBleHBvcnRzLlRyYW5zZm9ybSA9IFN0cmVhbS5UcmFuc2Zvcm07XG4gIGV4cG9ydHMuUGFzc1Rocm91Z2ggPSBTdHJlYW0uUGFzc1Rocm91Z2g7XG4gIGV4cG9ydHMuU3RyZWFtID0gU3RyZWFtO1xufSBlbHNlIHtcbiAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuICBleHBvcnRzLlN0cmVhbSA9IFN0cmVhbSB8fCBleHBvcnRzO1xuICBleHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbiAgZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiAgZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuICBleHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG4gIGV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/node_modules/readable-stream/readable.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/node_modules/safe-buffer/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/safe-buffer/index.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFLGNBQWM7QUFDaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcz83YTRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/node_modules/safe-buffer/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/node_modules/safe-buffer/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/safe-buffer/index.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRSxjQUFjO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb21wdG9waWEvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanM/NjEzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/node_modules/safe-buffer/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/jsforce/node_modules/string_decoder/lib/string_decoder.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/string_decoder/lib/string_decoder.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(action-browser)/./node_modules/jsforce/node_modules/safe-buffer/index.js\").Buffer);\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxhQUFhLDRIQUE2QjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0NBQXNDLHNDQUFzQztBQUN6RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL2pzZm9yY2Uvbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcz83MzU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsforce/node_modules/string_decoder/lib/string_decoder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsforce/node_modules/string_decoder/lib/string_decoder.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jsforce/node_modules/string_decoder/lib/string_decoder.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/jsforce/node_modules/safe-buffer/index.js\").Buffer);\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNmb3JjZS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsYUFBYSxpSEFBNkI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNDQUFzQyxzQ0FBc0M7QUFDekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0b3BpYS8uL25vZGVfbW9kdWxlcy9qc2ZvcmNlL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanM/ZDM3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsforce/node_modules/string_decoder/lib/string_decoder.js\n");

/***/ })

};
;