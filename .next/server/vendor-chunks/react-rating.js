"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-rating";
exports.ids = ["vendor-chunks/react-rating"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-rating/lib/react-rating.esm.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-rating/lib/react-rating.esm.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\nvar style = {\n    display: \"inline-block\",\n    borderRadius: \"50%\",\n    border: \"5px double white\",\n    width: 30,\n    height: 30\n};\nvar Style = {\n    empty: _objectSpread({}, style, {\n        backgroundColor: \"#ccc\"\n    }),\n    full: _objectSpread({}, style, {\n        backgroundColor: \"black\"\n    }),\n    placeholder: _objectSpread({}, style, {\n        backgroundColor: \"red\"\n    })\n};\n// Return the corresponding React node for an icon.\nvar _iconNode = function _iconNode(icon) {\n    // If it is already a React Element just return it.\n    if (/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().isValidElement(icon)) {\n        return icon;\n    } // If it is an object, try to use it as a CSS style object.\n    if (_typeof(icon) === \"object\" && icon !== null) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", {\n            style: icon\n        });\n    } // If it is a string, use it as class names.\n    if (Object.prototype.toString.call(icon) === \"[object String]\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", {\n            className: icon\n        });\n    }\n};\nvar RatingSymbol = /*#__PURE__*/ function(_React$PureComponent) {\n    _inherits(RatingSymbol, _React$PureComponent);\n    function RatingSymbol() {\n        _classCallCheck(this, RatingSymbol);\n        return _possibleConstructorReturn(this, _getPrototypeOf(RatingSymbol).apply(this, arguments));\n    }\n    _createClass(RatingSymbol, [\n        {\n            key: \"render\",\n            value: function render() {\n                var _iconContainerStyle;\n                var _this$props = this.props, index = _this$props.index, inactiveIcon = _this$props.inactiveIcon, activeIcon = _this$props.activeIcon, percent = _this$props.percent, direction = _this$props.direction, readonly = _this$props.readonly, onClick = _this$props.onClick, onMouseMove = _this$props.onMouseMove;\n                var backgroundNode = _iconNode(inactiveIcon);\n                var showbgIcon = percent < 100;\n                var bgIconContainerStyle = showbgIcon ? {} : {\n                    visibility: \"hidden\"\n                };\n                var iconNode = _iconNode(activeIcon);\n                var iconContainerStyle = (_iconContainerStyle = {\n                    display: \"inline-block\",\n                    position: \"absolute\",\n                    overflow: \"hidden\",\n                    top: 0\n                }, _defineProperty(_iconContainerStyle, direction === \"rtl\" ? \"right\" : \"left\", 0), _defineProperty(_iconContainerStyle, \"width\", \"\".concat(percent, \"%\")), _iconContainerStyle);\n                var style = {\n                    cursor: !readonly ? \"pointer\" : \"inherit\",\n                    display: \"inline-block\",\n                    position: \"relative\"\n                };\n                function handleMouseMove(e) {\n                    if (onMouseMove) {\n                        onMouseMove(index, e);\n                    }\n                }\n                function handleMouseClick(e) {\n                    if (onClick) {\n                        // [Supporting both TouchEvent and MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/Touch_events/Supporting_both_TouchEvent_and_MouseEvent)\n                        // We must prevent firing click event twice on touch devices.\n                        e.preventDefault();\n                        onClick(index, e);\n                    }\n                }\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", {\n                    style: style,\n                    onClick: handleMouseClick,\n                    onMouseMove: handleMouseMove,\n                    onTouchMove: handleMouseMove,\n                    onTouchEnd: handleMouseClick\n                }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", {\n                    style: bgIconContainerStyle\n                }, backgroundNode), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", {\n                    style: iconContainerStyle\n                }, iconNode));\n            }\n        }\n    ]);\n    return RatingSymbol;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent)); // Define propTypes only in development. They will be void in production.\nvar Rating = /*#__PURE__*/ function(_React$PureComponent) {\n    _inherits(Rating, _React$PureComponent);\n    function Rating(props) {\n        var _this;\n        _classCallCheck(this, Rating);\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(Rating).call(this, props));\n        _this.state = {\n            // Indicates the value that is displayed to the user in the form of symbols.\n            // It can be either 0 (for no displayed symbols) or (0, end]\n            displayValue: _this.props.value,\n            // Indicates if the user is currently hovering over the rating element\n            interacting: false\n        };\n        _this.onMouseLeave = _this.onMouseLeave.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n        _this.symbolMouseMove = _this.symbolMouseMove.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n        _this.symbolClick = _this.symbolClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n        return _this;\n    }\n    _createClass(Rating, [\n        {\n            key: \"UNSAFE_componentWillReceiveProps\",\n            value: function UNSAFE_componentWillReceiveProps(nextProps) {\n                var valueChanged = this.props.value !== nextProps.value;\n                this.setState(function(prevState) {\n                    return {\n                        displayValue: valueChanged ? nextProps.value : prevState.displayValue\n                    };\n                });\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate(prevProps, prevState) {\n                // Ignore state update due to value changed from props.\n                // Usually originated through an onClick event.\n                if (prevProps.value !== this.props.value) {\n                    return;\n                } // When hover ends, call this.props.onHover with no value.\n                if (prevState.interacting && !this.state.interacting) {\n                    return this.props.onHover();\n                } // When hover over.\n                if (this.state.interacting) {\n                    this.props.onHover(this.state.displayValue);\n                }\n            }\n        },\n        {\n            key: \"symbolClick\",\n            value: function symbolClick(symbolIndex, event) {\n                var value = this.calculateDisplayValue(symbolIndex, event);\n                this.props.onClick(value, event);\n            }\n        },\n        {\n            key: \"symbolMouseMove\",\n            value: function symbolMouseMove(symbolIndex, event) {\n                var value = this.calculateDisplayValue(symbolIndex, event); // This call should cause an update only if the state changes.\n                // Mainly the first time the mouse enters and whenever the value changes.\n                // So DidComponentUpdate is NOT called for every mouse movement.\n                this.setState({\n                    interacting: !this.props.readonly,\n                    displayValue: value\n                });\n            }\n        },\n        {\n            key: \"onMouseLeave\",\n            value: function onMouseLeave() {\n                this.setState({\n                    displayValue: this.props.value,\n                    interacting: false\n                });\n            }\n        },\n        {\n            key: \"calculateDisplayValue\",\n            value: function calculateDisplayValue(symbolIndex, event) {\n                var percentage = this.calculateHoverPercentage(event); // Get the closest top fraction.\n                var fraction = Math.ceil(percentage % 1 * this.props.fractions) / this.props.fractions; // Truncate decimal trying to avoid float precission issues.\n                var precision = Math.pow(10, 3);\n                var displayValue = symbolIndex + (Math.floor(percentage) + Math.floor(fraction * precision) / precision); // ensure the returned value is greater than 0 and lower than totalSymbols\n                return displayValue > 0 ? displayValue > this.props.totalSymbols ? this.props.totalSymbols : displayValue : 1 / this.props.fractions;\n            }\n        },\n        {\n            key: \"calculateHoverPercentage\",\n            value: function calculateHoverPercentage(event) {\n                var clientX = event.nativeEvent.type.indexOf(\"touch\") > -1 ? event.nativeEvent.type.indexOf(\"touchend\") > -1 ? event.changedTouches[0].clientX : event.touches[0].clientX : event.clientX;\n                var targetRect = event.target.getBoundingClientRect();\n                var delta = this.props.direction === \"rtl\" ? targetRect.right - clientX : clientX - targetRect.left; // Returning 0 if the delta is negative solves the flickering issue\n                return delta < 0 ? 0 : delta / targetRect.width;\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props = this.props, readonly = _this$props.readonly, quiet = _this$props.quiet, totalSymbols = _this$props.totalSymbols, value = _this$props.value, placeholderValue = _this$props.placeholderValue, direction = _this$props.direction, emptySymbol = _this$props.emptySymbol, fullSymbol = _this$props.fullSymbol, placeholderSymbol = _this$props.placeholderSymbol, className = _this$props.className, id = _this$props.id, style = _this$props.style, tabIndex = _this$props.tabIndex;\n                var _this$state = this.state, displayValue = _this$state.displayValue, interacting = _this$state.interacting;\n                var symbolNodes = [];\n                var empty = [].concat(emptySymbol);\n                var full = [].concat(fullSymbol);\n                var placeholder = [].concat(placeholderSymbol);\n                var shouldDisplayPlaceholder = placeholderValue !== 0 && value === 0 && !interacting; // The value that will be used as base for calculating how to render the symbols\n                var renderedValue;\n                if (shouldDisplayPlaceholder) {\n                    renderedValue = placeholderValue;\n                } else {\n                    renderedValue = quiet ? value : displayValue;\n                } // The amount of full symbols\n                var fullSymbols = Math.floor(renderedValue);\n                for(var i = 0; i < totalSymbols; i++){\n                    var percent = void 0; // Calculate each symbol's fullness percentage\n                    if (i - fullSymbols < 0) {\n                        percent = 100;\n                    } else if (i - fullSymbols === 0) {\n                        percent = (renderedValue - i) * 100;\n                    } else {\n                        percent = 0;\n                    }\n                    symbolNodes.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RatingSymbol, _extends({\n                        key: i,\n                        index: i,\n                        readonly: readonly,\n                        inactiveIcon: empty[i % empty.length],\n                        activeIcon: shouldDisplayPlaceholder ? placeholder[i % full.length] : full[i % full.length],\n                        percent: percent,\n                        direction: direction\n                    }, !readonly && {\n                        onClick: this.symbolClick,\n                        onMouseMove: this.symbolMouseMove,\n                        onTouchMove: this.symbolMouseMove,\n                        onTouchEnd: this.symbolClick\n                    })));\n                }\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", _extends({\n                    id: id,\n                    style: _objectSpread({}, style, {\n                        display: \"inline-block\",\n                        direction: direction\n                    }),\n                    className: className,\n                    tabIndex: tabIndex,\n                    \"aria-label\": this.props[\"aria-label\"]\n                }, !readonly && {\n                    onMouseLeave: this.onMouseLeave\n                }), symbolNodes);\n            }\n        }\n    ]);\n    return Rating;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent)); // Define propTypes only in development.\nfunction noop() {}\nnoop._name = \"react_rating_noop\";\nvar RatingAPILayer = /*#__PURE__*/ function(_React$PureComponent) {\n    _inherits(RatingAPILayer, _React$PureComponent);\n    function RatingAPILayer(props) {\n        var _this;\n        _classCallCheck(this, RatingAPILayer);\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(RatingAPILayer).call(this, props));\n        _this.state = {\n            value: props.initialRating\n        };\n        _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n        _this.handleHover = _this.handleHover.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n        return _this;\n    }\n    _createClass(RatingAPILayer, [\n        {\n            key: \"UNSAFE_componentWillReceiveProps\",\n            value: function UNSAFE_componentWillReceiveProps(nextProps) {\n                this.setState({\n                    value: nextProps.initialRating\n                });\n            }\n        },\n        {\n            key: \"handleClick\",\n            value: function handleClick(value, e) {\n                var _this2 = this;\n                var newValue = this.translateDisplayValueToValue(value);\n                this.props.onClick(newValue); // Avoid calling setState if not necessary. Micro optimisation.\n                if (this.state.value !== newValue) {\n                    // If we have a new value trigger onChange callback.\n                    this.setState({\n                        value: newValue\n                    }, function() {\n                        return _this2.props.onChange(_this2.state.value);\n                    });\n                }\n            }\n        },\n        {\n            key: \"handleHover\",\n            value: function handleHover(displayValue) {\n                var value = displayValue === undefined ? displayValue : this.translateDisplayValueToValue(displayValue);\n                this.props.onHover(value);\n            }\n        },\n        {\n            key: \"translateDisplayValueToValue\",\n            value: function translateDisplayValueToValue(displayValue) {\n                var translatedValue = displayValue * this.props.step + this.props.start; // minimum value cannot be equal to start, since it's exclusive\n                return translatedValue === this.props.start ? translatedValue + 1 / this.props.fractions : translatedValue;\n            }\n        },\n        {\n            key: \"tranlateValueToDisplayValue\",\n            value: function tranlateValueToDisplayValue(value) {\n                if (value === undefined) {\n                    return 0;\n                }\n                return (value - this.props.start) / this.props.step;\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props = this.props, step = _this$props.step, emptySymbol = _this$props.emptySymbol, fullSymbol = _this$props.fullSymbol, placeholderSymbol = _this$props.placeholderSymbol, readonly = _this$props.readonly, quiet = _this$props.quiet, fractions = _this$props.fractions, direction = _this$props.direction, start = _this$props.start, stop = _this$props.stop, id = _this$props.id, className = _this$props.className, style = _this$props.style, tabIndex = _this$props.tabIndex;\n                function calculateTotalSymbols(start, stop, step) {\n                    return Math.floor((stop - start) / step);\n                }\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Rating, {\n                    id: id,\n                    style: style,\n                    className: className,\n                    tabIndex: tabIndex,\n                    \"aria-label\": this.props[\"aria-label\"],\n                    totalSymbols: calculateTotalSymbols(start, stop, step),\n                    value: this.tranlateValueToDisplayValue(this.state.value),\n                    placeholderValue: this.tranlateValueToDisplayValue(this.props.placeholderRating),\n                    readonly: readonly,\n                    quiet: quiet,\n                    fractions: fractions,\n                    direction: direction,\n                    emptySymbol: emptySymbol,\n                    fullSymbol: fullSymbol,\n                    placeholderSymbol: placeholderSymbol,\n                    onClick: this.handleClick,\n                    onHover: this.handleHover\n                });\n            }\n        }\n    ]);\n    return RatingAPILayer;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent));\nRatingAPILayer.defaultProps = {\n    start: 0,\n    stop: 5,\n    step: 1,\n    readonly: false,\n    quiet: false,\n    fractions: 1,\n    direction: \"ltr\",\n    onHover: noop,\n    onClick: noop,\n    onChange: noop,\n    emptySymbol: Style.empty,\n    fullSymbol: Style.full,\n    placeholderSymbol: Style.placeholder\n}; // Define propTypes only in development.\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RatingAPILayer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmF0aW5nL2xpYi9yZWFjdC1yYXRpbmcuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwQjtBQUUxQixTQUFTQyxRQUFRQyxHQUFHO0lBQ2xCLElBQUksT0FBT0MsV0FBVyxjQUFjLE9BQU9BLE9BQU9DLFFBQVEsS0FBSyxVQUFVO1FBQ3ZFSCxVQUFVLFNBQVVDLEdBQUc7WUFDckIsT0FBTyxPQUFPQTtRQUNoQjtJQUNGLE9BQU87UUFDTEQsVUFBVSxTQUFVQyxHQUFHO1lBQ3JCLE9BQU9BLE9BQU8sT0FBT0MsV0FBVyxjQUFjRCxJQUFJRyxXQUFXLEtBQUtGLFVBQVVELFFBQVFDLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO1FBQzNIO0lBQ0Y7SUFFQSxPQUFPRCxRQUFRQztBQUNqQjtBQUVBLFNBQVNLLGdCQUFnQkMsUUFBUSxFQUFFQyxXQUFXO0lBQzVDLElBQUksQ0FBRUQsQ0FBQUEsb0JBQW9CQyxXQUFVLEdBQUk7UUFDdEMsTUFBTSxJQUFJQyxVQUFVO0lBQ3RCO0FBQ0Y7QUFFQSxTQUFTQyxrQkFBa0JDLE1BQU0sRUFBRUMsS0FBSztJQUN0QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUQsTUFBTUUsTUFBTSxFQUFFRCxJQUFLO1FBQ3JDLElBQUlFLGFBQWFILEtBQUssQ0FBQ0MsRUFBRTtRQUN6QkUsV0FBV0MsVUFBVSxHQUFHRCxXQUFXQyxVQUFVLElBQUk7UUFDakRELFdBQVdFLFlBQVksR0FBRztRQUMxQixJQUFJLFdBQVdGLFlBQVlBLFdBQVdHLFFBQVEsR0FBRztRQUNqREMsT0FBT0MsY0FBYyxDQUFDVCxRQUFRSSxXQUFXTSxHQUFHLEVBQUVOO0lBQ2hEO0FBQ0Y7QUFFQSxTQUFTTyxhQUFhZCxXQUFXLEVBQUVlLFVBQVUsRUFBRUMsV0FBVztJQUN4RCxJQUFJRCxZQUFZYixrQkFBa0JGLFlBQVlILFNBQVMsRUFBRWtCO0lBQ3pELElBQUlDLGFBQWFkLGtCQUFrQkYsYUFBYWdCO0lB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SSxLQUFLLENBQUMsYUFBYTtvQkFDdEMwSCxjQUFjeUMsc0JBQXNCSCxPQUFPRSxNQUFNSDtvQkFDakRqSixPQUFPLElBQUksQ0FBQ21KLDJCQUEyQixDQUFDLElBQUksQ0FBQ2xFLEtBQUssQ0FBQ2pGLEtBQUs7b0JBQ3hEeUgsa0JBQWtCLElBQUksQ0FBQzBCLDJCQUEyQixDQUFDLElBQUksQ0FBQ2pLLEtBQUssQ0FBQ29LLGlCQUFpQjtvQkFDL0UzRixVQUFVQTtvQkFDVjZELE9BQU9BO29CQUNQaEIsV0FBV0E7b0JBQ1g5QyxXQUFXQTtvQkFDWGdFLGFBQWFBO29CQUNiQyxZQUFZQTtvQkFDWkMsbUJBQW1CQTtvQkFDbkJoRSxTQUFTLElBQUksQ0FBQzZFLFdBQVc7b0JBQ3pCMUMsU0FBUyxJQUFJLENBQUMyQyxXQUFXO2dCQUMzQjtZQUNGO1FBQ0Y7S0FBRTtJQUVGLE9BQU9IO0FBQ1QsRUFBRWxLLDREQUFtQjtBQUVyQmtLLGVBQWVnQixZQUFZLEdBQUc7SUFDNUJMLE9BQU87SUFDUEUsTUFBTTtJQUNOSCxNQUFNO0lBQ050RixVQUFVO0lBQ1Y2RCxPQUFPO0lBQ1BoQixXQUFXO0lBQ1g5QyxXQUFXO0lBQ1hxQyxTQUFTc0M7SUFDVHpFLFNBQVN5RTtJQUNUUyxVQUFVVDtJQUNWWCxhQUFhcEYsTUFBTUMsS0FBSztJQUN4Qm9GLFlBQVlyRixNQUFNRyxJQUFJO0lBQ3RCbUYsbUJBQW1CdEYsTUFBTUksV0FBVztBQUN0QyxHQUFHLHdDQUF3QztBQUUzQyxpRUFBZTZGLGNBQWNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRvcGlhLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJhdGluZy9saWIvcmVhY3QtcmF0aW5nLmVzbS5qcz9mZjgyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG52YXIgc3R5bGUgPSB7XG4gIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICBib3JkZXI6ICc1cHggZG91YmxlIHdoaXRlJyxcbiAgd2lkdGg6IDMwLFxuICBoZWlnaHQ6IDMwXG59O1xudmFyIFN0eWxlID0ge1xuICBlbXB0eTogX29iamVjdFNwcmVhZCh7fSwgc3R5bGUsIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjY2NjJ1xuICB9KSxcbiAgZnVsbDogX29iamVjdFNwcmVhZCh7fSwgc3R5bGUsIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdibGFjaydcbiAgfSksXG4gIHBsYWNlaG9sZGVyOiBfb2JqZWN0U3ByZWFkKHt9LCBzdHlsZSwge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ3JlZCdcbiAgfSlcbn07XG5cbi8vIFJldHVybiB0aGUgY29ycmVzcG9uZGluZyBSZWFjdCBub2RlIGZvciBhbiBpY29uLlxudmFyIF9pY29uTm9kZSA9IGZ1bmN0aW9uIF9pY29uTm9kZShpY29uKSB7XG4gIC8vIElmIGl0IGlzIGFscmVhZHkgYSBSZWFjdCBFbGVtZW50IGp1c3QgcmV0dXJuIGl0LlxuICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoaWNvbikpIHtcbiAgICByZXR1cm4gaWNvbjtcbiAgfSAvLyBJZiBpdCBpcyBhbiBvYmplY3QsIHRyeSB0byB1c2UgaXQgYXMgYSBDU1Mgc3R5bGUgb2JqZWN0LlxuXG5cbiAgaWYgKF90eXBlb2YoaWNvbikgPT09ICdvYmplY3QnICYmIGljb24gIT09IG51bGwpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgc3R5bGU6IGljb25cbiAgICB9KTtcbiAgfSAvLyBJZiBpdCBpcyBhIHN0cmluZywgdXNlIGl0IGFzIGNsYXNzIG5hbWVzLlxuXG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpY29uKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgY2xhc3NOYW1lOiBpY29uXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBSYXRpbmdTeW1ib2wgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRQdXJlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSYXRpbmdTeW1ib2wsIF9SZWFjdCRQdXJlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSYXRpbmdTeW1ib2woKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhdGluZ1N5bWJvbCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFJhdGluZ1N5bWJvbCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmF0aW5nU3ltYm9sLCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF9pY29uQ29udGFpbmVyU3R5bGU7XG5cbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgaW5kZXggPSBfdGhpcyRwcm9wcy5pbmRleCxcbiAgICAgICAgICBpbmFjdGl2ZUljb24gPSBfdGhpcyRwcm9wcy5pbmFjdGl2ZUljb24sXG4gICAgICAgICAgYWN0aXZlSWNvbiA9IF90aGlzJHByb3BzLmFjdGl2ZUljb24sXG4gICAgICAgICAgcGVyY2VudCA9IF90aGlzJHByb3BzLnBlcmNlbnQsXG4gICAgICAgICAgZGlyZWN0aW9uID0gX3RoaXMkcHJvcHMuZGlyZWN0aW9uLFxuICAgICAgICAgIHJlYWRvbmx5ID0gX3RoaXMkcHJvcHMucmVhZG9ubHksXG4gICAgICAgICAgb25DbGljayA9IF90aGlzJHByb3BzLm9uQ2xpY2ssXG4gICAgICAgICAgb25Nb3VzZU1vdmUgPSBfdGhpcyRwcm9wcy5vbk1vdXNlTW92ZTtcblxuICAgICAgdmFyIGJhY2tncm91bmROb2RlID0gX2ljb25Ob2RlKGluYWN0aXZlSWNvbik7XG5cbiAgICAgIHZhciBzaG93YmdJY29uID0gcGVyY2VudCA8IDEwMDtcbiAgICAgIHZhciBiZ0ljb25Db250YWluZXJTdHlsZSA9IHNob3diZ0ljb24gPyB7fSA6IHtcbiAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbidcbiAgICAgIH07XG5cbiAgICAgIHZhciBpY29uTm9kZSA9IF9pY29uTm9kZShhY3RpdmVJY29uKTtcblxuICAgICAgdmFyIGljb25Db250YWluZXJTdHlsZSA9IChfaWNvbkNvbnRhaW5lclN0eWxlID0ge1xuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgdG9wOiAwXG4gICAgICB9LCBfZGVmaW5lUHJvcGVydHkoX2ljb25Db250YWluZXJTdHlsZSwgZGlyZWN0aW9uID09PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCcsIDApLCBfZGVmaW5lUHJvcGVydHkoX2ljb25Db250YWluZXJTdHlsZSwgXCJ3aWR0aFwiLCBcIlwiLmNvbmNhdChwZXJjZW50LCBcIiVcIikpLCBfaWNvbkNvbnRhaW5lclN0eWxlKTtcbiAgICAgIHZhciBzdHlsZSA9IHtcbiAgICAgICAgY3Vyc29yOiAhcmVhZG9ubHkgPyAncG9pbnRlcicgOiAnaW5oZXJpdCcsXG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGUpIHtcbiAgICAgICAgaWYgKG9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgb25Nb3VzZU1vdmUoaW5kZXgsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlQ2xpY2soZSkge1xuICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgIC8vIFtTdXBwb3J0aW5nIGJvdGggVG91Y2hFdmVudCBhbmQgTW91c2VFdmVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RvdWNoX2V2ZW50cy9TdXBwb3J0aW5nX2JvdGhfVG91Y2hFdmVudF9hbmRfTW91c2VFdmVudClcbiAgICAgICAgICAvLyBXZSBtdXN0IHByZXZlbnQgZmlyaW5nIGNsaWNrIGV2ZW50IHR3aWNlIG9uIHRvdWNoIGRldmljZXMuXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIG9uQ2xpY2soaW5kZXgsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgb25DbGljazogaGFuZGxlTW91c2VDbGljayxcbiAgICAgICAgb25Nb3VzZU1vdmU6IGhhbmRsZU1vdXNlTW92ZSxcbiAgICAgICAgb25Ub3VjaE1vdmU6IGhhbmRsZU1vdXNlTW92ZSxcbiAgICAgICAgb25Ub3VjaEVuZDogaGFuZGxlTW91c2VDbGlja1xuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBzdHlsZTogYmdJY29uQ29udGFpbmVyU3R5bGVcbiAgICAgIH0sIGJhY2tncm91bmROb2RlKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBzdHlsZTogaWNvbkNvbnRhaW5lclN0eWxlXG4gICAgICB9LCBpY29uTm9kZSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSYXRpbmdTeW1ib2w7XG59KFJlYWN0LlB1cmVDb21wb25lbnQpOyAvLyBEZWZpbmUgcHJvcFR5cGVzIG9ubHkgaW4gZGV2ZWxvcG1lbnQuIFRoZXkgd2lsbCBiZSB2b2lkIGluIHByb2R1Y3Rpb24uXG5cbnZhciBSYXRpbmcgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRQdXJlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSYXRpbmcsIF9SZWFjdCRQdXJlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSYXRpbmcocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmF0aW5nKTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFJhdGluZykuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgLy8gSW5kaWNhdGVzIHRoZSB2YWx1ZSB0aGF0IGlzIGRpc3BsYXllZCB0byB0aGUgdXNlciBpbiB0aGUgZm9ybSBvZiBzeW1ib2xzLlxuICAgICAgLy8gSXQgY2FuIGJlIGVpdGhlciAwIChmb3Igbm8gZGlzcGxheWVkIHN5bWJvbHMpIG9yICgwLCBlbmRdXG4gICAgICBkaXNwbGF5VmFsdWU6IF90aGlzLnByb3BzLnZhbHVlLFxuICAgICAgLy8gSW5kaWNhdGVzIGlmIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBob3ZlcmluZyBvdmVyIHRoZSByYXRpbmcgZWxlbWVudFxuICAgICAgaW50ZXJhY3Rpbmc6IGZhbHNlXG4gICAgfTtcbiAgICBfdGhpcy5vbk1vdXNlTGVhdmUgPSBfdGhpcy5vbk1vdXNlTGVhdmUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG4gICAgX3RoaXMuc3ltYm9sTW91c2VNb3ZlID0gX3RoaXMuc3ltYm9sTW91c2VNb3ZlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuICAgIF90aGlzLnN5bWJvbENsaWNrID0gX3RoaXMuc3ltYm9sQ2xpY2suYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJhdGluZywgW3tcbiAgICBrZXk6IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICB2YXIgdmFsdWVDaGFuZ2VkID0gdGhpcy5wcm9wcy52YWx1ZSAhPT0gbmV4dFByb3BzLnZhbHVlO1xuICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlzcGxheVZhbHVlOiB2YWx1ZUNoYW5nZWQgPyBuZXh0UHJvcHMudmFsdWUgOiBwcmV2U3RhdGUuZGlzcGxheVZhbHVlXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgLy8gSWdub3JlIHN0YXRlIHVwZGF0ZSBkdWUgdG8gdmFsdWUgY2hhbmdlZCBmcm9tIHByb3BzLlxuICAgICAgLy8gVXN1YWxseSBvcmlnaW5hdGVkIHRocm91Z2ggYW4gb25DbGljayBldmVudC5cbiAgICAgIGlmIChwcmV2UHJvcHMudmFsdWUgIT09IHRoaXMucHJvcHMudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBXaGVuIGhvdmVyIGVuZHMsIGNhbGwgdGhpcy5wcm9wcy5vbkhvdmVyIHdpdGggbm8gdmFsdWUuXG5cblxuICAgICAgaWYgKHByZXZTdGF0ZS5pbnRlcmFjdGluZyAmJiAhdGhpcy5zdGF0ZS5pbnRlcmFjdGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5vbkhvdmVyKCk7XG4gICAgICB9IC8vIFdoZW4gaG92ZXIgb3Zlci5cblxuXG4gICAgICBpZiAodGhpcy5zdGF0ZS5pbnRlcmFjdGluZykge1xuICAgICAgICB0aGlzLnByb3BzLm9uSG92ZXIodGhpcy5zdGF0ZS5kaXNwbGF5VmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzeW1ib2xDbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeW1ib2xDbGljayhzeW1ib2xJbmRleCwgZXZlbnQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuY2FsY3VsYXRlRGlzcGxheVZhbHVlKHN5bWJvbEluZGV4LCBldmVudCk7XG4gICAgICB0aGlzLnByb3BzLm9uQ2xpY2sodmFsdWUsIGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3ltYm9sTW91c2VNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN5bWJvbE1vdXNlTW92ZShzeW1ib2xJbmRleCwgZXZlbnQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuY2FsY3VsYXRlRGlzcGxheVZhbHVlKHN5bWJvbEluZGV4LCBldmVudCk7IC8vIFRoaXMgY2FsbCBzaG91bGQgY2F1c2UgYW4gdXBkYXRlIG9ubHkgaWYgdGhlIHN0YXRlIGNoYW5nZXMuXG4gICAgICAvLyBNYWlubHkgdGhlIGZpcnN0IHRpbWUgdGhlIG1vdXNlIGVudGVycyBhbmQgd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMuXG4gICAgICAvLyBTbyBEaWRDb21wb25lbnRVcGRhdGUgaXMgTk9UIGNhbGxlZCBmb3IgZXZlcnkgbW91c2UgbW92ZW1lbnQuXG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpbnRlcmFjdGluZzogIXRoaXMucHJvcHMucmVhZG9ubHksXG4gICAgICAgIGRpc3BsYXlWYWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbk1vdXNlTGVhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3VzZUxlYXZlKCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRpc3BsYXlWYWx1ZTogdGhpcy5wcm9wcy52YWx1ZSxcbiAgICAgICAgaW50ZXJhY3Rpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlRGlzcGxheVZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3BsYXlWYWx1ZShzeW1ib2xJbmRleCwgZXZlbnQpIHtcbiAgICAgIHZhciBwZXJjZW50YWdlID0gdGhpcy5jYWxjdWxhdGVIb3ZlclBlcmNlbnRhZ2UoZXZlbnQpOyAvLyBHZXQgdGhlIGNsb3Nlc3QgdG9wIGZyYWN0aW9uLlxuXG4gICAgICB2YXIgZnJhY3Rpb24gPSBNYXRoLmNlaWwocGVyY2VudGFnZSAlIDEgKiB0aGlzLnByb3BzLmZyYWN0aW9ucykgLyB0aGlzLnByb3BzLmZyYWN0aW9uczsgLy8gVHJ1bmNhdGUgZGVjaW1hbCB0cnlpbmcgdG8gYXZvaWQgZmxvYXQgcHJlY2lzc2lvbiBpc3N1ZXMuXG5cbiAgICAgIHZhciBwcmVjaXNpb24gPSBNYXRoLnBvdygxMCwgMyk7XG4gICAgICB2YXIgZGlzcGxheVZhbHVlID0gc3ltYm9sSW5kZXggKyAoTWF0aC5mbG9vcihwZXJjZW50YWdlKSArIE1hdGguZmxvb3IoZnJhY3Rpb24gKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uKTsgLy8gZW5zdXJlIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gMCBhbmQgbG93ZXIgdGhhbiB0b3RhbFN5bWJvbHNcblxuICAgICAgcmV0dXJuIGRpc3BsYXlWYWx1ZSA+IDAgPyBkaXNwbGF5VmFsdWUgPiB0aGlzLnByb3BzLnRvdGFsU3ltYm9scyA/IHRoaXMucHJvcHMudG90YWxTeW1ib2xzIDogZGlzcGxheVZhbHVlIDogMSAvIHRoaXMucHJvcHMuZnJhY3Rpb25zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVIb3ZlclBlcmNlbnRhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlSG92ZXJQZXJjZW50YWdlKGV2ZW50KSB7XG4gICAgICB2YXIgY2xpZW50WCA9IGV2ZW50Lm5hdGl2ZUV2ZW50LnR5cGUuaW5kZXhPZihcInRvdWNoXCIpID4gLTEgPyBldmVudC5uYXRpdmVFdmVudC50eXBlLmluZGV4T2YoXCJ0b3VjaGVuZFwiKSA+IC0xID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCA6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCA6IGV2ZW50LmNsaWVudFg7XG4gICAgICB2YXIgdGFyZ2V0UmVjdCA9IGV2ZW50LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBkZWx0YSA9IHRoaXMucHJvcHMuZGlyZWN0aW9uID09PSAncnRsJyA/IHRhcmdldFJlY3QucmlnaHQgLSBjbGllbnRYIDogY2xpZW50WCAtIHRhcmdldFJlY3QubGVmdDsgLy8gUmV0dXJuaW5nIDAgaWYgdGhlIGRlbHRhIGlzIG5lZ2F0aXZlIHNvbHZlcyB0aGUgZmxpY2tlcmluZyBpc3N1ZVxuXG4gICAgICByZXR1cm4gZGVsdGEgPCAwID8gMCA6IGRlbHRhIC8gdGFyZ2V0UmVjdC53aWR0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgcmVhZG9ubHkgPSBfdGhpcyRwcm9wcy5yZWFkb25seSxcbiAgICAgICAgICBxdWlldCA9IF90aGlzJHByb3BzLnF1aWV0LFxuICAgICAgICAgIHRvdGFsU3ltYm9scyA9IF90aGlzJHByb3BzLnRvdGFsU3ltYm9scyxcbiAgICAgICAgICB2YWx1ZSA9IF90aGlzJHByb3BzLnZhbHVlLFxuICAgICAgICAgIHBsYWNlaG9sZGVyVmFsdWUgPSBfdGhpcyRwcm9wcy5wbGFjZWhvbGRlclZhbHVlLFxuICAgICAgICAgIGRpcmVjdGlvbiA9IF90aGlzJHByb3BzLmRpcmVjdGlvbixcbiAgICAgICAgICBlbXB0eVN5bWJvbCA9IF90aGlzJHByb3BzLmVtcHR5U3ltYm9sLFxuICAgICAgICAgIGZ1bGxTeW1ib2wgPSBfdGhpcyRwcm9wcy5mdWxsU3ltYm9sLFxuICAgICAgICAgIHBsYWNlaG9sZGVyU3ltYm9sID0gX3RoaXMkcHJvcHMucGxhY2Vob2xkZXJTeW1ib2wsXG4gICAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICAgIGlkID0gX3RoaXMkcHJvcHMuaWQsXG4gICAgICAgICAgc3R5bGUgPSBfdGhpcyRwcm9wcy5zdHlsZSxcbiAgICAgICAgICB0YWJJbmRleCA9IF90aGlzJHByb3BzLnRhYkluZGV4O1xuICAgICAgdmFyIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICBkaXNwbGF5VmFsdWUgPSBfdGhpcyRzdGF0ZS5kaXNwbGF5VmFsdWUsXG4gICAgICAgICAgaW50ZXJhY3RpbmcgPSBfdGhpcyRzdGF0ZS5pbnRlcmFjdGluZztcbiAgICAgIHZhciBzeW1ib2xOb2RlcyA9IFtdO1xuICAgICAgdmFyIGVtcHR5ID0gW10uY29uY2F0KGVtcHR5U3ltYm9sKTtcbiAgICAgIHZhciBmdWxsID0gW10uY29uY2F0KGZ1bGxTeW1ib2wpO1xuICAgICAgdmFyIHBsYWNlaG9sZGVyID0gW10uY29uY2F0KHBsYWNlaG9sZGVyU3ltYm9sKTtcbiAgICAgIHZhciBzaG91bGREaXNwbGF5UGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlclZhbHVlICE9PSAwICYmIHZhbHVlID09PSAwICYmICFpbnRlcmFjdGluZzsgLy8gVGhlIHZhbHVlIHRoYXQgd2lsbCBiZSB1c2VkIGFzIGJhc2UgZm9yIGNhbGN1bGF0aW5nIGhvdyB0byByZW5kZXIgdGhlIHN5bWJvbHNcblxuICAgICAgdmFyIHJlbmRlcmVkVmFsdWU7XG5cbiAgICAgIGlmIChzaG91bGREaXNwbGF5UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgcmVuZGVyZWRWYWx1ZSA9IHBsYWNlaG9sZGVyVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJlZFZhbHVlID0gcXVpZXQgPyB2YWx1ZSA6IGRpc3BsYXlWYWx1ZTtcbiAgICAgIH0gLy8gVGhlIGFtb3VudCBvZiBmdWxsIHN5bWJvbHNcblxuXG4gICAgICB2YXIgZnVsbFN5bWJvbHMgPSBNYXRoLmZsb29yKHJlbmRlcmVkVmFsdWUpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsU3ltYm9sczsgaSsrKSB7XG4gICAgICAgIHZhciBwZXJjZW50ID0gdm9pZCAwOyAvLyBDYWxjdWxhdGUgZWFjaCBzeW1ib2wncyBmdWxsbmVzcyBwZXJjZW50YWdlXG5cbiAgICAgICAgaWYgKGkgLSBmdWxsU3ltYm9scyA8IDApIHtcbiAgICAgICAgICBwZXJjZW50ID0gMTAwO1xuICAgICAgICB9IGVsc2UgaWYgKGkgLSBmdWxsU3ltYm9scyA9PT0gMCkge1xuICAgICAgICAgIHBlcmNlbnQgPSAocmVuZGVyZWRWYWx1ZSAtIGkpICogMTAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ltYm9sTm9kZXMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFJhdGluZ1N5bWJvbCwgX2V4dGVuZHMoe1xuICAgICAgICAgIGtleTogaSxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICByZWFkb25seTogcmVhZG9ubHksXG4gICAgICAgICAgaW5hY3RpdmVJY29uOiBlbXB0eVtpICUgZW1wdHkubGVuZ3RoXSxcbiAgICAgICAgICBhY3RpdmVJY29uOiBzaG91bGREaXNwbGF5UGxhY2Vob2xkZXIgPyBwbGFjZWhvbGRlcltpICUgZnVsbC5sZW5ndGhdIDogZnVsbFtpICUgZnVsbC5sZW5ndGhdLFxuICAgICAgICAgIHBlcmNlbnQ6IHBlcmNlbnQsXG4gICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgfSwgIXJlYWRvbmx5ICYmIHtcbiAgICAgICAgICBvbkNsaWNrOiB0aGlzLnN5bWJvbENsaWNrLFxuICAgICAgICAgIG9uTW91c2VNb3ZlOiB0aGlzLnN5bWJvbE1vdXNlTW92ZSxcbiAgICAgICAgICBvblRvdWNoTW92ZTogdGhpcy5zeW1ib2xNb3VzZU1vdmUsXG4gICAgICAgICAgb25Ub3VjaEVuZDogdGhpcy5zeW1ib2xDbGlja1xuICAgICAgICB9KSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgX2V4dGVuZHMoe1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKHt9LCBzdHlsZSwge1xuICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICAgIH0pLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgdGFiSW5kZXg6IHRhYkluZGV4LFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogdGhpcy5wcm9wc1snYXJpYS1sYWJlbCddXG4gICAgICB9LCAhcmVhZG9ubHkgJiYge1xuICAgICAgICBvbk1vdXNlTGVhdmU6IHRoaXMub25Nb3VzZUxlYXZlXG4gICAgICB9KSwgc3ltYm9sTm9kZXMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSYXRpbmc7XG59KFJlYWN0LlB1cmVDb21wb25lbnQpOyAvLyBEZWZpbmUgcHJvcFR5cGVzIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5ub29wLl9uYW1lID0gJ3JlYWN0X3JhdGluZ19ub29wJztcblxudmFyIFJhdGluZ0FQSUxheWVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUmF0aW5nQVBJTGF5ZXIsIF9SZWFjdCRQdXJlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSYXRpbmdBUElMYXllcihwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYXRpbmdBUElMYXllcik7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihSYXRpbmdBUElMYXllcikuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgdmFsdWU6IHByb3BzLmluaXRpYWxSYXRpbmdcbiAgICB9O1xuICAgIF90aGlzLmhhbmRsZUNsaWNrID0gX3RoaXMuaGFuZGxlQ2xpY2suYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG4gICAgX3RoaXMuaGFuZGxlSG92ZXIgPSBfdGhpcy5oYW5kbGVIb3Zlci5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmF0aW5nQVBJTGF5ZXIsIFt7XG4gICAga2V5OiBcIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZhbHVlOiBuZXh0UHJvcHMuaW5pdGlhbFJhdGluZ1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUNsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKHZhbHVlLCBlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG5ld1ZhbHVlID0gdGhpcy50cmFuc2xhdGVEaXNwbGF5VmFsdWVUb1ZhbHVlKHZhbHVlKTtcbiAgICAgIHRoaXMucHJvcHMub25DbGljayhuZXdWYWx1ZSk7IC8vIEF2b2lkIGNhbGxpbmcgc2V0U3RhdGUgaWYgbm90IG5lY2Vzc2FyeS4gTWljcm8gb3B0aW1pc2F0aW9uLlxuXG4gICAgICBpZiAodGhpcy5zdGF0ZS52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG5ldyB2YWx1ZSB0cmlnZ2VyIG9uQ2hhbmdlIGNhbGxiYWNrLlxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICB2YWx1ZTogbmV3VmFsdWVcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIucHJvcHMub25DaGFuZ2UoX3RoaXMyLnN0YXRlLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUhvdmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUhvdmVyKGRpc3BsYXlWYWx1ZSkge1xuICAgICAgdmFyIHZhbHVlID0gZGlzcGxheVZhbHVlID09PSB1bmRlZmluZWQgPyBkaXNwbGF5VmFsdWUgOiB0aGlzLnRyYW5zbGF0ZURpc3BsYXlWYWx1ZVRvVmFsdWUoZGlzcGxheVZhbHVlKTtcbiAgICAgIHRoaXMucHJvcHMub25Ib3Zlcih2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zbGF0ZURpc3BsYXlWYWx1ZVRvVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNsYXRlRGlzcGxheVZhbHVlVG9WYWx1ZShkaXNwbGF5VmFsdWUpIHtcbiAgICAgIHZhciB0cmFuc2xhdGVkVmFsdWUgPSBkaXNwbGF5VmFsdWUgKiB0aGlzLnByb3BzLnN0ZXAgKyB0aGlzLnByb3BzLnN0YXJ0OyAvLyBtaW5pbXVtIHZhbHVlIGNhbm5vdCBiZSBlcXVhbCB0byBzdGFydCwgc2luY2UgaXQncyBleGNsdXNpdmVcblxuICAgICAgcmV0dXJuIHRyYW5zbGF0ZWRWYWx1ZSA9PT0gdGhpcy5wcm9wcy5zdGFydCA/IHRyYW5zbGF0ZWRWYWx1ZSArIDEgLyB0aGlzLnByb3BzLmZyYWN0aW9ucyA6IHRyYW5zbGF0ZWRWYWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbmxhdGVWYWx1ZVRvRGlzcGxheVZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5sYXRlVmFsdWVUb0Rpc3BsYXlWYWx1ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAodmFsdWUgLSB0aGlzLnByb3BzLnN0YXJ0KSAvIHRoaXMucHJvcHMuc3RlcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgc3RlcCA9IF90aGlzJHByb3BzLnN0ZXAsXG4gICAgICAgICAgZW1wdHlTeW1ib2wgPSBfdGhpcyRwcm9wcy5lbXB0eVN5bWJvbCxcbiAgICAgICAgICBmdWxsU3ltYm9sID0gX3RoaXMkcHJvcHMuZnVsbFN5bWJvbCxcbiAgICAgICAgICBwbGFjZWhvbGRlclN5bWJvbCA9IF90aGlzJHByb3BzLnBsYWNlaG9sZGVyU3ltYm9sLFxuICAgICAgICAgIHJlYWRvbmx5ID0gX3RoaXMkcHJvcHMucmVhZG9ubHksXG4gICAgICAgICAgcXVpZXQgPSBfdGhpcyRwcm9wcy5xdWlldCxcbiAgICAgICAgICBmcmFjdGlvbnMgPSBfdGhpcyRwcm9wcy5mcmFjdGlvbnMsXG4gICAgICAgICAgZGlyZWN0aW9uID0gX3RoaXMkcHJvcHMuZGlyZWN0aW9uLFxuICAgICAgICAgIHN0YXJ0ID0gX3RoaXMkcHJvcHMuc3RhcnQsXG4gICAgICAgICAgc3RvcCA9IF90aGlzJHByb3BzLnN0b3AsXG4gICAgICAgICAgaWQgPSBfdGhpcyRwcm9wcy5pZCxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5jbGFzc05hbWUsXG4gICAgICAgICAgc3R5bGUgPSBfdGhpcyRwcm9wcy5zdHlsZSxcbiAgICAgICAgICB0YWJJbmRleCA9IF90aGlzJHByb3BzLnRhYkluZGV4O1xuXG4gICAgICBmdW5jdGlvbiBjYWxjdWxhdGVUb3RhbFN5bWJvbHMoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHN0b3AgLSBzdGFydCkgLyBzdGVwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmF0aW5nLCB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgdGFiSW5kZXg6IHRhYkluZGV4LFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogdGhpcy5wcm9wc1snYXJpYS1sYWJlbCddLFxuICAgICAgICB0b3RhbFN5bWJvbHM6IGNhbGN1bGF0ZVRvdGFsU3ltYm9scyhzdGFydCwgc3RvcCwgc3RlcCksXG4gICAgICAgIHZhbHVlOiB0aGlzLnRyYW5sYXRlVmFsdWVUb0Rpc3BsYXlWYWx1ZSh0aGlzLnN0YXRlLnZhbHVlKSxcbiAgICAgICAgcGxhY2Vob2xkZXJWYWx1ZTogdGhpcy50cmFubGF0ZVZhbHVlVG9EaXNwbGF5VmFsdWUodGhpcy5wcm9wcy5wbGFjZWhvbGRlclJhdGluZyksXG4gICAgICAgIHJlYWRvbmx5OiByZWFkb25seSxcbiAgICAgICAgcXVpZXQ6IHF1aWV0LFxuICAgICAgICBmcmFjdGlvbnM6IGZyYWN0aW9ucyxcbiAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICAgIGVtcHR5U3ltYm9sOiBlbXB0eVN5bWJvbCxcbiAgICAgICAgZnVsbFN5bWJvbDogZnVsbFN5bWJvbCxcbiAgICAgICAgcGxhY2Vob2xkZXJTeW1ib2w6IHBsYWNlaG9sZGVyU3ltYm9sLFxuICAgICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLFxuICAgICAgICBvbkhvdmVyOiB0aGlzLmhhbmRsZUhvdmVyXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmF0aW5nQVBJTGF5ZXI7XG59KFJlYWN0LlB1cmVDb21wb25lbnQpO1xuXG5SYXRpbmdBUElMYXllci5kZWZhdWx0UHJvcHMgPSB7XG4gIHN0YXJ0OiAwLFxuICBzdG9wOiA1LFxuICBzdGVwOiAxLFxuICByZWFkb25seTogZmFsc2UsXG4gIHF1aWV0OiBmYWxzZSxcbiAgZnJhY3Rpb25zOiAxLFxuICBkaXJlY3Rpb246ICdsdHInLFxuICBvbkhvdmVyOiBub29wLFxuICBvbkNsaWNrOiBub29wLFxuICBvbkNoYW5nZTogbm9vcCxcbiAgZW1wdHlTeW1ib2w6IFN0eWxlLmVtcHR5LFxuICBmdWxsU3ltYm9sOiBTdHlsZS5mdWxsLFxuICBwbGFjZWhvbGRlclN5bWJvbDogU3R5bGUucGxhY2Vob2xkZXJcbn07IC8vIERlZmluZSBwcm9wVHlwZXMgb25seSBpbiBkZXZlbG9wbWVudC5cblxuZXhwb3J0IGRlZmF1bHQgUmF0aW5nQVBJTGF5ZXI7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9kZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImNvbmNhdCIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImZvckVhY2giLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJfZ2V0UHJvdG90eXBlT2YiLCJvIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsInAiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwic2VsZiIsIlJlZmVyZW5jZUVycm9yIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzdHlsZSIsImRpc3BsYXkiLCJib3JkZXJSYWRpdXMiLCJib3JkZXIiLCJ3aWR0aCIsImhlaWdodCIsIlN0eWxlIiwiZW1wdHkiLCJiYWNrZ3JvdW5kQ29sb3IiLCJmdWxsIiwicGxhY2Vob2xkZXIiLCJfaWNvbk5vZGUiLCJpY29uIiwiaXNWYWxpZEVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidG9TdHJpbmciLCJjbGFzc05hbWUiLCJSYXRpbmdTeW1ib2wiLCJfUmVhY3QkUHVyZUNvbXBvbmVudCIsInJlbmRlciIsIl9pY29uQ29udGFpbmVyU3R5bGUiLCJfdGhpcyRwcm9wcyIsImluZGV4IiwiaW5hY3RpdmVJY29uIiwiYWN0aXZlSWNvbiIsInBlcmNlbnQiLCJkaXJlY3Rpb24iLCJyZWFkb25seSIsIm9uQ2xpY2siLCJvbk1vdXNlTW92ZSIsImJhY2tncm91bmROb2RlIiwic2hvd2JnSWNvbiIsImJnSWNvbkNvbnRhaW5lclN0eWxlIiwidmlzaWJpbGl0eSIsImljb25Ob2RlIiwiaWNvbkNvbnRhaW5lclN0eWxlIiwicG9zaXRpb24iLCJvdmVyZmxvdyIsInRvcCIsImN1cnNvciIsImhhbmRsZU1vdXNlTW92ZSIsImUiLCJoYW5kbGVNb3VzZUNsaWNrIiwicHJldmVudERlZmF1bHQiLCJvblRvdWNoTW92ZSIsIm9uVG91Y2hFbmQiLCJQdXJlQ29tcG9uZW50IiwiUmF0aW5nIiwiX3RoaXMiLCJzdGF0ZSIsImRpc3BsYXlWYWx1ZSIsImludGVyYWN0aW5nIiwib25Nb3VzZUxlYXZlIiwiYmluZCIsInN5bWJvbE1vdXNlTW92ZSIsInN5bWJvbENsaWNrIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJuZXh0UHJvcHMiLCJ2YWx1ZUNoYW5nZWQiLCJzZXRTdGF0ZSIsInByZXZTdGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsIm9uSG92ZXIiLCJzeW1ib2xJbmRleCIsImV2ZW50IiwiY2FsY3VsYXRlRGlzcGxheVZhbHVlIiwicGVyY2VudGFnZSIsImNhbGN1bGF0ZUhvdmVyUGVyY2VudGFnZSIsImZyYWN0aW9uIiwiTWF0aCIsImNlaWwiLCJmcmFjdGlvbnMiLCJwcmVjaXNpb24iLCJwb3ciLCJmbG9vciIsInRvdGFsU3ltYm9scyIsImNsaWVudFgiLCJuYXRpdmVFdmVudCIsInR5cGUiLCJpbmRleE9mIiwiY2hhbmdlZFRvdWNoZXMiLCJ0b3VjaGVzIiwidGFyZ2V0UmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImRlbHRhIiwicmlnaHQiLCJsZWZ0IiwicXVpZXQiLCJwbGFjZWhvbGRlclZhbHVlIiwiZW1wdHlTeW1ib2wiLCJmdWxsU3ltYm9sIiwicGxhY2Vob2xkZXJTeW1ib2wiLCJpZCIsInRhYkluZGV4IiwiX3RoaXMkc3RhdGUiLCJzeW1ib2xOb2RlcyIsInNob3VsZERpc3BsYXlQbGFjZWhvbGRlciIsInJlbmRlcmVkVmFsdWUiLCJmdWxsU3ltYm9scyIsInB1c2giLCJub29wIiwiX25hbWUiLCJSYXRpbmdBUElMYXllciIsImluaXRpYWxSYXRpbmciLCJoYW5kbGVDbGljayIsImhhbmRsZUhvdmVyIiwiX3RoaXMyIiwibmV3VmFsdWUiLCJ0cmFuc2xhdGVEaXNwbGF5VmFsdWVUb1ZhbHVlIiwib25DaGFuZ2UiLCJ1bmRlZmluZWQiLCJ0cmFuc2xhdGVkVmFsdWUiLCJzdGVwIiwic3RhcnQiLCJ0cmFubGF0ZVZhbHVlVG9EaXNwbGF5VmFsdWUiLCJzdG9wIiwiY2FsY3VsYXRlVG90YWxTeW1ib2xzIiwicGxhY2Vob2xkZXJSYXRpbmciLCJkZWZhdWx0UHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-rating/lib/react-rating.esm.js\n");

/***/ })

};
;